# Comparing `tmp/vios-2.3.4-py3-none-any.whl.zip` & `tmp/vios-2.3.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,26 @@
-Zip file size: 46821 bytes, number of entries: 25
--rw-rw-rw-  2.0 fat     2858 b- defN 24-Mar-19 07:04 quark/__main__.py
--rw-rw-rw-  2.0 fat    19343 b- defN 24-Apr-22 01:34 quark/proxy.py
--rw-rw-rw-  2.0 fat    18861 b- defN 24-Mar-21 01:49 quark/app/__init__.py
--rw-rw-rw-  2.0 fat     2575 b- defN 24-Apr-18 07:42 quark/app/_data.py
--rw-rw-rw-  2.0 fat    10205 b- defN 24-Mar-19 07:04 quark/app/demo.py
--rw-rw-rw-  2.0 fat     9043 b- defN 24-Mar-19 07:04 quark/app/task.py
--rw-rw-rw-  2.0 fat     5876 b- defN 24-Mar-19 07:16 quark/app/uapi.py
--rw-rw-rw-  2.0 fat     7914 b- defN 24-Apr-12 08:12 quark/driver/VirtualDevice.py
--rw-rw-rw-  2.0 fat      386 b- defN 24-Mar-19 07:04 quark/driver/__init__.py
--rw-rw-rw-  2.0 fat      217 b- defN 24-Mar-19 07:04 quark/driver/common/__init__.py
--rw-rw-rw-  2.0 fat     4478 b- defN 24-Mar-19 07:04 quark/driver/common/basedriver.py
--rw-rw-rw-  2.0 fat     4663 b- defN 24-Mar-19 07:04 quark/driver/common/quantity.py
--rw-rw-rw-  2.0 fat     5432 b- defN 24-Mar-19 07:04 quark/driver/common/visadriver.py
--rw-rw-rw-  2.0 fat     1188 b- defN 24-Mar-19 07:04 quark/envelope/__init__.py
--rw-rw-rw-  2.0 fat    15111 b- defN 24-Mar-19 07:04 quark/envelope/assembler.py
--rw-rw-rw-  2.0 fat     4322 b- defN 24-Mar-19 07:04 quark/envelope/calculator.py
--rw-rw-rw-  2.0 fat     1106 b- defN 24-Mar-19 07:04 quark/envelope/device.py
--rw-rw-rw-  2.0 fat     3758 b- defN 24-Mar-25 01:32 quark/envelope/processor.py
--rw-rw-rw-  2.0 fat     4324 b- defN 24-Apr-11 01:52 quark/envelope/router.py
--rw-rw-rw-  2.0 fat     2841 b- defN 24-Mar-25 01:32 quark/envelope/systemq.py
--rw-rw-rw-  2.0 fat     1085 b- defN 24-Apr-22 01:35 vios-2.3.4.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1215 b- defN 24-Apr-22 01:35 vios-2.3.4.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-22 01:35 vios-2.3.4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 24-Apr-22 01:35 vios-2.3.4.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1995 b- defN 24-Apr-22 01:35 vios-2.3.4.dist-info/RECORD
-25 files, 128894 bytes uncompressed, 43645 bytes compressed:  66.1%
+Zip file size: 45407 bytes, number of entries: 24
+-rw-rw-rw-  2.0 fat    18569 b- defN 24-Apr-25 14:44 quark/proxy.py
+-rw-rw-rw-  2.0 fat    18867 b- defN 24-Apr-28 13:53 quark/app/__init__.py
+-rw-rw-rw-  2.0 fat     2575 b- defN 24-Mar-19 11:19 quark/app/_data.py
+-rw-rw-rw-  2.0 fat    10205 b- defN 24-Mar-19 11:19 quark/app/demo.py
+-rw-rw-rw-  2.0 fat     8790 b- defN 24-Apr-28 13:40 quark/app/task.py
+-rw-rw-rw-  2.0 fat     5876 b- defN 24-Mar-19 11:19 quark/app/uapi.py
+-rw-rw-rw-  2.0 fat     7914 b- defN 24-Mar-19 11:19 quark/driver/VirtualDevice.py
+-rw-rw-rw-  2.0 fat      386 b- defN 24-Mar-19 11:19 quark/driver/__init__.py
+-rw-rw-rw-  2.0 fat      217 b- defN 24-Mar-19 11:19 quark/driver/common/__init__.py
+-rw-rw-rw-  2.0 fat     4478 b- defN 24-Mar-19 11:19 quark/driver/common/basedriver.py
+-rw-rw-rw-  2.0 fat     4663 b- defN 24-Mar-19 11:19 quark/driver/common/quantity.py
+-rw-rw-rw-  2.0 fat     5432 b- defN 24-Mar-19 11:19 quark/driver/common/visadriver.py
+-rw-rw-rw-  2.0 fat     1188 b- defN 24-Mar-19 11:19 quark/envelope/__init__.py
+-rw-rw-rw-  2.0 fat    15111 b- defN 24-Mar-19 11:19 quark/envelope/assembler.py
+-rw-rw-rw-  2.0 fat     4322 b- defN 24-Mar-19 11:19 quark/envelope/calculator.py
+-rw-rw-rw-  2.0 fat     1106 b- defN 24-Mar-19 11:19 quark/envelope/device.py
+-rw-rw-rw-  2.0 fat     3733 b- defN 24-Apr-25 14:44 quark/envelope/processor.py
+-rw-rw-rw-  2.0 fat     4320 b- defN 24-Apr-25 14:44 quark/envelope/router.py
+-rw-rw-rw-  2.0 fat     2841 b- defN 24-Mar-21 12:16 quark/envelope/systemq.py
+-rw-rw-rw-  2.0 fat     1085 b- defN 24-Apr-28 14:00 vios-2.3.5.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1211 b- defN 24-Apr-28 14:00 vios-2.3.5.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-28 14:00 vios-2.3.5.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 24-Apr-28 14:00 vios-2.3.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1921 b- defN 24-Apr-28 14:00 vios-2.3.5.dist-info/RECORD
+24 files, 124908 bytes uncompressed, 42341 bytes compressed:  66.1%
```

## zipnote {}

```diff
@@ -1,10 +1,7 @@
-Filename: quark/__main__.py
-Comment: 
-
 Filename: quark/proxy.py
 Comment: 
 
 Filename: quark/app/__init__.py
 Comment: 
 
 Filename: quark/app/_data.py
@@ -54,23 +51,23 @@
 
 Filename: quark/envelope/router.py
 Comment: 
 
 Filename: quark/envelope/systemq.py
 Comment: 
 
-Filename: vios-2.3.4.dist-info/LICENSE
+Filename: vios-2.3.5.dist-info/LICENSE
 Comment: 
 
-Filename: vios-2.3.4.dist-info/METADATA
+Filename: vios-2.3.5.dist-info/METADATA
 Comment: 
 
-Filename: vios-2.3.4.dist-info/WHEEL
+Filename: vios-2.3.5.dist-info/WHEEL
 Comment: 
 
-Filename: vios-2.3.4.dist-info/top_level.txt
+Filename: vios-2.3.5.dist-info/top_level.txt
 Comment: 
 
-Filename: vios-2.3.4.dist-info/RECORD
+Filename: vios-2.3.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quark/proxy.py

```diff
@@ -1,556 +1,548 @@
-"""!!! note "**用户输入输出**"
-
-- app: 用户函数或任务定义
-- driver: 设备驱动. **NOTE: 如发生改动, 需要重启server**
-    - 所有驱动继承自BaseDriver，类名统一为Driver，并要求实现open/close/read/write四个方法。样板见VirtualDevice
-    - 以设备或厂家为名新建文件夹(并于其内新建__init__.py文件)放于driver/common内，将厂家提供的底层库(若有)置于其内
-
-- envelope: 执行流程，见各模块说明. **NOTE: 如发生改动, 需要重启server**
-"""
-
-
-import asyncio
-import inspect
-import json
-import string
-import sys
-import time
-from collections import defaultdict
-from functools import cached_property
-from multiprocessing.shared_memory import SharedMemory
-from pathlib import Path
-from threading import Lock, Thread, current_thread
-
-import numpy as np
-from loguru import logger
-
-QUARK = Path.home()/'quark'
-
-try:
-    with open(QUARK/'startup.json', 'r') as f:
-        startup = json.loads(f.read())
-        SYSTEMQ = str(Path(startup['site']).resolve())
-        if SYSTEMQ.lower() not in sys.path:
-            sys.path.append(SYSTEMQ)
-except Exception as e:
-    logger.error(str(e))
-    startup = {}
-
-
-def setlog(prefix: str = ''):
-    logger.remove()
-    root = Path.home()/f"Desktop/home/log/proxy/{prefix}"
-    path = root/"{time:%Y-%m-%d}.log"
-    level = "INFO"
-    config = {'handlers': [{'sink': sys.stdout,
-                            'level': level},
-                           {'sink': path,
-                            'rotation': '00:00',
-                            'retention': '10 days',
-                            'encoding': 'utf-8',
-                            'level': level,
-                            'backtrace': False, }]}
-    # logger.add(path, rotation="20 MB")
-    logger.configure(**config)
-
-
-def debug(circuit: list = [(('Measure', 0), 'Q1001')], tid: int = 0):
-    from .app import get_config_by_tid
-    from .envelope import ccompile, initialize
-    initialize(get_config_by_tid(tid))
-    return ccompile(0, {}, circuit, signal='iq')
-
-
-TABLE = string.digits+string.ascii_uppercase
-
-
-def basen(number: int, base: int, table: str = TABLE):
-    mods = []
-    while True:
-        div, mod = divmod(number, base)
-        mods.append(mod)
-        if div == 0:
-            mods.reverse()
-            return ''.join([table[i] for i in mods])
-        number = div
-
-
-def baser(number: str, base: int, table: str = TABLE):
-    return sum([table.index(c)*base**i for i, c in enumerate(reversed(number))])
-
-
-def dumpv(value):
-    # print('ccccccccccccccccccccccc', value)
-    # if type(value).__name__ in ['Waveform', 'WaveVStack']:
-    #     sl = ShareableList([dump(value)])
-    #     result = ('ShareableList', sl.shm.name)
-    if isinstance(value, np.ndarray):
-        sm = SharedMemory(create=True, size=value.nbytes)
-        buf = np.ndarray(value.shape, dtype=value.dtype, buffer=sm.buf)
-        buf[:] = value[:]
-        result = sm, ('SharedMemory', sm.name, buf.shape, buf.dtype.str)
-        # sm.close()
-    else:
-        result = '', value
-    return result
-
-
-def loadv(value):
-    if isinstance(value, tuple) and value[0] == 'SharedMemory':
-        name, shape, dtype = value[1:]
-        shm = SharedMemory(name=name)
-        buf = np.ndarray(shape=shape, dtype=dtype, buffer=shm.buf)
-        return shm, buf
-    else:
-        return '', value
-
-
-try:
-    from IPython import get_ipython
-
-    shell = get_ipython().__class__.__name__
-    if shell == 'ZMQInteractiveShell':
-        from tqdm.notebook import tqdm  # jupyter notebook or qtconsole
-    else:
-        # ipython in terminal(TerminalInteractiveShell)
-        # None(Win)
-        # Nonetype(Mac)
-        from tqdm import tqdm
-except Exception as e:
-    # not installed or Probably IDLE
-    from tqdm import tqdm
-
-
-class Progress(tqdm):
-    """兼容JupyterProgressBar接口(from kernel)的实现
-    """
-    bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
-
-    def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
-        super().__init__([], desc, total, ncols=None, colour='blue',
-                         bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
-
-    @property
-    def max(self):
-        return self.total
-
-    @max.setter
-    def max(self, value: int):
-        self.reset(value)
-
-    def goto(self, index: int):
-        self.n = index
-        self.refresh()
-
-    def finish(self, success: bool = True):
-        self.colour = 'green' if success else 'red'
-        # self.set_description_str(str(success))
-
-
-class Task(object):
-    """适用于大量任务连续提交(如量子云)
-    """
-
-    handles = {}
-    counter = defaultdict(lambda: 0)
-    server = None
-
-    def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
-        """实例化任务，用于跟踪进度、获取结果以及画图
-
-        Args:
-            task (dict): 任务描述，详见submit函数
-            timeout (float | None, optional): 阻塞任务最大时间. Defaults to None.
-            plot (bool, optional): 是否实时画图. 默认为False.
-        """
-        self.task = task
-        self.timeout = timeout
-        self.plot = plot
-
-        self.data: dict[str, np.ndarray] = {}  # 从server取回的数据
-        self.meta = {}  # 坐标轴等描述类信息
-        self.index = 0  # 当前已取回的数据数量
-        self.last = 0  # 上一次获取的数据量
-
-        self.thread = current_thread().name
-
-    @cached_property
-    def name(self):
-        return self.task['metainfo'].get('name', 'Unknown')
-
-    @cached_property
-    def ctx(self):
-        return self.step(-9, 'ctx')
-
-    def run(self):
-        """提交任务，如果有正在执行的任务则需等待
-        """
-        self.stime = time.time()  # start time
-        try:
-            circuit = self.task['taskinfo']['CIRQ']
-            if isinstance(circuit, list) and callable(circuit[0]):
-                circuit[0] = inspect.getsource(circuit[0])
-        except Exception as e:
-            logger.error(f'Failed to get circuit: {e}')
-        self.tid = self.server.submit(self.task)
-
-    def cancel(self):
-        """处理从server取回的数据
-        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值
-        """
-        self.server.cancel(self.tid)
-        # self.clear()
-
-    def result(self):
-        """从server取回数据
-        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值.
-        """
-        meta = True if not self.meta else False
-        res = self.server.fetch(self.tid, start=self.index, meta=meta)
-
-        if isinstance(res, str):
-            return self.data
-        elif isinstance(res, tuple):
-            if isinstance(res[0], str):
-                return self.data
-            data, self.meta = res
-        else:
-            data = res
-        self.last = self.index
-        self.index += len(data)
-        # data.clear()
-        self.process(data)
-
-        if callable(self.plot):
-            self.plot(self, not meta)
-            # self.plot(not meta)
-
-        return self.data
-
-    def status(self, key: str = 'runtime'):
-        if key == 'runtime':
-            return self.server.track(self.tid)
-        elif key == 'compile':
-            return self.server.apply('status', user='task')
-        else:
-            return 'supported arguments are: {rumtime, compile}'
-
-    def report(self):
-        return self.server.report(self.tid)
-
-    def step(self, index: int, stage: str = 'raw'):
-        """获取任务中某一步的详细信息
-
-        Args:
-            index (int): 步数.
-            stage (str, optional): 任务执行所经历的阶段. Defaults to 'raw'.
-
-        Examples: stage可取以下值
-            - ini: 编译生成的指令
-            - raw: 映射为硬件通道后的指令及收集好的相关参数
-            - ctx: 编译所用的上下文环境(ctx)
-            - debug: 由设备返回的原始数据
-            - trace: 每个指令执行所用时间
-
-        Returns:
-            _type_: _description_
-        """
-        if stage in ['ini', 'raw', 'ctx', 'byp']:
-            return self.server.review(self.tid, index)[stage]
-        elif stage in ['debug', 'trace']:
-            return self.server.track(self.tid, index)[stage]
-
-    def process(self, data: list[dict]):
-        for dat in data:
-            for k, v in dat.items():
-                if k in self.data:
-                    self.data[k].append(v)
-                else:
-                    self.data[k] = [v]
-
-    def update(self):
-        try:
-            self.result()
-        except Exception as e:
-            logger.error(f'Failed to fetch result: {e}')
-
-        status = self.status()['status']
-
-        if status in ['Failed', 'Canceled']:
-            self.stop(self.tid, False)
-            return True
-        elif status in ['Running']:
-            self.progress.goto(self.index)
-            return False
-        elif status in ['Finished', 'Archived']:
-            self.progress.goto(self.progress.max)
-            if hasattr(self, 'app'):
-                self.app.save()
-            self.stop(self.tid)
-            self.result()
-            return True
-
-    def clear(self):
-        self.counter.clear()
-        for tid, handle in self.handles.items():
-            self.stop(tid)
-
-    def stop(self, tid: int, success: bool = True):
-        try:
-            self.progress.finish(success)
-            self.handles[tid].cancel()
-        except Exception as e:
-            pass
-
-    def bar(self, interval: float = 2.0, disable: bool = False):
-        """任务进度信息. 如果timeout非零, 则同步阻塞执行, 否则异步.
-        NOTE: 如果结果获取不到或者不全, 可能是save清空导致,可减小interval增加取数频率.
-
-        Args:
-            interval (float, optional): 进度刷新时间间隔, 不宜也不必过快. Defaults to 2.0.
-
-        Raises:
-            TimeoutError: 如果任务超过了认定的最大时间还未完则停止.
-                实际还在执行, 只是Task不再获取数据及进度.如不需要执行, 可cancel任务.
-        """
-        while True:
-            try:
-                status = self.status()['status']
-                if status in ['Pending']:
-                    time.sleep(interval)
-                    continue
-                elif status == 'Canceled':
-                    return 'Task canceled!'
-                else:
-                    self.progress = Progress(desc=self.name,
-                                             total=self.report()['size'],
-                                             postfix=self.thread, disable=disable)
-                    break
-            except Exception as e:
-                logger.error(
-                    f'Failed to get status: {e},{self.report()}')
-
-        if isinstance(self.timeout, float):
-            while True:
-                if self.timeout > 0 and (time.time() - self.stime > self.timeout):
-                    msg = f'Timeout: {self.timeout}'
-                    logger.warning(msg)
-                    raise TimeoutError(msg)
-                time.sleep(interval)
-                if self.update():
-                    break
-        else:
-            self.progress.clear()
-            self.refresh(interval)
-        self.progress.close()
-
-    def refresh(self, interval: float = 2.0):
-        self.progress.display()
-        if self.update():
-            self.progress.display()
-            return
-        self.handles[self.tid] = asyncio.get_running_loop(
-        ).call_later(interval, self.refresh, *(interval,))
-
-
-def transpile(task: dict):
-    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
-    if quafuos not in sys.path:
-        print('adding quafuos', quafuos)
-        sys.path.append(quafuos)
-
-    circuit = task.get('circuit', '')
-    qasm = ''
-    if not isinstance(circuit, list):
-        from ._cloud import openqasm_to_qlisp
-        # if task.get('compile', True):
-        from qusteedAPIs import call_transpiler_api
-        qasm, final_qubit2cbit, compiled_circuit_information = call_transpiler_api(
-            input_circuit=circuit,
-            compile=task.get('compile', True),
-            backend=task.get('chip', ''))
-        # import compiler
-        # transpile
-        # else:
-        #     print('nononononoonoo compile')
-        #     qasm = circuit
-        mapping = {}
-        try:
-            with open(Path.home()/'Desktop/home/mapping.json', 'r') as f:
-                mapping = json.loads(f.read())
-        except Exception as e:
-            if task['chip'] == 'Haituo':
-                mapping[task['chip']] = {
-                    str(i): f'Q{i+39}' for i in range(156)}
-            else:
-                mapping[task['chip']] = {str(i): f'Q{i+0}' for i in range(156)}
-        QMAP = mapping[task['chip']]
-
-        circuit, qubits = openqasm_to_qlisp(qasm, QMAP=QMAP)
-
-    qlisp = ',\n'.join([str(op) for op in circuit])
-    logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
-
-    measure = []
-    for ops in circuit:
-        if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
-            measure.append((ops[0][1], ops[1]))
-    return qasm, [circuit], measure
-
-
-def update(backend: str, info: dict, token: str = ''):
-
-    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
-    if quafuos not in sys.path:
-        print('adding quafuos', quafuos)
-        sys.path.append(quafuos)
-    with open(f'{backend}.json', 'w') as f:
-        f.write(json.dumps(info, indent=4))
-    from qusteedAPIs import call_local_backend_api
-    call_local_backend_api(backend=backend, chip_info_dict=info)
-    logger.warning(f'database of {backend} updated!')
-
-    try:
-        from ._cloud import update_chip_info_of_quafu
-        msg = update_chip_info_of_quafu(backend.lower(), info, token)
-        logger.warning(f'chip info of quafu[{backend.lower()}] updated!')
-    except Exception as e:
-        msg = f'Failed to update chip info of quafu, {e}'
-        logger.critical(msg)
-
-    return f'compiler database of {backend} updated!\r\n{msg}'
-
-
-class QuarkProxy(object):
-    """云客户端
-    """
-
-    def __init__(self) -> None:
-        from .app import login
-
-        self.server = login()
-        setlog()
-
-    def submit(self, task: dict, block: bool = False):
-        from .app import submit
-
-        # by server
-        # logger.info(f'task will be executed on local machine: {chip}!')
-        logger.warning(f'\n\n\n{"#"*80} task start to run ...\n')
-
-        try:
-            from home.ylfeng.cloud import get_bias_of_coupler
-            bias = get_bias_of_coupler()
-        except Exception as e:
-            bias = []
-            logger.error(f'Failed to get bias of coupler, {e}!')
-        circuit = [bias+c for c in task['taskinfo']['CIRQ']]
-        task['taskinfo']['CIRQ'] = circuit
-
-        qlisp = ',\n'.join([str(op) for op in circuit[0]])
-        qasm = task['metainfo']['coqis']['qasm']
-        logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
-
-        t: Task = submit(task, block=block)  # local machine
-        if block:
-            t.bar(0.2, disable=False)  # if block is True
-        eid = task['metainfo']['coqis']['eid']
-        logger.warning(f'task {t.tid}[{eid}] will be executed!')
-
-        return t.tid
-        # t.bar(0.1, True)
-
-        # ret = {}
-        # for kv in t.result()['count']:
-        #     base = tuple(kv[:-1])
-        #     ret[base] = ret.get(base, 0)+kv[-1]
-
-        # return ret, t.status()['status']
-
-    def cancel(self, tid: int):
-        return self.server.cancel(tid)
-
-    def status(self, tid: int = 0):
-        pass
-
-    def result(self, tid: int, raw: bool = False):
-        """根据任务id获取结果
-
-        Args:
-            tid (int): 任务id
-
-        Returns:
-            dict: 数据及任务元信息
-        """
-        from .app import get_data_by_tid
-        try:
-            result = get_data_by_tid(tid, 'count')
-            return result if raw else self.process(result)
-        except Exception as e:
-            return f'No data found for {tid}!'
-
-    @classmethod
-    def process(cls, result: dict, dropout: bool = False):
-        def _delete_dict(ret: dict, num: int = 0):
-            while num > 0:
-                tmp = np.cumsum(list(ret.values()))
-                ran_num = np.random.randint(tmp[-1]+1)
-                ran_pos = np.searchsorted(tmp, ran_num)
-                ret[list(ret.keys())[ran_pos]] -= 1
-                if ret[list(ret.keys())[ran_pos]] == 0:
-                    ret.pop(list(ret.keys())[ran_pos], 0)
-                num -= 1
-
-        meta = result['meta']
-        coqis = meta.get('coqis', {})
-        status = 'Failed'
-        if meta['status'] in ['Finished', 'Archived']:
-            try:
-                # data: list[dict] = result['data']['count']
-                data: list[np.ndarray] = result['data']['count']
-                status = 'Finished'
-            except Exception as e:
-                logger.error(f'Failed to postprocess result: {e}')
-
-        dres, cdres = {}, {}
-        if status == 'Finished':
-            for dat in data:
-                # for k, v in dat.items():  # dat[()][0]
-                #     dres[k] = dres.get(k, 0)+v
-                for kv in dat:
-                    if kv[-1] < 0:
-                        continue
-                    base = tuple(kv[:-1]-1)  # from 1&2 to 0&1
-                    dres[base] = dres.get(base, 0)+int(kv[-1])
-
-            try:
-                if dropout:
-                    shots = meta['other']['shots'] * \
-                        len(meta['axis']['repeat']['repeat'])
-                    _delete_dict(dres, shots - (shots//1000)*1000)
-            except Exception as e:
-                logger.error(f'Failed to dropout: {e}')
-
-            try:
-                if meta['coqis']['correct']:
-                    from home.ylfeng.cloud import correct_readout
-                    cdres = correct_readout(dres, meta['other']['measure'])
-                else:
-                    cdres = {}
-            except Exception as e:
-                cdres = dres
-                logger.error(f'Failed to correct readout, {e}!')
-
-        ret = {'count': {''.join((str(i) for i in k)): v for k, v in dres.items()},
-               'corrected': {''.join((str(i) for i in k)): v for k, v in cdres.items()},
-               'transpiled': coqis.get('qasm', ''),
-               'qlisp': coqis.get('qlisp', ''),
-               'tid': meta['tid'],
-               'error': meta.get('error', ''),
-               'status': status,
-               'finished': meta['finished'],
-               }
-        return ret
-
-    def snr(self, data):
-        return data
+"""!!! note "**用户输入输出**"
+
+- app: 用户函数或任务定义
+- driver: 设备驱动. **NOTE: 如发生改动, 需要重启server**
+    - 所有驱动继承自BaseDriver，类名统一为Driver，并要求实现open/close/read/write四个方法。样板见VirtualDevice
+    - 以设备或厂家为名新建文件夹(并于其内新建__init__.py文件)放于driver/common内，将厂家提供的底层库(若有)置于其内
+
+- envelope: 执行流程，见各模块说明. **NOTE: 如发生改动, 需要重启server**
+"""
+
+
+import asyncio
+import inspect
+import json
+import string
+import sys
+import time
+from collections import defaultdict
+from functools import cached_property
+from multiprocessing.shared_memory import SharedMemory
+from pathlib import Path
+from threading import Lock, Thread, current_thread
+
+import numpy as np
+from loguru import logger
+
+QUARK = Path.home()/'quark'
+
+try:
+    with open(QUARK/'startup.json', 'r') as f:
+        startup = json.loads(f.read())
+        SYSTEMQ = str(Path(startup['site']).resolve())
+        if SYSTEMQ.lower() not in sys.path:
+            sys.path.append(SYSTEMQ)
+except Exception as e:
+    logger.error(str(e))
+    startup = {}
+
+
+def setlog(prefix: str = ''):
+    logger.remove()
+    root = Path.home()/f"Desktop/home/log/proxy/{prefix}"
+    path = root/"{time:%Y-%m-%d}.log"
+    level = "INFO"
+    config = {'handlers': [{'sink': sys.stdout,
+                            'level': level},
+                           {'sink': path,
+                            'rotation': '00:00',
+                            'retention': '10 days',
+                            'encoding': 'utf-8',
+                            'level': level,
+                            'backtrace': False, }]}
+    # logger.add(path, rotation="20 MB")
+    logger.configure(**config)
+
+
+def debug(circuit: list = [(('Measure', 0), 'Q1001')], tid: int = 0):
+    from .app import get_config_by_tid
+    from .envelope import ccompile, initialize
+    initialize(get_config_by_tid(tid))
+    return ccompile(0, {}, circuit, signal='iq')
+
+
+TABLE = string.digits+string.ascii_uppercase
+
+
+def basen(number: int, base: int, table: str = TABLE):
+    mods = []
+    while True:
+        div, mod = divmod(number, base)
+        mods.append(mod)
+        if div == 0:
+            mods.reverse()
+            return ''.join([table[i] for i in mods])
+        number = div
+
+
+def baser(number: str, base: int, table: str = TABLE):
+    return sum([table.index(c)*base**i for i, c in enumerate(reversed(number))])
+
+
+def dumpv(value):
+    # print('ccccccccccccccccccccccc', value)
+    # if type(value).__name__ in ['Waveform', 'WaveVStack']:
+    #     sl = ShareableList([dump(value)])
+    #     result = ('ShareableList', sl.shm.name)
+    if isinstance(value, np.ndarray):
+        sm = SharedMemory(create=True, size=value.nbytes)
+        buf = np.ndarray(value.shape, dtype=value.dtype, buffer=sm.buf)
+        buf[:] = value[:]
+        result = sm, ('SharedMemory', sm.name, buf.shape, buf.dtype.str)
+        # sm.close()
+    else:
+        result = '', value
+    return result
+
+
+def loadv(value):
+    if isinstance(value, tuple) and value[0] == 'SharedMemory':
+        name, shape, dtype = value[1:]
+        shm = SharedMemory(name=name)
+        buf = np.ndarray(shape=shape, dtype=dtype, buffer=shm.buf)
+        return shm, buf
+    else:
+        return '', value
+
+
+try:
+    from IPython import get_ipython
+
+    shell = get_ipython().__class__.__name__
+    if shell == 'ZMQInteractiveShell':
+        from tqdm.notebook import tqdm  # jupyter notebook or qtconsole
+    else:
+        # ipython in terminal(TerminalInteractiveShell)
+        # None(Win)
+        # Nonetype(Mac)
+        from tqdm import tqdm
+except Exception as e:
+    # not installed or Probably IDLE
+    from tqdm import tqdm
+
+
+class Progress(tqdm):
+    """兼容JupyterProgressBar接口(from kernel)的实现
+    """
+    bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
+
+    def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
+        super().__init__([], desc, total, ncols=None, colour='blue',
+                         bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
+
+    @property
+    def max(self):
+        return self.total
+
+    @max.setter
+    def max(self, value: int):
+        self.reset(value)
+
+    def goto(self, index: int):
+        self.n = index
+        self.refresh()
+
+    def finish(self, success: bool = True):
+        self.colour = 'green' if success else 'red'
+        # self.set_description_str(str(success))
+
+
+class Task(object):
+    """适用于大量任务连续提交(如量子云)
+    """
+
+    handles = {}
+    counter = defaultdict(lambda: 0)
+    server = None
+
+    def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
+        """实例化任务，用于跟踪进度、获取结果以及画图
+
+        Args:
+            task (dict): 任务描述，详见submit函数
+            timeout (float | None, optional): 阻塞任务最大时间. Defaults to None.
+            plot (bool, optional): 是否实时画图. 默认为False.
+        """
+        self.task = task
+        self.timeout = timeout
+        self.plot = plot
+
+        self.data: dict[str, np.ndarray] = {}  # 从server取回的数据
+        self.meta = {}  # 坐标轴等描述类信息
+        self.index = 0  # 当前已取回的数据数量
+        self.last = 0  # 上一次获取的数据量
+
+        self.thread = current_thread().name
+
+    @cached_property
+    def name(self):
+        return self.task['metainfo'].get('name', 'Unknown')
+
+    @cached_property
+    def ctx(self):
+        return self.step(-9, 'ctx')
+
+    def run(self):
+        """提交任务，如果有正在执行的任务则需等待
+        """
+        self.stime = time.time()  # start time
+        try:
+            circuit = self.task['taskinfo']['CIRQ']
+            if isinstance(circuit, list) and callable(circuit[0]):
+                circuit[0] = inspect.getsource(circuit[0])
+        except Exception as e:
+            logger.error(f'Failed to get circuit: {e}')
+        self.tid = self.server.submit(self.task)
+
+    def cancel(self):
+        """处理从server取回的数据
+        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值
+        """
+        self.server.cancel(self.tid)
+        # self.clear()
+
+    def result(self):
+        """从server取回数据
+        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值.
+        """
+        meta = True if not self.meta else False
+        res = self.server.fetch(self.tid, start=self.index, meta=meta)
+
+        if isinstance(res, str):
+            return self.data
+        elif isinstance(res, tuple):
+            if isinstance(res[0], str):
+                return self.data
+            data, self.meta = res
+        else:
+            data = res
+        self.last = self.index
+        self.index += len(data)
+        # data.clear()
+        self.process(data)
+
+        if callable(self.plot):
+            self.plot(self, not meta)
+            # self.plot(not meta)
+
+        return self.data
+
+    def status(self, key: str = 'runtime'):
+        if key == 'runtime':
+            return self.server.track(self.tid)
+        elif key == 'compile':
+            return self.server.apply('status', user='task')
+        else:
+            return 'supported arguments are: {rumtime, compile}'
+
+    def report(self):
+        return self.server.report(self.tid)
+
+    def step(self, index: int, stage: str = 'raw'):
+        """获取任务中某一步的详细信息
+
+        Args:
+            index (int): 步数.
+            stage (str, optional): 任务执行所经历的阶段. Defaults to 'raw'.
+
+        Examples: stage可取以下值
+            - ini: 编译生成的指令
+            - raw: 映射为硬件通道后的指令及收集好的相关参数
+            - ctx: 编译所用的上下文环境(ctx)
+            - debug: 由设备返回的原始数据
+            - trace: 每个指令执行所用时间
+
+        Returns:
+            _type_: _description_
+        """
+        if stage in ['ini', 'raw', 'ctx', 'byp']:
+            return self.server.review(self.tid, index)[stage]
+        elif stage in ['debug', 'trace']:
+            return self.server.track(self.tid, index)[stage]
+
+    def process(self, data: list[dict]):
+        for dat in data:
+            for k, v in dat.items():
+                if k in self.data:
+                    self.data[k].append(v)
+                else:
+                    self.data[k] = [v]
+
+    def update(self):
+        try:
+            self.result()
+        except Exception as e:
+            logger.error(f'Failed to fetch result: {e}')
+
+        status = self.status()['status']
+
+        if status in ['Failed', 'Canceled']:
+            self.stop(self.tid, False)
+            return True
+        elif status in ['Running']:
+            self.progress.goto(self.index)
+            return False
+        elif status in ['Finished', 'Archived']:
+            self.progress.goto(self.progress.max)
+            if hasattr(self, 'app'):
+                self.app.save()
+            self.stop(self.tid)
+            self.result()
+            return True
+
+    def clear(self):
+        self.counter.clear()
+        for tid, handle in self.handles.items():
+            self.stop(tid)
+
+    def stop(self, tid: int, success: bool = True):
+        try:
+            self.progress.finish(success)
+            self.handles[tid].cancel()
+        except Exception as e:
+            pass
+
+    def bar(self, interval: float = 2.0, disable: bool = False):
+        """任务进度信息. 如果timeout非零, 则同步阻塞执行, 否则异步.
+        NOTE: 如果结果获取不到或者不全, 可能是save清空导致,可减小interval增加取数频率.
+
+        Args:
+            interval (float, optional): 进度刷新时间间隔, 不宜也不必过快. Defaults to 2.0.
+
+        Raises:
+            TimeoutError: 如果任务超过了认定的最大时间还未完则停止.
+                实际还在执行, 只是Task不再获取数据及进度.如不需要执行, 可cancel任务.
+        """
+        while True:
+            try:
+                status = self.status()['status']
+                if status in ['Pending']:
+                    time.sleep(interval)
+                    continue
+                elif status == 'Canceled':
+                    return 'Task canceled!'
+                else:
+                    self.progress = Progress(desc=self.name,
+                                             total=self.report()['size'],
+                                             postfix=self.thread, disable=disable)
+                    break
+            except Exception as e:
+                logger.error(
+                    f'Failed to get status: {e},{self.report()}')
+
+        if isinstance(self.timeout, float):
+            while True:
+                if self.timeout > 0 and (time.time() - self.stime > self.timeout):
+                    msg = f'Timeout: {self.timeout}'
+                    logger.warning(msg)
+                    raise TimeoutError(msg)
+                time.sleep(interval)
+                if self.update():
+                    break
+        else:
+            self.progress.clear()
+            self.refresh(interval)
+        self.progress.close()
+
+    def refresh(self, interval: float = 2.0):
+        self.progress.display()
+        if self.update():
+            self.progress.display()
+            return
+        self.handles[self.tid] = asyncio.get_running_loop(
+        ).call_later(interval, self.refresh, *(interval,))
+
+
+def transpile(task: dict):
+    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
+    if quafuos not in sys.path:
+        print('adding quafuos', quafuos)
+        sys.path.append(quafuos)
+
+    circuit = task.get('circuit', '')
+    qasm = ''
+    if not isinstance(circuit, list):
+        from ._cloud import openqasm_to_qlisp
+        # if task.get('compile', True):
+        from qusteedAPIs import call_transpiler_api
+        qasm, final_qubit2cbit, compiled_circuit_information = call_transpiler_api(
+            input_circuit=circuit,
+            compile=task.get('compile', True),
+            backend=task.get('chip', ''))
+        # import compiler
+        # transpile
+        # else:
+        #     print('nononononoonoo compile')
+        #     qasm = circuit
+        mapping = {}
+        try:
+            with open(Path.home()/'Desktop/home/mapping.json', 'r') as f:
+                mapping = json.loads(f.read())
+        except Exception as e:
+            if task['chip'] == 'Haituo':
+                mapping[task['chip']] = {
+                    str(i): f'Q{i+39}' for i in range(156)}
+            else:
+                mapping[task['chip']] = {str(i): f'Q{i+0}' for i in range(156)}
+        QMAP = mapping[task['chip']]
+
+        circuit, qubits = openqasm_to_qlisp(qasm, QMAP=QMAP)
+
+    qlisp = ',\n'.join([str(op) for op in circuit])
+    logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
+
+    measure = []
+    for ops in circuit:
+        if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
+            measure.append((ops[0][1], ops[1]))
+    return qasm, [circuit], measure
+
+
+def update(backend: str, info: dict, token: str = ''):
+
+    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
+    if quafuos not in sys.path:
+        print('adding quafuos', quafuos)
+        sys.path.append(quafuos)
+    with open(f'{backend}.json', 'w') as f:
+        f.write(json.dumps(info, indent=4))
+    from qusteedAPIs import call_local_backend_api
+    call_local_backend_api(backend=backend, chip_info_dict=info)
+    logger.warning(f'database of {backend} updated!')
+
+    try:
+        from ._cloud import update_chip_info_of_quafu
+        msg = update_chip_info_of_quafu(backend.lower(), info, token)
+        logger.warning(f'chip info of quafu[{backend.lower()}] updated!')
+    except Exception as e:
+        msg = f'Failed to update chip info of quafu, {e}'
+        logger.critical(msg)
+
+    return f'compiler database of {backend} updated!\r\n{msg}'
+
+
+class QuarkProxy(object):
+    """云客户端
+    """
+
+    def __init__(self) -> None:
+        from .app import login
+
+        self.server = login()
+        setlog()
+
+    def submit(self, task: dict, block: bool = False):
+        from .app import submit
+
+        # by server
+        # logger.info(f'task will be executed on local machine: {chip}!')
+        logger.warning(f'\n\n\n{"#"*80} task start to run ...\n')
+
+        try:
+            from home.ylfeng.cloud import get_bias_of_coupler
+            bias = get_bias_of_coupler()
+        except Exception as e:
+            bias = []
+            logger.error(f'Failed to get bias of coupler, {e}!')
+        circuit = [bias+c for c in task['taskinfo']['CIRQ']]
+        task['taskinfo']['CIRQ'] = circuit
+
+        qlisp = ',\n'.join([str(op) for op in circuit[0]])
+        qasm = task['metainfo']['coqis']['qasm']
+        logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
+
+        t: Task = submit(task, block=block)  # local machine
+        if block:
+            t.bar(0.2, disable=False)  # if block is True
+        eid = task['metainfo']['coqis']['eid']
+        logger.warning(f'task {t.tid}[{eid}] will be executed!')
+
+        return t.tid
+
+    def cancel(self, tid: int):
+        return self.server.cancel(tid)
+
+    def status(self, tid: int = 0):
+        pass
+
+    def result(self, tid: int, raw: bool = False):
+        """根据任务id获取结果
+
+        Args:
+            tid (int): 任务id
+
+        Returns:
+            dict: 数据及任务元信息
+        """
+        from .app import get_data_by_tid
+        try:
+            result = get_data_by_tid(tid, 'count')
+            return result if raw else self.process(result)
+        except Exception as e:
+            return f'No data found for {tid}!'
+
+    @classmethod
+    def process(cls, result: dict, dropout: bool = False):
+        def _delete_dict(ret: dict, num: int = 0):
+            while num > 0:
+                tmp = np.cumsum(list(ret.values()))
+                ran_num = np.random.randint(tmp[-1]+1)
+                ran_pos = np.searchsorted(tmp, ran_num)
+                ret[list(ret.keys())[ran_pos]] -= 1
+                if ret[list(ret.keys())[ran_pos]] == 0:
+                    ret.pop(list(ret.keys())[ran_pos], 0)
+                num -= 1
+
+        meta = result['meta']
+        coqis = meta.get('coqis', {})
+        status = 'Failed'
+        if meta['status'] in ['Finished', 'Archived']:
+            try:
+                # data: list[dict] = result['data']['count']
+                data: list[np.ndarray] = result['data']['count']
+                status = 'Finished'
+            except Exception as e:
+                logger.error(f'Failed to postprocess result: {e}')
+
+        dres, cdres = {}, {}
+        if status == 'Finished':
+            for dat in data:
+                # for k, v in dat.items():  # dat[()][0]
+                #     dres[k] = dres.get(k, 0)+v
+                for kv in dat:
+                    if kv[-1] < 0:
+                        continue
+                    base = tuple(kv[:-1]-1)  # from 1&2 to 0&1
+                    dres[base] = dres.get(base, 0)+int(kv[-1])
+
+            try:
+                if dropout:
+                    shots = meta['other']['shots'] * \
+                        len(meta['axis']['repeat']['repeat'])
+                    _delete_dict(dres, shots - (shots//1000)*1000)
+            except Exception as e:
+                logger.error(f'Failed to dropout: {e}')
+
+            try:
+                if meta['coqis']['correct']:
+                    from home.ylfeng.cloud import correct_readout
+                    cdres = correct_readout(dres, meta['other']['measure'])
+                else:
+                    cdres = {}
+            except Exception as e:
+                cdres = dres
+                logger.error(f'Failed to correct readout, {e}!')
+
+        ret = {'count': {''.join((str(i) for i in k)): v for k, v in dres.items()},
+               'corrected': {''.join((str(i) for i in k)): v for k, v in cdres.items()},
+               'transpiled': coqis.get('qasm', ''),
+               'qlisp': coqis.get('qlisp', ''),
+               'tid': meta['tid'],
+               'error': meta.get('error', ''),
+               'status': status,
+               'finished': meta['finished'],
+               }
+        return ret
+
+    def snr(self, data):
+        return data
```

## quark/app/__init__.py

```diff
@@ -128,15 +128,15 @@
         t = Task(app)
         t.server = ss
         t.plot = plot if kwds.get('plot', False) else False
         t.timeout = 1e9 if block else None
         t.run()
         return t
 
-    from .task import Scan, Scanner
+    from kernel.task import Scan, Scanner
 
     if not isinstance(app, (Scan, Scanner)):
         return logger.critical('Unknown type of App, Scan or Scanner required!')
 
     app.toserver = 'ready'
     app.run(dry_run=True, quiet=True)
     time.sleep(3)
```

## quark/app/task.py

```diff
@@ -1,253 +1,253 @@
-"""扩展各Scanner以用于submit
-"""
-
-from abc import ABC, abstractmethod
-from pathlib import Path
-
-import dill
-import numpy as np
-from kernel.terminal.scan import App
-from kernel.terminal.scan import Scan as _Scan
-from loguru import logger
-from qos_tools.experiment.scanner2 import Scanner as _Scanner
-from tqdm import tqdm
-from waveforms.dicttree import flattenDictIter
-from waveforms.scan_iter import StepStatus
-
-
-class TaskMixin(ABC):
-    """扩展兼容App
-    """
-
-    def __new__(cls, *args, **kwds):
-        for base in cls.__mro__:
-            if base.__name__ == 'TaskMixin':
-                for k in dir(base):
-                    if not k.startswith('__') and k not in base.__abstractmethods__:
-                        setattr(cls, k, getattr(base, k))
-        return super().__new__(cls)
-
-    @abstractmethod
-    def variables(self) -> dict[str, list[tuple]]:
-        """生成变量
-
-        Examples: 形如
-            >>> {'x':[('x1', [1,2,3], 'au'), ('x2', [1,2,3], 'au')],
-                'y':[('y1', [1,2,3], 'au'), ('y2', [1,2,3], 'au')],
-                'z':[('z1', [1,2,3], 'au'), ('z2', [1,2,3], 'au')]
-                }
-        """
-        return {}
-
-    @abstractmethod
-    def dependencies(self) -> list[str]:
-        """生成参数依赖
-
-        Examples: 形如
-            >>> [f'<gate.rfUnitary.{q}.params.frequency>=12345' for q in qubits]
-        """
-        return []
-
-    @abstractmethod
-    def circuits(self):
-        """生成线路描述
-
-        Examples: 形如
-            >>> [c1, c2, c3, ...]
-        """
-        yield
-
-    def run(self, dry_run=False, quiet=False):
-        try:
-            self.toserver.run()
-        except:
-            import kernel
-            from kernel.sched.sched import generate_task_id, get_system_info
-            self.runtime.prog.task_arguments = (), {}
-            self.runtime.prog.meta_info['arguments'] = {}
-            self.runtime.id = generate_task_id()
-            self.runtime.user = None
-            self.runtime.system_info = {}  # get_system_info()
-            kernel.submit(self, dry_run=dry_run)
-            if not dry_run and not quiet:
-                self.bar()
-
-    def result(self, reshape=True):
-        d = super(App, self).result(reshape)
-        try:
-            if self.toserver:
-                for k, v in self.toserver.result().items():
-                    try:
-                        dk = np.asarray(v)
-                        d[k] = dk.reshape([*self.shape, *dk[0].shape])
-                    except Exception as e:
-                        logger.error(f'Failed to fill result: {e}')
-                        d[k] = v
-                d['mqubits'] = self.toserver.title
-        except Exception as e:
-            logger.error(f'Failed to get result: {e}')
-        return d
-
-    def cancel(self):
-        try:
-            self.toserver.cancel()
-        except:
-            super(App, self).cancel()
-
-    def bar(self, interval: float = 2.0):
-        try:
-            self.toserver.bar(interval)
-        except:
-            super(App, self).bar()
-
-    def save(self):
-        from kernel.sched.sched import session
-        from storage.models import Record
-        with session() as db:
-            record = db.get(Record, self.record_id)
-            record.data = self.result(self.reshape_record)
-
-    def dumps(self, filepath: Path, localhost: bool = True):
-        """将线路写入文件
-
-        Args:
-            filepath (Path): 线路待写入的文件路径
-
-        Raises:
-            TypeError: 线路由StepStatus得到
-
-        Returns:
-            list: 线路中的比特列表
-        """
-        qubtis = []
-        circuits = []
-        with open(filepath, 'w', encoding='utf-8') as f:
-            for step in tqdm(self.circuits(), desc='CircuitExpansion'):
-                if isinstance(step, StepStatus):
-                    cc = step.kwds['circuit']
-                    if localhost:
-                        f.writelines(str(dill.dumps(cc))+'\n')
-                    else:
-                        circuits.append(cc)
-
-                    if step.iteration == 0:
-                        # 获取线路中读取比特列表
-                        for ops in cc:
-                            if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
-                                qubtis.append((ops[0][1], ops[1]))
-                else:
-                    raise TypeError('Wrong type of step!')
-            self.shape = [i+1 for i in step.index]
-        return qubtis, circuits
-
-
-class Scan(_Scan, TaskMixin):
-    """扩展Scanner3, 可直接替换原Scanner3
-    """
-    def __init__(self, name, *args, mixin=None, **kwds):
-        super().__init__(name, *args, mixin=mixin, **kwds)
-        self.patches = {}
-
-    def variables(self) -> dict[str, list[tuple]]:
-        loops = {}
-        for k, v in self.loops.items():
-            loops[k] = [(k, v, 'au')]
-        return loops
-
-    def circuits(self):
-        from waveforms.scan.base import _try_to_call as try_to_call
-
-        self.assemble()
-        for step in self.scan():
-            for k, v in self.mapping.items():
-                self.set(k, step.kwds[v])
-                if not isinstance(step.kwds[v], dict):
-                    self.patches.setdefault((k, v), []).append(step.kwds[v])
-            circ = try_to_call(self.circuit, (), step.kwds)
-            step.kwds['circuit'] = circ
-            yield step
-        # self.assemble()
-        # for step in self.scan():
-        #     for k, v in self.mapping.items():
-        #         self.set(k, step.kwds[v])
-        #     yield step
-
-    def resolve(self):
-        """
-        Examples: 解析获取变量定义
-            >>> loops
-            ({'x': [('x',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
-                    ('__tmp_0__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
-                    ('__tmp_1__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), au'),
-                    ('__tmp_2__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
-                    ('__tmp_3__',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au')],
-            'frequency': [('frequency', array([-2000000.,  2000000.]), 'au')]},
-            >>> deps
-            ['<Q7.bias>=<x.__tmp_0__',
-            '<Q25.bias>=<x.__tmp_1__',
-            '<Q37.bias>=<x.__tmp_2__',
-            '<Q17.bias>=<x.__tmp_3__'])
-        """
-        loops = self.variables()
-        deps = []
-        for axis, value in loops.items():
-            _val = []
-            for k, v in self.patches.items():
-                self.patches[k] = np.unique(v)
-                target, tmpvar = k
-                if len(self.patches[k]) == len(value[0][1]):
-                    _val.append((tmpvar, self.patches[k], 'au'))
-                    deps.append(f'<{target}>=<{axis}.{tmpvar}>')
-                elif len(self.patches[k]) == 1:
-                    dep = f'<{target}>={self.patches[k][0]}'
-                    if dep not in deps:
-                        deps.append(dep)
-            value.extend(_val)
-        return loops, deps
-
-    def dependencies(self) -> list[str]:
-        deps = []
-        for k, v in self.mapping.items():
-            if isinstance(self[v], str):
-                deps.append(f'<{k}>="{self[v]}"')
-            elif isinstance(self[v], dict):
-                for _k, _v in flattenDictIter(self[v]):
-                    if isinstance(_v, str):
-                        deps.append(f'<{k}.{_k}>="{_v}"')
-                    else:
-                        deps.append(f'<{k}.{_k}>={_v}')
-            else:
-                deps.append(f'<{k}>={self[v]}')
-        return deps
-
-
-class Scanner(_Scanner, TaskMixin):
-    """扩展Scanner2, 可直接替换原Scanner2
-    """
-    def __init__(self, name: str, qubits: list[int], scanner_name: str = '', **kw):
-        super().__init__(name, qubits, scanner_name, **kw)
-
-    def variables(self) -> dict[str, list[tuple]]:
-        loops = {}
-        for k, v in self.sweep_setting.items():
-            if isinstance(k, tuple):
-                loops['temp'] = list(zip(k, v, ['au']*len(k)))
-            else:
-                if 'rb' in self.name.lower() and k == 'gate':
-                    continue
-                loops[k] = [(k, v, 'au')]
-        return loops
-
-    def circuits(self):
-        for step in self.scan():
-            # self.update({v_dict['addr']: step.kwds[k]
-            #              for k, v_dict in self.sweep_config.items()})
-            yield step
-
-    def resolve(self):
-        loops = self.variables()
-        deps = []
-        return loops, deps
-
-    def dependencies(self) -> list[str]:
-        return super().dependencies()
+"""扩展各Scanner以用于submit
+"""
+
+from abc import ABC, abstractmethod
+from pathlib import Path
+
+import dill
+import numpy as np
+from kernel.terminal.scan import App
+from kernel.terminal.scan import Scan as _Scan
+from loguru import logger
+from qos_tools.experiment.scanner2 import Scanner as _Scanner
+from tqdm import tqdm
+from waveforms.dicttree import flattenDictIter
+from waveforms.scan_iter import StepStatus
+
+
+class TaskMixin(ABC):
+    """扩展兼容App
+    """
+
+    def __new__(cls, *args, **kwds):
+        for base in cls.__mro__:
+            if base.__name__ == 'TaskMixin':
+                for k in dir(base):
+                    if not k.startswith('__') and k not in base.__abstractmethods__:
+                        setattr(cls, k, getattr(base, k))
+        return super().__new__(cls)
+
+    @abstractmethod
+    def variables(self) -> dict[str, list[tuple]]:
+        """生成变量
+
+        Examples: 形如
+            >>> {'x':[('x1', [1,2,3], 'au'), ('x2', [1,2,3], 'au')],
+                'y':[('y1', [1,2,3], 'au'), ('y2', [1,2,3], 'au')],
+                'z':[('z1', [1,2,3], 'au'), ('z2', [1,2,3], 'au')]
+                }
+        """
+        return {}
+
+    @abstractmethod
+    def dependencies(self) -> list[str]:
+        """生成参数依赖
+
+        Examples: 形如
+            >>> [f'<gate.rfUnitary.{q}.params.frequency>=12345' for q in qubits]
+        """
+        return []
+
+    @abstractmethod
+    def circuits(self):
+        """生成线路描述
+
+        Examples: 形如
+            >>> [c1, c2, c3, ...]
+        """
+        yield
+
+    def run(self, dry_run=False, quiet=False):
+        try:
+            self.toserver.run()
+        except:
+            import kernel
+            from kernel.sched.sched import generate_task_id, get_system_info
+            self.runtime.prog.task_arguments = (), {}
+            self.runtime.prog.meta_info['arguments'] = {}
+            self.runtime.id = generate_task_id()
+            self.runtime.user = None
+            self.runtime.system_info = {}  # get_system_info()
+            kernel.submit(self, dry_run=dry_run)
+            if not dry_run and not quiet:
+                self.bar()
+
+    def result(self, reshape=True):
+        d = super(App, self).result(reshape)
+        try:
+            if self.toserver:
+                for k, v in self.toserver.result().items():
+                    try:
+                        dk = np.asarray(v)
+                        d[k] = dk.reshape([*self.shape, *dk[0].shape])
+                    except Exception as e:
+                        logger.error(f'Failed to fill result: {e}')
+                        d[k] = v
+                d['mqubits'] = self.toserver.title
+        except Exception as e:
+            logger.error(f'Failed to get result: {e}')
+        return d
+
+    def cancel(self):
+        try:
+            self.toserver.cancel()
+        except:
+            super(App, self).cancel()
+
+    def bar(self, interval: float = 2.0):
+        try:
+            self.toserver.bar(interval)
+        except:
+            super(App, self).bar()
+
+    def save(self):
+        from kernel.sched.sched import session
+        from storage.models import Record
+        with session() as db:
+            record = db.get(Record, self.record_id)
+            record.data = self.result(self.reshape_record)
+
+    def dumps(self, filepath: Path, localhost: bool = True):
+        """将线路写入文件
+
+        Args:
+            filepath (Path): 线路待写入的文件路径
+
+        Raises:
+            TypeError: 线路由StepStatus得到
+
+        Returns:
+            list: 线路中的比特列表
+        """
+        qubits = []
+        circuits = []
+        with open(filepath, 'w', encoding='utf-8') as f:
+            for step in tqdm(self.circuits(), desc='CircuitExpansion'):
+                if isinstance(step, StepStatus):
+                    cc = step.kwds['circuit']
+                    if localhost:
+                        f.writelines(str(dill.dumps(cc))+'\n')
+                    else:
+                        circuits.append(cc)
+
+                    if step.iteration == 0:
+                        # 获取线路中读取比特列表
+                        for ops in cc:
+                            if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
+                                qubits.append((ops[0][1], ops[1]))
+                else:
+                    raise TypeError('Wrong type of step!')
+            self.shape = [i+1 for i in step.index]
+        return qubits, circuits
+
+
+class Scan(_Scan, TaskMixin):
+    """扩展Scanner3, 可直接替换原Scanner3
+    """
+    def __init__(self, name, *args, mixin=None, **kwds):
+        super().__init__(name, *args, mixin=mixin, **kwds)
+        self.patches = {}
+
+    def variables(self) -> dict[str, list[tuple]]:
+        loops = {}
+        for k, v in self.loops.items():
+            loops[k] = [(k, v, 'au')]
+        return loops
+
+    def circuits(self):
+        from waveforms.scan.base import _try_to_call as try_to_call
+
+        self.assemble()
+        for step in self.scan():
+            for k, v in self.mapping.items():
+                self.set(k, step.kwds[v])
+                if not isinstance(step.kwds[v], dict):
+                    self.patches.setdefault((k, v), []).append(step.kwds[v])
+            circ = try_to_call(self.circuit, (), step.kwds)
+            step.kwds['circuit'] = circ
+            yield step
+        # self.assemble()
+        # for step in self.scan():
+        #     for k, v in self.mapping.items():
+        #         self.set(k, step.kwds[v])
+        #     yield step
+
+    def resolve(self):
+        """
+        Examples: 解析获取变量定义
+            >>> loops
+            ({'x': [('x',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
+                    ('__tmp_0__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
+                    ('__tmp_1__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), au'),
+                    ('__tmp_2__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
+                    ('__tmp_3__',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au')],
+            'frequency': [('frequency', array([-2000000.,  2000000.]), 'au')]},
+            >>> deps
+            ['<Q7.bias>=<x.__tmp_0__',
+            '<Q25.bias>=<x.__tmp_1__',
+            '<Q37.bias>=<x.__tmp_2__',
+            '<Q17.bias>=<x.__tmp_3__'])
+        """
+        loops = self.variables()
+        deps = []
+        for axis, value in loops.items():
+            _val = []
+            for k, v in self.patches.items():
+                self.patches[k] = np.unique(v)
+                target, tmpvar = k
+                if len(self.patches[k]) == len(value[0][1]):
+                    _val.append((tmpvar, self.patches[k], 'au'))
+                    deps.append(f'<{target}>=<{axis}.{tmpvar}>')
+                elif len(self.patches[k]) == 1:
+                    dep = f'<{target}>={self.patches[k][0]}'
+                    if dep not in deps:
+                        deps.append(dep)
+            value.extend(_val)
+        return loops, deps
+
+    def dependencies(self) -> list[str]:
+        deps = []
+        for k, v in self.mapping.items():
+            if isinstance(self[v], str):
+                deps.append(f'<{k}>="{self[v]}"')
+            elif isinstance(self[v], dict):
+                for _k, _v in flattenDictIter(self[v]):
+                    if isinstance(_v, str):
+                        deps.append(f'<{k}.{_k}>="{_v}"')
+                    else:
+                        deps.append(f'<{k}.{_k}>={_v}')
+            else:
+                deps.append(f'<{k}>={self[v]}')
+        return deps
+
+
+class Scanner(_Scanner, TaskMixin):
+    """扩展Scanner2, 可直接替换原Scanner2
+    """
+    def __init__(self, name: str, qubits: list[int], scanner_name: str = '', **kw):
+        super().__init__(name, qubits, scanner_name, **kw)
+
+    def variables(self) -> dict[str, list[tuple]]:
+        loops = {}
+        for k, v in self.sweep_setting.items():
+            if isinstance(k, tuple):
+                loops['temp'] = list(zip(k, v, ['au']*len(k)))
+            else:
+                if 'rb' in self.name.lower() and k == 'gate':
+                    continue
+                loops[k] = [(k, v, 'au')]
+        return loops
+
+    def circuits(self):
+        for step in self.scan():
+            # self.update({v_dict['addr']: step.kwds[k]
+            #              for k, v_dict in self.sweep_config.items()})
+            yield step
+
+    def resolve(self):
+        loops = self.variables()
+        deps = []
+        return loops, deps
+
+    def dependencies(self) -> list[str]:
+        return super().dependencies()
```

## quark/envelope/processor.py

```diff
@@ -1,94 +1,95 @@
-"""### 数据处理
-- read操作返回见各设备驱动,
-- write操作返回None)
-- 原始结果传给process进行处理
-"""
-
-
-import numpy as np
-from loguru import logger
-
-from .systemq import baqisArchitecture, get_arch, register_arch
-
-register_arch(baqisArchitecture)
-
-
-def demodulate(raw_data, **kwds):
-    pass
-
-
-def process(raw_data, **kwds):
-    """处理数据
-
-    Args:
-        raw_data (dict): 从设备获取的原始结果
-
-    Returns:
-        result (dict): 处理后的数据, 形式为{'key1':np.array,'key2':np.array, ...}
-
-    Example: raw_data例子
-        ``` {.py3 linenums="1"}
-        {'main': {'DAx86_153': {'CH1.Waveform': None}, 
-                                'DAx86_50': {'CH1.Waveform': None}, 
-                                'ADx86_159': {'CH10.CaptureMode': None,
-                                              'CH11.CaptureMode': None, 
-                                              'CH10.StartCapture': None, 
-                                              'CH11.StartCapture': None}}, 
-         'tigger': {'Trigger': {'CH1.TRIG': None}}, 
-         'READ': {'ADx86_159': {'CH10.IQ': (array([[16.62256833],
-                                                   ...,
-                                                   [14.58617952]]), 
-                                            array([[4.0120324 ],
-                                                   ...,
-                                                   [4.97671573]])), 
-                                'CH11.IQ': (array([[14.6038444],
-                                                   ...,
-                                                   [15.33774413]]),
-                                            array([[10.76387584],
-                                                   ...,
-                                                   [11.23863306]]))}}
-        }
-        ```
-    """
-    # print('ddddddddddoooooooooooooooooooooo', kwds)
-    # print("=============================================", raw_data)
-
-    dataMap = kwds.get('dataMap', {'arch': 'baqis'})
-    result = {}
-
-    try:
-
-        if 'arch' in dataMap and dataMap['arch'] == 'general':
-            return raw_data['READ']['AD']
-        elif list(dataMap.keys()) == ['arch']:  # for NA
-            if 'READ' in raw_data:
-                print(raw_data)
-                nadata = result['data'] = raw_data['READ']['NA']
-                if 'CH1.Trace' in nadata:
-                    result['data'] = raw_data['READ']['NA'].pop('CH1.Trace')
-                elif 'CH1.S' in nadata:
-                    result['data'] = raw_data['READ']['NA'].pop('CH1.S')
-            result['extra'] = raw_data
-        else:
-            result = get_arch(dataMap['arch']).assembly_data(raw_data, dataMap)
-
-            for k, v in result.items():
-                if isinstance(v, dict):  # k: count
-                    # v: {(0, 0): 100, (0, 1): 1, (1, 0): 2, (1, 1): 100}
-                    base = np.array(tuple(v))
-                    count = np.array(tuple(v.values()))
-                    # result[k] = np.hstack((base, count[:, None]))
-                    nb, nq, shots = *base.shape, kwds.get('shots', 1024)
-                    result[k] = np.zeros((min(2**nq, shots), nq+1), int) - 1
-                    result[k][:nb] = np.hstack((base, count[:, None]))
-                else:
-                    result[k] = np.asarray(v)
-    except Exception as e:
-        logger.error(f"{'>'*10} 'Failed to process the result', {e}, {'<'*10}")
-        result['error'] = [
-            f'Failed to process the result, raise Exception: {e.__class__.__name__}("{str(e)}")',
-            raw_data,
-            dataMap
-        ]
-
-    return result
+"""### 数据处理
+- read操作返回见各设备驱动,
+- write操作返回None)
+- 原始结果传给process进行处理
+"""
+
+
+import numpy as np
+from loguru import logger
+
+from .systemq import baqisArchitecture, get_arch, register_arch
+
+register_arch(baqisArchitecture)
+
+
+def demodulate(raw_data, **kwds):
+    pass
+
+
+def process(raw_data, **kwds):
+    """处理数据
+
+    Args:
+        raw_data (dict): 从设备获取的原始结果
+
+    Returns:
+        result (dict): 处理后的数据, 形式为{'key1':np.array,'key2':np.array, ...}
+
+    Example: raw_data例子
+        ``` {.py3 linenums="1"}
+        {'main': {'DAx86_153': {'CH1.Waveform': None}, 
+                                'DAx86_50': {'CH1.Waveform': None}, 
+                                'ADx86_159': {'CH10.CaptureMode': None,
+                                              'CH11.CaptureMode': None, 
+                                              'CH10.StartCapture': None, 
+                                              'CH11.StartCapture': None}}, 
+         'tigger': {'Trigger': {'CH1.TRIG': None}}, 
+         'READ': {'ADx86_159': {'CH10.IQ': (array([[16.62256833],
+                                                   ...,
+                                                   [14.58617952]]), 
+                                            array([[4.0120324 ],
+                                                   ...,
+                                                   [4.97671573]])), 
+                                'CH11.IQ': (array([[14.6038444],
+                                                   ...,
+                                                   [15.33774413]]),
+                                            array([[10.76387584],
+                                                   ...,
+                                                   [11.23863306]]))}}
+        }
+        ```
+    """
+    # print('ddddddddddoooooooooooooooooooooo', kwds)
+    # print("=============================================", raw_data)
+
+    dataMap = kwds.get('dataMap', {'arch': 'baqis'})
+    result = {}
+
+    try:
+
+        if 'arch' in dataMap and dataMap['arch'] == 'general':
+            return raw_data['READ']['AD']
+        elif list(dataMap.keys()) == ['arch']:  # for NA
+            if 'READ' in raw_data:
+                print(raw_data)
+                nadata = result['data'] = raw_data['READ']['NA']
+                if 'CH1.Trace' in nadata:
+                    result['data'] = raw_data['READ']['NA'].pop('CH1.Trace')
+                elif 'CH1.S' in nadata:
+                    result['data'] = raw_data['READ']['NA'].pop('CH1.S')
+            result['extra'] = raw_data
+        else:
+            result = get_arch(dataMap['arch']).assembly_data(raw_data, dataMap)
+
+            for k, v in result.items():
+                if isinstance(v, dict):  # k: count or remote_count
+                    # v: {(0, 0): 100, (0, 1): 1, (1, 0): 2, (1, 1): 100}
+                    base = np.array(tuple(v))
+                    count = np.array(tuple(v.values()))
+                    # result[k] = np.hstack((base, count[:, None]))
+                    nb, nq, shots = *base.shape, kwds.get('shots', 1024)
+                    # _k = k.removeprefix('remote_')
+                    result[k] = np.zeros((min(2**nq, shots), nq+1), int) - 1
+                    result[k][:nb] = np.hstack((base, count[:, None]))
+                else:
+                    result[k] = np.asarray(v)
+    except Exception as e:
+        logger.error(f"{'>'*10} 'Failed to process the result', {e}, {'<'*10}")
+        result['error'] = [
+            f'Failed to process the result, raise Exception: {e.__class__.__name__}("{str(e)}")',
+            raw_data,
+            dataMap
+        ]
+
+    return result
```

## quark/envelope/router.py

```diff
@@ -98,15 +98,15 @@
                  "res": "",
                  'transpiled_circuit': res['transpiled'],
                  "server": quafu['systemid']}
 
     if res['status'].lower() == 'finished':
         rshot = sum(res['count'].values())
         post_data.update({"raw": str(res['count']).replace("\'", "\""),
-                          "res": str(res['corrected']).replace("\'", "\""),
+                          "res": str(res['count']).replace("\'", "\""),
                           })
 
     try:
         resp = requests.post(url=f"http://124.70.54.59/qbackend/scq_result/",
                              data=post_data,
                              headers={'api_token': quafu['token']})
         logger.info(f'Back to quafu: {resp.text} {rshot}')
```

## Comparing `vios-2.3.4.dist-info/LICENSE` & `vios-2.3.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `vios-2.3.4.dist-info/METADATA` & `vios-2.3.5.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: vios
-Version: 2.3.4
+Version: 2.3.5
 Summary: runtime requirements for systemq
 Author-email: YL Feng <fengyl@baqis.ac.cn>
 Project-URL: homepage, https://gitee.com
 Project-URL: bugs, https://gitee.com
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
@@ -24,16 +24,16 @@
 Requires-Dist: loguru
 Requires-Dist: cython
 Requires-Dist: gitpython
 Requires-Dist: waveforms
 Requires-Dist: pyvisa
 Requires-Dist: pyserial
 Provides-Extra: full
-Requires-Dist: quarkstudio[full] (>=6.5.0) ; extra == 'full'
-Requires-Dist: waveforms-math (>=1.0.0) ; extra == 'full'
+Requires-Dist: quarkstudio[full] >=6.5.0 ; extra == 'full'
+Requires-Dist: waveforms-math >=1.0.0 ; extra == 'full'
 
 ...
```

## Comparing `vios-2.3.4.dist-info/RECORD` & `vios-2.3.5.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,25 +1,24 @@
-quark/__main__.py,sha256=ky318p_RHmGRdMyzIL2meu-JOgqzRrH-hWfFvhceZGE,2858
-quark/proxy.py,sha256=Raj5V0uqtfn-9fWFWb-kzx4DcS2PTzej3gwen0VSj1k,19343
-quark/app/__init__.py,sha256=MjOh4mkjvwFzEEfPNv-dMOcoktAtYCBtl-P5_UA7MzQ,18861
+quark/proxy.py,sha256=4rpjQK0m_5OU1DAF4x4-jjjewDa9HxnKLWKHxyi4COo,18569
+quark/app/__init__.py,sha256=QwShGh3X6VQ1k8ltdDSP9l_xQLeXemXkpPeuutwhnWg,18867
 quark/app/_data.py,sha256=EGGTD2FrZ8vlbMh4jlmWhYk4fEG3FolGoWaQ26qxoss,2575
 quark/app/demo.py,sha256=eod5vSXKB0XI-Rr8UVKkNc9tOUfWCjI109Imd8bKmuo,10205
-quark/app/task.py,sha256=QEZuNia59sLEWa8pl2XIjItx2NismSTPZFnFt8-90HM,9043
+quark/app/task.py,sha256=OT3e7QWgyeP1aw5L4DlS8-2RvCyOmJKN3YNzaR_Tdj0,8790
 quark/app/uapi.py,sha256=itjEa89SUXozZqBGLH-3o4mKtRssNQODDj60knC-cGE,5876
 quark/driver/VirtualDevice.py,sha256=Cswl_ykFhIsocGV6Okh_YS1b48FeLm2fh1ruXqmNoyw,7914
 quark/driver/__init__.py,sha256=p1pVx1xTulBT8-qdp_zJ859tdIsA92XdvwrkqcVHL4s,386
 quark/driver/common/__init__.py,sha256=eSw0oQ4qSq6QMOlqmk01wys4EbWT9h1g-ITdrmtaiwI,217
 quark/driver/common/basedriver.py,sha256=h8YabyzreB4_vjLzbkieXrMrdWBYF5Lh3SYBgyE6IDs,4478
 quark/driver/common/quantity.py,sha256=fV9DMmjys44efe7TTvzXmFdozqGdS2QUm23wtfLxeBE,4663
 quark/driver/common/visadriver.py,sha256=LRyYDBF0u9EYf6p47LeGGKhx9pHiq4pux_pzDakaICY,5432
 quark/envelope/__init__.py,sha256=5_cs0tZ7mV4GjOsY2isx8sUQu4u6Y3WN-9DUGG27SQM,1188
 quark/envelope/assembler.py,sha256=ENwX7FutJvpg6_Wcm42_Zx-ddq40JozuYqHPwJp09ZA,15111
 quark/envelope/calculator.py,sha256=0rZAA46sWh_X8wOBmpBvmljqCV53ID4VHPX1cE_abEc,4322
 quark/envelope/device.py,sha256=5E3oWZ84IYnQdzlmzltgPyayYz_au7p7UIbFVpJUa0Q,1106
-quark/envelope/processor.py,sha256=uMIwu83a4SDZVM3OE5_WrBya_4jxtdcXPd6pYa0osrk,3758
-quark/envelope/router.py,sha256=w3PiOCtc0YZZapwut2jWYf5vISTdZQWOGT_6bXTjCmI,4324
+quark/envelope/processor.py,sha256=QTBsW0mUwg1xCZ6k3oEBzGc13DDP60dT-QP61tjwe2s,3733
+quark/envelope/router.py,sha256=XtTaZWRXQtqBpAkHCnEj99xmTuctNUFCrbXpoz49unY,4320
 quark/envelope/systemq.py,sha256=QAaHLv68C9UjMp9qHt9t-HJkOTpCkbHZTlNVOsAzIBc,2841
-vios-2.3.4.dist-info/LICENSE,sha256=B_BP5ebph3-SqRxXvo-6Bh7vzPL2nPY5qSFQfr7xM_s,1085
-vios-2.3.4.dist-info/METADATA,sha256=UMbZlfWCNYvi0xchpmbK3Gnjdxc1z00dnXHzGv8IKSE,1215
-vios-2.3.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-vios-2.3.4.dist-info/top_level.txt,sha256=7SspgYXMW_50_NVkPj0EbFg4jFlGVsaIDfpqNsA1IMY,6
-vios-2.3.4.dist-info/RECORD,,
+vios-2.3.5.dist-info/LICENSE,sha256=B_BP5ebph3-SqRxXvo-6Bh7vzPL2nPY5qSFQfr7xM_s,1085
+vios-2.3.5.dist-info/METADATA,sha256=UDdJtk94ZkFGq7KXwkjAcO2JjikDoHzD0Zqw5EXYo5M,1211
+vios-2.3.5.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
+vios-2.3.5.dist-info/top_level.txt,sha256=7SspgYXMW_50_NVkPj0EbFg4jFlGVsaIDfpqNsA1IMY,6
+vios-2.3.5.dist-info/RECORD,,
```

