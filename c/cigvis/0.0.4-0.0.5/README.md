# Comparing `tmp/cigvis-0.0.4-py3-none-any.whl.zip` & `tmp/cigvis-0.0.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,44 +1,53 @@
-Zip file size: 87032 bytes, number of entries: 42
--rw-r--r--  2.0 unx     1845 b- defN 24-Feb-05 06:17 cigvis/__init__.py
--rw-r--r--  2.0 unx    15775 b- defN 24-Feb-05 02:33 cigvis/colormap.py
+Zip file size: 110198 bytes, number of entries: 51
+-rw-r--r--  2.0 unx     1841 b- defN 24-Mar-29 07:23 cigvis/__init__.py
+-rw-r--r--  2.0 unx    16973 b- defN 24-Mar-29 07:23 cigvis/colormap.py
 -rw-r--r--  2.0 unx     1743 b- defN 23-Aug-23 14:10 cigvis/config.py
--rw-r--r--  2.0 unx    76159 b- defN 23-Aug-29 03:05 cigvis/customcmap.py
--rw-r--r--  2.0 unx    12334 b- defN 24-Feb-05 02:33 cigvis/mpl1dplot.py
+-rw-r--r--  2.0 unx    76159 b- defN 24-Feb-20 09:18 cigvis/customcmap.py
+-rw-r--r--  2.0 unx    12351 b- defN 24-Mar-29 07:23 cigvis/mpl1dplot.py
 -rw-r--r--  2.0 unx    10527 b- defN 24-Feb-05 02:33 cigvis/mpl2dplot.py
 -rw-r--r--  2.0 unx    12242 b- defN 24-Feb-05 02:33 cigvis/plotlyplot.py
--rw-r--r--  2.0 unx    27675 b- defN 24-Feb-05 06:23 cigvis/vispyplot.py
--rw-r--r--  2.0 unx      222 b- defN 23-Oct-16 15:34 cigvis/gui/__init__.py
--rw-r--r--  2.0 unx     1615 b- defN 24-Feb-05 02:51 cigvis/gui/custom_widgets.py
--rw-r--r--  2.0 unx    19858 b- defN 24-Feb-05 02:33 cigvis/gui/gui3d.py
--rw-r--r--  2.0 unx     5620 b- defN 23-Oct-19 02:52 cigvis/gui/params_widgets.py
+-rw-r--r--  2.0 unx    30568 b- defN 24-Mar-29 07:23 cigvis/vispyplot.py
+-rw-r--r--  2.0 unx      247 b- defN 24-Mar-29 07:23 cigvis/gui/__init__.py
+-rw-r--r--  2.0 unx    16999 b- defN 24-Apr-28 10:00 cigvis/gui/custom_widgets.py
+-rw-r--r--  2.0 unx    11300 b- defN 24-Mar-16 14:21 cigvis/gui/test_gui2d.py
+-rw-r--r--  2.0 unx    10581 b- defN 24-Mar-15 09:49 cigvis/gui/test_gui2d_vispy.py
+-rw-r--r--  2.0 unx      188 b- defN 24-Mar-29 07:23 cigvis/gui/gui2d/__init__.py
+-rw-r--r--  2.0 unx    14200 b- defN 24-Apr-28 10:00 cigvis/gui/gui2d/control_panel.py
+-rw-r--r--  2.0 unx     3596 b- defN 24-Apr-08 05:37 cigvis/gui/gui2d/mainwindow.py
+-rw-r--r--  2.0 unx    14637 b- defN 24-Apr-28 10:00 cigvis/gui/gui2d/plot_canvas.py
+-rw-r--r--  2.0 unx      189 b- defN 24-Mar-29 07:23 cigvis/gui/gui3d/__init__.py
+-rw-r--r--  2.0 unx    15644 b- defN 24-Apr-28 10:00 cigvis/gui/gui3d/control_panel.py
+-rw-r--r--  2.0 unx     3597 b- defN 24-Mar-29 07:23 cigvis/gui/gui3d/mainwindow.py
+-rw-r--r--  2.0 unx    13077 b- defN 24-Apr-28 10:00 cigvis/gui/gui3d/plot_canvas.py
 -rw-r--r--  2.0 unx      436 b- defN 24-Feb-05 06:23 cigvis/io/__init__.py
 -rw-r--r--  2.0 unx     8184 b- defN 23-Oct-07 14:00 cigvis/io/fault_skin.py
 -rw-r--r--  2.0 unx      605 b- defN 24-Feb-05 06:23 cigvis/io/horiz.py
 -rw-r--r--  2.0 unx     2998 b- defN 23-Oct-06 09:38 cigvis/io/las.py
 -rw-r--r--  2.0 unx     7837 b- defN 24-Feb-05 02:33 cigvis/io/vds.py
 -rw-r--r--  2.0 unx      212 b- defN 23-Oct-07 07:07 cigvis/meshs/__init__.py
 -rw-r--r--  2.0 unx      725 b- defN 23-Sep-26 15:01 cigvis/meshs/merge.py
 -rw-r--r--  2.0 unx     1541 b- defN 23-Oct-07 07:15 cigvis/meshs/points.py
 -rw-r--r--  2.0 unx      176 b- defN 23-Oct-07 09:01 cigvis/meshs/surfaces.py
 -rw-r--r--  2.0 unx     6412 b- defN 23-Oct-06 13:57 cigvis/meshs/well_logs.py
 -rw-r--r--  2.0 unx      279 b- defN 24-Feb-05 06:23 cigvis/utils/__init__.py
 -rw-r--r--  2.0 unx     1414 b- defN 24-Feb-05 02:33 cigvis/utils/coord.py
--rw-r--r--  2.0 unx     7860 b- defN 24-Feb-05 02:33 cigvis/utils/plotlyutils.py
+-rw-r--r--  2.0 unx     7875 b- defN 24-Mar-29 07:23 cigvis/utils/plotlyutils.py
 -rw-r--r--  2.0 unx     7945 b- defN 24-Feb-05 06:23 cigvis/utils/surfaceutils.py
--rw-r--r--  2.0 unx      601 b- defN 23-Aug-23 14:10 cigvis/utils/utils.py
+-rw-r--r--  2.0 unx     1656 b- defN 24-Mar-29 07:23 cigvis/utils/utils.py
 -rw-r--r--  2.0 unx     3375 b- defN 23-Sep-21 03:14 cigvis/utils/vispyutils.py
--rw-r--r--  2.0 unx      573 b- defN 23-Sep-21 03:15 cigvis/vispynodes/__init__.py
+-rw-r--r--  2.0 unx      573 b- defN 24-Mar-18 04:43 cigvis/vispynodes/__init__.py
 -rw-r--r--  2.0 unx     4245 b- defN 23-Sep-30 09:18 cigvis/vispynodes/axis3d.py
--rw-r--r--  2.0 unx    14106 b- defN 24-Feb-05 02:33 cigvis/vispynodes/axis_aligned_image.py
+-rw-r--r--  2.0 unx    17679 b- defN 24-Apr-28 08:37 cigvis/vispynodes/axis_aligned_image.py
+-rw-r--r--  2.0 unx    12878 b- defN 24-Mar-29 07:23 cigvis/vispynodes/canvas_mixin.py
 -rw-r--r--  2.0 unx    10341 b- defN 23-Nov-27 15:31 cigvis/vispynodes/colorbar.py
 -rw-r--r--  2.0 unx     6377 b- defN 23-Nov-27 03:23 cigvis/vispynodes/fixed_image.py
--rw-r--r--  2.0 unx    23841 b- defN 24-Feb-05 02:33 cigvis/vispynodes/vis_canvas.py
--rw-r--r--  2.0 unx     7413 b- defN 23-Sep-20 13:02 cigvis/vispynodes/volume_slices.py
+-rw-r--r--  2.0 unx    11263 b- defN 24-Mar-29 07:23 cigvis/vispynodes/vis_canvas.py
+-rw-r--r--  2.0 unx     6186 b- defN 24-Mar-29 07:23 cigvis/vispynodes/volume_slices.py
 -rw-r--r--  2.0 unx     8756 b- defN 23-Sep-22 12:46 cigvis/vispynodes/well_log.py
 -rw-r--r--  2.0 unx     6230 b- defN 23-Sep-12 12:54 cigvis/vispynodes/xyz_axis.py
--rw-r--r--  2.0 unx     1066 b- defN 24-Feb-05 06:43 cigvis-0.0.4.dist-info/LICENSE
--rw-r--r--  2.0 unx     7400 b- defN 24-Feb-05 06:43 cigvis-0.0.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Feb-05 06:43 cigvis-0.0.4.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 24-Feb-05 06:43 cigvis-0.0.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3372 b- defN 24-Feb-05 06:43 cigvis-0.0.4.dist-info/RECORD
-42 files, 330034 bytes uncompressed, 81746 bytes compressed:  75.2%
+-rw-r--r--  2.0 unx     1066 b- defN 24-Apr-28 10:00 cigvis-0.0.5.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7420 b- defN 24-Apr-28 10:00 cigvis-0.0.5.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-28 10:00 cigvis-0.0.5.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 24-Apr-28 10:00 cigvis-0.0.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4175 b- defN 24-Apr-28 10:00 cigvis-0.0.5.dist-info/RECORD
+51 files, 415617 bytes uncompressed, 103660 bytes compressed:  75.1%
```

## zipnote {}

```diff
@@ -24,18 +24,42 @@
 
 Filename: cigvis/gui/__init__.py
 Comment: 
 
 Filename: cigvis/gui/custom_widgets.py
 Comment: 
 
-Filename: cigvis/gui/gui3d.py
+Filename: cigvis/gui/test_gui2d.py
 Comment: 
 
-Filename: cigvis/gui/params_widgets.py
+Filename: cigvis/gui/test_gui2d_vispy.py
+Comment: 
+
+Filename: cigvis/gui/gui2d/__init__.py
+Comment: 
+
+Filename: cigvis/gui/gui2d/control_panel.py
+Comment: 
+
+Filename: cigvis/gui/gui2d/mainwindow.py
+Comment: 
+
+Filename: cigvis/gui/gui2d/plot_canvas.py
+Comment: 
+
+Filename: cigvis/gui/gui3d/__init__.py
+Comment: 
+
+Filename: cigvis/gui/gui3d/control_panel.py
+Comment: 
+
+Filename: cigvis/gui/gui3d/mainwindow.py
+Comment: 
+
+Filename: cigvis/gui/gui3d/plot_canvas.py
 Comment: 
 
 Filename: cigvis/io/__init__.py
 Comment: 
 
 Filename: cigvis/io/fault_skin.py
 Comment: 
@@ -87,14 +111,17 @@
 
 Filename: cigvis/vispynodes/axis3d.py
 Comment: 
 
 Filename: cigvis/vispynodes/axis_aligned_image.py
 Comment: 
 
+Filename: cigvis/vispynodes/canvas_mixin.py
+Comment: 
+
 Filename: cigvis/vispynodes/colorbar.py
 Comment: 
 
 Filename: cigvis/vispynodes/fixed_image.py
 Comment: 
 
 Filename: cigvis/vispynodes/vis_canvas.py
@@ -105,23 +132,23 @@
 
 Filename: cigvis/vispynodes/well_log.py
 Comment: 
 
 Filename: cigvis/vispynodes/xyz_axis.py
 Comment: 
 
-Filename: cigvis-0.0.4.dist-info/LICENSE
+Filename: cigvis-0.0.5.dist-info/LICENSE
 Comment: 
 
-Filename: cigvis-0.0.4.dist-info/METADATA
+Filename: cigvis-0.0.5.dist-info/METADATA
 Comment: 
 
-Filename: cigvis-0.0.4.dist-info/WHEEL
+Filename: cigvis-0.0.5.dist-info/WHEEL
 Comment: 
 
-Filename: cigvis-0.0.4.dist-info/top_level.txt
+Filename: cigvis-0.0.5.dist-info/top_level.txt
 Comment: 
 
-Filename: cigvis-0.0.4.dist-info/RECORD
+Filename: cigvis-0.0.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cigvis/__init__.py

```diff
@@ -34,14 +34,14 @@
 from . import io
 from . import colormap
 from . import meshs
 from . import gui
 
 injupyter = 'ipykernel_launcher.py' in sys.argv[0] or 'lab' in sys.argv[0]
 
-if not injupyter:
-    from .vispyplot import *
-else:
+if injupyter:
     from .plotlyplot import *
+else:
+    from .vispyplot import *
 
 from .mpl2dplot import *
 from .mpl1dplot import *
```

## cigvis/colormap.py

```diff
@@ -248,14 +248,44 @@
 def discrete_cmap(cmap, clim, values):
     colors = get_colors_from_cmap(cmap, clim, values)
     cmap = custom_disc_cmap(values, colors)
 
     return cmap
 
 
+def ramp(cmap, blow=0, up=1, alpha_min=0, alpha_max=1, forvispy=True):
+    """
+    Creates a modified colormap from an existing colormap, with adjustable transparency (alpha) levels.
+    
+    Parameters:
+    - cmap: The original colormap to be modified.
+    - blow (float, optional): The lower bound of the colormap normalization range. Defaults to 0.
+    - up (float, optional): The upper bound of the colormap normalization range. Defaults to 1.
+    - alpha_min (float, optional): The minimum alpha (transparency) value to apply. Defaults to 0.
+    - alpha_max (float, optional): The maximum alpha (transparency) value to apply. Defaults to 1.
+    
+    Returns:
+    - A new colormap with alpha adjusted from alpha_min to alpha_max within the specified range [blow, up].
+    """
+
+    cmap = get_cmap_from_str(cmap)
+    slope = (alpha_max - alpha_min) / (up - blow)
+    N = cmap.N
+    arr = cmap(np.arange(N))
+    istart = int(blow * N)
+    iend = int(up * N)
+    arr[:istart, 3] = alpha_min
+    arr[iend:, 3] = alpha_max
+    arr[istart:iend, 3] = np.arange(iend - istart) / N * slope + alpha_min
+    cmap = ListedColormap(arr)
+    if forvispy:
+        cmap = cmap_to_vispy(cmap)
+    return cmap
+
+
 def set_alpha(cmap, alpha: float, forvispy: bool = True):
     """
     Set the alpha blending value, between 0 (transparent) and 1 (opaque)
     for a cmap. This function is mainly used in vispy which
     doesn't contain a parameter like `alpha` in matplotlib to set opacity
 
     Parameters
```

## cigvis/mpl1dplot.py

```diff
@@ -11,28 +11,28 @@
 and provides more freedom, the implementations in this package 
 are very simple and are only for reference. 
 
 In the future, we will implement some demos that have more 
 geophysical features.
 """
 
-from typing import List, Tuple, Dict
+from typing import List, Tuple, Dict, Union
 import numpy as np
 import matplotlib.pyplot as plt
 from matplotlib.ticker import MultipleLocator
 from cigvis import colormap
 
 ################## For traces plot #############
 
 
-def plot1d(data: np.ndarray or List,
+def plot1d(data: Union[np.ndarray, List],
            dt: float = 1,
            beg: float = 0,
            orient: str = 'v',
-           figsize: Tuple or List = (2, 8),
+           figsize: Union[Tuple, List] = (2, 8),
            title: str = None,
            axis_label: str = None,
            value_label: str = None,
            fill_up=None,
            fill_down=None,
            fill_color=None,
            c='#1f77b4',
```

## cigvis/vispyplot.py

```diff
@@ -18,32 +18,53 @@
 
 - ni means the dimension size of inline / x
 - nx means the dimension size of crossline / y
 - nt means the dimension size of time / depth / z
 
 """
 
-from typing import List, Tuple, Dict, Union
+from typing import Callable, List, Tuple, Dict, Union
 import warnings
 import os
 import numpy as np
-from cigvis.vispynodes import (VisCanvas, volume_slices, Colorbar, WellLog,
-                               XYZAxis)
+from cigvis.vispynodes import (
+    VisCanvas,
+    volume_slices,
+    AxisAlignedImage,
+    Colorbar,
+    WellLog,
+    XYZAxis,
+)
 
 from vispy.scene.visuals import Mesh, Line
 import vispy
 from vispy.gloo.util import _screenshot
 from scipy.ndimage import gaussian_filter
 
 import cigvis
 from cigvis import colormap
 from cigvis.utils import surfaceutils
 from cigvis.utils import vispyutils
 import cigvis.utils as utils
 
+__all__ = [
+    "create_slices",
+    "add_mask",
+    "create_overlay",
+    "create_colorbar",
+    "create_surfaces",
+    "create_bodys",
+    "create_Line_logs",
+    "create_well_logs",
+    "create_points",
+    "create_fault_skin",
+    "plot3D",
+    "run",
+]
+
 
 def create_slices(volume: np.ndarray,
                   pos: Union[List, Dict] = None,
                   clim: List = None,
                   cmap: str = 'Petrel',
                   interpolation: str = 'cubic',
                   return_cbar: bool = False,
@@ -115,14 +136,93 @@
         cbar_kwargs = vispyutils.get_valid_kwargs('colorbar', **kwargs)
         cbar = create_colorbar(cmap, clim, **cbar_kwargs)
         return nodes, cbar
 
     return nodes
 
 
+def add_mask(nodes: List,
+             volumes: Union[List[np.ndarray], np.ndarray],
+             clims: Union[List, Tuple] = None,
+             cmaps: Union[str, List] = None,
+             interpolation: str = 'linear',
+             method: str = 'auto',
+             preproc_funcs: Callable = None,
+             **kwargs) -> List:
+    """
+    Add Mask/Overlay volumes
+    
+    Parameters
+    -----------
+    nodes: List[Node]
+        A List that contains `AxisAlignedImage` (may be created by `create_slices`)
+    volumes : array-like or List
+        3D array(s), foreground volume(s)/mask(s)
+    clims : List
+        [vmin, vmax] for foreground slices plotting
+    cmaps : str or Colormap
+        colormap for foreground slices, it can be str or matplotlib's Colormap or vispy's Colormap
+    interpolation : str
+        interpolation method. If the values of the slices is discrete, we recommand 
+        set as 'nearest'
+
+    Returns
+    -------
+    slices_nodes : List
+        list of slice nodes
+    """
+
+    if not isinstance(volumes, List):
+        volumes = [volumes]
+
+    for volume in volumes:
+        # TODO: check shape as same as base image
+        utils.check_mmap(volume)
+
+    if clims is None:
+        clims = [[v.min(), v.max()] for v in volumes]
+    if not isinstance(clims[0], (List, Tuple)):
+        clims = [clims]
+
+    if cmaps is None:
+        raise ValueError("'cmaps' cannot be 'None'")
+    if not isinstance(cmaps, List):
+        cmaps = [cmaps] * len(volumes)
+    for i in range(len(cmaps)):
+        cmaps[i] = colormap.cmap_to_vispy(cmaps[i])
+
+    if isinstance(interpolation, str):
+        interpolation = [interpolation] * len(volumes)
+    if not isinstance(preproc_funcs, List):
+        preproc_funcs = [preproc_funcs] * len(volumes)
+
+    shape = volumes[0].shape
+    line_first = cigvis.is_line_first()
+    if not line_first:
+        shape = shape[::-1]
+
+    for node in nodes:
+        if not isinstance(node, AxisAlignedImage):
+            continue
+        for i in range(len(volumes)):
+            node.add_mask(
+                volumes[i],
+                cmaps[i],
+                clims[i],
+                interpolation[i],
+                method,
+                preproc_funcs[i],
+            )
+
+    return nodes
+
+
+@utils.deprecated(
+    "The code is based on 'vispy' backbend, and this function will be removed in the feature version.\nExample:\nnodes=cigvis.create_overlay(bg, [fg1, fg2], fg_cmap=['jet', 'gray']\n==> change to ==>\nnodes=cigvis.create_slices(bg)\nnodes=cigvis.add_mask(nodes, [fg1, fg2], cmaps=['jet', 'gray'])\n",
+    "`cigvis.add_mask`")
 def create_overlay(bg_volume: np.ndarray,
                    fg_volume: np.ndarray,
                    pos: Union[List, Dict] = None,
                    bg_clim: List = None,
                    fg_clim: List = None,
                    bg_cmap: str = 'Petrel',
                    fg_cmap: str = None,
@@ -247,15 +347,15 @@
 
     return nodes
 
 
 def create_colorbar(cmap,
                     clim: List,
                     discrete: bool = False,
-                    disc_ticks: List or Dict = None,
+                    disc_ticks: Union[List, Dict] = None,
                     label_str: str = '',
                     **kwargs) -> Colorbar:
     """
     create a `Colorbar` instance. To draw colorbar, must spacify 
     `size` params or call `colorbar.update_size(size)` function.
 
     Parameters
@@ -488,15 +588,15 @@
     # # must call _prepare_draw before attaching ShadingFilter
     # # see: https://github.com/vispy/vispy/issues/2254#issuecomment-967276060
     # body._prepare_draw(body)
 
     return [body]
 
 
-def create_Line_logs(logs: List or np.ndarray,
+def create_Line_logs(logs: Union[List, np.ndarray],
                      value_type: str = 'depth',
                      cmap: str = 'jet',
                      clim: List = None,
                      width: float = 6.0,
                      return_cbar: bool = False,
                      **kwargs):
     """
@@ -858,8 +958,8 @@
         vispy.io.write_png(savedir + savename, screen_shot)
 
     if run_app:
         vispy.app.run()
 
 
 def run():
-    vispy.app.run()
+    vispy.app.run()
```

## cigvis/gui/__init__.py

```diff
@@ -3,8 +3,9 @@
 # University of Science and Technology of China (USTC).
 # All rights reserved.
 
 """
 Some GUI for simply plotting
 """
 
-from .gui3d import gui3d
+from .gui3d import gui3d
+from .gui2d import gui2d
```

## cigvis/gui/custom_widgets.py

```diff
@@ -1,17 +1,34 @@
 # Copyright (c) 2023 Jintao Li.
 # Computational and Interpretation Group (CIG),
 # University of Science and Technology of China (USTC).
 # All rights reserved.
-
 """
 Some custom widgets
 """
+from typing import List
 from PyQt5 import QtWidgets as qtw
-from PyQt5 import QtCore 
+from PyQt5 import QtCore, QtGui
+import numpy as np
+from pathlib import Path
+
+CANVAS_SIZE = (800, 600)  # (width, height)
+
+INT_validator = QtCore.QRegExp(r"^[1-9][0-9]*$")
+FLOAT_validator = QtCore.QRegExp(r"[-+]?[0-9]*\.?[0-9]+")
+
+
+def _sortfile(flist: List[Path]):
+    try:
+        flist = sorted(flist, key=lambda x: int(x.stem))
+    except:
+        flist = sorted(flist)
+
+    return flist
+
 
 class EditableComboBox(qtw.QComboBox):
     changed = QtCore.pyqtSignal(str)  # 自定义的信号
 
     def __init__(self, parent=None) -> None:
         super().__init__(parent)
         self.activated.connect(self.on_changed)
@@ -34,14 +51,26 @@
     def stepBy(self, steps):
         super().stepBy(steps)
         self.changed.emit(self.value())
 
     def keyPressEvent(self, event):
         if event.key() == QtCore.Qt.Key_Return:
             self.changed.emit(self.value())
+        elif event.key() == QtCore.Qt.Key_Up:
+            if self.value() >= self.maximum():
+                return
+            value = self.value() + 1
+            self.setValue(value)
+            self.changed.emit(value)
+        elif event.key() == QtCore.Qt.Key_Down:
+            if self.value() <= self.minimum():
+                return
+            value = self.value() - 1
+            self.setValue(value)
+            self.changed.emit(value)
         else:
             super().keyPressEvent(event)
 
 
 class MyQDoubleSpinBox(qtw.QDoubleSpinBox):
     changed = QtCore.pyqtSignal(float)
 
@@ -49,8 +78,454 @@
         super().stepBy(steps)
         self.changed.emit(self.value())
 
     def keyPressEvent(self, event):
         if event.key() == QtCore.Qt.Key_Return:
             self.changed.emit(self.value())
         else:
-            super().keyPressEvent(event)
+            super().keyPressEvent(event)
+
+
+class MyQLineEdit(qtw.QLineEdit):
+
+    def setTextAndEmit(self, text):
+        self.setText(text)
+        # 手动调用处理函数
+        self.editingFinished.emit()
+
+
+class UnpickRadioButton(qtw.QRadioButton):
+
+    def __init__(self, title, parent=None):
+        super(UnpickRadioButton, self).__init__(title, parent)
+
+    def mousePressEvent(self, event):
+        # 重写鼠标按下事件，但不调用基类的事件处理，阻止选中状态的改变
+        pass
+
+    def mouseReleaseEvent(self, event):
+        # 重写鼠标释放事件，同样不调用基类的事件处理
+        pass
+
+
+class RadioButtonPanel(qtw.QWidget):
+    selectionChanged = QtCore.pyqtSignal(str)
+
+    def __init__(self, names, picked=True, hori=True, parent=None):
+        super(RadioButtonPanel, self).__init__(parent)
+        self.names = names
+        self.radioButtons = []
+        radio = qtw.QRadioButton if picked else UnpickRadioButton
+
+        # 选择布局方向
+        self.layout = qtw.QHBoxLayout(self) if hori else qtw.QVBoxLayout(self)
+
+        # 创建并添加单选按钮到布局
+        for name in names:
+            radioButton = radio(name)
+            self.layout.addWidget(radioButton)
+            self.radioButtons.append(radioButton)
+            # 连接单选按钮的信号
+            radioButton.toggled.connect(self.onRadioButtonChanged)
+
+        # 设置第一个单选按钮为默认选中状态
+        self.radioButtons[0].setChecked(True)
+        self.selected = self.names[0]
+
+    def onRadioButtonChanged(self):
+        # 当单选按钮的状态改变时触发
+        radioButton = self.sender()
+        if radioButton.isChecked():
+            self.selected = radioButton.text()
+            self.selectionChanged.emit(self.selected)
+            for rad in self.radioButtons:
+                if rad != radioButton:
+                    rad.setChecked(False)
+
+    def getCurrentSelection(self):
+        return self.selected
+
+
+class ToggleButton(qtw.QPushButton):
+
+    def __init__(self, title=None, usesfix=False, exclu=True, parent=None):
+        if usesfix:
+            title = title + " OFF"
+        self.usesfix = usesfix
+        super().__init__(title, parent)
+        self.title = title
+        self.exclu = exclu
+        self.setCheckable(True)
+        self.toggled.connect(self.onToggle)
+
+    def onToggle(self, checked):
+        if self.exclu:
+            parent = self.parent()
+            if parent:
+                parent.updateToggleState(self, checked)
+
+        if not self.usesfix:
+            return
+        if checked:
+            self.setText(self.title + " ON")
+        else:
+            self.setText(self.title + " OFF")
+
+
+class RectP:
+
+    def __init__(self,
+                 x0: float = None,
+                 y0: float = None,
+                 x1: float = None,
+                 y1: float = None) -> None:
+        self.x0 = x0
+        self.y0 = y0
+        self.x1 = x1
+        self.y1 = y1
+
+    def add_p0(self, x0, y0):
+        self.x0 = x0
+        self.y0 = y0
+
+    def add_p1(self, x1, y1):
+        self.x1 = x1
+        self.y1 = y1
+
+    def add_p0event(self, event):
+        self.x0 = event.xdata
+        self.y0 = event.ydata
+
+    def add_p1event(self, event):
+        self.x1 = event.xdata
+        self.y1 = event.ydata
+
+    @classmethod
+    def from_points(cls, p0: List, p1: List):
+        # p1, p2可以是任何有x和y属性的对象
+        return cls(p0[0], p0[1], p1[0], p1[1])
+
+    @classmethod
+    def from_events(cls, e0, e1):
+        return cls(e0.xdata, e0.ydata, e1.xdata, e1.ydata)
+
+    def to_start_size(self):
+        width = abs(self.x1 - self.x0)
+        height = abs(self.y1 - self.y0)
+        return [self.x0, self.y0, width, height]
+
+    def to_points(self):
+        return [self.x0, self.y0, self.x1, self.y1]
+
+
+class BaseWidget(qtw.QWidget):
+
+    def __init__(self, parent=None) -> None:
+        super().__init__(parent)
+
+    def addwidgets(self, layout, widgets):
+        for widget in widgets:
+            layout.addWidget(widget)
+
+    def addlayout(self, layout, sublayouts):
+        for sublayout in sublayouts:
+            layout.addLayout(sublayout)
+
+
+class ImageParams(BaseWidget):
+
+    def __init__(self, interps=None, parent=None) -> None:
+        super().__init__(parent)
+
+        self.ilayout = qtw.QVBoxLayout()
+        self.ilayout.setContentsMargins(0, 0, 0, 0)
+        self.ilayout.setSpacing(0)
+
+        # clim
+        clim_layout = qtw.QHBoxLayout()
+        vmin_label = qtw.QLabel('vmin:')
+        self.vmin_input = MyQLineEdit()
+        self.vmin_input.setValidator(
+            QtGui.QRegExpValidator(FLOAT_validator, self))
+        vmax_label = qtw.QLabel('vmax:')
+        self.vmax_input = MyQLineEdit()
+        self.vmax_input.setValidator(
+            QtGui.QRegExpValidator(FLOAT_validator, self))
+        self.addwidgets(
+            clim_layout,
+            [vmin_label, self.vmin_input, vmax_label, self.vmax_input])
+
+        # colormap
+        layout2 = qtw.QHBoxLayout()
+        colormap_label = qtw.QLabel('cmap:')
+        self.colormap_combo = EditableComboBox()
+        colormaps = [
+            'gray', 'seismic', 'Petrel', 'stratum', 'jet', 'od_seismic1',
+            'od_seismic2', 'od_seismic3'
+        ]
+        self.colormap_combo.addItems(colormaps)
+        self.colormap_combo.setCurrentText('gray')  # 默认值为'gray'
+
+        # interpolation
+        interp_label = qtw.QLabel('Interp:')
+        self.interp_combo = qtw.QComboBox()
+        if interps is None:
+            interps = [
+                'none', 'nearest', 'bilinear', 'bicubic', 'quadric', 'sinc',
+                'blackman', 'antialiased', 'spline36', 'mitchell', 'hamming',
+                'catrom', 'gaussian', 'hanning', 'lanczos', 'bessel',
+                'spline16', 'kaiser', 'hermite'
+            ]
+        self.interp_combo.addItems(interps)
+        self.interp_combo.setCurrentText('bilinear')
+
+        self.addwidgets(layout2, [
+            colormap_label, self.colormap_combo, interp_label,
+            self.interp_combo
+        ])
+
+        sublayouts = [clim_layout, layout2]
+        self.addlayout(self.ilayout, sublayouts)
+        self.setLayout(self.ilayout)
+
+    def clear(self):
+        self.vmin_input.clear()
+        self.vmax_input.clear()
+        self.colormap_combo.setCurrentText('gray')
+        self.interp_combo.setCurrentText('bilinear')
+
+
+class MaskImageParams(ImageParams):
+
+    def __init__(self, updateCallback: callable = None, parent=None, **kwargs):
+        super().__init__(parent=parent, **kwargs)
+        self.updateCallback = updateCallback
+
+        self.colormap_combo.setCurrentText('jet')
+        self.interp_combo.setCurrentText('nearest')
+
+        layout3 = qtw.QHBoxLayout()
+        alpha_l = qtw.QLabel('alpha')
+        self.alpha = MyQDoubleSpinBox()
+        self.alpha.setRange(0, 1)
+        self.alpha.setSingleStep(0.05)
+        self.alpha.setValue(0.5)
+        exclude_l = qtw.QLabel('except')
+        self.exclude = EditableComboBox()
+        exclude = ['None', 'min', 'max', 'blow(0)', 'above(1)']
+        self.exclude.addItems(exclude)
+        self.exclude.setCurrentText('None')
+        self.addwidgets(
+            layout3,
+            [alpha_l, self.alpha, exclude_l, self.exclude],
+        )
+
+        self.ilayout.addLayout(layout3)
+
+        self.vmin_input.editingFinished.connect(
+            lambda: self.on_vmin_changed(self.vmin_input.text()))
+        self.vmax_input.editingFinished.connect(
+            lambda: self.on_vmax_changed(self.vmax_input.text()))
+        self.colormap_combo.changed.connect(self.on_cmap_changed)
+        self.interp_combo.currentTextChanged.connect(self.on_interp_changed)
+        self.alpha.changed.connect(self.on_alpha_changed)
+        self.exclude.changed.connect(self.on_except_changed)
+
+    def set_callback(self, updateCallback: callable):
+        self.updateCallback = updateCallback
+        self.on_vmin_changed(self.vmin_input.text())
+        self.on_vmax_changed(self.vmax_input.text())
+        self.on_cmap_changed(self.colormap_combo.currentText())
+        self.on_interp_changed(self.interp_combo.currentText())
+        self.on_alpha_changed(self.alpha.value())
+        self.on_except_changed(self.exclude.currentText())
+
+    def on_vmin_changed(self, text):
+        if self.updateCallback:
+            self.updateCallback('vmin', float(text))
+
+    def on_vmax_changed(self, text):
+        if self.updateCallback:
+            self.updateCallback('vmax', float(text))
+
+    def on_cmap_changed(self, text):
+        if self.updateCallback:
+            self.updateCallback('cmap', text)
+
+    def on_interp_changed(self, text):
+        if self.updateCallback:
+            self.updateCallback('interp', text)
+
+    def on_alpha_changed(self, alpha):
+        if self.updateCallback:
+            self.updateCallback('alpha', float(alpha))
+
+    def on_except_changed(self, text):
+        if self.updateCallback:
+            self.updateCallback('except', text)
+
+
+class MaskWidget(qtw.QWidget):
+    # TODO: 改变顺序的时候发送信号
+    params = QtCore.pyqtSignal(list)
+    deleteIdx = QtCore.pyqtSignal(int)
+
+    def __init__(self, visable_action=False, parent=None):
+        super().__init__(parent)
+        self.visable_action = visable_action
+        self.ilayout = qtw.QVBoxLayout(self)
+
+        self.listWidget = qtw.QListWidget()
+        self.listWidget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
+        self.listWidget.customContextMenuRequested.connect(
+            self.showContextMenu)
+        self.listWidget.setDragDropMode(qtw.QListWidget.InternalMove)
+        self.listWidget.itemClicked.connect(self.showDetails)
+        self.ilayout.addWidget(self.listWidget, 1)
+        self.ilayout.setContentsMargins(0, 0, 0, 0)
+        self.ilayout.setSpacing(0)
+
+        self.currentParamsWidget = None
+
+    def addItem(self, item: qtw.QListWidgetItem):
+        self.listWidget.addItem(item)
+        item.paramsWidget.set_callback(self.updateCallback)
+
+    def removeSelectedItem(self):
+        item = self.listWidget.currentItem()
+        idx = self.listWidget.currentRow()
+        if item:
+            paramsWidget = item.paramsWidget
+            if paramsWidget == self.currentParamsWidget:
+                self.ilayout.removeWidget(paramsWidget)
+                paramsWidget.setParent(None)
+                del paramsWidget
+                self.currentParamsWidget = None
+            self.listWidget.takeItem(self.listWidget.row(item))
+            del item
+            self.deleteIdx.emit(idx)
+
+    def showDetails(self, item):
+        if self.currentParamsWidget is not None:
+            self.ilayout.removeWidget(self.currentParamsWidget)
+            self.currentParamsWidget.hide()
+        self.currentParamsWidget = item.paramsWidget
+        self.ilayout.addWidget(self.currentParamsWidget, 2)  # 参数部分占用更多的空间
+        self.currentParamsWidget.show()
+
+    def showContextMenu(self, position):
+        menu = qtw.QMenu()
+        if self.visable_action:
+            visbaleAction = menu.addAction("Visable")
+        removeAction = menu.addAction("Delete")
+        action = menu.exec_(self.listWidget.mapToGlobal(position))
+        if action == removeAction:
+            self.removeSelectedItem()
+        if self.visable_action:
+            if action == visbaleAction:
+                pass
+
+    def clear(self):
+        # 清空所有项目和相关的参数界面
+        while self.listWidget.count() > 0:
+            item = self.listWidget.takeItem(0)
+            if item.paramsWidget:
+                item.paramsWidget.setParent(None)
+                del item.paramsWidget
+            del item  # 显式删除项目
+
+    def updateCallback(self, mode: str, value):
+        assert mode in ['vmin', 'vmax', 'cmap', 'interp', 'alpha', 'except']
+        idx = self.listWidget.currentRow()
+        self.params.emit([idx, mode, value])
+
+
+class LoadFolder(qtw.QPushButton):
+    fileList = QtCore.pyqtSignal(list)
+
+    def __init__(self, parent=None):
+        super(LoadFolder, self).__init__("Folder", parent)
+        self.clicked.connect(self.loadFolder)
+        self.loaded = False
+
+    def loadFolder(self, filePath: str = None):
+        if self.loaded:
+            qtw.QMessageBox.critical(
+                self, "Warn",
+                "Folder already loaded. Please clear existing folder first.")
+            return
+
+        if not filePath:
+            filePath = qtw.QFileDialog.getExistingDirectory(
+                self,
+                "Select Folder",
+                "",
+                # options=qtw.QFileDialog.DontUseNativeDialog
+            )
+        if not filePath:  # 用户取消选择
+            return
+
+        flist = list(Path(filePath).glob('*.dat'))
+        flist += list(Path(filePath).glob('*.npy'))
+        flist = [f for f in flist if not f.name.startswith('.')]
+        flist = _sortfile(flist)
+        n = len(flist)
+        if n > 0:
+            self.loaded = True
+            self.fileList.emit(flist)
+        else:
+            qtw.QMessageBox.critical(self, "Warn", f"An empty folder.")
+            return
+
+    def clear(self):
+        self.loaded = False
+
+
+class LoadFolderWidget(qtw.QWidget):
+    currentPath = QtCore.pyqtSignal(str)
+
+    def __init__(self, parent=None) -> None:
+        super().__init__(parent)
+        self.flist = []
+
+        hlayout = qtw.QHBoxLayout()
+        self.loadFd = LoadFolder(self)
+        self.fidx = MyQSpinBox()
+        self.fname = qtw.QLineEdit("None")
+        self.fname.setReadOnly(True)
+        hlayout.addWidget(self.loadFd)
+        hlayout.addWidget(self.fidx)
+        hlayout.addWidget(self.fname)
+        self.setLayout(hlayout)
+
+        self.loadFd.fileList.connect(self.set_range)
+        self.loadFd.fileList.connect(self.get_flist)
+        self.fidx.changed.connect(self.set_fname)
+        self.fidx.changed.connect(self.send_path)
+
+    def set_range(self, flist):
+        n = len(flist)
+        self.fidx.setRange(0, n - 1)
+
+    def get_flist(self, flist):
+        self.flist = flist
+        self.set_fname(self.fidx.value())
+        self.send_path(self.fidx.value())
+
+    def set_fname(self, idx):
+        if len(self.flist) == 0:
+            return
+
+        idx = int(idx)
+        self.fname.setText(Path(self.flist[idx]).name)
+
+    def send_path(self, idx):
+        if len(self.flist) == 0:
+            return
+        idx = int(idx)
+        self.currentPath.emit(str(self.flist[idx]))
+
+    def clear(self):
+        self.loadFd.clear()
+        self.fidx.setValue(0)
+        self.fname.setText("None")
+        self.flist = []
```

## cigvis/utils/plotlyutils.py

```diff
@@ -99,17 +99,17 @@
     if prefunc is not None:
         out = prefunc(out)
 
     return out
 
 
 def make_slices(data: np.ndarray,
-                x: List or int = [],
-                y: List or int = [],
-                z: List or int = [],
+                x: Union[List, int] = [],
+                y: Union[List, int] = [],
+                z: Union[List, int] = [],
                 pos: Dict = None) -> Tuple[Dict, Dict]:
     """
     make slices and locations for plotly
 
     Parameters
     ----------
     data : np.ndarray
```

## cigvis/utils/utils.py

```diff
@@ -1,21 +1,50 @@
 # Copyright (c) 2023 Jintao Li.
 # Computational and Interpretation Group (CIG),
 # University of Science and Technology of China (USTC).
 # All rights reserved.
-
 """
 some utils
 """
 
 import warnings
 import numpy as np
+import functools
 
 
 def check_mmap(d: np.ndarray) -> None:
     if isinstance(d, np.memmap):
         if d.mode != 'r' and d.mode != 'c':
             warnings.warn(
                 f"Your memmap data mode is '{d.mode}'. " +
                 f"We strongly recommend using `mode='r'` or " +
                 f"`mode='c'`, as `mode='{d.mode}'` may change " +
                 f"file in some cases", UserWarning)
+
+
+def deprecated(custom_message=None, replacement=None):
+    """Decorator to mark functions as deprecated with an optional custom message
+    and replacement function name.
+
+    :param custom_message: (str) Custom deprecation message
+    :param replacement: (str) The name of the replacement function
+    """
+
+    def decorator(func):
+
+        @functools.wraps(func)
+        def new_func(*args, **kwargs):
+            message = f"Call to deprecated function {func.__name__}."
+            if replacement:
+                message += f" Use {replacement} instead."
+            if custom_message:
+                message += f" {custom_message}"
+            warnings.simplefilter('always',
+                                  DeprecationWarning)  # turn off filter
+            warnings.warn(message, category=DeprecationWarning, stacklevel=2)
+            warnings.simplefilter('default',
+                                  DeprecationWarning)  # reset filter
+            return func(*args, **kwargs)
+
+        return new_func
+
+    return decorator
```

## cigvis/vispynodes/axis_aligned_image.py

```diff
@@ -5,17 +5,19 @@
 # University of Science and Technology of China (USTC)
 #
 # Copyright (C) 2019 Yunzhi Shi @ The University of Texas at Austin.
 # All rights reserved.
 # Distributed under the MIT License. See LICENSE for more info.
 # -----------------------------------------------------------------------------
 
+from typing import Callable, List
 import numpy as np
 from vispy import scene
 from vispy.visuals.transforms import MatrixTransform, STTransform
+import cigvis
 
 
 class AxisAlignedImage(scene.visuals.Image):
     """
     Visual subclass displaying an image that aligns to an axis.
     This image should be able to move along the perpendicular direction when
     user gives corresponding inputs.
@@ -42,15 +44,15 @@
     interpolations : List
         interpolation method for each image
     method : str
         method of `Image`
     """
 
     def __init__(self,
-                 image_funcs,
+                 image_funcs: List[Callable],
                  axis='z',
                  pos=0,
                  limit=None,
                  cmaps=['grays'],
                  clims=None,
                  interpolation=['linear'],
                  method='auto'):
@@ -125,14 +127,55 @@
         # Apply SRT transform according to the axis attribute.
         self.transform = MatrixTransform()
         # Move the image plane to the corresponding location.
         self._update_location()
 
         self.freeze()
 
+    def add_mask(self,
+                 vol: np.ndarray,
+                 cmap: str,
+                 clim: List,
+                 interpolation: str,
+                 method: str = 'auto',
+                 preproc_f: Callable = None):
+        self.unfreeze()
+        image_func = get_image_func(self.axis, vol, preproc_f)
+        self.image_funcs.append(image_func)
+
+        self.overlaid_images.append(
+            scene.visuals.Image(
+                parent=self,
+                cmap=cmap,
+                clim=clim,
+                interpolation=interpolation,
+                method=method,
+            ))
+        self._update_location()
+        self.freeze()
+
+    def remove_mask(self, idx):
+        if idx <= 0:
+            return
+        self.unfreeze()
+
+        image = self.overlaid_images.pop(idx)
+        image.parent = None
+        del image
+        image_func = self.image_funcs.pop(idx)
+        del image_func
+
+        # self._update_location()
+        self.freeze()
+
+    def set_visable(self, idx: int, visable=False):
+        if idx <= 0:
+            return
+        self.overlaid_images[idx].visible = visable
+
     @property
     def axis(self):
         """
         The dimension that this image is perpendicular aligned to.
         """
         return self._axis
 
@@ -321,7 +364,71 @@
             if axis_3d == 0: return (0, self.size[0])
             elif axis_3d == 1: return (self.pos, self.pos)
             elif axis_3d == 2: return (0, self.size[1])
         elif self.axis == 'x':
             if axis_3d == 0: return (self.pos, self.pos)
             elif axis_3d == 1: return (0, self.size[0])
             elif axis_3d == 2: return (0, self.size[1])
+
+    def _set_clipper(self, node, clipper):
+        """
+        To clipper its children
+
+        Assign a clipper that is inherited from a parent node.
+
+        If *clipper* is None, then remove any clippers for *node*.
+        """
+        super()._set_clipper(node, clipper)
+
+        for im in self.children:
+            if isinstance(im, scene.visuals.Image):
+                if node in im._clippers:
+                    im.detach(self._clippers.pop(node))
+                if clipper is not None:
+                    im.attach(clipper)
+                    im._clippers[node] = clipper
+
+
+def get_image_func(axis: str, vol: np.ndarray,
+                   preproc_f: Callable) -> Callable:
+    """
+    Parameters
+    ----------
+    axis : str
+        'x' or 'y' or 'z'
+    i_vol : int
+        index of the volumes
+    """
+    line_first = cigvis.is_line_first()
+    shape = list(vol.shape)
+    if not line_first:
+        shape = shape[::-1]
+
+    def slicing_at_axis(pos, get_shape=False):
+        if get_shape:  # just return the shape information
+            if axis == 'x': return shape[1], shape[2]
+            elif axis == 'y': return shape[0], shape[2]
+            elif axis == 'z': return shape[0], shape[1]
+        else:  # will slice the volume and return an np array image
+            pos = int(np.round(pos))
+            # vol = volumes[i_vol]
+            # preproc_f = preproc_funcs[i_vol]
+            if preproc_f is not None:
+                if line_first:
+                    if axis == 'x': return preproc_f(vol[pos, :, :].T)
+                    elif axis == 'y': return preproc_f(vol[:, pos, :].T)
+                    elif axis == 'z': return preproc_f(vol[:, :, pos].T)
+                else:
+                    if axis == 'x': return preproc_f(vol[:, :, pos])
+                    elif axis == 'y': return preproc_f(vol[:, pos, :])
+                    elif axis == 'z': return preproc_f(vol[pos, :, :])
+            else:
+                if line_first:
+                    if axis == 'x': return vol[pos, :, :].T
+                    elif axis == 'y': return vol[:, pos, :].T
+                    elif axis == 'z': return vol[:, :, pos].T
+                else:
+                    if axis == 'x': return vol[:, :, pos]
+                    elif axis == 'y': return vol[:, pos, :]
+                    elif axis == 'z': return vol[pos, :, :]
+
+    return slicing_at_axis
```

## cigvis/vispynodes/vis_canvas.py

```diff
@@ -7,28 +7,23 @@
 #
 # Copyright (C) 2019 Yunzhi Shi @ The University of Texas at Austin.
 # All rights reserved.
 # Distributed under the MIT License. See LICENSE for more info.
 # -----------------------------------------------------------------------------
 
 from typing import Dict, List, Tuple, Union
-import vispy
-from vispy.util import keys
-from vispy.gloo.util import _screenshot
-from vispy.visuals import MeshVisual, CompoundVisual
 from vispy import scene
-from vispy.gloo import gl
 
 import cigvis
 from .xyz_axis import XYZAxis
-from .axis_aligned_image import AxisAlignedImage
 from .colorbar import Colorbar
+from .canvas_mixin import EventMixin, LightMixin
 
 
-class VisCanvas(scene.SceneCanvas):
+class VisCanvas(scene.SceneCanvas, EventMixin, LightMixin):
     """
     A canvas that automatically draw all contents in a 3D seismic
     visualization scene, which may include 3D seismic volume slices, axis
     legend, colorbar, etc.
 
     Parameters
     ----------
@@ -187,309 +182,14 @@
         else:
             # pass
             # for view in self.view:
             self._attach_light_share(self.view[-1], self.nodes)
 
         self.freeze()
 
-    def on_mouse_press(self, event):
-        # Hold <Alt> and click left to print position
-        if keys.ALT in event.modifiers:
-            ## 屏幕/画布坐标系 Canvas Coordinates
-            # print(event.pos)
-
-            hover_on = self.visual_at(event.pos)
-            if hasattr(hover_on, 'get_click_pos3d'):
-                print(hover_on.get_click_pos3d(event))
-
-        # Hold <Ctrl> to enter drag mode or press <d> to toggle.
-        if keys.CONTROL in event.modifiers or self.drag_mode:
-            # Temporarily disable the interactive flag of the ViewBox because it
-            # is masking all the visuals. See details at:
-            # https://github.com/vispy/vispy/issues/1336
-            for view in self.view:
-                view.interactive = False
-            hover_on = self.visual_at(event.pos)
-
-            if event.button == 1 and self.selected is None:
-                # If no previous selection, make a new selection if cilck on a valid
-                # visual node, and highlight this node.
-                if self._check_drag(hover_on):
-                    self.selected = hover_on
-                    if self.share:
-                        self._get_selected2(self.selected)
-                    self.selected.highlight.visible = True
-                    # Set the anchor point on this node.
-                    self.selected.set_anchor(event)
-
-                # Nothing to do if the cursor is NOT on a valid visual node.
-
-            # Reenable the ViewBox interactive flag.
-            for view in self.view:
-                view.interactive = True
-
-    def on_mouse_release(self, event):
-        # Hold <Ctrl> to enter drag mode or press <d> to toggle.
-        if keys.CONTROL in event.modifiers or self.drag_mode:
-            if self.selected is not None:
-                # Erase the anchor point on this node.
-                self.selected.anchor = None
-                # Then, deselect any previous selection.
-                self.selected = None
-                self.selected2 = []
-
-    def on_mouse_move(self, event):
-        # Hold <Ctrl> to enter drag mode or press <d> to toggle.
-        if keys.CONTROL in event.modifiers or self.drag_mode:
-            # Temporarily disable the interactive flag of the ViewBox because it
-            # is masking all the visuals. See details at:
-            # https://github.com/vispy/vispy/issues/1336
-            for view in self.view:
-                view.interactive = False
-            hover_on = self.visual_at(event.pos)
-
-            if event.button == 1:
-                # if self.selected is not None:
-                if self._check_drag(self.selected):
-                    self.selected.drag_visual_node(event)
-                    for node in self.selected2:
-                        if isinstance(node, XYZAxis):
-                            node._update_axis(self.selected.loc)
-                        else:
-                            node._update_location(self.selected.pos)
-            else:
-                # If the left cilck is released, update highlight to the new visual
-                # node that mouse hovers on.
-                if hover_on != self.hover_on:
-                    # de-highlight previous hover_on
-                    if self._check_drag(self.hover_on):
-                        self.hover_on.highlight.visible = False
-                    self.hover_on = hover_on
-                    # highlight the new hover_on
-                    if self._check_drag(self.hover_on):
-                        self.hover_on.highlight.visible = True
-
-            # Reenable the ViewBox interactive flag.
-            for view in self.view:
-                view.interactive = True
-
-    def on_key_press(self, event):
-        # Press <Space> to reset camera.
-        if event.text == ' ':
-            for view in self.view:
-                view.camera.fov = self.fov
-                view.camera.azimuth = self.azimuth
-                view.camera.elevation = self.elevation
-                view.camera.set_range()
-                view.camera.scale_factor = self.scale_factor
-                view.camera.scale_factor /= self.zoom_factor
-
-                view.camera._flip_factors = self.axis_scales
-                view.camera._update_camera_pos()
-
-                for child in view.children:
-                    if isinstance(child, XYZAxis):
-                        child._update_axis()
-
-        # Press <s> to save a screenshot.
-        if event.text == 's':
-            # viewport = list(gl.glGetParameter(gl.GL_VIEWPORT))
-            # border = (viewport[3] - self.size[1]) // 2
-            # viewport[0] = viewport[2] - self.size[0] - border
-            # viewport[1] = viewport[3] - self.size[1] - border
-            # viewport[2] = self.size[0]
-            # viewport[3] = self.size[1]
-            screenshot = _screenshot()
-            # screenshot = self.render()
-            vispy.io.write_png(self.pngDir + self.title + '.png', screenshot)
-
-        # Press <d> to toggle drag mode.
-        if event.text == 'd':
-            if not self.drag_mode:
-                self.drag_mode = True
-                for view in self.view:
-                    view.camera.viewbox.events.mouse_move.disconnect(
-                        view.camera.viewbox_mouse_event)
-            else:
-                self.drag_mode = False
-                self._exit_drag_mode()
-                for view in self.view:
-                    view.camera.viewbox.events.mouse_move.connect(
-                        view.camera.viewbox_mouse_event)
-
-        # Press <a> to get the parameters of all visual nodes.
-        if event.text == 'a':
-            print("===== All useful parameters ====")
-            # Canvas size.
-            print("Canvas size = {}".format(self.size))
-            # Collect camera parameters.
-            print("Camera:")
-            camera_state = self.view[0].camera.get_state()
-            for key, value in camera_state.items():
-                print(" - {} = {}".format(key, value))
-            print(" - {} = {}".format('zoom factor', self.zoom_factor))
-
-            # axis scales
-            factors = list(self.view[0].camera._flip_factors)
-            print(f'axes scale ratio (< 0 means axis reversed):')
-            print(f' - x: {factors[0]}')
-            print(f' - y: {factors[1]}')
-            print(f' - z: {factors[2]}')
-
-            # Collect slice parameters.
-            print("Slices:")
-            pos_dict = {'x': [], 'y': [], 'z': []}
-            for node in self.view[0].scene.children:
-                if self._check_drag(node):
-                    pos = node.pos
-                    pos_dict[node.axis].append(pos)
-            for axis, pos in pos_dict.items():
-                print(" - {}: {}".format(axis, pos))
-            # Collect the axis legend parameters.
-            for node in self.view[0].children:
-                if isinstance(node, XYZAxis):
-                    print("XYZAxis loc = {}".format(node.loc))
-
-        # zoom in z axis, press <z>
-        if event.text == 'z':
-            for view in self.view:
-                factors = list(view.camera._flip_factors)
-                factors[2] += (0.2 * (1 - 2 * cigvis.is_z_reversed()))
-                view.camera._flip_factors = factors
-                view.camera._update_camera_pos()
-
-                self.update()
-
-        # zoom out z axis, press <Z>, i.e. <Shift>+<z>
-        if event.text == 'Z':
-            for view in self.view:
-                factors = list(view.camera._flip_factors)
-                factors[2] -= (0.2 * (1 - 2 * cigvis.is_z_reversed()))
-                view.camera._flip_factors = factors
-                view.camera._update_camera_pos()
-
-            self.update()
-
-        # zoom in fov, press <f>
-        if event.text == 'f':
-            for view in self.view:
-                view.camera.fov += 5
-
-        # zoom out fov, press <F>
-        if event.text == 'F':
-            for view in self.view:
-                view.camera.fov -= 5
-
-    def on_key_release(self, event):
-        # Cancel selection and highlight if release <Ctrl>.
-        if keys.CONTROL not in event.modifiers:
-            self._exit_drag_mode()
-
-    def _exit_drag_mode(self):
-        if self._check_drag(self.hover_on):
-            self.hover_on.highlight.visible = False
-            self.hover_on = None
-        if self._check_drag(self.selected):
-            self.selected.highlight.visible = False
-            self.selected.anchor = None
-            self.selected = None
-            self.selected2 = []
-
-    # HACK: 直接绑定 ShadingFilter 会不会更方便
-    # 使用 mesh._vshare.filters 获取 attach 的 ShadingFilter
-    def _attach_light(self, view, nodes):
-        light_dir = (0, -1, 0, 0)
-
-        for node in nodes:
-            if isinstance(node, MeshVisual):
-                if node.shading_filter is not None:
-                    node.shading_filter.light_dir = light_dir[:3]
-            if isinstance(node, CompoundVisual):
-                if hasattr(node, 'meshs'):
-                    for mesh in node.meshs:
-                        if mesh.shading_filter is not None:
-                            mesh.shading_filter.light_dir = light_dir[:3]
-
-        initial_light_dir = view.camera.transform.imap(light_dir)
-        view.camera.azimuth = self.azimuth
-        view.camera.elevation = self.elevation
-
-        @view.scene.transform.changed.connect
-        def on_transform_change(event):
-            transform = view.camera.transform
-            for node in nodes:
-                if isinstance(node, MeshVisual):
-                    if node.shading_filter is not None:
-                        # print(transform.map(initial_light_dir))
-                        node.shading_filter.light_dir = transform.map(
-                            initial_light_dir)[:3]
-                if isinstance(node, CompoundVisual):
-                    if hasattr(node, 'meshs'):
-                        for mesh in node.meshs:
-                            if mesh.shading_filter is not None:
-                                mesh.shading_filter.light_dir = transform.map(
-                                    initial_light_dir)[:3]
-
-    def _attach_light_share(self, view, nodess):
-        light_dir = (0, -1, 0, 0)
-
-        for nodes in nodess.values():
-            for node in nodes:
-                if isinstance(node, MeshVisual):
-                    if node.shading_filter is not None:
-                        node.shading_filter.light_dir = light_dir[:3]
-                if isinstance(node, CompoundVisual):
-                    if hasattr(node, 'meshs'):
-                        for mesh in node.meshs:
-                            if mesh.shading_filter is not None:
-                                mesh.shading_filter.light_dir = light_dir[:3]
-        initial_light_dir = view.camera.transform.imap(light_dir)
-
-        view.camera.azimuth = self.azimuth
-        view.camera.elevation = self.elevation
-
-        @view.scene.transform.changed.connect
-        def on_transform_change(event):
-            transform = view.camera.transform
-            for nodes in nodess.values():
-                for node in nodes:
-                    if isinstance(node, MeshVisual):
-                        if node.shading_filter is not None:
-                            # print(transform.map(initial_light_dir))
-                            node.shading_filter.light_dir = transform.map(
-                                initial_light_dir)[:3]
-                    if isinstance(node, CompoundVisual):
-                        if hasattr(node, 'meshs'):
-                            for mesh in node.meshs:
-                                if mesh.shading_filter is not None:
-                                    mesh.shading_filter.light_dir = transform.map(
-                                        initial_light_dir)[:3]
-
-    def _check_drag(self, node):
-        """
-        Only AxisAlignedImage and XYZAxis can be drag
-        """
-        return isinstance(node, (AxisAlignedImage, XYZAxis))
-
-    def _get_selected2(self, node):
-        """
-        uesed when self.share == true
-        get the correspanding Nodes of the input node to drag
-        """
-        assert self._check_drag(node)
-        ids = node.ids
-        k = node.name[:3]
-
-        for key in self.nodes.keys():
-            if key != k:
-                self.selected2 += [
-                    n for n in self.nodes[key]
-                    if self._check_drag(n) and n.ids == ids
-                ]
-
     def _init_grid_input(self, grid, visual_nodes):
         """
         inital grid (get self.nrows and self.ncols),
         and convert visual_nodes to self.nodes (Dict)
 
         self.nodes is a dict like {'i,j': nodes}, its
         key 'i,j' represents a loctaion (i, j) in the grid
@@ -614,20 +314,21 @@
         # use PanZoomCamera so we can draw a **high qaulity** colorbar image
         # view.camera = scene.cameras.PanZoomCamera(aspect=1)
 
         # disable mouse drag, keep zoom in/out
         # view.camera.viewbox.events.mouse_move.disconnect(
         #     view.camera.viewbox_mouse_event)
 
-        colorbar.pos = (0, self.size[1]/2/self.nrows)
+        colorbar.pos = (0, self.size[1] / 2 / self.nrows)
         colorbar.canvas_size = self.size
         # view.camera.flip = (0, 1, 0)
         # view.camera.set_range()
         self.events.resize.connect(colorbar.on_resize)
 
     def link_cameras(self):
         """
         link all cameras
         """
 
         for view in self.view[:-1]:
             view.camera.link(self.view[-1].camera)
+
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## cigvis/vispynodes/volume_slices.py

```diff
@@ -5,29 +5,32 @@
 # University of Science and Technology of China (USTC)
 #
 # Copyright (C) 2019 Yunzhi Shi @ The University of Texas at Austin.
 # All rights reserved.
 # Distributed under the MIT License. See LICENSE for more info.
 # -----------------------------------------------------------------------------
 
-from typing import List, Callable, Tuple
+from typing import List, Callable, Tuple, Union
 import numpy as np
 from vispy.color import Colormap
 from cigvis import is_line_first
 
-from .axis_aligned_image import AxisAlignedImage
 
+from .axis_aligned_image import AxisAlignedImage, get_image_func
 
-def volume_slices(volumes: np.ndarray or List,
-                  x_pos: List or int = None,
-                  y_pos: List or int = None,
-                  z_pos: List or int = None,
+__all__ = ["volume_slices"]
+
+
+def volume_slices(volumes: Union[np.ndarray, List],
+                  x_pos: Union[List, int] = None,
+                  y_pos: Union[List, int] = None,
+                  z_pos: Union[List, int] = None,
                   preproc_funcs: Callable = None,
-                  cmaps: str or Colormap or List = 'grays',
-                  clims: List or Tuple = None,
+                  cmaps: Union[str, Colormap, List] = 'grays',
+                  clims: Union[List, Tuple] = None,
                   interpolation: str = 'linear',
                   method: str = 'auto') -> List[AxisAlignedImage]:
     """ 
     Acquire a list of slices in the form of AxisAlignedImage.
     The list can be attached to a VisCanvas to visualize the volume
     in 3D interactively.
 
@@ -54,14 +57,68 @@
         see: https://vispy.org/api/vispy.scene.visuals.html#vispy.scene.visuals.Image
 
     Returns
     -------
     visual_nodes : List[AxisAlignedImage]
         return seismic_canvas's visual_nodes
     """
+    volumes, preproc_funcs, cmaps, clims, interpolation, n_vol, shape = _process_args(
+        volumes, preproc_funcs, cmaps, clims, interpolation)
+
+    slices_list = []
+
+    # Function that returns the limitation of slice movement.
+    def limit(axis):
+        if axis == 'x': return (0, shape[0] - 1)
+        elif axis == 'y': return (0, shape[1] - 1)
+        elif axis == 'z': return (0, shape[2] - 1)
+
+    # Organize the slice positions.
+    for xyz_pos in (x_pos, y_pos, z_pos):
+        if not (isinstance(xyz_pos,
+                           (list, tuple, int, float)) or xyz_pos is None):
+            raise ValueError(
+                'Wrong type of x_pos/y_pos/z_pos={}'.format(xyz_pos))
+    axis_slices = {'x': x_pos, 'y': y_pos, 'z': z_pos}
+
+    # Create AxisAlignedImage nodes and append to the slices_list.
+    for axis, pos_list in axis_slices.items():
+        if pos_list is not None:
+            if isinstance(pos_list, (int, float)):
+                # make it iterable, even only one element
+                pos_list = [pos_list]
+            for pos in pos_list:
+                pos = int(np.round(pos))
+
+                # Generate a list of image funcs for each input volume.
+                image_funcs = []
+                for i in range(n_vol):
+                    image_funcs.append(
+                        get_image_func(axis, volumes[i], preproc_funcs[i]))
+
+                # Construct the AxisAlignedImage node.
+                image_node = AxisAlignedImage(image_funcs,
+                                              axis=axis,
+                                              pos=pos,
+                                              limit=limit(axis),
+                                              cmaps=cmaps,
+                                              clims=clims,
+                                              interpolation=interpolation,
+                                              method=method)
+
+                slices_list.append(image_node)
+
+    return slices_list
+
+
+def _process_args(volumes: Union[np.ndarray, List],
+                  preproc_funcs: Callable = None,
+                  cmaps: Union[str, Colormap, List] = 'grays',
+                  clims: Union[List, Tuple] = None,
+                  interpolation: str = 'linear') -> Tuple:
     # check and init
     # Check whether single volume or multiple volumes are provided.
     if isinstance(volumes, (tuple, list)):
         n_vol = len(volumes)
         if preproc_funcs is None:
             preproc_funcs = [None] * n_vol  # repeat n times ...
         else:
@@ -80,16 +137,14 @@
         cmaps = [cmaps]
         clims = [clims]
         n_vol = 1
     if isinstance(interpolation, str):
         interpolation = [interpolation] * len(volumes)
     assert len(interpolation) == len(volumes)
 
-    slices_list = []
-
     shape = volumes[0].shape
     line_first = is_line_first()
     if not line_first:
         shape = shape[::-1]
 
     # Automatically set clim (cmap range) if not specified.
     for i_vol in range(n_vol):
@@ -101,90 +156,8 @@
                 warn(
                     "cmap='auto' with np.memmap can significantly impact launching "
                     + "time, cmap=(cmin, cmax) is recommended.",
                     UserWarning,
                     stacklevel=2)
             clims[i_vol] = (vol.min(), vol.max())
 
-    # Function that returns the limitation of slice movement.
-    def limit(axis):
-        if axis == 'x': return (0, shape[0] - 1)
-        elif axis == 'y': return (0, shape[1] - 1)
-        elif axis == 'z': return (0, shape[2] - 1)
-
-    # Function that returns a function that provides the slice image at
-    # specified slicing position.
-    def get_image_func(axis, i_vol):
-        """
-        Parameters
-        ----------
-        axis : str
-            'x' or 'y' or 'z'
-        i_vol : int
-            index of the volumes
-        """
-
-        def slicing_at_axis(pos, get_shape=False):
-            if get_shape:  # just return the shape information
-                if axis == 'x': return shape[1], shape[2]
-                elif axis == 'y': return shape[0], shape[2]
-                elif axis == 'z': return shape[0], shape[1]
-            else:  # will slice the volume and return an np array image
-                pos = int(np.round(pos))
-                vol = volumes[i_vol]
-                preproc_f = preproc_funcs[i_vol]
-                if preproc_f is not None:
-                    if line_first:
-                        if axis == 'x': return preproc_f(vol[pos, :, :].T)
-                        elif axis == 'y': return preproc_f(vol[:, pos, :].T)
-                        elif axis == 'z': return preproc_f(vol[:, :, pos].T)
-                    else:
-                        if axis == 'x': return preproc_f(vol[:, :, pos])
-                        elif axis == 'y': return preproc_f(vol[:, pos, :])
-                        elif axis == 'z': return preproc_f(vol[pos, :, :])
-                else:
-                    if line_first:
-                        if axis == 'x': return vol[pos, :, :].T
-                        elif axis == 'y': return vol[:, pos, :].T
-                        elif axis == 'z': return vol[:, :, pos].T
-                    else:
-                        if axis == 'x': return vol[:, :, pos]
-                        elif axis == 'y': return vol[:, pos, :]
-                        elif axis == 'z': return vol[pos, :, :]
-
-        return slicing_at_axis
-
-    # Organize the slice positions.
-    for xyz_pos in (x_pos, y_pos, z_pos):
-        if not (isinstance(xyz_pos,
-                           (list, tuple, int, float)) or xyz_pos is None):
-            raise ValueError(
-                'Wrong type of x_pos/y_pos/z_pos={}'.format(xyz_pos))
-    axis_slices = {'x': x_pos, 'y': y_pos, 'z': z_pos}
-
-    # Create AxisAlignedImage nodes and append to the slices_list.
-    for axis, pos_list in axis_slices.items():
-        if pos_list is not None:
-            if isinstance(pos_list, (int, float)):
-                # make it iterable, even only one element
-                pos_list = [pos_list]
-            for pos in pos_list:
-                pos = int(np.round(pos))
-
-                # Generate a list of image funcs for each input volume.
-                image_funcs = []
-                for i_vol in range(n_vol):
-                    image_funcs.append(get_image_func(axis, i_vol))
-
-                # Construct the AxisAlignedImage node.
-                image_node = AxisAlignedImage(image_funcs,
-                                              axis=axis,
-                                              pos=pos,
-                                              limit=limit(axis),
-                                              cmaps=cmaps,
-                                              clims=clims,
-                                              interpolation=interpolation,
-                                              method=method)
-
-                slices_list.append(image_node)
-
-    return slices_list
+    return volumes, preproc_funcs, cmaps, clims, interpolation, n_vol, shape
```

## Comparing `cigvis/gui/gui3d.py` & `cigvis/gui/gui3d/control_panel.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,218 +1,252 @@
-# Copyright (c) 2023 Jintao Li.
+# Copyright (c) 2024 Jintao Li.
 # Computational and Interpretation Group (CIG),
 # University of Science and Technology of China (USTC).
 # All rights reserved.
-"""
-Run: 
-    python -c "import cigvis; cigvis.gui.gui3d()"
-
-TODO:
-    add other nodes (i.e., surface, well logs, ...)
-"""
 
-import re
 import sys
-import typing
-from PyQt5.QtWidgets import QWidget
-import numpy as np
-
+import re
 from PyQt5 import QtWidgets as qtw
 from PyQt5 import QtCore, QtGui
-
-from vispy.app import use_app
-
+from pathlib import Path
 import cigvis
-from cigvis.vispynodes import VisCanvas
-
-from .custom_widgets import *
-
-CANVAS_SIZE = (800, 600)  # (width, height)
-
-INT_validator = QtCore.QRegExp(r"^[1-9][0-9]*$")
-FLOAT_validator = QtCore.QRegExp(r"[-+]?[0-9]*\.?[0-9]+")
 
+from cigvis.gui.custom_widgets import *
 
-class MyMainWindow(qtw.QMainWindow):
+INTERPS = [
+    'nearest', 'linear', 'bicubic', 'bilinear', 'cubic', 'sinc', 'blackman',
+    'catrom', 'bessel', 'gaussian', 'hamming', 'hanning', 'hermite', 'kaiser',
+    'lanczos', 'mitchell', 'quadric', 'spline16', 'spline36'
+]
+
+
+class GlobalState(QtCore.QObject):
+
+    def __init__(self, nx=None, ny=None, nz=None) -> None:
+        self.dataLoaded = False
+        self.loadType = 'base'
+        self.nx = nx
+        self.ny = ny
+        self.nz = nz
+        self.transpose = False
 
-    def __init__(self, nx=None, ny=None, nz=None, clear_dim=True):
-        super().__init__()
+    def get_shape(self):
+        if (self.nx is None) or (self.ny is None) or (self.nz is None):
+            return False
+        return self.nx, self.ny, self.nz
 
-        self.clear_dim = clear_dim
 
-        self.initUI(nx, ny, nz)
+class LoadBtn(qtw.QPushButton):
+    data = QtCore.pyqtSignal(object)  # 用于通知数据加载完成的信号
+    nx = QtCore.pyqtSignal(str)
+    ny = QtCore.pyqtSignal(str)
+    nz = QtCore.pyqtSignal(str)
+    vmin = QtCore.pyqtSignal(str)
+    vmax = QtCore.pyqtSignal(str)
+    maskItem = QtCore.pyqtSignal(qtw.QListWidgetItem)
+
+    def __init__(self, gstates: GlobalState, parent=None):
+        super(LoadBtn, self).__init__("Load File", parent)
+        self.gstates = gstates
+        self.clicked.connect(self.loadData)
 
-    def initUI(self, nx=None, ny=None, nz=None):
-        central_widget = qtw.QWidget()
-        self.main_layout = qtw.QHBoxLayout()
+    def _is_base(self):
+        if self.gstates.loadType == 'base':
+            return True
+        else:
+            return False
 
-        self._controls = Controls(nx, ny, nz, self.clear_dim)
-        self.main_layout.addWidget(self._controls)
-        self._canvas_wrapper = CanvasWrapper()
-        self.main_layout.addWidget(self._canvas_wrapper.canvas.native)
+    def _check_load_valid(self):
+        flag = True
+        if self.gstates.dataLoaded and self._is_base():
+            qtw.QMessageBox.critical(
+                self, "Warn",
+                "Data already loaded. Please clear existing data first.")
+            flag = False
+
+        if not self.gstates.dataLoaded and not self._is_base():
+            qtw.QMessageBox.critical(
+                self, "Warn",
+                "Base Image is empty. Please load base image first.")
+            flag = False
+        return flag
+
+    def loadData(self, filePath: str = None, check=True):
+        if check and not self._check_load_valid():
+            return
+
+        if not filePath:
+            filePath, _ = qtw.QFileDialog.getOpenFileName(
+                self,
+                "Open File",
+                "",
+                "All Files (*)",
+                # options=qtw.QFileDialog.DontUseNativeDialog
+            )
+        if not filePath:  # 用户取消选择
+            return
 
-        central_widget.setLayout(self.main_layout)
-        self.setCentralWidget(central_widget)
+        if filePath and not self.gstates.get_shape():
+            dim = _get_dim_from_filename(filePath)
+            if dim:
+                nx, ny, nz = dim
+                self.gstates.nx = nx
+                self.gstates.ny = ny
+                self.gstates.nz = nz
+                self.nx.emit(f'{nx}')
+                self.ny.emit(f'{ny}')
+                self.nz.emit(f'{nz}')
+            else:
+                qtw.QMessageBox.critical(
+                    self, "Error", "Please enter values for nx, ny, and nz.")
+                return
 
-        self._canvas_wrapper.canvas.native.setAcceptDrops(True)
-        self._canvas_wrapper.canvas.native.dragEnterEvent = self.handleDragEnterEvent
-        self._canvas_wrapper.canvas.native.dropEvent = self.handleDropEvent
+        if filePath:
+            nx, ny, nz = self.gstates.get_shape()
+            try:
+                if filePath.endswith('.vds'):
+                    data = cigvis.io.VDSReader(filePath)
+                elif filePath.endswith('.npy'):
+                    data = np.load(filePath)
+                else:
+                    # data = np.memmap(filePath,
+                    #                  np.float32,
+                    #                  'c',
+                    #                  shape=(nx, ny, nz))
+                    data = np.fromfile(filePath,
+                                       np.float32).reshape(nx, ny, nz)
+                if not self._is_base():
+                    nxc, nyc, nzc = data.shape
+                    if (nxc != nx) or (nyc != ny) or (nzc != nz):
+                        qtw.QMessageBox.critical(
+                            self, "Warn",
+                            f"Mask image's shape must be same as base image, but base is ({nx}, {ny}, {nz}), mask is ({nxc}, {nyc}, {nzc})") # yapf: disable
+                        return
+            except Exception as e:
+                qtw.QMessageBox.critical(self, "Error",
+                                         f"Error loading data: {e}")
 
-        self._connect_controls()
+        if self.gstates.transpose:
+            data = data.T
+        self.gstates.dataLoaded = True  # 标记数据已加载
+        if self._is_base():
+            self.vmin.emit(f'{data.min():.2f}')
+            self.vmax.emit(f'{data.max():.2f}')
+        else:
+            item = qtw.QListWidgetItem(Path(filePath).name)
+            paramsWidget = MaskImageParams(interps=INTERPS)
+            paramsWidget.vmin_input.setTextAndEmit(f'{data.min():.2f}')
+            paramsWidget.vmax_input.setTextAndEmit(f'{data.max():.2f}')
+            item.paramsWidget = paramsWidget
+            item.visible = True  # TODO:
+            self.maskItem.emit(item)
 
-    def handleDragEnterEvent(self, event):
-        if event.mimeData().hasUrls():
-            event.acceptProposedAction()
+        self.data.emit(data)  # 发送数据加载完成的信号
 
-    def handleDropEvent(self, event):
-        if len(event.mimeData().urls()) > 1:
-            qtw.QMessageBox.critical(self, "Error", "Only support 1 file")
-            return
-        fpath = event.mimeData().urls()[0].toLocalFile()
-        self._controls.load_data(fpath)
 
-    def _connect_controls(self):
-        self._controls.data_loaded[list].connect(self._canvas_wrapper.set_data)
-        self._controls.colormap_combo.changed.connect(self._set_cmap)
-        self._controls.vmin_input.editingFinished.connect(
-            lambda: self._canvas_wrapper.set_vmin(self._controls.vmin_input.
-                                                  text()))
-        self._controls.vmax_input.editingFinished.connect(
-            lambda: self._canvas_wrapper.set_vmax(self._controls.vmax_input.
-                                                  text()))
-
-        self._controls.azimuth_input.changed.connect(
-            self._canvas_wrapper.set_azimuth)
-        self._controls.elevation_input.changed.connect(
-            self._canvas_wrapper.set_elevation)
-        self._controls.fov_input.changed.connect(self._canvas_wrapper.set_fov)
-
-        self._controls.xpos.changed.connect(self._canvas_wrapper.set_xpos)
-        self._controls.ypos.changed.connect(self._canvas_wrapper.set_ypos)
-        self._controls.zpos.changed.connect(self._canvas_wrapper.set_zpos)
-
-        self._controls.aspx.changed.connect(self._canvas_wrapper.set_aspectx)
-        self._controls.aspy.changed.connect(self._canvas_wrapper.set_aspecty)
-        self._controls.aspz.changed.connect(self._canvas_wrapper.set_aspectz)
-
-        self._canvas_wrapper.camera_params[list].connect(
-            self._controls.update_camera)
-        self._controls.update_btn.clicked.connect(
-            lambda: self._controls.update_camera(self._canvas_wrapper.
-                                                 get_params()))
-        self._controls.clear_btn.clicked.connect(self._canvas_wrapper.clear)
-        self._controls.clear_btn.clicked.connect(self._controls.clear)
-
-    def _set_cmap(self, cmap):
-        try:
-            self._canvas_wrapper.set_cmap(cmap)
-        except Exception as e:
-            qtw.QMessageBox.critical(self, "Error", f"Error colormap: {e}")
+class HorizonWidget(qtw.QWidget):
 
+    def __init__(self, parent=None):
+        super().__init__(parent)
 
-class Controls(qtw.QWidget):
 
-    data_loaded = QtCore.pyqtSignal(list)
+class ControlP(qtw.QWidget):
 
-    def __init__(self, nx=None, ny=None, nz=None, clear_dim=True, parent=None):
+    def __init__(self,
+                 gstates: GlobalState,
+                 nx: int = None,
+                 ny: int = None,
+                 nz: int = None,
+                 clear_dim: bool = True,
+                 parent=None):
         super().__init__(parent)
+        assert isinstance(gstates, GlobalState)
 
+        self.gstates = gstates
         self.clear_dim = clear_dim
 
         layout = qtw.QVBoxLayout()
 
-        self.loaded = False
-
         # dimensions
         row1_layout = qtw.QHBoxLayout()
         nx_label = qtw.QLabel('nx:')
-        self.nx_input = qtw.QLineEdit()
+        self.nx_input = MyQLineEdit()
         self.nx_input.setValidator(QtGui.QRegExpValidator(INT_validator, self))
         if nx is not None:
-            self.nx_input.setText(f'{nx}')
+            self.nx_input.setTextAndEmit(f'{nx}')
         ny_label = qtw.QLabel('ny:')
-        self.ny_input = qtw.QLineEdit()
+        self.ny_input = MyQLineEdit()
         self.ny_input.setValidator(QtGui.QRegExpValidator(INT_validator, self))
         if ny is not None:
-            self.ny_input.setText(f'{ny}')
+            self.ny_input.setTextAndEmit(f'{ny}')
         nz_label = qtw.QLabel('nz:')
-        self.nz_input = qtw.QLineEdit()
+        self.nz_input = MyQLineEdit()
         self.nz_input.setValidator(QtGui.QRegExpValidator(INT_validator, self))
         if nz is not None:
-            self.nz_input.setText(f'{nz}')
-        self.load_btn = qtw.QPushButton('Load')
+            self.nz_input.setTextAndEmit(f'{nz}')
         self.addwidgets(row1_layout, [
             nx_label, self.nx_input, ny_label, self.ny_input, nz_label,
-            self.nz_input, self.load_btn
+            self.nz_input
         ])
 
-        # clim
-        row2_layout = qtw.QHBoxLayout()
-        vmin_label = qtw.QLabel('vmin:')
-        self.vmin_input = qtw.QLineEdit()
-        self.vmin_input.setValidator(
-            QtGui.QRegExpValidator(FLOAT_validator, self))
-        vmax_label = qtw.QLabel('vmax:')
-        self.vmax_input = qtw.QLineEdit()
-        self.vmax_input.setValidator(
-            QtGui.QRegExpValidator(FLOAT_validator, self))
-        self.addwidgets(
-            row2_layout,
-            [vmin_label, self.vmin_input, vmax_label, self.vmax_input])
+        row_folder = qtw.QHBoxLayout()
+        self.loadfolder = LoadFolderWidget()
+        self.addwidgets(row_folder, [self.loadfolder])
 
-        # colormap
-        row3_layout = qtw.QHBoxLayout()
-        colormap_label = qtw.QLabel('Colormap:')
-        self.colormap_combo = EditableComboBox()
-        colormaps = [
-            'gray', 'seismic', 'Petrel', 'od_seismic1', 'od_seismic2',
-            'od_seismic3'
-        ]
-        self.colormap_combo.addItems(colormaps)
-        self.colormap_combo.setCurrentText('gray')  # 默认值为'gray'
-        self.addwidgets(row3_layout, [colormap_label, self.colormap_combo])
+        row2_layout = qtw.QHBoxLayout()
+        self.loadBtn = LoadBtn(gstates, self)
+        trans_label = qtw.QLabel("Transpose")
+        self.loadRad = RadioButtonPanel(['on', 'off'])
+        self.loadRad.radioButtons[1].setChecked(True)
+        self.addwidgets(row2_layout, [self.loadBtn, trans_label, self.loadRad])
 
         # parameters of the camera
         row4_layout = qtw.QHBoxLayout()
         azimuth_label = qtw.QLabel('Azimuth:')
-        self.azimuth_input = MyQDoubleSpinBox()
+        self.azimuth_input = MyQSpinBox()
         self.azimuth_input.setRange(0, 360)
         self.azimuth_input.setValue(50)
         elevation_label = qtw.QLabel('Elevation:')
-        self.elevation_input = MyQDoubleSpinBox()
+        self.elevation_input = MyQSpinBox()
         self.elevation_input.setRange(-90, 90)
         self.elevation_input.setValue(50)
         fov_label = qtw.QLabel('FOV:')
-        self.fov_input = MyQDoubleSpinBox()
+        self.fov_input = MyQSpinBox()
         self.fov_input.setRange(1, 179)
         self.fov_input.setValue(30)
         self.addwidgets(row4_layout, [
             azimuth_label, self.azimuth_input, elevation_label,
             self.elevation_input, fov_label, self.fov_input
         ])
 
         # pos
         row5_layout = qtw.QHBoxLayout()
         xpos_label = qtw.QLabel('x:')
         self.xpos = MyQSpinBox()
         self.xpos.setMinimum(0)
+        if nx:
+            self.xpos.setMaximum(nx - 1)
         ypos_label = qtw.QLabel('y:')
         self.ypos = MyQSpinBox()
         self.ypos.setMinimum(0)
+        if ny:
+            self.ypos.setMaximum(ny - 1)
         zpos_label = qtw.QLabel('z:')
         self.zpos = MyQSpinBox()
         self.zpos.setMinimum(0)
+        if nz:
+            self.zpos.setMaximum(nz - 1)
 
         self.addwidgets(row5_layout, [
             xpos_label, self.xpos, ypos_label, self.ypos, zpos_label, self.zpos
         ])
 
         # aspect ratio
         row_aspect = qtw.QHBoxLayout()
-        asp1 = qtw.QLabel('Aspect Ratio  x ')
+        asp1 = qtw.QLabel('Aspect x ')
         self.aspx = MyQDoubleSpinBox()
         self.aspx.setMinimum(0.1)
         self.aspx.setValue(1)
         self.aspx.setSingleStep(0.1)
         asp2 = qtw.QLabel('  :  y ')
         self.aspy = MyQDoubleSpinBox()
         self.aspy.setMinimum(0.1)
@@ -230,362 +264,205 @@
         # update params
         row6_layout = qtw.QHBoxLayout()
         self.update_btn = qtw.QPushButton('update params')
         self.clear_btn = qtw.QPushButton('clear')
 
         self.addwidgets(row6_layout, [self.update_btn, self.clear_btn])
 
+        row_tab = qtw.QHBoxLayout()
+        self.tab_widget = qtw.QTabWidget()
+        self.base_tab = ImageParams(interps=INTERPS)
+        self.tab_widget.addTab(self.base_tab, "Base")
+        self.mask_tab = MaskWidget()
+        self.tab_widget.addTab(self.mask_tab, "Masks")
+        self.horz_tab = HorizonWidget()
+        self.tab_widget.addTab(self.horz_tab, "Horiz")
+        self.other_tab = HorizonWidget()
+        self.tab_widget.addTab(self.other_tab, "Other")
+        row_tab.addWidget(self.tab_widget)
+        row_tab.setStretch(0, 1)
+
         self.addlayout(layout, [
-            row1_layout, row2_layout, row3_layout, row4_layout, row5_layout,
-            row_aspect, row6_layout
+            row1_layout,
+            row_folder,
+            row2_layout,
+            row4_layout,
+            row5_layout,
+            row_aspect,
+            row6_layout,
+            row_tab,
         ])
 
         layout.addStretch(1)
         self.setLayout(layout)
-        self.setMaximumWidth(400)
+        self.setMaximumWidth(350)
+        self.innerConnection()
 
-        self.load_btn.clicked.connect(self.load_data)
+    def innerConnection(self):
+        self.nx_input.editingFinished.connect(
+            lambda: self.update_xpos_limit(self.nx_input.text()))
+        self.ny_input.editingFinished.connect(
+            lambda: self.update_ypos_limit(self.ny_input.text()))
+        self.nz_input.editingFinished.connect(
+            lambda: self.update_zpos_limit(self.nz_input.text()))
+
+        self.nx_input.editingFinished.connect(
+            lambda: self.update_nx(self.nx_input.text()))
+        self.ny_input.editingFinished.connect(
+            lambda: self.update_ny(self.ny_input.text()))
+        self.nz_input.editingFinished.connect(
+            lambda: self.update_nz(self.nz_input.text()))
+
+        self.clear_btn.clicked.connect(self.clear)
+        self.loadBtn.nx[str].connect(self.nx_input.setTextAndEmit)
+        self.loadBtn.ny[str].connect(self.ny_input.setTextAndEmit)
+        self.loadBtn.vmin[str].connect(self.base_tab.vmin_input.setTextAndEmit)
+        self.loadBtn.vmax[str].connect(self.base_tab.vmax_input.setTextAndEmit)
+        self.loadfolder.currentPath[str].connect(
+            lambda fpath: self.loadBtn.loadData(fpath, check=False))
+        self.loadBtn.maskItem[qtw.QListWidgetItem].connect(
+            self.mask_tab.addItem)
+
+        self.tab_widget.currentChanged.connect(self.tabSelected)
+        self.loadRad.selectionChanged[str].connect(self.transpose)
+
+    def tabSelected(self, idx):
+        if idx == 1:
+            # self.loadRad.radioButtons[1].setChecked(True)
+            self.gstates.loadType = 'mask'
+        else:
+            # self.loadRad.radioButtons[0].setChecked(True)
+            self.gstates.loadType = 'base'
 
     def addwidgets(self, layout, widgets):
         for widget in widgets:
             layout.addWidget(widget)
 
     def addlayout(self, layout, sublayouts):
         for sublayout in sublayouts:
             layout.addLayout(sublayout)
 
-    def is_set_dim(self):
-        if self.nx_input.text() and self.ny_input.text(
-        ) and self.nz_input.text():
-            return True
-        else:
-            return False
-
-    def load_data(self, file_path=None):
-        if self.loaded:
-            qtw.QMessageBox.critical(self, "Warn",
-                                     "Need to click clear to reset")
-            return
-
-        if not file_path:
-            file_dialog = qtw.QFileDialog()
-            file_path, _ = file_dialog.getOpenFileName(self, 'Open Data File',
-                                                       '', 'Binary Files (*)')
-
-        if file_path and not self.is_set_dim():
-            dim = get_dim_from_filename(file_path, False)
-            if dim:
-                self.nx_input.setText(dim[0])
-                self.ny_input.setText(dim[1])
-                self.nz_input.setText(dim[2])
-            else:
-                qtw.QMessageBox.critical(
-                    self, "Error", "Please enter values for nx, ny, and nz.")
-                return
-
-        if file_path:
-            try:
-                nx = int(self.nx_input.text())
-                ny = int(self.ny_input.text())
-                nz = int(self.nz_input.text())
-
-                if file_path.endswith('.vds'):
-                    data = cigvis.io.VDSReader(file_path)
-                else:
-                    data = np.fromfile(file_path,
-                                       dtype=np.float32).reshape(nx, ny, nz)
-
-                if not self.vmin_input.text():
-                    self.vmin_input.setText(f'{data.min():.2f}')
-                if not self.vmax_input.text():
-                    self.vmax_input.setText(f'{data.max():.2f}')
-
-                self.xpos.setMaximum(nx - 1)
-                self.ypos.setMaximum(ny - 1)
-                self.zpos.setMaximum(nz - 1)
-
-                if self.zpos.value() == 0:
-                    self.zpos.setValue(nz - 1)
-
-                self.data_loaded.emit([
-                    data,
-                    [self.xpos.value(),
-                     self.ypos.value(),
-                     self.zpos.value()],
-                    [
-                        float(self.vmin_input.text()),
-                        float(self.vmax_input.text())
-                    ],
-                    self.colormap_combo.currentText(),
-                    self.azimuth_input.value(),
-                    self.elevation_input.value(),
-                    self.fov_input.value(),
-                    [self.aspx.value(),
-                     self.aspy.value(),
-                     self.aspz.value()]
-                ])
-                self.loaded = True
-            except Exception as e:
-                qtw.QMessageBox.critical(self, "Error",
-                                         f"Error loading data: {e}")
-
     def update_camera(self, params):
         if params is None:
             return
         self.azimuth_input.setValue(params[0])
         self.elevation_input.setValue(params[1])
         self.fov_input.setValue(params[2])
 
         if len(params) == 4:
             pos = params[3]
             self.xpos.setValue(pos['x'][0])
             self.ypos.setValue(pos['y'][0])
             self.zpos.setValue(pos['z'][0])
 
+    def update_xpos_limit(self, nx):
+        if nx:
+            self.xpos.setMaximum(int(nx) - 1)
+
+    def update_ypos_limit(self, ny):
+        if ny:
+            self.ypos.setMaximum(int(ny) - 1)
+
+    def update_zpos_limit(self, nz):
+        if nz:
+            self.zpos.setMaximum(int(nz) - 1)
+
+    def update_nx(self, nx):
+        if nx:
+            self.gstates.nx = int(nx)
+
+    def update_ny(self, ny):
+        if ny:
+            self.gstates.ny = int(ny)
+
+    def update_nz(self, nz):
+        if nz:
+            self.gstates.nz = int(nz)
+
+    def transpose(self, text):
+        if text == 'on':
+            self.gstates.transpose = True
+        else:
+            self.gstates.transpose = False
+
     def clear(self):
         if self.clear_dim:
             self.nx_input.clear()
             self.ny_input.clear()
             self.nz_input.clear()
-        self.vmin_input.clear()
-        self.vmax_input.clear()
-        self.colormap_combo.setCurrentText('gray')
+            self.gstates.nx = None
+            self.gstates.ny = None
+            self.gstates.nz = None
+
+        self.gstates.dataLoaded = False
+        self.gstates.loadType = 'base'
+
+        self.loadfolder.clear()
+        self.base_tab.clear()
+        self.mask_tab.clear()
+
         self.azimuth_input.setValue(50)
         self.elevation_input.setValue(50)
         self.fov_input.setValue(30)
         self.xpos.setValue(0)
         self.ypos.setValue(0)
         self.zpos.setValue(0)
         self.aspx.setValue(1)
         self.aspy.setValue(1)
         self.aspz.setValue(1)
-        self.loaded = False
-
-
-class CanvasWrapper(qtw.QWidget):
-
-    camera_params = QtCore.pyqtSignal(list)
-
-    def __init__(self, parent=None):
-        super().__init__(parent)
-        self.data = None
-        self.nodes = []
-        self.canvas = VisCanvas(size=CANVAS_SIZE)
-        self.canvas.events.key_press.connect(self.on_key_press)
-
-    def set_data(self, data):
-        self.data = data[0]
-        self.canvas.update_camera(data[4], data[5], data[6])
-        self.canvas.update_axis_scales(data[7])
-        self.nodes = cigvis.create_slices(self.data,
-                                          pos=data[1],
-                                          clim=data[2],
-                                          cmap=data[3])
-        self.canvas.add_nodes(self.nodes)
-
-    def set_cmap(self, cmap):
-        cmap = cigvis.colormap.cmap_to_vispy(cmap)
-
-        for node in self.nodes:
-            node.cmap = cmap
-
-    def set_vmin(self, vmin):
-        vmin = float(vmin)
-        for node in self.nodes:
-            old_clim = node.clim
-            node.clim = [vmin, old_clim[1]]
-
-    def set_vmax(self, vmax):
-        vmax = float(vmax)
-        for node in self.nodes:
-            old_clim = node.clim
-            node.clim = [old_clim[0], vmax]
-
-    def set_azimuth(self, azimuth):
-        if not hasattr(self.canvas, 'view'):
-            return
-        for view in self.canvas.view:
-            view.camera.azimuth = azimuth
-
-    def set_elevation(self, elevation):
-        if not hasattr(self.canvas, 'view'):
-            return
-        for view in self.canvas.view:
-            view.camera.elevation = elevation
-
-    def set_fov(self, fov):
-        if not hasattr(self.canvas, 'view'):
-            return
-        for view in self.canvas.view:
-            view.camera.fov = fov
-
-    def set_xpos(self, xpos):
-        if not xpos:
-            return
-        xpos = int(xpos)
-        if len(self.nodes) > 0:
-            for node in self.nodes:
-                if node.axis == 'x':
-                    node._update_location(xpos)
-
-    def set_ypos(self, ypos):
-        if not ypos:
-            return
-        ypos = int(ypos)
-        if len(self.nodes) > 0:
-            for node in self.nodes:
-                if node.axis == 'y':
-                    node._update_location(ypos)
-
-    def set_zpos(self, zpos):
-        if not zpos:
-            return
-        zpos = int(zpos)
-        if len(self.nodes) > 0:
-            for node in self.nodes:
-                if node.axis == 'z':
-                    node._update_location(zpos)
-
-    def set_aspectx(self, aspx):
-        r = cigvis.is_x_reversed()
-        aspx *= (1 - 2 * r)
-        if not hasattr(self.canvas, 'view'):
-            return
-        for view in self.canvas.view:
-            axis_scales = view.camera._flip_factors
-            axis_scales[0] = aspx
-            view.camera._flip_factors = axis_scales
-            view.camera._update_camera_pos()
-            self.canvas.update()
-
-    def set_aspecty(self, aspy):
-        r = cigvis.is_y_reversed()
-        aspy *= (1 - 2 * r)
-        if not hasattr(self.canvas, 'view'):
-            return
-        for view in self.canvas.view:
-            axis_scales = view.camera._flip_factors
-            axis_scales[1] = aspy
-            view.camera._flip_factors = axis_scales
-            view.camera._update_camera_pos()
-            self.canvas.update()
-
-    def set_aspectz(self, aspz):
-        r = cigvis.is_z_reversed()
-        aspz *= (1 - 2 * r)
-        if not hasattr(self.canvas, 'view'):
-            return
-        for view in self.canvas.view:
-            axis_scales = view.camera._flip_factors
-            axis_scales[2] = aspz
-            view.camera._flip_factors = axis_scales
-            view.camera._update_camera_pos()
-            self.canvas.update()
-
-    def get_params(self):
-        out = None
-        if hasattr(self.canvas, 'view'):
-            camera = self.canvas.view[0].camera
-            out = [camera.azimuth, camera.elevation, camera.fov]
-
-        if len(self.nodes) > 0:
-            pos = {'x': [], 'y': [], 'z': []}
-            for node in self.nodes:
-                axis = node.axis
-                apos = node.pos
-                pos[axis].append(apos)
-
-            out.append(pos)
-
-        return out
-
-    def on_key_press(self, event):
-        if event.key == 'u':
-            out = self.get_params()
-            if out is not None:
-                self.camera_params.emit(out)
-
-    def clear(self):
-        for node in self.nodes:
-            node.parent = None
-            del node
-        self.nodes = []
-        del self.data
-        self.data = None
-
 
-class DimsWidget(qtw.QWidget):
-
-    def __init__(self, nx=None, ny=None, nz=None, clear_dim=True, parent=None):
-        super().__init__(parent)
-
-        self.clear_dim = clear_dim
 
-        # dimensions
-        row1_layout = qtw.QHBoxLayout()
-        nx_label = qtw.QLabel('nx:')
-        self.nx_input = qtw.QLineEdit()
-        self.nx_input.setValidator(QtGui.QRegExpValidator(INT_validator, self))
-        if nx is not None:
-            self.nx_input.setText(f'{nx}')
-        ny_label = qtw.QLabel('ny:')
-        self.ny_input = qtw.QLineEdit()
-        self.ny_input.setValidator(QtGui.QRegExpValidator(INT_validator, self))
-        if ny is not None:
-            self.ny_input.setText(f'{ny}')
-        nz_label = qtw.QLabel('nz:')
-        self.nz_input = qtw.QLineEdit()
-        self.nz_input.setValidator(QtGui.QRegExpValidator(INT_validator, self))
-        if nz is not None:
-            self.nz_input.setText(f'{nz}')
-        self.load_btn = qtw.QPushButton('Load')
-        self.addwidgets(row1_layout, [
-            nx_label, self.nx_input, ny_label, self.ny_input, nz_label,
-            self.nz_input, self.load_btn
-        ])
-
-    def addwidgets(self, layout, widgets):
-        for widget in widgets:
-            layout.addWidget(widget)
-
-    def set_dims(self, nx, ny, nz):
-        self.nx_input.setText(f'{nx}')
-        self.ny_input.setText(f'{ny}')
-        self.nz_input.setText(f'{nz}')
-
-    def clear(self):
-        if self.clear_dim:
-            self.nx_input.clear()
-            self.ny_input.clear()
-            self.nz_input.clear()
-
-
-def get_dim_from_filename(fname: str, return_int: bool = True):
+def _get_dim_from_filename(fname: str, return_int: bool = True):
     """
     obtain the dimension size from file path, 
     support template:
-    - fname_h{z}x{y}x{x}.siff, i.e.,  fname_h128x500x200.dat
+    - fname_h{z}x{y}x{x}.siff, e.g.,  fname_h128x500x200.dat
+    - xxx.vds, i.e., VDS file
+    - fname_{x}_{y}_{z}.sufix, e.g., fname_200_500_128.dat
+    - xxx.npy, i.e., numpy file
     """
     if fname.endswith(".vds"):
         vds = cigvis.io.VDSReader(fname)
         shape = vds.shape
         vds.close()
-        return str(shape[0]), str(shape[1]), str(shape[2])
-    
-    f = fname.split('/')[-1]
-    pattern = r'^[A-Za-z0-9_]+_h(\d+)x(\d+)x(\d+)+\.\w+$'
-    m = re.match(pattern, f)
-    if m:
         if return_int:
-            return int(m.group(3)), int(m.group(2)), int(m.group(1))
+            return shape
+        else:
+            return str(shape[0]), str(shape[1]), str(shape[2])
+    elif fname.endswith(".npy"):
+        with open(fname, 'rb') as f:
+            version = np.lib.format.read_magic(f)
+            shape, _, _ = np.lib.format._read_array_header(f, version)
+
+        if len(shape) != 3:
+            return False
+
+        if return_int:
+            return shape
         else:
-            return m.group(3), m.group(2), m.group(1)
-    else:
-        return False
+            return str(shape[0]), str(shape[1]), str(shape[2])
+
+    pattern1 = r'\w+\_h(\d+)x(\d+)x(\d+)'
+    pattern2 = r'\w+\_(\d+)\_(\d+)\_(\d+)'
+    fname = Path(fname).stem
+    match1 = re.search(pattern1, fname)
+    if match1:
+        z, y, x = match1.groups()
+        if return_int:
+            return int(x), int(y), int(z)
+        else:
+            return x, y, z
+
+    match2 = re.search(pattern2, fname)
+    if match2:
+        x, y, z = match2.groups()
+        if return_int:
+            return int(x), int(y), int(z)
+        else:
+            return x, y, z
+
+    return False
 
 
-def gui3d(nx=None, ny=None, nz=None, clear_dim=True):
-    app = use_app("pyqt5")
-    app.create()
-    win = MyMainWindow(nx, ny, nz, clear_dim)
-    win.show()
-    app.run()
+if __name__ == '__main__':
+    fname = '/dsf/dsds/dsc_ds_123_412_512.dat'
+    print(_get_dim_from_filename(fname))
```

## Comparing `cigvis-0.0.4.dist-info/LICENSE` & `cigvis-0.0.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cigvis-0.0.4.dist-info/METADATA` & `cigvis-0.0.5.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 Metadata-Version: 2.1
 Name: cigvis
-Version: 0.0.4
+Version: 0.0.5
 Summary: CIGVis is a tool for geophysical data visualization, which developed by Computational Interpretation Group (CIG)
 Home-page: https://github.com/JintaoLee-Roger/cigvis
 Author: Jintao Li, and others
 License: MIT
+Platform: UNKNOWN
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 ![im1](https://raw.githubusercontent.com/JintaoLee-Roger/images/main/cigvis/more_demos/070.png)
 
 # CIGVis - a tool for visualizing multidimensional geophysical data
@@ -127,7 +128,9 @@
 See: [cigvis/gallery](https://cigvis.readthedocs.io/en/latest/gallery/index.html)
 
 ## TODO
 
 - [ ] move all functions for triangle mesh creation to `meshs/`
 
 
+
+
```

## Comparing `cigvis-0.0.4.dist-info/RECORD` & `cigvis-0.0.5.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,51 @@
-cigvis/__init__.py,sha256=oAsz4TErOvgmOVX4YKvjQcg_4Dh9Yj769d_vN0eD20s,1845
-cigvis/colormap.py,sha256=ChPX7uK3C1URaTr_VQh4rk5xkzthLqf7seSx5Ahvo2k,15775
+cigvis/__init__.py,sha256=ySEXF3Z3-k6xCZ2jWsfjAZ0RKwrwOc_fOTyyCsgjhHY,1841
+cigvis/colormap.py,sha256=Se3ZubG5-fxZ1qIZTL4FzFLA4VGh3gS2eHfB0PIH6Xk,16973
 cigvis/config.py,sha256=YcaBnDoUfTzaOK9Oa24W2gc9HfWorAt_Gvgeb2QNGdQ,1743
 cigvis/customcmap.py,sha256=haB3Ypuce79TOELnKf7a1jx_gIqXwfKkPesZaqGqGnI,76159
-cigvis/mpl1dplot.py,sha256=YaaJZv4S24w7ANLzguZTUrEy9mc8QyD4rhL2F7GFrFw,12334
+cigvis/mpl1dplot.py,sha256=bcQrrhpV_hJ8SZDWBqltG2qqAPAtxJEPgVRy6RTI1Jk,12351
 cigvis/mpl2dplot.py,sha256=_IVA1Sk6CoB7Bep82EuhzNCuiVBaGXiSa7K6DnH1O28,10527
 cigvis/plotlyplot.py,sha256=uzXZemXzNMsWqxv_RPGVgNi2oLbO6_RetZ_BwBxN0Zw,12242
-cigvis/vispyplot.py,sha256=pEiRlrXVnpAhjlvgMSCNavQFvSyVzCp_KMj0kuMCE1w,27675
-cigvis/gui/__init__.py,sha256=o_Qb4kBAqRCNyT9WZQmakYcr9gU6sm5ZvQQhjE1sarY,222
-cigvis/gui/custom_widgets.py,sha256=ehZuvauKKckcIQbf8WxKCYbciMJq27v1gKI-kS57-TI,1615
-cigvis/gui/gui3d.py,sha256=oR9Ws97TTjwUd-7cL9IJVJEW9QRw6RUF3O5Bife1LkA,19858
-cigvis/gui/params_widgets.py,sha256=S0CvhzVNMYcCpILuRNzOtuLqM6XqJh43gphHDO-S0b8,5620
+cigvis/vispyplot.py,sha256=76WgGkj1Rtit3jPnjRwk5I1csJOuGzaXYSkqngIUafo,30568
+cigvis/gui/__init__.py,sha256=_RPpTQhUKbmWHqHhVGmxySs7tiS3MTjcM-WU-1sfFcA,247
+cigvis/gui/custom_widgets.py,sha256=qbIVOoLsy16V5qMhaYzjb2s-1nd5fL-Gs46Mu93IVP8,16999
+cigvis/gui/test_gui2d.py,sha256=i888eq4oByuNHQjY4MzXjNBJsUfwNxOcZSWvmSvWV8c,11300
+cigvis/gui/test_gui2d_vispy.py,sha256=pC9urbR_DT1I1LdX8EAEcBR2EAQH0esvqrUS2U0Z4wo,10581
+cigvis/gui/gui2d/__init__.py,sha256=kr-LhJ7r2oEwctFhJSVokDhAW_Fuly4LIhVtgDAyz0M,188
+cigvis/gui/gui2d/control_panel.py,sha256=CRhS2Jay3M9sJk8xw-gnQxuF5Rwdy-AHsoQGM1t8NUE,14200
+cigvis/gui/gui2d/mainwindow.py,sha256=QAD4-0PjQmxKmk6bK4f8t-sQJ4u6eEktXMSlk-TtSKk,3596
+cigvis/gui/gui2d/plot_canvas.py,sha256=q58KCZpNdmwwQLSxjZXRJodMss8SYacH3xIw1SnGqSc,14637
+cigvis/gui/gui3d/__init__.py,sha256=bLcRbFjx5d0R5l85nhD8haCsM3YRWQJ70cpUnFaBj2Q,189
+cigvis/gui/gui3d/control_panel.py,sha256=dNdurBLiUC5X_h8DniIZLXxgsXDZQYNdOXLNfSz1D2s,15644
+cigvis/gui/gui3d/mainwindow.py,sha256=vbmT2DbJp65_Ar1BdDHzSZBL2bagU9LveGBwypiW03I,3597
+cigvis/gui/gui3d/plot_canvas.py,sha256=8w7Xq4VYaK7KMsZCd09BKT73uxYnTf59Fy62izOC1EI,13077
 cigvis/io/__init__.py,sha256=0kHWpz2ZJoIcLtldslBVQGOeL6lDvNkrGs_y_amiQis,436
 cigvis/io/fault_skin.py,sha256=Mae5M95mE6WK89a5Pv8cD0CKD6Elh1TE5uPahZ60KV4,8184
 cigvis/io/horiz.py,sha256=wDJkN336wZyphTWNkeEoWCAcX7MhuZ2Qy89SE_rMxgE,605
 cigvis/io/las.py,sha256=MNVI26F5Xb0uzzXoBrXynQ6zZdxi8g5f1lGDaZr3QmI,2998
 cigvis/io/vds.py,sha256=iGrFKWU481ZJvzWwtf7id-IgaA9bkBACiHvhDFZH-Ds,7837
 cigvis/meshs/__init__.py,sha256=S6vfyxzuGx6AUfNV-UE8OhKZDH0Dvm08X52J-bsC6N0,212
 cigvis/meshs/merge.py,sha256=CwWXhMuedrHpR4944TYUU9_E8JhVqUkpBn2VTLQ1UZE,725
 cigvis/meshs/points.py,sha256=yhIfrwci-bAB6EDIWjpGGQ6OGoy6bfNVliEnHV0HgOQ,1541
 cigvis/meshs/surfaces.py,sha256=REy6Uv4S_zy5XlwFI93KjsAHSC_U6TmuZ4SXmtpqhsY,176
 cigvis/meshs/well_logs.py,sha256=2frKO-QXHWyWWTRgL2PlF5VEffcH4o4fkwH_uoQ0m6c,6412
 cigvis/utils/__init__.py,sha256=VT6EBYDUOdaouQANV1PHhT6zdLczR7AhctgCbGX-ipM,279
 cigvis/utils/coord.py,sha256=pvrDsSw9riK9P35_0zKj3m9LiPAsJt03CwAgL1lgU8c,1414
-cigvis/utils/plotlyutils.py,sha256=8dxldZCoPSWL1kVkf43CdtMjS4MnTfWb8cgkavF7gGg,7860
+cigvis/utils/plotlyutils.py,sha256=m8OmYWvSqDJmxA2Bahcbdz0rXCHAHjBvgLkGdRsx88k,7875
 cigvis/utils/surfaceutils.py,sha256=BiVG2q3UCbrcgzDUGT58I8S-ZmHl1PDjXhlHhMpf_QU,7945
-cigvis/utils/utils.py,sha256=N8yySEF-hSKP0DrqtyMgy4GzPPT_W5qwYjrgouFYzO8,601
+cigvis/utils/utils.py,sha256=j1wzcBZdXyWbzTAMr1V5olJCuz7FkvlyLHhzl8e3lqo,1656
 cigvis/utils/vispyutils.py,sha256=fd-rP_Ow-SsmzAwrPtcb9gd10dnZs4kHvsTZYlfyLLY,3375
 cigvis/vispynodes/__init__.py,sha256=Jymp00BjwjVye39E4gO6Qnxy1U_HDbOjumX8XJ8F_XE,573
 cigvis/vispynodes/axis3d.py,sha256=77lnMpNfUK2quQFZqYYHtqSmJi5G_wkNvf9pgSxnGUM,4245
-cigvis/vispynodes/axis_aligned_image.py,sha256=0LD2TvGgFk4Z17Jxcc_eNMmfyUVpbej8U8P9gI0K1pU,14106
+cigvis/vispynodes/axis_aligned_image.py,sha256=TISppZudOl6zC9zpyFRAP88T0fl5B2OlnpQxtXMR_R0,17679
+cigvis/vispynodes/canvas_mixin.py,sha256=AsMX5kxDIf0sPHLBNZdnewwyGRnUDwLpLPI9rA-_J1M,12878
 cigvis/vispynodes/colorbar.py,sha256=LC9j5WxIbSCImxj4JFNjrsK02CpIp_AeBX0G4jEQtn8,10341
 cigvis/vispynodes/fixed_image.py,sha256=nWwpzE1oOxMK5V1D-QANs1FX6rSNX5k9x7vlly0JvbU,6377
-cigvis/vispynodes/vis_canvas.py,sha256=ympvP-GegZfXoFZVNg8n4liyOVlkUPBpzs1XpabEAOQ,23841
-cigvis/vispynodes/volume_slices.py,sha256=fRBseND-GNnw-P8ZBK1P63UbYTXXPu6loVBlOIFuCaA,7413
+cigvis/vispynodes/vis_canvas.py,sha256=XLy2U_fsd3JbD54NeP0-948p0xouHP1RZKL68nc2ZZU,11263
+cigvis/vispynodes/volume_slices.py,sha256=8JFeLwPr5FzmV7LL-jQH-4wqKqICM8NAGa1gzktZw0I,6186
 cigvis/vispynodes/well_log.py,sha256=nRKC737EVmpLPAO5jnHDuRd-wjw-9Zltln9JRHKaH2Y,8756
 cigvis/vispynodes/xyz_axis.py,sha256=2HHC6CIBwG6nFoJlfh8ARYkdnM_YVB3lFuIMJQnF4DU,6230
-cigvis-0.0.4.dist-info/LICENSE,sha256=8ot4Ai0hDKX4YrLbHPXKGruSb2SLwYsxEz9fccE32TM,1066
-cigvis-0.0.4.dist-info/METADATA,sha256=2ZUePkca_jg0K8_3HDuP-QujjbMMGC3zUcVQLmougYQ,7400
-cigvis-0.0.4.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-cigvis-0.0.4.dist-info/top_level.txt,sha256=V7LWoBmidxj1fP-ZK80CYWoQnyJm2p2eo54SapevIrA,7
-cigvis-0.0.4.dist-info/RECORD,,
+cigvis-0.0.5.dist-info/LICENSE,sha256=8ot4Ai0hDKX4YrLbHPXKGruSb2SLwYsxEz9fccE32TM,1066
+cigvis-0.0.5.dist-info/METADATA,sha256=SJEukqaGZ3zvKo2lbvBf5VOemvtZAwOiup-1cKtGX0E,7420
+cigvis-0.0.5.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+cigvis-0.0.5.dist-info/top_level.txt,sha256=V7LWoBmidxj1fP-ZK80CYWoQnyJm2p2eo54SapevIrA,7
+cigvis-0.0.5.dist-info/RECORD,,
```

