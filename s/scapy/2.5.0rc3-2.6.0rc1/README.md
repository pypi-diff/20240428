# Comparing `tmp/scapy-2.5.0rc3.tar.gz` & `tmp/scapy-2.6.0rc1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "scapy-2.5.0rc3.tar", last modified: Mon Dec 12 20:42:27 2022, max compression
+gzip compressed data, was "scapy-2.6.0rc1.tar", last modified: Mon Apr 29 18:53:09 2024, max compression
```

## Comparing `scapy-2.5.0rc3.tar` & `scapy-2.6.0rc1.tar`

### file list

```diff
@@ -1,387 +1,436 @@
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.686640 scapy-2.5.0rc3/
--rw-r--r--   0 root         (0) staff       (20)    18092 2018-01-10 10:39:24.000000 scapy-2.5.0rc3/LICENSE
--rw-r--r--   0 root         (0) staff       (20)       76 2021-09-26 17:21:11.000000 scapy-2.5.0rc3/MANIFEST.in
--rw-r--r--   0 root         (0) staff       (20)     6003 2022-12-12 20:42:27.687091 scapy-2.5.0rc3/PKG-INFO
--rw-r--r--   0 root         (0) staff       (20)     4649 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/README
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.259328 scapy-2.5.0rc3/doc/
--rw-r--r--   0 root         (0) staff       (20)     5270 2021-09-26 17:21:11.000000 scapy-2.5.0rc3/doc/scapy.1
--rwxr-xr-x   0 root         (0) staff       (20)      427 2021-09-26 17:21:11.000000 scapy-2.5.0rc3/run_scapy
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.299317 scapy-2.5.0rc3/scapy/
--rw-r--r--   0 root         (0) staff       (20)        8 2022-12-12 20:42:26.000000 scapy-2.5.0rc3/scapy/VERSION
--rw-r--r--   0 root         (0) staff       (20)     4031 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/__init__.py
--rw-r--r--   0 root         (0) staff       (20)      391 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/__main__.py
--rw-r--r--   0 root         (0) staff       (20)     1292 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/all.py
--rw-r--r--   0 root         (0) staff       (20)     8999 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/ansmachine.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.310928 scapy-2.5.0rc3/scapy/arch/
--rw-r--r--   0 root         (0) staff       (20)     4214 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.315672 scapy-2.5.0rc3/scapy/arch/bpf/
--rw-r--r--   0 root         (0) staff       (20)      207 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/arch/bpf/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     1424 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/arch/bpf/consts.py
--rw-r--r--   0 root         (0) staff       (20)     7488 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/bpf/core.py
--rw-r--r--   0 root         (0) staff       (20)    17696 2022-12-12 20:03:15.000000 scapy-2.5.0rc3/scapy/arch/bpf/supersocket.py
--rw-r--r--   0 root         (0) staff       (20)     3322 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/common.py
--rw-r--r--   0 root         (0) staff       (20)    20992 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/libpcap.py
--rw-r--r--   0 root         (0) staff       (20)    22903 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/linux.py
--rw-r--r--   0 root         (0) staff       (20)     1022 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/solaris.py
--rw-r--r--   0 root         (0) staff       (20)    13166 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/unix.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.320730 scapy-2.5.0rc3/scapy/arch/windows/
--rwxr-xr-x   0 root         (0) staff       (20)    35675 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/windows/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    10026 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/windows/native.py
--rw-r--r--   0 root         (0) staff       (20)    18062 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/arch/windows/structures.py
--rw-r--r--   0 root         (0) staff       (20)     4549 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/as_resolvers.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.325735 scapy-2.5.0rc3/scapy/asn1/
--rw-r--r--   0 root         (0) staff       (20)      213 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/asn1/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    22653 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/asn1/asn1.py
--rw-r--r--   0 root         (0) staff       (20)    21638 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/asn1/ber.py
--rw-r--r--   0 root         (0) staff       (20)    23384 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/asn1/mib.py
--rw-r--r--   0 root         (0) staff       (20)    31613 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/asn1fields.py
--rw-r--r--   0 root         (0) staff       (20)     1456 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/asn1packet.py
--rw-r--r--   0 root         (0) staff       (20)    50425 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/automaton.py
--rw-r--r--   0 root         (0) staff       (20)     8202 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/autorun.py
--rw-r--r--   0 root         (0) staff       (20)    16127 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/base_classes.py
--rw-r--r--   0 root         (0) staff       (20)    10713 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/compat.py
--rwxr-xr-x   0 root         (0) staff       (20)    31482 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/config.py
--rw-r--r--   0 root         (0) staff       (20)      810 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/consts.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.444658 scapy-2.5.0rc3/scapy/contrib/
--rw-r--r--   0 root         (0) staff       (20)      236 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     2686 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/altbeacon.py
--rw-r--r--   0 root         (0) staff       (20)     6197 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/aoe.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.460320 scapy-2.5.0rc3/scapy/contrib/automotive/
--rw-r--r--   0 root         (0) staff       (20)      390 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.469076 scapy-2.5.0rc3/scapy/contrib/automotive/bmw/
--rw-r--r--   0 root         (0) staff       (20)      284 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/bmw/__init__.py
--rw-r--r--   0 root         (0) staff       (20)   335186 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/bmw/definitions.py
--rw-r--r--   0 root         (0) staff       (20)     1169 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/bmw/enumerator.py
--rw-r--r--   0 root         (0) staff       (20)     5467 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/bmw/hsfz.py
--rw-r--r--   0 root         (0) staff       (20)    14346 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/ccp.py
--rw-r--r--   0 root         (0) staff       (20)    20447 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/doip.py
--rw-r--r--   0 root         (0) staff       (20)    26933 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/ecu.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.475219 scapy-2.5.0rc3/scapy/contrib/automotive/gm/
--rw-r--r--   0 root         (0) staff       (20)      283 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/gm/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    24773 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan.py
--rw-r--r--   0 root         (0) staff       (20)     1597 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan_ecu_states.py
--rw-r--r--   0 root         (0) staff       (20)     6664 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan_logging.py
--rw-r--r--   0 root         (0) staff       (20)    30321 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan_scanner.py
--rw-r--r--   0 root         (0) staff       (20)    12805 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlanutils.py
--rw-r--r--   0 root         (0) staff       (20)    28741 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/kwp.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.479243 scapy-2.5.0rc3/scapy/contrib/automotive/obd/
--rw-r--r--   0 root         (0) staff       (20)      340 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.480799 scapy-2.5.0rc3/scapy/contrib/automotive/obd/iid/
--rw-r--r--   0 root         (0) staff       (20)      340 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/iid/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     5160 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/iid/iids.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.482378 scapy-2.5.0rc3/scapy/contrib/automotive/obd/mid/
--rw-r--r--   0 root         (0) staff       (20)      340 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/mid/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    24775 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/mid/mids.py
--rw-r--r--   0 root         (0) staff       (20)     4051 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/obd.py
--rw-r--r--   0 root         (0) staff       (20)      361 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/packet.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.490229 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/
--rw-r--r--   0 root         (0) staff       (20)      340 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    18756 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids.py
--rw-r--r--   0 root         (0) staff       (20)     9343 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_00_1F.py
--rw-r--r--   0 root         (0) staff       (20)     5411 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_20_3F.py
--rw-r--r--   0 root         (0) staff       (20)     8258 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_40_5F.py
--rw-r--r--   0 root         (0) staff       (20)    19043 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_60_7F.py
--rw-r--r--   0 root         (0) staff       (20)     7346 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_80_9F.py
--rw-r--r--   0 root         (0) staff       (20)     2932 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_A0_C0.py
--rw-r--r--   0 root         (0) staff       (20)    10316 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/scanner.py
--rw-r--r--   0 root         (0) staff       (20)     3710 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/services.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.491699 scapy-2.5.0rc3/scapy/contrib/automotive/obd/tid/
--rw-r--r--   0 root         (0) staff       (20)      340 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/tid/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     4077 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/obd/tid/tids.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.501705 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/
--rw-r--r--   0 root         (0) staff       (20)      246 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     5516 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/configuration.py
--rw-r--r--   0 root         (0) staff       (20)    32986 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/enumerator.py
--rw-r--r--   0 root         (0) staff       (20)    16173 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/executor.py
--rw-r--r--   0 root         (0) staff       (20)     6139 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/graph.py
--rw-r--r--   0 root         (0) staff       (20)    10476 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/staged_test_case.py
--rw-r--r--   0 root         (0) staff       (20)     9672 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/scanner/test_case.py
--rw-r--r--   0 root         (0) staff       (20)    16476 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/someip.py
--rw-r--r--   0 root         (0) staff       (20)    52428 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/uds.py
--rw-r--r--   0 root         (0) staff       (20)     3078 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/automotive/uds_ecu_states.py
--rw-r--r--   0 root         (0) staff       (20)    10031 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/uds_logging.py
--rw-r--r--   0 root         (0) staff       (20)    49948 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/automotive/uds_scan.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.503678 scapy-2.5.0rc3/scapy/contrib/automotive/volkswagen/
--rw-r--r--   0 root         (0) staff       (20)      284 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/volkswagen/__init__.py
--rw-r--r--   0 root         (0) staff       (20)   272588 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/volkswagen/definitions.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.514060 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/
--rw-r--r--   0 root         (0) staff       (20)      294 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    14519 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/cto_commands_master.py
--rw-r--r--   0 root         (0) staff       (20)    16311 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/cto_commands_slave.py
--rw-r--r--   0 root         (0) staff       (20)     5848 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/scanner.py
--rw-r--r--   0 root         (0) staff       (20)     4094 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/utils.py
--rw-r--r--   0 root         (0) staff       (20)    18832 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/automotive/xcp/xcp.py
--rw-r--r--   0 root         (0) staff       (20)     2094 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/avs.py
--rw-r--r--   0 root         (0) staff       (20)     2132 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/bfd.py
--rw-r--r--   0 root         (0) staff       (20)    72773 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/bgp.py
--rw-r--r--   0 root         (0) staff       (20)     1806 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/bier.py
--rw-r--r--   0 root         (0) staff       (20)     3898 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/bp.py
--rw-r--r--   0 root         (0) staff       (20)     1409 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/cansocket.py
--rw-r--r--   0 root         (0) staff       (20)     5652 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/cansocket_native.py
--rw-r--r--   0 root         (0) staff       (20)    13031 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/cansocket_python_can.py
--rw-r--r--   0 root         (0) staff       (20)     2295 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/carp.py
--rw-r--r--   0 root         (0) staff       (20)    13494 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/cdp.py
--rw-r--r--   0 root         (0) staff       (20)     2145 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/chdlc.py
--rw-r--r--   0 root         (0) staff       (20)     6425 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/coap.py
--rw-r--r--   0 root         (0) staff       (20)    12325 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/concox.py
--rw-r--r--   0 root         (0) staff       (20)   184162 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/diameter.py
--rw-r--r--   0 root         (0) staff       (20)     3418 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/dtp.py
--rw-r--r--   0 root         (0) staff       (20)     6774 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/eddystone.py
--rw-r--r--   0 root         (0) staff       (20)    16356 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/eigrp.py
--rw-r--r--   0 root         (0) staff       (20)     7033 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/enipTCP.py
--rw-r--r--   0 root         (0) staff       (20)     2756 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/erspan.py
--rw-r--r--   0 root         (0) staff       (20)     1608 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/esmc.py
--rw-r--r--   0 root         (0) staff       (20)    20314 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ethercat.py
--rw-r--r--   0 root         (0) staff       (20)      562 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/etherip.py
--rw-r--r--   0 root         (0) staff       (20)     2311 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/exposure_notification.py
--rw-r--r--   0 root         (0) staff       (20)     3120 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/geneve.py
--rw-r--r--   0 root         (0) staff       (20)    42517 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/gtp.py
--rwxr-xr-x   0 root         (0) staff       (20)    62248 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/gtp_v2.py
--rw-r--r--   0 root         (0) staff       (20)     5355 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/gxrp.py
--rw-r--r--   0 root         (0) staff       (20)    75592 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/homeplugav.py
--rw-r--r--   0 root         (0) staff       (20)     9507 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/homepluggp.py
--rw-r--r--   0 root         (0) staff       (20)     1462 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/homeplugsg.py
--rw-r--r--   0 root         (0) staff       (20)   104162 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/http2.py
--rw-r--r--   0 root         (0) staff       (20)     3288 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ibeacon.py
--rw-r--r--   0 root         (0) staff       (20)     6612 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/icmp_extensions.py
--rw-r--r--   0 root         (0) staff       (20)     3163 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ife.py
--rw-r--r--   0 root         (0) staff       (20)     6276 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/igmp.py
--rw-r--r--   0 root         (0) staff       (20)     5993 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/igmpv3.py
--rw-r--r--   0 root         (0) staff       (20)    36525 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/ikev2.py
--rw-r--r--   0 root         (0) staff       (20)    36694 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/isis.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.521654 scapy-2.5.0rc3/scapy/contrib/isotp/
--rw-r--r--   0 root         (0) staff       (20)     1683 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/isotp/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    17052 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/isotp/isotp_native_socket.py
--rw-r--r--   0 root         (0) staff       (20)    10863 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/isotp/isotp_packet.py
--rw-r--r--   0 root         (0) staff       (20)    20441 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/isotp/isotp_scanner.py
--rw-r--r--   0 root         (0) staff       (20)    35531 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/isotp/isotp_soft_socket.py
--rw-r--r--   0 root         (0) staff       (20)    12146 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/isotp/isotp_utils.py
--rw-r--r--   0 root         (0) staff       (20)    19733 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/knx.py
--rw-r--r--   0 root         (0) staff       (20)     2543 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/lacp.py
--rw-r--r--   0 root         (0) staff       (20)    11839 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ldp.py
--rw-r--r--   0 root         (0) staff       (20)    25013 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/lldp.py
--rw-r--r--   0 root         (0) staff       (20)    27151 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/loraphy2wan.py
--rwxr-xr-x   0 root         (0) staff       (20)     7741 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ltp.py
--rw-r--r--   0 root         (0) staff       (20)     7318 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/mac_control.py
--rwxr-xr-x   0 root         (0) staff       (20)     9092 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/macsec.py
--rw-r--r--   0 root         (0) staff       (20)      955 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/metawatch.py
--rw-r--r--   0 root         (0) staff       (20)    34738 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/modbus.py
--rw-r--r--   0 root         (0) staff       (20)     2974 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/mount.py
--rw-r--r--   0 root         (0) staff       (20)     1958 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/mpls.py
--rw-r--r--   0 root         (0) staff       (20)     9588 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/mqtt.py
--rw-r--r--   0 root         (0) staff       (20)    12925 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/mqttsn.py
--rw-r--r--   0 root         (0) staff       (20)    30071 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/nfs.py
--rw-r--r--   0 root         (0) staff       (20)     7518 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/nlm.py
--rw-r--r--   0 root         (0) staff       (20)     3002 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/nsh.py
--rw-r--r--   0 root         (0) staff       (20)     6211 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/oncrpc.py
--rw-r--r--   0 root         (0) staff       (20)    34247 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/opc_da.py
--rwxr-xr-x   0 root         (0) staff       (20)    47683 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/openflow.py
--rwxr-xr-x   0 root         (0) staff       (20)   123502 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/openflow3.py
--rw-r--r--   0 root         (0) staff       (20)    30021 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ospf.py
--rw-r--r--   0 root         (0) staff       (20)    77929 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/pfcp.py
--rw-r--r--   0 root         (0) staff       (20)     7299 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/pim.py
--rw-r--r--   0 root         (0) staff       (20)    11911 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/pnio.py
--rw-r--r--   0 root         (0) staff       (20)    21592 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/pnio_dcp.py
--rw-r--r--   0 root         (0) staff       (20)    48926 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/pnio_rpc.py
--rw-r--r--   0 root         (0) staff       (20)     2128 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/portmap.py
--rw-r--r--   0 root         (0) staff       (20)    20478 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/postgres.py
--rw-r--r--   0 root         (0) staff       (20)     2338 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ppi_cace.py
--rw-r--r--   0 root         (0) staff       (20)    14309 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ppi_geotag.py
--rw-r--r--   0 root         (0) staff       (20)      984 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ripng.py
--rw-r--r--   0 root         (0) staff       (20)     7191 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/roce.py
--rw-r--r--   0 root         (0) staff       (20)    10723 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rpl.py
--rw-r--r--   0 root         (0) staff       (20)     6507 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rpl_metrics.py
--rw-r--r--   0 root         (0) staff       (20)     7036 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rsvp.py
--rw-r--r--   0 root         (0) staff       (20)     3388 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rtcp.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.524771 scapy-2.5.0rc3/scapy/contrib/rtps/
--rw-r--r--   0 root         (0) staff       (20)      480 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rtps/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     9178 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rtps/common_types.py
--rw-r--r--   0 root         (0) staff       (20)    17192 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rtps/pid_types.py
--rw-r--r--   0 root         (0) staff       (20)    18842 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rtps/rtps.py
--rwxr-xr-x   0 root         (0) staff       (20)    10616 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/rtr.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.526687 scapy-2.5.0rc3/scapy/contrib/scada/
--rw-r--r--   0 root         (0) staff       (20)      359 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/scada/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.531314 scapy-2.5.0rc3/scapy/contrib/scada/iec104/
--rw-r--r--   0 root         (0) staff       (20)    20835 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/scada/iec104/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     3586 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/scada/iec104/iec104_fields.py
--rw-r--r--   0 root         (0) staff       (20)    44325 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/scada/iec104/iec104_information_elements.py
--rw-r--r--   0 root         (0) staff       (20)    74341 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/scada/iec104/iec104_information_objects.py
--rwxr-xr-x   0 root         (0) staff       (20)     7463 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/scada/pcom.py
--rw-r--r--   0 root         (0) staff       (20)     2595 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/sdnv.py
--rw-r--r--   0 root         (0) staff       (20)     4780 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/sebek.py
--rw-r--r--   0 root         (0) staff       (20)     3443 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/send.py
--rw-r--r--   0 root         (0) staff       (20)    17732 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/skinny.py
--rw-r--r--   0 root         (0) staff       (20)      690 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/slowprot.py
--rw-r--r--   0 root         (0) staff       (20)     5380 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/socks.py
--rw-r--r--   0 root         (0) staff       (20)     1971 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/spbm.py
--rw-r--r--   0 root         (0) staff       (20)    12719 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/stamp.py
--rw-r--r--   0 root         (0) staff       (20)     6539 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/contrib/stun.py
--rwxr-xr-x   0 root         (0) staff       (20)    15006 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/tacacs.py
--rw-r--r--   0 root         (0) staff       (20)     7336 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/tcpao.py
--rw-r--r--   0 root         (0) staff       (20)    13968 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/tzsp.py
--rw-r--r--   0 root         (0) staff       (20)     3810 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/ubberlogger.py
--rw-r--r--   0 root         (0) staff       (20)     1928 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/vqp.py
--rw-r--r--   0 root         (0) staff       (20)     6070 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/vtp.py
--rw-r--r--   0 root         (0) staff       (20)     2502 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/wireguard.py
--rw-r--r--   0 root         (0) staff       (20)     1398 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/contrib/wpa_eapol.py
--rw-r--r--   0 root         (0) staff       (20)     3948 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/dadict.py
--rw-r--r--   0 root         (0) staff       (20)    16112 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/data.py
--rw-r--r--   0 root         (0) staff       (20)     3981 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/error.py
--rw-r--r--   0 root         (0) staff       (20)   126585 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/fields.py
--rw-r--r--   0 root         (0) staff       (20)    13361 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/interfaces.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.612431 scapy-2.5.0rc3/scapy/layers/
--rw-r--r--   0 root         (0) staff       (20)      189 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/__init__.py
--rw-r--r--   0 root         (0) staff       (20)      868 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/all.py
--rw-r--r--   0 root         (0) staff       (20)    53820 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/bluetooth.py
--rw-r--r--   0 root         (0) staff       (20)    17911 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/bluetooth4LE.py
--rw-r--r--   0 root         (0) staff       (20)    25643 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/can.py
--rw-r--r--   0 root         (0) staff       (20)     2026 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/clns.py
--rw-r--r--   0 root         (0) staff       (20)    57117 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/dcerpc.py
--rw-r--r--   0 root         (0) staff       (20)    22084 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/dhcp.py
--rw-r--r--   0 root         (0) staff       (20)    75301 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/dhcp6.py
--rw-r--r--   0 root         (0) staff       (20)    42873 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/dns.py
--rw-r--r--   0 root         (0) staff       (20)    59228 2022-12-12 20:03:15.000000 scapy-2.5.0rc3/scapy/layers/dot11.py
--rw-r--r--   0 root         (0) staff       (20)    21320 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/dot15d4.py
--rw-r--r--   0 root         (0) staff       (20)    22747 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/eap.py
--rw-r--r--   0 root         (0) staff       (20)      508 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/gprs.py
--rw-r--r--   0 root         (0) staff       (20)    13965 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/gssapi.py
--rw-r--r--   0 root         (0) staff       (20)     2398 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/hsrp.py
--rw-r--r--   0 root         (0) staff       (20)    24399 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/http.py
--rw-r--r--   0 root         (0) staff       (20)    76429 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/inet.py
--rw-r--r--   0 root         (0) staff       (20)   154797 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/inet6.py
--rw-r--r--   0 root         (0) staff       (20)    45635 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/ipsec.py
--rw-r--r--   0 root         (0) staff       (20)     1471 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/ir.py
--rw-r--r--   0 root         (0) staff       (20)    14478 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/isakmp.py
--rw-r--r--   0 root         (0) staff       (20)    50359 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/kerberos.py
--rw-r--r--   0 root         (0) staff       (20)    36196 2022-12-12 20:03:15.000000 scapy-2.5.0rc3/scapy/layers/l2.py
--rw-r--r--   0 root         (0) staff       (20)     1771 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/l2tp.py
--rw-r--r--   0 root         (0) staff       (20)    15728 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/ldap.py
--rw-r--r--   0 root         (0) staff       (20)     2965 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/llmnr.py
--rw-r--r--   0 root         (0) staff       (20)    26108 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/lltd.py
--rw-r--r--   0 root         (0) staff       (20)     1684 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/mgcp.py
--rw-r--r--   0 root         (0) staff       (20)     1676 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/mobileip.py
--rw-r--r--   0 root         (0) staff       (20)    23468 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/mspac.py
--rw-r--r--   0 root         (0) staff       (20)    12877 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/netbios.py
--rw-r--r--   0 root         (0) staff       (20)    60868 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/netflow.py
--rw-r--r--   0 root         (0) staff       (20)    42075 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/ntlm.py
--rw-r--r--   0 root         (0) staff       (20)    56130 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/ntp.py
--rw-r--r--   0 root         (0) staff       (20)     4745 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/pflog.py
--rw-r--r--   0 root         (0) staff       (20)     3018 2021-09-26 17:21:11.000000 scapy-2.5.0rc3/scapy/layers/ppi.py
--rw-r--r--   0 root         (0) staff       (20)    30349 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/ppp.py
--rw-r--r--   0 root         (0) staff       (20)    16353 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/pptp.py
--rw-r--r--   0 root         (0) staff       (20)    30326 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/radius.py
--rw-r--r--   0 root         (0) staff       (20)     2845 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/rip.py
--rw-r--r--   0 root         (0) staff       (20)     1868 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/rtp.py
--rw-r--r--   0 root         (0) staff       (20)    26096 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/sctp.py
--rw-r--r--   0 root         (0) staff       (20)    39077 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/sixlowpan.py
--rw-r--r--   0 root         (0) staff       (20)     5786 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/skinny.py
--rw-r--r--   0 root         (0) staff       (20)    24735 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/smb.py
--rw-r--r--   0 root         (0) staff       (20)    66200 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/smb2.py
--rw-r--r--   0 root         (0) staff       (20)    14854 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/smbclient.py
--rw-r--r--   0 root         (0) staff       (20)    20254 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/smbserver.py
--rw-r--r--   0 root         (0) staff       (20)     9476 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/snmp.py
--rw-r--r--   0 root         (0) staff       (20)    14941 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tftp.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.637054 scapy-2.5.0rc3/scapy/layers/tls/
--rw-r--r--   0 root         (0) staff       (20)     3532 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     1008 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/all.py
--rw-r--r--   0 root         (0) staff       (20)    10747 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/automaton.py
--rw-r--r--   0 root         (0) staff       (20)    52975 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/automaton_cli.py
--rw-r--r--   0 root         (0) staff       (20)    53219 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/automaton_srv.py
--rw-r--r--   0 root         (0) staff       (20)     8430 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/basefields.py
--rw-r--r--   0 root         (0) staff       (20)    37367 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/cert.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.652109 scapy-2.5.0rc3/scapy/layers/tls/crypto/
--rw-r--r--   0 root         (0) staff       (20)      254 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/__init__.py
--rw-r--r--   0 root         (0) staff       (20)      313 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/all.py
--rw-r--r--   0 root         (0) staff       (20)    16030 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/cipher_aead.py
--rw-r--r--   0 root         (0) staff       (20)     7624 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/cipher_block.py
--rw-r--r--   0 root         (0) staff       (20)     4433 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/cipher_stream.py
--rw-r--r--   0 root         (0) staff       (20)      652 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/ciphers.py
--rw-r--r--   0 root         (0) staff       (20)      247 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/common.py
--rw-r--r--   0 root         (0) staff       (20)     2164 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/compression.py
--rw-r--r--   0 root         (0) staff       (20)    35323 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/groups.py
--rw-r--r--   0 root         (0) staff       (20)     3024 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/h_mac.py
--rw-r--r--   0 root         (0) staff       (20)     1762 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/hash.py
--rw-r--r--   0 root         (0) staff       (20)     2133 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/hkdf.py
--rw-r--r--   0 root         (0) staff       (20)     6138 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/kx_algs.py
--rw-r--r--   0 root         (0) staff       (20)     2831 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/md4.py
--rw-r--r--   0 root         (0) staff       (20)     7690 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/pkcs1.py
--rw-r--r--   0 root         (0) staff       (20)    12932 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/prf.py
--rw-r--r--   0 root         (0) staff       (20)    30079 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/crypto/suites.py
--rw-r--r--   0 root         (0) staff       (20)    34113 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/extensions.py
--rw-r--r--   0 root         (0) staff       (20)    72258 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/handshake.py
--rw-r--r--   0 root         (0) staff       (20)    22437 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/handshake_sslv2.py
--rw-r--r--   0 root         (0) staff       (20)    36729 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/keyexchange.py
--rw-r--r--   0 root         (0) staff       (20)    11419 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/keyexchange_tls13.py
--rw-r--r--   0 root         (0) staff       (20)    34619 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/record.py
--rw-r--r--   0 root         (0) staff       (20)     9282 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/record_sslv2.py
--rw-r--r--   0 root         (0) staff       (20)     8700 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/record_tls13.py
--rw-r--r--   0 root         (0) staff       (20)    47280 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/session.py
--rw-r--r--   0 root         (0) staff       (20)     7179 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tls/tools.py
--rw-r--r--   0 root         (0) staff       (20)     8623 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/tuntap.py
--rw-r--r--   0 root         (0) staff       (20)     9858 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/usb.py
--rw-r--r--   0 root         (0) staff       (20)     3681 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/vrrp.py
--rw-r--r--   0 root         (0) staff       (20)     3319 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/vxlan.py
--rw-r--r--   0 root         (0) staff       (20)    49226 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/x509.py
--rw-r--r--   0 root         (0) staff       (20)    57437 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/layers/zigbee.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.660637 scapy-2.5.0rc3/scapy/libs/
--rw-r--r--   0 root         (0) staff       (20)      141 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     8445 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/ethertypes.py
--rw-r--r--   0 root         (0) staff       (20)     1210 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/matplot.py
--rw-r--r--   0 root         (0) staff       (20)    24437 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/rfc3961.py
--rw-r--r--   0 root         (0) staff       (20)    34624 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/six.py
--rw-r--r--   0 root         (0) staff       (20)      773 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/structures.py
--rw-r--r--   0 root         (0) staff       (20)     1187 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/libs/test_pyx.py
--rw-r--r--   0 root         (0) staff       (20)    34022 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/libs/winpcapy.py
--rw-r--r--   0 root         (0) staff       (20)    23806 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/main.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.666259 scapy-2.5.0rc3/scapy/modules/
--rw-r--r--   0 root         (0) staff       (20)      238 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.669673 scapy-2.5.0rc3/scapy/modules/krack/
--rw-r--r--   0 root         (0) staff       (20)     1385 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/krack/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    31073 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/krack/automaton.py
--rw-r--r--   0 root         (0) staff       (20)    13254 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/krack/crypto.py
--rw-r--r--   0 root         (0) staff       (20)     7700 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/modules/nmap.py
--rw-r--r--   0 root         (0) staff       (20)    32273 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/p0f.py
--rw-r--r--   0 root         (0) staff       (20)    21286 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/p0fv2.py
--rw-r--r--   0 root         (0) staff       (20)     4561 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/modules/voip.py
--rw-r--r--   0 root         (0) staff       (20)    91117 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/packet.py
--rw-r--r--   0 root         (0) staff       (20)    25204 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/pipetool.py
--rw-r--r--   0 root         (0) staff       (20)    30714 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/plist.py
--rw-r--r--   0 root         (0) staff       (20)     4606 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/pton_ntop.py
--rw-r--r--   0 root         (0) staff       (20)     7323 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/route.py
--rw-r--r--   0 root         (0) staff       (20)    13612 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/route6.py
--rw-r--r--   0 root         (0) staff       (20)    18797 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/scapypipes.py
--rw-r--r--   0 root         (0) staff       (20)    51136 2022-12-12 20:03:15.000000 scapy-2.5.0rc3/scapy/sendrecv.py
--rw-r--r--   0 root         (0) staff       (20)    13313 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/sessions.py
--rw-r--r--   0 root         (0) staff       (20)    18949 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/supersocket.py
--rw-r--r--   0 root         (0) staff       (20)    15304 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/themes.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.674553 scapy-2.5.0rc3/scapy/tools/
--rw-r--r--   0 root         (0) staff       (20)    40640 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/tools/UTscapy.py
--rw-r--r--   0 root         (0) staff       (20)      212 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.679712 scapy-2.5.0rc3/scapy/tools/automotive/
--rw-r--r--   0 root         (0) staff       (20)      213 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/automotive/__init__.py
--rwxr-xr-x   0 root         (0) staff       (20)     8331 2022-12-03 13:37:52.000000 scapy-2.5.0rc3/scapy/tools/automotive/isotpscanner.py
--rwxr-xr-x   0 root         (0) staff       (20)     8028 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/automotive/obdscanner.py
--rwxr-xr-x   0 root         (0) staff       (20)     4131 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/automotive/xcpscanner.py
--rwxr-xr-x   0 root         (0) staff       (20)     3110 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/check_asdis.py
--rw-r--r--   0 root         (0) staff       (20)     1777 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/generate_ethertypes.py
--rw-r--r--   0 root         (0) staff       (20)      469 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/tools/scapy_pyannotate.py
--rw-r--r--   0 root         (0) staff       (20)   104818 2022-12-12 20:03:15.000000 scapy-2.5.0rc3/scapy/utils.py
--rw-r--r--   0 root         (0) staff       (20)    29874 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/utils6.py
--rw-r--r--   0 root         (0) staff       (20)    45538 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/scapy/volatile.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.303806 scapy-2.5.0rc3/scapy.egg-info/
--rw-r--r--   0 root         (0) staff       (20)     6003 2022-12-12 20:42:26.000000 scapy-2.5.0rc3/scapy.egg-info/PKG-INFO
--rw-r--r--   0 root         (0) staff       (20)     9621 2022-12-12 20:42:27.000000 scapy-2.5.0rc3/scapy.egg-info/SOURCES.txt
--rw-r--r--   0 root         (0) staff       (20)        1 2022-12-12 20:42:26.000000 scapy-2.5.0rc3/scapy.egg-info/dependency_links.txt
--rw-r--r--   0 root         (0) staff       (20)       47 2022-12-12 20:42:26.000000 scapy-2.5.0rc3/scapy.egg-info/entry_points.txt
--rw-r--r--   0 root         (0) staff       (20)        1 2019-07-29 19:11:59.000000 scapy-2.5.0rc3/scapy.egg-info/not-zip-safe
--rw-r--r--   0 root         (0) staff       (20)      127 2022-12-12 20:42:26.000000 scapy-2.5.0rc3/scapy.egg-info/requires.txt
--rw-r--r--   0 root         (0) staff       (20)       11 2022-12-12 20:42:26.000000 scapy-2.5.0rc3/scapy.egg-info/top_level.txt
--rw-r--r--   0 root         (0) staff       (20)      360 2022-12-12 20:42:27.688590 scapy-2.5.0rc3/setup.cfg
--rwxr-xr-x   0 root         (0) staff       (20)     3473 2022-12-12 20:05:26.000000 scapy-2.5.0rc3/setup.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.681438 scapy-2.5.0rc3/test/
--rw-r--r--   0 root         (0) staff       (20)        0 2022-03-03 18:14:00.000000 scapy-2.5.0rc3/test/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     5126 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/test/testsocket.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-12-12 20:42:27.685590 scapy-2.5.0rc3/test/tls/
--rw-r--r--   0 root         (0) staff       (20)      228 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/test/tls/__init__.py
--rwxr-xr-x   0 root         (0) staff       (20)     3528 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/test/tls/example_client.py
--rwxr-xr-x   0 root         (0) staff       (20)     2585 2022-08-21 14:59:33.000000 scapy-2.5.0rc3/test/tls/example_server.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.239889 scapy-2.6.0rc1/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1786 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/.appveyor.yml
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.config/
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.config/appveyor/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2868 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/.config/appveyor/InstallNpcap.ps1
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1073 2023-04-05 19:21:57.000000 scapy-2.6.0rc1/.config/appveyor/InstallWindumpNpcap.ps1
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.config/ci/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1120 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/.config/ci/install.sh
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      963 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/.config/ci/openssl.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2993 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/.config/ci/test.sh
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      345 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/.config/codespell_ignore.txt
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.config/mypy/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      657 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/.config/mypy/mypy.ini
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3199 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/.config/mypy/mypy_check.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1683 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/.config/mypy/mypy_deployment_stats.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2704 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/.config/mypy/mypy_enabled.txt
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)       64 2023-04-05 19:21:57.000000 scapy-2.6.0rc1/.gitattributes
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.github/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)       44 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/.github/FUNDING.yml
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.github/ISSUE_TEMPLATE/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2751 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/.github/ISSUE_TEMPLATE/BUGS.yml
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      161 2024-02-04 18:45:17.000000 scapy-2.6.0rc1/.github/ISSUE_TEMPLATE/config.yml
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      958 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/.github/PULL_REQUEST_TEMPLATE.md
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      672 2023-04-05 19:21:57.000000 scapy-2.6.0rc1/.github/codecov.yml
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.189890 scapy-2.6.0rc1/.github/workflows/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4927 2024-04-29 18:13:33.000000 scapy-2.6.0rc1/.github/workflows/unittests.yml
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      189 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/.gitignore
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      573 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/.readthedocs.yml
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      414 2023-04-05 19:21:57.000000 scapy-2.6.0rc1/.travis.yml
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    18092 2023-04-05 19:21:57.000000 scapy-2.6.0rc1/LICENSE
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)       65 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/MANIFEST.in
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5507 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/PKG-INFO
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4804 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/README.md
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2392 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/pyproject.toml
+-rwxr-xr-x   0 gpotter   (1000) gpotter   (1000)      270 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/run_scapy
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      503 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/run_scapy.bat
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.239889 scapy-2.6.0rc1/scapy/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)        8 2024-04-29 18:53:09.239889 scapy-2.6.0rc1/scapy/VERSION
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4963 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      391 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/__main__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1292 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/all.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9406 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/scapy/ansmachine.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.199890 scapy-2.6.0rc1/scapy/arch/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4939 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/arch/__init__.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.199890 scapy-2.6.0rc1/scapy/arch/bpf/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      207 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/arch/bpf/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1723 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/arch/bpf/consts.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7993 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/arch/bpf/core.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    19275 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/scapy/arch/bpf/supersocket.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3635 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/arch/common.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    21268 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/scapy/arch/libpcap.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.199890 scapy-2.6.0rc1/scapy/arch/linux/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14034 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/arch/linux/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    27986 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/arch/linux/rtnetlink.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1022 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/arch/solaris.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    13527 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/arch/unix.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.199890 scapy-2.6.0rc1/scapy/arch/windows/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    36098 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/arch/windows/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    11273 2024-04-29 00:15:17.000000 scapy-2.6.0rc1/scapy/arch/windows/native.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    19803 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/arch/windows/structures.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4504 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/as_resolvers.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.199890 scapy-2.6.0rc1/scapy/asn1/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      213 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/asn1/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    23156 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/asn1/asn1.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    22096 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/asn1/ber.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    23375 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/asn1/mib.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    32379 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/asn1fields.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1435 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/asn1packet.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    57744 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/automaton.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8108 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/autorun.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    15955 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/base_classes.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4178 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/compat.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    38481 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/config.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      810 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/consts.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      300 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2721 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/altbeacon.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6197 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/contrib/aoe.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      390 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/contrib/automotive/__init__.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/autosar/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      291 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/autosar/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1384 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/autosar/pdu.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/bmw/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      284 2024-04-21 00:10:59.000000 scapy-2.6.0rc1/scapy/contrib/automotive/bmw/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   337068 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/automotive/bmw/definitions.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1177 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/bmw/enumerator.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6172 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/automotive/bmw/hsfz.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14346 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/ccp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    21508 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/automotive/doip.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    26835 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/automotive/ecu.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/gm/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      283 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/gm/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    24925 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1597 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan_ecu_states.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6689 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan_logging.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    30353 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan_scanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12833 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlanutils.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    29074 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/kwp.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/obd/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      340 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/__init__.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/obd/iid/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      340 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/iid/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5160 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/iid/iids.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/obd/mid/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      340 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/mid/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    24775 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/mid/mids.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4051 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/obd.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      361 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/packet.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.209890 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      340 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    18756 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9343 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_00_1F.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5411 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_20_3F.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8258 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_40_5F.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    19043 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_60_7F.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7346 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_80_9F.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2932 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_A0_C0.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10349 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/scanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3710 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/services.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/automotive/obd/tid/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      340 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/tid/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4077 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/obd/tid/tids.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      246 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6637 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/configuration.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    34411 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/enumerator.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    17159 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/executor.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6184 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/graph.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10508 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/staged_test_case.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9653 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/scanner/test_case.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    17431 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/automotive/someip.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    55064 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/automotive/uds.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3078 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/uds_ecu_states.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10039 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/uds_logging.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    50779 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/automotive/uds_scan.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/automotive/volkswagen/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      284 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/volkswagen/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   272648 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/volkswagen/definitions.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      294 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14519 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/cto_commands_master.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    16311 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/cto_commands_slave.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5881 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/scanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4094 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/utils.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    18832 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/automotive/xcp/xcp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2094 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/avs.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4241 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/bfd.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    73492 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/bgp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1806 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/bier.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3898 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/bp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1368 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/cansocket.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6347 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/cansocket_native.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12820 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/cansocket_python_can.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2295 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/carp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14514 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/cdp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2145 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/chdlc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6421 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/coap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12325 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/concox.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   184126 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/diameter.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3341 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/dtp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6735 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/eddystone.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    16317 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/eigrp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9131 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/enipTCP.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2960 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/erspan.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1608 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/esmc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    20226 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/ethercat.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      562 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/etherip.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2311 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/exposure_notification.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3236 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/geneve.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    42983 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/gtp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    62350 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/gtp_v2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5355 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/gxrp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9301 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/hicp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    75557 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/homeplugav.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9468 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/homepluggp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1423 2024-04-21 00:21:02.000000 scapy-2.6.0rc1/scapy/contrib/homeplugsg.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   103970 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/http2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3288 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/ibeacon.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      802 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/icmp_extensions.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3162 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/ife.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6238 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/igmp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5955 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/igmpv3.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    31401 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/ikev2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    36655 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/isis.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/isotp/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1798 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/isotp/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    17385 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/isotp/isotp_native_socket.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14854 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/isotp/isotp_packet.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    22526 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/isotp/isotp_scanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    36346 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/isotp/isotp_soft_socket.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12304 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/isotp/isotp_utils.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    19733 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/knx.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2543 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/lacp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    11894 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/ldp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    25013 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/lldp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    27242 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/loraphy2wan.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7705 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/ltp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7318 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/mac_control.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8952 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/macsec.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      955 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/metawatch.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    34756 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/modbus.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2974 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/mount.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2396 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/mpls.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10026 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/mqtt.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12925 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/mqttsn.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    30020 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/nfs.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7518 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/nlm.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4704 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/nrf_sniffer.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3008 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/nsh.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    19162 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/oam.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6211 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/oncrpc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    34247 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/opc_da.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    47608 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/openflow.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   123427 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/openflow3.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    30021 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/ospf.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    77929 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/pfcp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9125 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/pim.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    11875 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/pnio.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    21592 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/pnio_dcp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    48926 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/pnio_rpc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2128 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/portmap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    20479 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/postgres.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2338 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/ppi_cace.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14225 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/ppi_geotag.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      984 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/ripng.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7965 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/roce.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10723 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/rpl.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6507 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/rpl_metrics.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7036 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/rsvp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3628 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/rtcp.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/rtps/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      480 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/rtps/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9370 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/rtps/common_types.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    17192 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/rtps/pid_types.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    19145 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/rtps/rtps.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10616 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/rtr.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3896 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/rtsp.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/scada/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      359 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/scada/__init__.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.219889 scapy-2.6.0rc1/scapy/contrib/scada/iec104/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    20835 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/scada/iec104/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3586 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/scada/iec104/iec104_fields.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    44382 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/scada/iec104/iec104_information_elements.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    74341 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/scada/iec104/iec104_information_objects.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7464 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/scada/pcom.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2595 2024-04-21 00:11:00.000000 scapy-2.6.0rc1/scapy/contrib/sdnv.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4780 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/sebek.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3404 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/send.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    17693 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/skinny.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      690 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/slowprot.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5393 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/socks.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12573 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/stamp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6539 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/stun.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14981 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/contrib/tacacs.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7364 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/contrib/tcpao.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    32958 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/contrib/tcpros.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    13968 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/tzsp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1928 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/vqp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6070 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/vtp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2502 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/contrib/wireguard.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4196 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/dadict.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    18320 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/data.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3593 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/error.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   131566 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/fields.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14215 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/interfaces.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/layers/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      253 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      806 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/all.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    91067 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/bluetooth.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    24826 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/bluetooth4LE.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    26165 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/can.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2026 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/clns.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    95425 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/dcerpc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    22437 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/dhcp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    77623 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/dhcp6.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    59075 2024-04-29 18:21:28.000000 scapy-2.6.0rc1/scapy/layers/dns.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    68844 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/dot11.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    21320 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/dot15d4.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    25458 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/eap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      508 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/gprs.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14247 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/gssapi.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2458 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/hsrp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    24625 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/layers/http.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    85814 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/layers/inet.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   157471 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/inet6.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    48359 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/ipsec.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1471 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/ir.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    18507 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/isakmp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   131582 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/kerberos.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    40254 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/l2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1771 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/l2tp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    45087 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/ldap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2954 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/llmnr.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    26006 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/lltd.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1684 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/mgcp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1676 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/mobileip.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/layers/msrpce/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      682 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/msrpce/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    32195 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/all.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6991 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/ept.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    15015 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/msrpce/msdcom.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    15879 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/msrpce/msnrpc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    26003 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/mspac.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/layers/msrpce/raw/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      168 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3484 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/ept.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4035 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/ms_dcom.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2824 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/ms_nrpc.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3084 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/ms_samr.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5432 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/ms_srvs.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3987 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/msrpce/raw/ms_wkst.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    26363 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/msrpce/rpcclient.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    15721 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/msrpce/rpcserver.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    13972 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/netbios.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    68409 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/netflow.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    60525 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/layers/ntlm.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    56297 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/ntp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4745 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/pflog.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2450 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/ppi.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    30838 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/ppp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    16353 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/pptp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    30326 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/radius.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2845 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/rip.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1868 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/rtp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    32765 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/sctp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    39067 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/sixlowpan.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5786 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/skinny.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    35243 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/smb.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   130162 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/layers/smb2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    58609 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/smbclient.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    64116 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/layers/smbserver.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9732 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/snmp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    31966 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/spnego.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12421 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/ssh.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14902 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tftp.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/layers/tls/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3415 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1008 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/all.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    11085 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/automaton.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    52932 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/automaton_cli.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    53120 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/automaton_srv.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8412 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/basefields.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    38384 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/cert.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/layers/tls/crypto/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      254 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      313 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/all.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    15898 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/cipher_aead.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7969 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/cipher_block.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4333 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/cipher_stream.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      652 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/ciphers.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      247 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/common.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2078 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/compression.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    34564 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/groups.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3130 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/h_mac.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1714 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/hash.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2283 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/hkdf.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     6060 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/kx_algs.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2831 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/md4.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7350 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/pkcs1.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    12893 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/prf.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    29979 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/crypto/suites.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    34403 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/extensions.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    74228 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/handshake.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    22437 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/tls/handshake_sslv2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    36582 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/tls/keyexchange.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    11332 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/keyexchange_tls13.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    35104 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/tls/record.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     9286 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/tls/record_sslv2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8625 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/tls/record_tls13.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    51485 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/tls/session.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7140 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tls/tools.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8337 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/layers/tuntap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5297 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/layers/usb.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3681 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/vrrp.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3319 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/vxlan.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    43947 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/layers/x509.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    57437 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/layers/zigbee.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/libs/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      141 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/libs/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5167 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/libs/ethertypes.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7846 2024-04-28 22:37:30.000000 scapy-2.6.0rc1/scapy/libs/extcap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   910353 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/libs/manuf.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1210 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/libs/matplot.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    46713 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/libs/rfc3961.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      773 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/libs/structures.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1187 2024-04-29 00:12:29.000000 scapy-2.6.0rc1/scapy/libs/test_pyx.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    34022 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/libs/winpcapy.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    32330 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/main.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/modules/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      302 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/modules/__init__.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/modules/krack/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1384 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/modules/krack/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    31072 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/modules/krack/automaton.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    13211 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/modules/krack/crypto.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7668 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/modules/nmap.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    32122 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/modules/p0f.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    21168 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/modules/p0fv2.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    83535 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/modules/ticketer.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4522 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/modules/voip.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    95111 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/packet.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    25095 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/pipetool.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    29808 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/plist.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4694 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/pton_ntop.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7605 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/route.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    13665 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/route6.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    18813 2024-04-21 00:21:03.000000 scapy-2.6.0rc1/scapy/scapypipes.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    52861 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/sendrecv.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    14000 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/sessions.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    20506 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/supersocket.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    16138 2024-04-28 22:37:31.000000 scapy-2.6.0rc1/scapy/themes.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/tools/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    39784 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/tools/UTscapy.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      212 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/tools/__init__.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy/tools/automotive/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      213 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/tools/automotive/__init__.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     8282 2024-04-21 00:21:04.000000 scapy-2.6.0rc1/scapy/tools/automotive/isotpscanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     7950 2024-04-21 00:21:04.000000 scapy-2.6.0rc1/scapy/tools/automotive/obdscanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     4131 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/tools/automotive/xcpscanner.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     3072 2024-04-21 00:21:04.000000 scapy-2.6.0rc1/scapy/tools/check_asdis.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2212 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/tools/generate_ethertypes.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     1171 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/tools/generate_manuf.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      469 2024-04-21 00:11:01.000000 scapy-2.6.0rc1/scapy/tools/scapy_pyannotate.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)   127978 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/utils.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    29917 2024-04-29 18:13:40.000000 scapy-2.6.0rc1/scapy/utils6.py
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    42069 2024-04-29 00:15:18.000000 scapy-2.6.0rc1/scapy/volatile.py
+drwxr-xr-x   0 gpotter   (1000) gpotter   (1000)        0 2024-04-29 18:53:09.229889 scapy-2.6.0rc1/scapy.egg-info/
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     5507 2024-04-29 18:53:09.000000 scapy-2.6.0rc1/scapy.egg-info/PKG-INFO
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)    10777 2024-04-29 18:53:09.000000 scapy-2.6.0rc1/scapy.egg-info/SOURCES.txt
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)        1 2024-04-29 18:53:09.000000 scapy-2.6.0rc1/scapy.egg-info/dependency_links.txt
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)       46 2024-04-29 18:53:09.000000 scapy-2.6.0rc1/scapy.egg-info/entry_points.txt
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)        1 2023-03-26 21:19:44.000000 scapy-2.6.0rc1/scapy.egg-info/not-zip-safe
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)      119 2024-04-29 18:53:09.000000 scapy-2.6.0rc1/scapy.egg-info/requires.txt
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)        6 2024-04-29 18:53:09.000000 scapy-2.6.0rc1/scapy.egg-info/top_level.txt
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)       38 2024-04-29 18:53:09.239889 scapy-2.6.0rc1/setup.cfg
+-rw-r--r--   0 gpotter   (1000) gpotter   (1000)     2634 2024-04-21 00:21:04.000000 scapy-2.6.0rc1/setup.py
```

### Comparing `scapy-2.5.0rc3/LICENSE` & `scapy-2.6.0rc1/LICENSE`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/PKG-INFO` & `scapy-2.6.0rc1/PKG-INFO`

 * *Files 22% similar despite different names*

```diff
@@ -1,124 +1,129 @@
 Metadata-Version: 2.1
 Name: scapy
-Version: 2.5.0rc3
+Version: 2.6.0rc1
 Summary: Scapy: interactive packet manipulation tool
-Home-page: https://scapy.net
 Author: Philippe BIONDI
-Author-email: guillaume@valadon.net
-Maintainer: Pierre LALET, Gabriel POTTER, Guillaume VALADON
+Maintainer: Pierre LALET, Gabriel POTTER, Guillaume VALADON, Nils WEISS
 License: GPL-2.0-only
-Download-URL: https://github.com/secdev/scapy/tarball/master
-Project-URL: Documentation, https://scapy.readthedocs.io
-Project-URL: Source Code, https://github.com/secdev/scapy/
-Description: # <img src="https://github.com/secdev/scapy/raw/master/doc/scapy/graphics/scapy_logo.png" width="64" valign="middle" alt="Scapy" />&nbsp;&nbsp; Scapy
-        
-        [![PyPI Version](https://img.shields.io/pypi/v/scapy.svg)](https://pypi.python.org/pypi/scapy/)
-        [![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](LICENSE)
-        
-        Scapy is a powerful Python-based interactive packet manipulation program and
-        library.
-        
-        It is able to forge or decode packets of a wide number of protocols, send them
-        on the wire, capture them, store or read them using pcap files, match requests
-        and replies, and much more. It is designed to allow fast packet prototyping by
-        using default values that work.
-        
-        It can easily handle most classical tasks like scanning, tracerouting, probing,
-        unit tests, attacks or network discovery (it can replace `hping`, 85% of `nmap`,
-        `arpspoof`, `arp-sk`, `arping`, `tcpdump`, `wireshark`, `p0f`, etc.). It also
-        performs very well at a lot of other specific tasks that most other tools can't
-        handle, like sending invalid frames, injecting your own 802.11 frames, combining
-        techniques (VLAN hopping+ARP cache poisoning, VoIP decoding on WEP protected
-        channel, ...), etc.
-        
-        Scapy supports Python 2.7 and Python 3 (3.4 to 3.9). It's intended to
-        be cross platform, and runs on many different platforms (Linux, OSX,
-        \*BSD, and Windows).
-        
-        ## Getting started
-        
-        Scapy is usable either as a **shell** or as a **library**.
-        For further details, please head over to [Getting started with Scapy](https://scapy.readthedocs.io/en/latest/introduction.html), which is part of the documentation.
-        
-        ### Shell demo
-        
-        ![Scapy install demo](https://secdev.github.io/files/doc/animation-scapy-install.svg)
-        
-        Scapy can easily be used as an interactive shell to interact with the network.
-        The following example shows how to send an ICMP Echo Request message to
-        `github.com`, then display the reply source IP address:
-        
-        ```python
-        sudo ./run_scapy
-        Welcome to Scapy
-        >>> p = IP(dst="github.com")/ICMP()
-        >>> r = sr1(p)
-        Begin emission:
-        .Finished to send 1 packets.
-        *
-        Received 2 packets, got 1 answers, remaining 0 packets
-        >>> r[IP].src
-        '192.30.253.113'
-        ```
-        
-        ### Resources
-        
-        The [documentation](https://scapy.readthedocs.io/en/latest/) contains more
-        advanced use cases, and examples.
-        
-        Other useful resources:
-        
-        -   [Scapy in 20 minutes](https://github.com/secdev/scapy/blob/master/doc/notebooks/Scapy%20in%2015%20minutes.ipynb)
-        -   [Interactive tutorial](https://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial) (part of the documentation)
-        -   [The quick demo: an interactive session](https://scapy.readthedocs.io/en/latest/introduction.html#quick-demo)
-        (some examples may be outdated)
-        -   [HTTP/2 notebook](https://github.com/secdev/scapy/blob/master/doc/notebooks/HTTP_2_Tuto.ipynb)
-        -   [TLS notebooks](https://github.com/secdev/scapy/blob/master/doc/notebooks/tls)
-        
-        ## [Installation](https://scapy.readthedocs.io/en/latest/installation.html)
-        
-        Scapy works without any external Python modules on Linux and BSD like operating
-        systems. On Windows, you need to install some mandatory dependencies as
-        described in [the
-        documentation](http://scapy.readthedocs.io/en/latest/installation.html#windows).
-        
-        On most systems, using Scapy is as simple as running the following commands:
-        
-        ```bash
-        git clone https://github.com/secdev/scapy
-        cd scapy
-        ./run_scapy
-        ```
-        
-        To benefit from all Scapy features, such as plotting, you might want to install
-        Python modules, such as `matplotlib` or `cryptography`. See the
-        [documentation](http://scapy.readthedocs.io/en/latest/installation.html) and
-        follow the instructions to install them.
+Project-URL: homepage, https://scapy.net
+Project-URL: documentation, https://scapy.readthedocs.io
+Project-URL: repository, https://github.com/secdev/scapy
+Project-URL: changelog, https://github.com/secdev/scapy/releases
 Keywords: network
-Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Information Technology
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: System Administrators
 Classifier: Intended Audience :: Telecommunications Industry
 Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.4
-Classifier: Programming Language :: Python :: 3.5
-Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: Security
 Classifier: Topic :: System :: Networking
 Classifier: Topic :: System :: Networking :: Monitoring
-Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, <4
+Requires-Python: <4,>=3.7
 Description-Content-Type: text/markdown
-Provides-Extra: basic
-Provides-Extra: complete
-Provides-Extra: docs
+License-File: LICENSE
+Provides-Extra: cli
+Requires-Dist: ipython; extra == "cli"
+Provides-Extra: all
+Requires-Dist: ipython; extra == "all"
+Requires-Dist: pyx; extra == "all"
+Requires-Dist: cryptography>=2.0; extra == "all"
+Requires-Dist: matplotlib; extra == "all"
+Provides-Extra: doc
+Requires-Dist: sphinx>=7.0.0; extra == "doc"
+Requires-Dist: sphinx_rtd_theme>=1.3.0; extra == "doc"
+Requires-Dist: tox>=3.0.0; extra == "doc"
+
+# <img src="https://github.com/secdev/scapy/raw/master/doc/scapy/graphics/scapy_logo.png" width="64" valign="middle" alt="Scapy" />&nbsp;&nbsp; Scapy
+
+[![PyPI Version](https://img.shields.io/pypi/v/scapy.svg)](https://pypi.python.org/pypi/scapy/)
+[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](LICENSE)
+
+Scapy is a powerful Python-based interactive packet manipulation program and
+library.
+
+It is able to forge or decode packets of a wide number of protocols, send them
+on the wire, capture them, store or read them using pcap files, match requests
+and replies, and much more. It is designed to allow fast packet prototyping by
+using default values that work.
+
+It can easily handle most classical tasks like scanning, tracerouting, probing,
+unit tests, attacks or network discovery (it can replace `hping`, 85% of `nmap`,
+`arpspoof`, `arp-sk`, `arping`, `tcpdump`, `wireshark`, `p0f`, etc.). It also
+performs very well at a lot of other specific tasks that most other tools can't
+handle, like sending invalid frames, injecting your own 802.11 frames, combining
+techniques (VLAN hopping+ARP cache poisoning, VoIP decoding on WEP protected
+channel, ...), etc.
+
+Scapy supports Python 3.7+. It's intended to
+be cross platform, and runs on many different platforms (Linux, OSX,
+\*BSD, and Windows).
+
+## Getting started
+
+Scapy is usable either as a **shell** or as a **library**.
+For further details, please head over to [Getting started with Scapy](https://scapy.readthedocs.io/en/latest/introduction.html), which is part of the documentation.
+
+### Shell demo
+
+![Scapy install demo](https://secdev.github.io/files/doc/animation-scapy-install.svg)
+
+Scapy can easily be used as an interactive shell to interact with the network.
+The following example shows how to send an ICMP Echo Request message to
+`github.com`, then display the reply source IP address:
+
+```python
+sudo ./run_scapy
+Welcome to Scapy
+>>> p = IP(dst="github.com")/ICMP()
+>>> r = sr1(p)
+Begin emission:
+.Finished to send 1 packets.
+*
+Received 2 packets, got 1 answers, remaining 0 packets
+>>> r[IP].src
+'192.30.253.113'
+```
+
+### Resources
+
+The [documentation](https://scapy.readthedocs.io/en/latest/) contains more
+advanced use cases, and examples.
+
+Other useful resources:
+
+-   [Scapy in 20 minutes](https://github.com/secdev/scapy/blob/master/doc/notebooks/Scapy%20in%2015%20minutes.ipynb)
+-   [Interactive tutorial](https://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial) (part of the documentation)
+-   [The quick demo: an interactive session](https://scapy.readthedocs.io/en/latest/introduction.html#quick-demo) (some examples may be outdated)
+-   [HTTP/2 notebook](https://github.com/secdev/scapy/blob/master/doc/notebooks/HTTP_2_Tuto.ipynb)
+-   [TLS notebooks](https://github.com/secdev/scapy/blob/master/doc/notebooks/tls)
+
+## [Installation](https://scapy.readthedocs.io/en/latest/installation.html)
+
+Scapy works without any external Python modules on Linux and BSD like operating
+systems. On Windows, you need to install some mandatory dependencies as
+described in [the
+documentation](http://scapy.readthedocs.io/en/latest/installation.html#windows).
+
+On most systems, using Scapy is as simple as running the following commands:
+
+```bash
+git clone https://github.com/secdev/scapy
+cd scapy
+./run_scapy
+```
+
+To benefit from all Scapy features, such as plotting, you might want to install
+Python modules, such as `matplotlib` or `cryptography`. See the
+[documentation](http://scapy.readthedocs.io/en/latest/installation.html) and
+follow the instructions to install them.
```

### Comparing `scapy-2.5.0rc3/README` & `scapy-2.6.0rc1/README.md`

 * *Files 11% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 <!-- start_ppi_description -->
 
 # <img src="https://github.com/secdev/scapy/raw/master/doc/scapy/graphics/scapy_logo.png" width="64" valign="middle" alt="Scapy" />&nbsp;&nbsp; Scapy
 
-[![Scapy unit tests](https://github.com/secdev/scapy/workflows/Scapy%20unit%20tests/badge.svg?event=push)](https://github.com/secdev/scapy/actions?query=workflow%3A%22Scapy+unit+tests%22+branch%3Amaster+event%3Apush) <!-- ignore_ppi -->
+[![Scapy unit tests](https://github.com/secdev/scapy/actions/workflows/unittests.yml/badge.svg?branch=master&event=push)](https://github.com/secdev/scapy/actions/workflows/unittests.yml?query=event%3Apush) <!-- ignore_ppi -->
 [![AppVeyor Build status](https://ci.appveyor.com/api/projects/status/os03daotfja0wtp7/branch/master?svg=true)](https://ci.appveyor.com/project/secdev/scapy/branch/master) <!-- ignore_ppi -->
 [![Codecov Status](https://codecov.io/gh/secdev/scapy/branch/master/graph/badge.svg)](https://codecov.io/gh/secdev/scapy) <!-- ignore_ppi -->
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/30ee6772bb264a689a2604f5cdb0437b)](https://www.codacy.com/app/secdev/scapy) <!-- ignore_ppi -->
 [![PyPI Version](https://img.shields.io/pypi/v/scapy.svg)](https://pypi.python.org/pypi/scapy/)
 [![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](LICENSE)
 [![Join the chat at https://gitter.im/secdev/scapy](https://badges.gitter.im/secdev/scapy.svg)](https://gitter.im/secdev/scapy) <!-- ignore_ppi -->
 
@@ -22,15 +22,15 @@
 unit tests, attacks or network discovery (it can replace `hping`, 85% of `nmap`,
 `arpspoof`, `arp-sk`, `arping`, `tcpdump`, `wireshark`, `p0f`, etc.). It also
 performs very well at a lot of other specific tasks that most other tools can't
 handle, like sending invalid frames, injecting your own 802.11 frames, combining
 techniques (VLAN hopping+ARP cache poisoning, VoIP decoding on WEP protected
 channel, ...), etc.
 
-Scapy supports Python 2.7 and Python 3 (3.4 to 3.9). It's intended to
+Scapy supports Python 3.7+. It's intended to
 be cross platform, and runs on many different platforms (Linux, OSX,
 \*BSD, and Windows).
 
 ## Getting started
 
 Scapy is usable either as a **shell** or as a **library**.
 For further details, please head over to [Getting started with Scapy](https://scapy.readthedocs.io/en/latest/introduction.html), which is part of the documentation.
@@ -61,16 +61,15 @@
 The [documentation](https://scapy.readthedocs.io/en/latest/) contains more
 advanced use cases, and examples.
 
 Other useful resources:
 
 -   [Scapy in 20 minutes](https://github.com/secdev/scapy/blob/master/doc/notebooks/Scapy%20in%2015%20minutes.ipynb)
 -   [Interactive tutorial](https://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial) (part of the documentation)
--   [The quick demo: an interactive session](https://scapy.readthedocs.io/en/latest/introduction.html#quick-demo)
-(some examples may be outdated)
+-   [The quick demo: an interactive session](https://scapy.readthedocs.io/en/latest/introduction.html#quick-demo) (some examples may be outdated)
 -   [HTTP/2 notebook](https://github.com/secdev/scapy/blob/master/doc/notebooks/HTTP_2_Tuto.ipynb)
 -   [TLS notebooks](https://github.com/secdev/scapy/blob/master/doc/notebooks/tls)
 
 ## [Installation](https://scapy.readthedocs.io/en/latest/installation.html)
 
 Scapy works without any external Python modules on Linux and BSD like operating
 systems. On Windows, you need to install some mandatory dependencies as
@@ -88,11 +87,16 @@
 To benefit from all Scapy features, such as plotting, you might want to install
 Python modules, such as `matplotlib` or `cryptography`. See the
 [documentation](http://scapy.readthedocs.io/en/latest/installation.html) and
 follow the instructions to install them.
 
 <!-- stop_ppi_description -->
 
+## License
+
+Scapy's code, tests and tools are licensed under GPL v2.
+The documentation (everything unless marked otherwise in `doc/`, and except the logo) is licensed under CC BY-NC-SA 2.5.
+
 ## Contributing
 
 Want to contribute? Great! Please take a few minutes to
 [read this](CONTRIBUTING.md)!
```

### Comparing `scapy-2.5.0rc3/scapy/__init__.py` & `scapy-2.6.0rc1/scapy/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -6,18 +6,24 @@
 """
 Scapy: create, send, sniff, dissect and manipulate network packets.
 
 Usable either from an interactive console or as a Python library.
 https://scapy.net
 """
 
+import datetime
 import os
 import re
 import subprocess
 
+__all__ = [
+    "VERSION",
+    "__version__",
+]
+
 _SCAPY_PKG_DIR = os.path.dirname(__file__)
 
 
 def _parse_tag(tag):
     # type: (str) -> str
     """
     Parse a tag from ``git describe`` into a version.
@@ -27,16 +33,49 @@
         v2.3.2-346-g164a52c075c8 -> '2.3.2.dev346'
     """
     match = re.match('^v?(.+?)-(\\d+)-g[a-f0-9]+$', tag)
     if match:
         # remove the 'v' prefix and add a '.devN' suffix
         return '%s.dev%s' % (match.group(1), match.group(2))
     else:
-        # just remove the 'v' prefix
-        return re.sub('^v', '', tag)
+        raise ValueError('tag has invalid format')
+
+
+def _version_from_git_archive():
+    # type: () -> str
+    """
+    Rely on git archive "export-subst" git attribute.
+    See 'man gitattributes' for more details.
+    Note: describe is only supported with git >= 2.32.0,
+    and the `tags=true` option with git >= 2.35.0 but we
+    use it to workaround GH#3121.
+    """
+    git_archive_id = '$Format:%ct %(describe:tags=true)$'.split()
+    tstamp = git_archive_id[0]
+    if len(git_archive_id) > 1:
+        tag = git_archive_id[1]
+    else:
+        # project is run in CI and has another %(describe)
+        tag = ""
+
+    if "Format" in tstamp:
+        raise ValueError('not a git archive')
+
+    if "describe" in tag:
+        # git is too old!
+        tag = ""
+    if tag:
+        # archived revision is tagged, use the tag
+        return _parse_tag(tag)
+    elif tstamp:
+        # archived revision is not tagged, use the commit date
+        d = datetime.datetime.utcfromtimestamp(int(tstamp))
+        return d.strftime('%Y.%m.%d')
+
+    raise ValueError("invalid git archive format")
 
 
 def _version_from_git_describe():
     # type: () -> str
     """
     Read the version from ``git describe``. It returns the latest tag with an
     optional suffix if the current directory is not exactly on the tag.
@@ -73,65 +112,70 @@
         )
         out, err = process.communicate()
         if process.returncode == 0:
             return out.decode().strip()
         else:
             raise subprocess.CalledProcessError(process.returncode, err)
 
-    tag = _git("git describe --always")
+    tag = _git("git describe --tags --always --long")
     if not tag.startswith("v"):
         # Upstream was not fetched
         commit = _git("git rev-list --tags --max-count=1")
         tag = _git("git describe --tags --always --long %s" % commit)
     return _parse_tag(tag)
 
 
 def _version():
     # type: () -> str
     """Returns the Scapy version from multiple methods
 
     :return: the Scapy version
     """
-    # Rely on git archive "export-subst" git attribute.
-    # See 'man gitattributes' for more details.
-    # Note: describe is only supported with git >= 2.32.0
-    # but we use it to workaround GH#3121
-    git_archive_id = '$Format:%h %(describe)$'.strip().split()
-    sha1 = git_archive_id[0]
-    tag = git_archive_id[1]
-    if "Format" not in sha1:
-        # We are in a git archive
-        if "describe" in tag:
-            # git is too old!
-            tag = ""
-        if tag:
-            return _parse_tag(tag)
-        elif sha1:
-            return "git-archive." + sha1
-        return 'unknown.version'
-    # Fallback to calling git
+    # Method 0: from external packaging
+    try:
+        # possibly forced by external packaging
+        return os.environ['SCAPY_VERSION']
+    except KeyError:
+        pass
+
+    # Method 1: from the VERSION file, included in sdist and wheels
     version_file = os.path.join(_SCAPY_PKG_DIR, 'VERSION')
     try:
-        tag = _version_from_git_describe()
-        # successfully read the tag from git, write it in VERSION for
-        # installation and/or archive generation.
-        with open(version_file, 'w') as fdesc:
-            fdesc.write(tag)
+        # file generated when running sdist
+        with open(version_file, 'r') as fdsec:
+            tag = fdsec.read()
         return tag
+    except FileNotFoundError:
+        pass
+
+    # Method 2: from the archive tag, exported when using git archives
+    try:
+        return _version_from_git_archive()
+    except ValueError:
+        pass
+
+    # Method 3: from git itself, used when Scapy was cloned
+    try:
+        return _version_from_git_describe()
     except Exception:
-        # failed to read the tag from git, try to read it from a VERSION file
-        try:
-            with open(version_file, 'r') as fdsec:
-                tag = fdsec.read()
-            return tag
-        except Exception:
-            return 'unknown.version'
+        pass
+
+    # Fallback
+    try:
+        # last resort, use the modification date of __init__.py
+        d = datetime.datetime.utcfromtimestamp(os.path.getmtime(__file__))
+        return d.strftime('%Y.%m.%d')
+    except Exception:
+        pass
+
+    # all hope is lost
+    return '0.0.0'
 
 
 VERSION = __version__ = _version()
 
-_tmp = re.search(r"[0-9.]+", VERSION)
+_tmp = re.search(r"([0-9]|\.[0-9])+", VERSION)
 VERSION_MAIN = _tmp.group() if _tmp is not None else VERSION
 
 if __name__ == "__main__":
     from scapy.main import interact
     interact()
```

### Comparing `scapy-2.5.0rc3/scapy/all.py` & `scapy-2.6.0rc1/scapy/all.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/ansmachine.py` & `scapy-2.6.0rc1/scapy/ansmachine.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,43 +7,42 @@
 Answering machines.
 """
 
 ########################
 #  Answering machines  #
 ########################
 
+import abc
 import functools
+import threading
 import socket
 import warnings
 
 from scapy.arch import get_if_addr
 from scapy.config import conf
-from scapy.sendrecv import send, sniff, AsyncSniffer
+from scapy.sendrecv import sendp, sniff, AsyncSniffer
 from scapy.packet import Packet
 from scapy.plist import PacketList
 
-import scapy.libs.six as six
-
-from scapy.compat import (
+from typing import (
     Any,
     Callable,
     Dict,
     Generic,
     Optional,
     Tuple,
     Type,
     TypeVar,
-    _Generic_metaclass,
     cast,
 )
 
 _T = TypeVar("_T", Packet, PacketList)
 
 
-class ReferenceAM(_Generic_metaclass):
+class ReferenceAM(type):
     def __new__(cls,
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
         # type: (...) -> Type['AnsweringMachine[_T]']
         obj = cast('Type[AnsweringMachine[_T]]',
@@ -64,24 +63,23 @@
                 func.__signature__ = obj.__signature__  # type: ignore
             except (AttributeError):
                 pass
             globals()[obj.function_name] = func
         return obj
 
 
-@six.add_metaclass(ReferenceAM)
-class AnsweringMachine(Generic[_T]):
+class AnsweringMachine(Generic[_T], metaclass=ReferenceAM):
     function_name = ""
     filter = None  # type: Optional[str]
     sniff_options = {"store": 0}  # type: Dict[str, Any]
     sniff_options_list = ["store", "iface", "count", "promisc", "filter",
                           "type", "prn", "stop_filter", "opened_socket"]
     send_options = {"verbose": 0}  # type: Dict[str, Any]
     send_options_list = ["iface", "inter", "loop", "verbose", "socket"]
-    send_function = staticmethod(send)
+    send_function = staticmethod(sendp)
 
     def __init__(self, **kargs):
         # type: (Any) -> None
         self.mode = 0
         self.verbose = kargs.get("verbose", conf.verb >= 0)
         if self.filter:
             kargs.setdefault("filter", self.filter)
@@ -141,17 +139,18 @@
             self.__dict__["mode"] = omode
         return sendopt, sniffopt
 
     def is_request(self, req):
         # type: (Packet) -> int
         return 1
 
+    @abc.abstractmethod
     def make_reply(self, req):
         # type: (Packet) -> _T
-        return req
+        pass
 
     def send_reply(self, reply, send_function=None):
         # type: (_T, Optional[Callable[..., None]]) -> None
         if send_function:
             send_function(reply)
         else:
             self.send_function(reply, **self.optsend)
@@ -223,29 +222,35 @@
         self.sniffer = AsyncSniffer(**self.optsniff)
         self.sniffer.start()
 
 
 class AnsweringMachineTCP(AnsweringMachine[Packet]):
     """
     An answering machine that use the classic socket.socket to
-    answer multiple clients
+    answer multiple TCP clients
     """
+    TYPE = socket.SOCK_STREAM
+
     def parse_options(self, port=80, cls=conf.raw_layer):
         # type: (int, Type[Packet]) -> None
         self.port = port
-        self.cls = conf.raw_layer
+        self.cls = cls
 
     def close(self):
         # type: () -> None
         pass
 
     def sniff(self):
         # type: () -> None
         from scapy.supersocket import StreamSocket
-        ssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        ssock = socket.socket(socket.AF_INET, self.TYPE)
+        try:
+            ssock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        except OSError:
+            pass
         ssock.bind(
             (get_if_addr(self.optsniff.get("iface", conf.iface)), self.port))
         ssock.listen()
         sniffers = []
         try:
             while True:
                 clientsocket, address = ssock.accept()
@@ -265,10 +270,23 @@
                     sniffer.stop()
                 except Exception:
                     pass
                 sock.close()
             self.close()
             ssock.close()
 
+    def sniff_bg(self):
+        # type: () -> None
+        self.sniffer = threading.Thread(target=self.sniff)  # type: ignore
+        self.sniffer.start()
+
     def make_reply(self, req, address=None):
         # type: (Packet, Optional[Any]) -> Packet
-        return super(AnsweringMachineTCP, self).make_reply(req)
+        return req
+
+
+class AnsweringMachineUDP(AnsweringMachineTCP):
+    """
+    An answering machine that use the classic socket.socket to
+    answer multiple UDP clients
+    """
+    TYPE = socket.SOCK_DGRAM
```

### Comparing `scapy-2.5.0rc3/scapy/arch/__init__.py` & `scapy-2.6.0rc1/scapy/arch/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -17,39 +17,49 @@
     ARPHDR_ETHER,
     ARPHDR_LOOPBACK,
     ARPHDR_PPP,
     ARPHDR_TUN,
     IPV6_ADDR_GLOBAL
 )
 from scapy.error import log_loading, Scapy_Exception
-from scapy.interfaces import NetworkInterface, network_name
+from scapy.interfaces import _GlobInterfaceType, network_name
 from scapy.pton_ntop import inet_pton, inet_ntop
 
+from scapy.libs.extcap import load_extcap
+
 # Typing imports
-from scapy.compat import (
+from typing import (
+    List,
     Optional,
+    Tuple,
     Union,
+    TYPE_CHECKING,
 )
 
+if TYPE_CHECKING:
+    from scapy.interfaces import NetworkInterface
+
 # Note: the typing of this file is heavily ignored because MyPy doesn't allow
 # to import the same function from different files.
 
 # This list only includes imports that are common across all platforms.
 __all__ = [  # noqa: F405
     "get_if_addr",
     "get_if_addr6",
     "get_if_hwaddr",
     "get_if_list",
     "get_if_raw_addr",
     "get_if_raw_addr6",
     "get_if_raw_hwaddr",
     "get_working_if",
     "in6_getifaddr",
+    "read_nameservers",
     "read_routes",
     "read_routes6",
+    "load_extcap",
     "SIOCGIFHWADDR",
 ]
 
 # BACKWARD COMPATIBILITY
 from scapy.interfaces import (
     get_if_list,
     get_working_if,
@@ -62,48 +72,48 @@
 def str2mac(s):
     # Duplicated from scapy/utils.py for import reasons
     # type: (bytes) -> str
     return ("%02x:" * 6)[:-1] % tuple(orb(x) for x in s)
 
 
 def get_if_addr(iff):
-    # type: (str) -> str
+    # type: (_GlobInterfaceType) -> str
     """
     Returns the IPv4 of an interface or "0.0.0.0" if not available
     """
     return inet_ntop(socket.AF_INET, get_if_raw_addr(iff))  # noqa: F405
 
 
 def get_if_hwaddr(iff):
-    # type: (Union[NetworkInterface, str]) -> str
+    # type: (_GlobInterfaceType) -> str
     """
     Returns the MAC (hardware) address of an interface
     """
     from scapy.arch import get_if_raw_hwaddr
     addrfamily, mac = get_if_raw_hwaddr(iff)  # noqa: F405
     if addrfamily in [ARPHDR_ETHER, ARPHDR_LOOPBACK, ARPHDR_PPP, ARPHDR_TUN]:
         return str2mac(mac)
     else:
         raise Scapy_Exception("Unsupported address family (%i) for interface [%s]" % (addrfamily, iff))  # noqa: E501
 
 
 def get_if_addr6(niff):
-    # type: (NetworkInterface) -> Optional[str]
+    # type: (_GlobInterfaceType) -> Optional[str]
     """
     Returns the main global unicast address associated with provided
     interface, in human readable form. If no global address is found,
     None is returned.
     """
     iff = network_name(niff)
     return next((x[0] for x in in6_getifaddr()
                  if x[2] == iff and x[1] == IPV6_ADDR_GLOBAL), None)
 
 
 def get_if_raw_addr6(iff):
-    # type: (NetworkInterface) -> Optional[bytes]
+    # type: (_GlobInterfaceType) -> Optional[bytes]
     """
     Returns the main global unicast address associated with provided
     interface, in network format. If no global address is found, None
     is returned.
     """
     ip6 = get_if_addr6(iff)
     if ip6 is not None:
@@ -111,26 +121,31 @@
 
     return None
 
 
 # Next step is to import following architecture specific functions:
 # def attach_filter(s, filter, iface)
 # def get_if(iff,cmd)
-# def get_if_index(iff)
 # def get_if_raw_addr(iff)
 # def get_if_raw_hwaddr(iff)
 # def in6_getifaddr()
+# def read_nameservers()
 # def read_routes()
 # def read_routes6()
 # def set_promisc(s,iff,val=1)
 
 if LINUX:
     from scapy.arch.linux import *  # noqa F403
 elif BSD:
-    from scapy.arch.unix import read_routes, read_routes6, in6_getifaddr  # noqa: E501
+    from scapy.arch.unix import (  # noqa F403
+        read_nameservers,
+        read_routes,
+        read_routes6,
+        in6_getifaddr,
+    )
     from scapy.arch.bpf.core import *  # noqa F403
     if not conf.use_pcap:
         # Native
         from scapy.arch.bpf.supersocket import *  # noqa F403
         conf.use_bpf = True
     SIOCGIFHWADDR = 0  # mypy compat
 elif SOLARIS:
@@ -141,11 +156,30 @@
     SIOCGIFHWADDR = 0  # mypy compat
 else:
     log_loading.critical(
         "Scapy currently does not support %s! I/O will NOT work!" % sys.platform
     )
     SIOCGIFHWADDR = 0  # mypy compat
 
+    # DUMMYS
+    def get_if_raw_addr(iff: Union['NetworkInterface', str]) -> bytes:
+        return b"\0\0\0\0"
+
+    def get_if_raw_hwaddr(iff: Union['NetworkInterface', str]) -> Tuple[int, bytes]:
+        return -1, b""
+
+    def in6_getifaddr() -> List[Tuple[str, int, str]]:
+        return []
+
+    def read_nameservers() -> List[str]:
+        return []
+
+    def read_routes() -> List[str]:
+        return []
+
+    def read_routes6() -> List[str]:
+        return []
+
 if LINUX or BSD:
     conf.load_layers.append("tuntap")
 
 _set_conf_sockets()  # Apply config
```

### Comparing `scapy-2.5.0rc3/scapy/arch/bpf/consts.py` & `scapy-2.6.0rc1/scapy/arch/bpf/consts.py`

 * *Files 27% similar despite different names*

```diff
@@ -8,38 +8,45 @@
 """
 
 import ctypes
 
 from scapy.libs.structures import bpf_program
 from scapy.data import MTU
 
+# Type hints
+from typing import (
+    Any,
+    Callable,
+)
+
 SIOCGIFFLAGS = 0xc0206911
 BPF_BUFFER_LENGTH = MTU
 
 # From sys/ioccom.h
 
 IOCPARM_MASK = 0x1fff
 IOC_VOID = 0x20000000
 IOC_OUT = 0x40000000
 IOC_IN = 0x80000000
 IOC_INOUT = IOC_IN | IOC_OUT
 
-_th = lambda x: x if isinstance(x, int) else ctypes.sizeof(x)
+_th = lambda x: x if isinstance(x, int) else ctypes.sizeof(x)  # type: Callable[[Any], int]  # noqa: E501
 
 
 def _IOC(inout, group, num, len):
+    # type: (int, str, int, Any) -> int
     return (inout |
             ((_th(len) & IOCPARM_MASK) << 16) |
             (ord(group) << 8) | (num))
 
 
-_IO = lambda g, n: _IOC(IOC_VOID, g, n, 0)
-_IOR = lambda g, n, t: _IOC(IOC_OUT, g, n, t)
-_IOW = lambda g, n, t: _IOC(IOC_IN, g, n, t)
-_IOWR = lambda g, n, t: _IOC(IOC_INOUT, g, n, t)
+_IO = lambda g, n: _IOC(IOC_VOID, g, n, 0)  # type: Callable[[str, int], int]
+_IOR = lambda g, n, t: _IOC(IOC_OUT, g, n, t)  # type: Callable[[str, int, Any], int]
+_IOW = lambda g, n, t: _IOC(IOC_IN, g, n, t)  # type: Callable[[str, int, Any], int]
+_IOWR = lambda g, n, t: _IOC(IOC_INOUT, g, n, t)  # type: Callable[[str, int, Any], int]
 
 # Length of some structures
 _bpf_stat = 8
 _ifreq = 32
 
 # From net/bpf.h
 BIOCGBLEN = _IOR('B', 102, ctypes.c_uint)
```

### Comparing `scapy-2.5.0rc3/scapy/arch/bpf/core.py` & `scapy-2.6.0rc1/scapy/arch/bpf/core.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Guillaume Valadon <guillaume@valadon.net>
 
 """
 Scapy *BSD native support - core
 """
 
-from __future__ import absolute_import
 
 from ctypes import cdll, cast, pointer
 from ctypes import c_int, c_ulong, c_uint, c_char_p, Structure, POINTER
 from ctypes.util import find_library
 import fcntl
 import os
 import re
@@ -24,18 +23,30 @@
 from scapy.arch.common import compile_filter, _iff_flags
 from scapy.arch.unix import get_if, in6_getifaddr
 from scapy.compat import plain_str
 from scapy.config import conf
 from scapy.consts import LINUX
 from scapy.data import ARPHDR_LOOPBACK, ARPHDR_ETHER
 from scapy.error import Scapy_Exception, warning
-from scapy.interfaces import InterfaceProvider, IFACES, NetworkInterface, \
-    network_name
+from scapy.interfaces import (
+    InterfaceProvider,
+    NetworkInterface,
+    network_name,
+    _GlobInterfaceType,
+)
 from scapy.pton_ntop import inet_ntop
 
+# Typing
+from typing import (
+    Dict,
+    List,
+    Optional,
+    Tuple,
+)
+
 if LINUX:
     raise OSError("BPF conflicts with Linux")
 
 
 # ctypes definitions
 
 LIBC = cdll.LoadLibrary(find_library("c"))
@@ -61,15 +72,18 @@
 LIBC.if_freenameindex.argtypes = [_ptr_ifnameindex_table]
 LIBC.if_freenameindex.restype = None
 
 # Addresses manipulation functions
 
 
 def get_if_raw_addr(ifname):
-    """Returns the IPv4 address configured on 'ifname', packed with inet_pton."""  # noqa: E501
+    # type: (_GlobInterfaceType) -> bytes
+    """
+    Returns the IPv4 address configured on 'ifname', packed with inet_pton.
+    """
 
     ifname = network_name(ifname)
 
     # Get ifconfig output
     subproc = subprocess.Popen(
         [conf.prog.ifconfig, ifname],
         close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
@@ -93,14 +107,15 @@
     address = addresses[0].split(' ')[1]
     if '/' in address:  # NetBSD 8.0
         address = address.split("/")[0]
     return socket.inet_pton(socket.AF_INET, address)
 
 
 def get_if_raw_hwaddr(ifname):
+    # type: (_GlobInterfaceType) -> Tuple[int, bytes]
     """Returns the packed MAC address configured on 'ifname'."""
 
     NULL_MAC_ADDRESS = b'\x00' * 6
 
     ifname = network_name(ifname)
     # Handle the loopback interface separately
     if ifname == conf.loopback_name:
@@ -122,27 +137,27 @@
             "ether" in line or "lladdr" in line or "address" in line
         )
     ]
     if not addresses:
         raise Scapy_Exception("No MAC address found on %s !" % ifname)
 
     # Pack and return the MAC address
-    mac = addresses[0].split(' ')[1]
-    mac = [chr(int(b, 16)) for b in mac.split(':')]
+    mac = [int(b, 16) for b in addresses[0].split(' ')[1].split(':')]
 
     # Check that the address length is correct
     if len(mac) != 6:
         raise Scapy_Exception("No MAC address found on %s !" % ifname)
 
-    return (ARPHDR_ETHER, ''.join(mac))
+    return (ARPHDR_ETHER, struct.pack("!BBBBBB", *mac))
 
 
 # BPF specific functions
 
 def get_dev_bpf():
+    # type: () -> Tuple[int, int]
     """Returns an opened BPF file object"""
 
     # Get the first available BPF handle
     for bpf in range(256):
         try:
             fd = os.open("/dev/bpf%i" % bpf, os.O_RDWR)
             return (fd, bpf)
@@ -154,25 +169,27 @@
                 ) % bpf)
             continue
 
     raise Scapy_Exception("No /dev/bpf handle is available !")
 
 
 def attach_filter(fd, bpf_filter, iface):
+    # type: (int, str, _GlobInterfaceType) -> None
     """Attach a BPF filter to the BPF file descriptor"""
     bp = compile_filter(bpf_filter, iface)
     # Assign the BPF program to the interface
     ret = LIBC.ioctl(c_int(fd), BIOCSETF, cast(pointer(bp), c_char_p))
     if ret < 0:
         raise Scapy_Exception("Can't attach the BPF filter !")
 
 
 # Interface manipulation functions
 
 def _get_ifindex_list():
+    # type: () -> List[Tuple[str, int]]
     """
     Returns a list containing (iface, index)
     """
     ptr = LIBC.if_nameindex()
     ifaces = []
     for i in range(255):
         iface = ptr.contents[i]
@@ -183,14 +200,15 @@
     return ifaces
 
 
 _IFNUM = re.compile(r"([0-9]*)([ab]?)$")
 
 
 def _get_if_flags(ifname):
+    # type: (_GlobInterfaceType) -> Optional[int]
     """Internal function to get interface flags"""
     # Get interface flags
     try:
         result = get_if(ifname, SIOCGIFFLAGS)
     except IOError:
         warning("ioctl(SIOCGIFFLAGS) failed on %s !", ifname)
         return None
@@ -200,14 +218,15 @@
     return ifflags
 
 
 class BPFInterfaceProvider(InterfaceProvider):
     name = "BPF"
 
     def _is_valid(self, dev):
+        # type: (NetworkInterface) -> bool
         if not dev.flags & 0x1:  # not IFF_UP
             return False
         # Get a BPF handle
         try:
             fd = get_dev_bpf()[0]
         except Scapy_Exception:
             return True  # Can't check if available (non sudo?)
@@ -222,33 +241,36 @@
         else:
             return True
         finally:
             # Close the file descriptor
             os.close(fd)
 
     def load(self):
+        # type: () -> Dict[str, NetworkInterface]
         from scapy.fields import FlagValue
         data = {}
         ips = in6_getifaddr()
         for ifname, index in _get_ifindex_list():
             try:
-                ifflags = _get_if_flags(ifname)
+                ifflags_int = _get_if_flags(ifname)
+                if ifflags_int is None:
+                    continue
                 mac = scapy.utils.str2mac(get_if_raw_hwaddr(ifname)[1])
                 ip = inet_ntop(socket.AF_INET, get_if_raw_addr(ifname))
             except Scapy_Exception:
                 continue
-            ifflags = FlagValue(ifflags, _iff_flags)
+            ifflags = FlagValue(ifflags_int, _iff_flags)
             if_data = {
                 "name": ifname,
                 "network_name": ifname,
                 "description": ifname,
                 "flags": ifflags,
                 "index": index,
                 "ip": ip,
                 "ips": [x[0] for x in ips if x[2] == ifname] + [ip],
                 "mac": mac
             }
             data[ifname] = NetworkInterface(self, if_data)
         return data
 
 
-IFACES.register_provider(BPFInterfaceProvider)
+conf.ifaces.register_provider(BPFInterfaceProvider)
```

### Comparing `scapy-2.5.0rc3/scapy/arch/bpf/supersocket.py` & `scapy-2.6.0rc1/scapy/arch/bpf/supersocket.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,14 +4,16 @@
 # Copyright (C) Guillaume Valadon <guillaume@valadon.net>
 
 """
 Scapy *BSD native support - BPF sockets
 """
 
 from select import select
+
+import abc
 import ctypes
 import errno
 import fcntl
 import os
 import platform
 import struct
 import sys
@@ -32,18 +34,30 @@
     BPF_BUFFER_LENGTH,
     BPF_T_NANOTIME,
 )
 from scapy.config import conf
 from scapy.consts import DARWIN, FREEBSD, NETBSD
 from scapy.data import ETH_P_ALL, DLT_IEEE802_11_RADIO
 from scapy.error import Scapy_Exception, warning
-from scapy.interfaces import network_name
+from scapy.interfaces import network_name, _GlobInterfaceType
 from scapy.supersocket import SuperSocket
 from scapy.compat import raw
 
+# Typing
+from typing import (
+    Any,
+    List,
+    Optional,
+    Tuple,
+    Type,
+    TYPE_CHECKING,
+)
+if TYPE_CHECKING:
+    from scapy.packet import Packet
+
 # Structures & c types
 
 if FREEBSD or NETBSD:
     # On 32bit architectures long might be 32bit.
     BPF_ALIGNMENT = ctypes.sizeof(ctypes.c_long)
 else:
     # DARWIN, OPENBSD
@@ -57,15 +71,15 @@
         _fields_ = [("tv_sec", ctypes.c_ulong),
                     ("tv_nsec", ctypes.c_ulong)]
 elif NETBSD:
     class bpf_timeval(ctypes.Structure):
         _fields_ = [("tv_sec", ctypes.c_ulong),
                     ("tv_usec", ctypes.c_ulong)]
 else:
-    class bpf_timeval(ctypes.Structure):
+    class bpf_timeval(ctypes.Structure):  # type: ignore
         _fields_ = [("tv_sec", ctypes.c_uint32),
                     ("tv_usec", ctypes.c_uint32)]
 
 
 class bpf_hdr(ctypes.Structure):
     # Also called bpf_xhdr on some OSes
     _fields_ = [("bh_tstamp", bpf_timeval),
@@ -77,74 +91,79 @@
 _bpf_hdr_len = ctypes.sizeof(bpf_hdr)
 
 # SuperSockets definitions
 
 
 class _L2bpfSocket(SuperSocket):
     """"Generic Scapy BPF Super Socket"""
+    __slots__ = ["bpf_fd"]
 
     desc = "read/write packets using BPF"
     nonblocking_socket = True
 
-    def __init__(self, iface=None, type=ETH_P_ALL, promisc=None, filter=None,
-                 nofilter=0, monitor=False):
+    def __init__(self,
+                 iface=None,  # type: Optional[_GlobInterfaceType]
+                 type=ETH_P_ALL,  # type: int
+                 promisc=None,  # type: Optional[bool]
+                 filter=None,  # type: Optional[str]
+                 nofilter=0,  # type: int
+                 monitor=False,  # type: bool
+                 ):
         if monitor:
             raise Scapy_Exception(
                 "We do not natively support monitor mode on BPF. "
                 "Please turn on libpcap using conf.use_pcap = True"
             )
 
-        self.fd_flags = None
+        self.fd_flags = None  # type: Optional[int]
         self.assigned_interface = None
 
         # SuperSocket mandatory variables
         if promisc is None:
             promisc = conf.sniff_promisc
         self.promisc = promisc
 
         self.iface = network_name(iface or conf.iface)
 
         # Get the BPF handle
-        self.ins = None
-        (self.ins, self.dev_bpf) = get_dev_bpf()
-        self.outs = self.ins
+        self.bpf_fd, self.dev_bpf = get_dev_bpf()
 
         if FREEBSD:
             # Set the BPF timeval format. Availability issues here !
             try:
                 fcntl.ioctl(
-                    self.ins, BIOCSTSTAMP,
+                    self.bpf_fd, BIOCSTSTAMP,
                     struct.pack('I', BPF_T_NANOTIME)
                 )
             except IOError:
                 raise Scapy_Exception("BIOCSTSTAMP failed on /dev/bpf%i" %
                                       self.dev_bpf)
         # Set the BPF buffer length
         try:
             fcntl.ioctl(
-                self.ins, BIOCSBLEN,
+                self.bpf_fd, BIOCSBLEN,
                 struct.pack('I', BPF_BUFFER_LENGTH)
             )
         except IOError:
             raise Scapy_Exception("BIOCSBLEN failed on /dev/bpf%i" %
                                   self.dev_bpf)
 
         # Assign the network interface to the BPF handle
         try:
             fcntl.ioctl(
-                self.ins, BIOCSETIF,
+                self.bpf_fd, BIOCSETIF,
                 struct.pack("16s16x", self.iface.encode())
             )
         except IOError:
             raise Scapy_Exception("BIOCSETIF failed on %s" % self.iface)
         self.assigned_interface = self.iface
 
         # Set the interface into promiscuous
         if self.promisc:
-            self.set_promisc(1)
+            self.set_promisc(True)
 
         # Set the interface to monitor mode
         # Note: - trick from libpcap/pcap-bpf.c - monitor_mode()
         #       - it only works on OS X 10.5 and later
         if DARWIN and monitor:
             # Convert macOS version to an integer
             try:
@@ -156,203 +175,222 @@
                 warning("Could not determine your macOS version!")
                 macos_version = sys.maxint
 
             # Disable 802.11 monitoring on macOS Catalina (aka 10.15) and upper
             if macos_version < 101500:
                 dlt_radiotap = struct.pack('I', DLT_IEEE802_11_RADIO)
                 try:
-                    fcntl.ioctl(self.ins, BIOCSDLT, dlt_radiotap)
+                    fcntl.ioctl(self.bpf_fd, BIOCSDLT, dlt_radiotap)
                 except IOError:
                     raise Scapy_Exception("Can't set %s into monitor mode!" %
                                           self.iface)
             else:
                 warning("Scapy won't activate 802.11 monitoring, "
                         "as it will crash your macOS kernel!")
 
         # Don't block on read
         try:
-            fcntl.ioctl(self.ins, BIOCIMMEDIATE, struct.pack('I', 1))
+            fcntl.ioctl(self.bpf_fd, BIOCIMMEDIATE, struct.pack('I', 1))
         except IOError:
             raise Scapy_Exception("BIOCIMMEDIATE failed on /dev/bpf%i" %
                                   self.dev_bpf)
 
         # Scapy will provide the link layer source address
         # Otherwise, it is written by the kernel
         try:
-            fcntl.ioctl(self.ins, BIOCSHDRCMPLT, struct.pack('i', 1))
+            fcntl.ioctl(self.bpf_fd, BIOCSHDRCMPLT, struct.pack('i', 1))
         except IOError:
             raise Scapy_Exception("BIOCSHDRCMPLT failed on /dev/bpf%i" %
                                   self.dev_bpf)
 
         # Configure the BPF filter
         filter_attached = False
         if not nofilter:
             if conf.except_filter:
                 if filter:
                     filter = "(%s) and not (%s)" % (filter, conf.except_filter)
                 else:
                     filter = "not (%s)" % conf.except_filter
             if filter is not None:
                 try:
-                    attach_filter(self.ins, filter, self.iface)
+                    attach_filter(self.bpf_fd, filter, self.iface)
                     filter_attached = True
-                except ImportError as ex:
-                    warning("Cannot set filter: %s" % ex)
+                except (ImportError, Scapy_Exception) as ex:
+                    raise Scapy_Exception("Cannot set filter: %s" % ex)
         if NETBSD and filter_attached is False:
             # On NetBSD, a filter must be attached to an interface, otherwise
             # no frame will be received by os.read(). When no filter has been
             # configured, Scapy uses a simple tcpdump filter that does nothing
             # more than ensuring the length frame is not null.
             filter = "greater 0"
             try:
-                attach_filter(self.ins, filter, self.iface)
+                attach_filter(self.bpf_fd, filter, self.iface)
             except ImportError as ex:
                 warning("Cannot set filter: %s" % ex)
 
         # Set the guessed packet class
         self.guessed_cls = self.guess_cls()
 
     def set_promisc(self, value):
+        # type: (bool) -> None
         """Set the interface in promiscuous mode"""
 
         try:
-            fcntl.ioctl(self.ins, BIOCPROMISC, struct.pack('i', value))
+            fcntl.ioctl(self.bpf_fd, BIOCPROMISC, struct.pack('i', value))
         except IOError:
             raise Scapy_Exception("Cannot set promiscuous mode on interface "
                                   "(%s)!" % self.iface)
 
     def __del__(self):
+        # type: () -> None
         """Close the file descriptor on delete"""
         # When the socket is deleted on Scapy exits, __del__ is
         # sometimes called "too late", and self is None
         if self is not None:
             self.close()
 
     def guess_cls(self):
+        # type: () -> type
         """Guess the packet class that must be used on the interface"""
 
         # Get the data link type
         try:
-            ret = fcntl.ioctl(self.ins, BIOCGDLT, struct.pack('I', 0))
-            ret = struct.unpack('I', ret)[0]
+            ret = fcntl.ioctl(self.bpf_fd, BIOCGDLT, struct.pack('I', 0))
+            linktype = struct.unpack('I', ret)[0]
         except IOError:
             cls = conf.default_l2
             warning("BIOCGDLT failed: unable to guess type. Using %s !",
                     cls.name)
             return cls
 
         # Retrieve the corresponding class
         try:
-            return conf.l2types[ret]
+            return conf.l2types.num2layer[linktype]
         except KeyError:
             cls = conf.default_l2
-            warning("Unable to guess type (type %i). Using %s", ret, cls.name)
+            warning("Unable to guess type (type %i). Using %s", linktype, cls.name)
+            return cls
 
     def set_nonblock(self, set_flag=True):
+        # type: (bool) -> None
         """Set the non blocking flag on the socket"""
 
         # Get the current flags
         if self.fd_flags is None:
             try:
-                self.fd_flags = fcntl.fcntl(self.ins, fcntl.F_GETFL)
+                self.fd_flags = fcntl.fcntl(self.bpf_fd, fcntl.F_GETFL)
             except IOError:
                 warning("Cannot get flags on this file descriptor !")
                 return
 
         # Set the non blocking flag
         if set_flag:
             new_fd_flags = self.fd_flags | os.O_NONBLOCK
         else:
             new_fd_flags = self.fd_flags & ~os.O_NONBLOCK
 
         try:
-            fcntl.fcntl(self.ins, fcntl.F_SETFL, new_fd_flags)
+            fcntl.fcntl(self.bpf_fd, fcntl.F_SETFL, new_fd_flags)
             self.fd_flags = new_fd_flags
         except Exception:
             warning("Can't set flags on this file descriptor !")
 
     def get_stats(self):
+        # type: () -> Tuple[Optional[int], Optional[int]]
         """Get received / dropped statistics"""
 
         try:
-            ret = fcntl.ioctl(self.ins, BIOCGSTATS, struct.pack("2I", 0, 0))
+            ret = fcntl.ioctl(self.bpf_fd, BIOCGSTATS, struct.pack("2I", 0, 0))
             return struct.unpack("2I", ret)
         except IOError:
             warning("Unable to get stats from BPF !")
             return (None, None)
 
     def get_blen(self):
+        # type: () -> Optional[int]
         """Get the BPF buffer length"""
 
         try:
-            ret = fcntl.ioctl(self.ins, BIOCGBLEN, struct.pack("I", 0))
-            return struct.unpack("I", ret)[0]
+            ret = fcntl.ioctl(self.bpf_fd, BIOCGBLEN, struct.pack("I", 0))
+            return struct.unpack("I", ret)[0]  # type: ignore
         except IOError:
             warning("Unable to get the BPF buffer length")
-            return
+            return None
 
     def fileno(self):
+        # type: () -> int
         """Get the underlying file descriptor"""
-        return self.ins
+        return self.bpf_fd
 
     def close(self):
+        # type: () -> None
         """Close the Super Socket"""
 
-        if not self.closed and self.ins is not None:
-            os.close(self.ins)
+        if not self.closed and self.bpf_fd != -1:
+            os.close(self.bpf_fd)
             self.closed = True
-            self.ins = None
+            self.bpf_fd = -1
 
+    @abc.abstractmethod
     def send(self, x):
+        # type: (Packet) -> int
         """Dummy send method"""
         raise Exception(
             "Can't send anything with %s" % self.__class__.__name__
         )
 
+    @abc.abstractmethod
     def recv_raw(self, x=BPF_BUFFER_LENGTH):
+        # type: (int) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]  # noqa: E501
         """Dummy recv method"""
         raise Exception(
             "Can't recv anything with %s" % self.__class__.__name__
         )
 
     @staticmethod
     def select(sockets, remain=None):
+        # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
         """This function is called during sendrecv() routine to select
         the available sockets.
         """
         # sockets, None (means use the socket's recv() )
         return bpf_select(sockets, remain)
 
 
 class L2bpfListenSocket(_L2bpfSocket):
     """"Scapy L2 BPF Listen Super Socket"""
 
     def __init__(self, *args, **kwargs):
-        self.received_frames = []
+        # type: (*Any, **Any) -> None
+        self.received_frames = []  # type: List[Tuple[Optional[type], Optional[bytes], Optional[float]]]  # noqa: E501
         super(L2bpfListenSocket, self).__init__(*args, **kwargs)
 
     def buffered_frames(self):
+        # type: () -> int
         """Return the number of frames in the buffer"""
         return len(self.received_frames)
 
     def get_frame(self):
+        # type: () -> Tuple[Optional[type], Optional[bytes], Optional[float]]
         """Get a frame or packet from the received list"""
         if self.received_frames:
             return self.received_frames.pop(0)
         else:
             return None, None, None
 
     @staticmethod
     def bpf_align(bh_h, bh_c):
+        # type: (int, int) -> int
         """Return the index to the end of the current packet"""
 
         # from <net/bpf.h>
         return ((bh_h + bh_c) + (BPF_ALIGNMENT - 1)) & ~(BPF_ALIGNMENT - 1)
 
     def extract_frames(self, bpf_buffer):
+        # type: (bytes) -> None
         """
         Extract all frames from the buffer and stored them in the received list
         """
 
         # Ensure that the BPF buffer contains at least the header
         len_bb = len(bpf_buffer)
         if len_bb < _bpf_hdr_len:
@@ -377,43 +415,46 @@
 
         # Extract the next frame
         end = self.bpf_align(bh_hdr.bh_hdrlen, bh_hdr.bh_caplen)
         if (len_bb - end) >= 20:
             self.extract_frames(bpf_buffer[end:])
 
     def recv_raw(self, x=BPF_BUFFER_LENGTH):
+        # type: (int) -> Tuple[Optional[type], Optional[bytes], Optional[float]]
         """Receive a frame from the network"""
 
         x = min(x, BPF_BUFFER_LENGTH)
 
         if self.buffered_frames():
             # Get a frame from the buffer
             return self.get_frame()
 
         # Get data from BPF
         try:
-            bpf_buffer = os.read(self.ins, x)
+            bpf_buffer = os.read(self.bpf_fd, x)
         except EnvironmentError as exc:
             if exc.errno != errno.EAGAIN:
                 warning("BPF recv_raw()", exc_info=True)
             return None, None, None
 
         # Extract all frames from the BPF buffer
         self.extract_frames(bpf_buffer)
         return self.get_frame()
 
 
 class L2bpfSocket(L2bpfListenSocket):
     """"Scapy L2 BPF Super Socket"""
 
     def send(self, x):
+        # type: (Packet) -> int
         """Send a frame"""
-        return os.write(self.outs, raw(x))
+        return os.write(self.bpf_fd, raw(x))
 
     def nonblock_recv(self):
+        # type: () -> Optional[Packet]
         """Non blocking receive"""
 
         if self.buffered_frames():
             # Get a frame from the buffer
             return L2bpfListenSocket.recv(self)
 
         # Set the non blocking flag, read from the socket, and unset the flag
@@ -421,35 +462,36 @@
         pkt = L2bpfListenSocket.recv(self)
         self.set_nonblock(False)
         return pkt
 
 
 class L3bpfSocket(L2bpfSocket):
 
-    def recv(self, x=BPF_BUFFER_LENGTH):
+    def recv(self, x: int = BPF_BUFFER_LENGTH, **kwargs: Any) -> Optional['Packet']:
         """Receive on layer 3"""
-        r = SuperSocket.recv(self, x)
+        r = SuperSocket.recv(self, x, **kwargs)
         if r:
             r.payload.time = r.time
             return r.payload
         return r
 
     def send(self, pkt):
+        # type: (Packet) -> int
         """Send a packet"""
         from scapy.layers.l2 import Loopback
 
         # Use the routing table to find the output interface
         iff = pkt.route()[0]
         if iff is None:
             iff = network_name(conf.iface)
 
         # Assign the network interface to the BPF handle
         if self.assigned_interface != iff:
             try:
-                fcntl.ioctl(self.outs, BIOCSETIF, struct.pack("16s16x", iff.encode()))  # noqa: E501
+                fcntl.ioctl(self.bpf_fd, BIOCSETIF, struct.pack("16s16x", iff.encode()))  # noqa: E501
             except IOError:
                 raise Scapy_Exception("BIOCSETIF failed on %s" % iff)
             self.assigned_interface = iff
 
         # Build the frame
         #
         # LINKTYPE_NULL / DLT_NULL (Loopback) is a special case. From the
@@ -472,55 +514,48 @@
         #
         # There might be other drivers which make the same mistake as
         # tuntaposx, but these are typically provided with VPN software, and
         # Apple are breaking these kexts in a future version of macOS... so
         # the problem will eventually go away. They already don't work on Macs
         # with Apple Silicon (M1).
         if DARWIN and iff.startswith('tun') and self.guessed_cls == Loopback:
-            frame = raw(pkt)
+            frame = pkt
         elif FREEBSD and (iff.startswith('tun') or iff.startswith('tap')):
             # On FreeBSD, the bpf manpage states that it is only possible
             # to write packets to Ethernet and SLIP network interfaces
             # using /dev/bpf
             #
             # Note: `open("/dev/tun0", "wb").write(raw(pkt())) should be
             #   used
             warning("Cannot write to %s according to the documentation!", iff)
             return
         else:
-            frame = raw(self.guessed_cls() / pkt)
+            frame = self.guessed_cls() / pkt
 
         pkt.sent_time = time.time()
 
         # Send the frame
-        L2bpfSocket.send(self, frame)
+        return L2bpfSocket.send(self, frame)
 
 
 # Sockets manipulation functions
 
-def isBPFSocket(obj):
-    """Return True is obj is a BPF Super Socket"""
-    return isinstance(
-        obj,
-        (L2bpfListenSocket, L2bpfListenSocket, L3bpfSocket)
-    )
-
-
 def bpf_select(fds_list, timeout=None):
+    # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
     """A call to recv() can return several frames. This functions hides the fact
        that some frames are read from the internal buffer."""
 
     # Check file descriptors types
-    bpf_scks_buffered = list()
+    bpf_scks_buffered = list()  # type: List[SuperSocket]
     select_fds = list()
 
     for tmp_fd in fds_list:
 
         # Specific BPF sockets: get buffers status
-        if isBPFSocket(tmp_fd) and tmp_fd.buffered_frames():
+        if isinstance(tmp_fd, L2bpfListenSocket) and tmp_fd.buffered_frames():
             bpf_scks_buffered.append(tmp_fd)
             continue
 
         # Regular file descriptors or empty BPF buffer
         select_fds.append(tmp_fd)
 
     if select_fds:
```

### Comparing `scapy-2.5.0rc3/scapy/arch/common.py` & `scapy-2.6.0rc1/scapy/arch/common.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,25 +3,28 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Functions common to different architectures
 """
 
+import socket
 import ctypes
+
 from scapy.config import conf
 from scapy.data import MTU, ARPHDR_ETHER, ARPHRD_TO_DLT
 from scapy.error import Scapy_Exception
-from scapy.interfaces import network_name
+from scapy.interfaces import network_name, resolve_iface, NetworkInterface
 from scapy.libs.structures import bpf_program
+from scapy.pton_ntop import inet_pton
 from scapy.utils import decode_locale_str
 
 # Type imports
 import scapy
-from scapy.compat import (
+from typing import (
     Optional,
     Union,
 )
 
 # From if.h
 _iff_flags = [
     "UP",
@@ -29,28 +32,36 @@
     "DEBUG",
     "LOOPBACK",
     "POINTTOPOINT",
     "NOTRAILERS",
     "RUNNING",
     "NOARP",
     "PROMISC",
-    "NOTRAILERS",
     "ALLMULTI",
     "MASTER",
     "SLAVE",
     "MULTICAST",
     "PORTSEL",
     "AUTOMEDIA",
     "DYNAMIC",
     "LOWER_UP",
     "DORMANT",
     "ECHO"
 ]
 
 
+def get_if_raw_addr(iff):
+    # type: (Union[NetworkInterface, str]) -> bytes
+    """Return the raw IPv4 address of interface"""
+    iff = resolve_iface(iff)
+    if not iff.ip:
+        return b"\x00" * 4
+    return inet_pton(socket.AF_INET, iff.ip)
+
+
 # BPF HANDLERS
 
 
 def compile_filter(filter_exp,  # type: str
                    iface=None,  # type: Optional[Union[str, 'scapy.interfaces.NetworkInterface']]  # noqa: E501
                    linktype=None,  # type: Optional[int]
                    promisc=False  # type: bool
```

### Comparing `scapy-2.5.0rc3/scapy/arch/libpcap.py` & `scapy-2.6.0rc1/scapy/arch/libpcap.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,22 +33,23 @@
 from scapy.packet import Packet
 from scapy.pton_ntop import inet_ntop
 from scapy.supersocket import SuperSocket
 from scapy.utils import str2mac, decode_locale_str
 
 import scapy.consts
 
-from scapy.compat import (
-    cast,
+from typing import (
+    Any,
     Dict,
     List,
     NoReturn,
     Optional,
     Tuple,
     Type,
+    cast,
 )
 
 if not scapy.consts.WINDOWS:
     from fcntl import ioctl
 
 # AF_LINK is only available and provided on BSD (MAC)
 # but because we use its value elsewhere, let's patch it.
@@ -131,14 +132,16 @@
             self.pcap_fd.close()
 
 
 ##########
 #  PCAP  #
 ##########
 
+if WINDOWS:
+    NPCAP_PATH = ""
 
 if conf.use_pcap:
     if WINDOWS:
         # Windows specific
         NPCAP_PATH = os.environ["WINDIR"] + "\\System32\\Npcap"
         from scapy.libs.winpcapy import pcap_setmintocopy, pcap_getevent
     else:
@@ -155,14 +158,15 @@
             PCAP_ERROR_PERM_DENIED,
             bpf_program,
             pcap_close,
             pcap_compile,
             pcap_datalink,
             pcap_findalldevs,
             pcap_freealldevs,
+            pcap_geterr,
             pcap_if_t,
             pcap_lib_version,
             pcap_next_ex,
             pcap_open_live,
             pcap_pkthdr,
             pcap_setfilter,
             pcap_setnonblock,
@@ -260,16 +264,14 @@
                 elif platform.release() != "XP":
                     warning("WinPcap is now deprecated (not maintained). "
                             "Please use Npcap instead")
             elif b"npcap" in version.lower():
                 conf.use_npcap = True
                 conf.loopback_name = conf.loopback_name = "Npcap Loopback Adapter"  # noqa: E501
 
-if WINDOWS:
-    NPCAP_PATH = ""
 if conf.use_pcap:
     class _PcapWrapper_libpcap:  # noqa: F811
         """Wrapper for the libpcap calls"""
 
         def __init__(self,
                      device,  # type: _GlobInterfaceType
                      snaplen,  # type: int
@@ -360,15 +362,15 @@
             if not c > 0:
                 return None, None
             ts = (
                 self.header.contents.ts.tv_sec +
                 float(self.header.contents.ts.tv_usec) / 1e6
             )
             pkt = bytes(bytearray(
-                self.pkt_data[:self.header.contents.len]  # type: ignore
+                self.pkt_data[:self.header.contents.len]
             ))
             return ts, pkt
         __next__ = next
 
         def datalink(self):
             # type: () -> int
             """Wrapper around pcap_datalink"""
@@ -381,24 +383,24 @@
             if WINDOWS:
                 return cast(int, pcap_getevent(self.pcap))
             else:
                 # This does not exist under Windows
                 return cast(int, pcap_get_selectable_fd(self.pcap))
 
         def setfilter(self, f):
-            # type: (str) -> bool
+            # type: (str) -> None
             filter_exp = create_string_buffer(f.encode("utf8"))
-            if pcap_compile(self.pcap, byref(self.bpf_program), filter_exp, 1, -1) == -1:  # noqa: E501
-                log_runtime.error("Could not compile filter expression %s", f)
-                return False
-            else:
-                if pcap_setfilter(self.pcap, byref(self.bpf_program)) == -1:
-                    log_runtime.error("Could not set filter %s", f)
-                    return False
-            return True
+            if pcap_compile(self.pcap, byref(self.bpf_program), filter_exp, 1, -1) >= 0:  # noqa: E501
+                if pcap_setfilter(self.pcap, byref(self.bpf_program)) >= 0:
+                    # Success
+                    return
+            errstr = decode_locale_str(
+                bytearray(pcap_geterr(self.pcap)).strip(b"\x00")
+            )
+            raise Scapy_Exception("Cannot set filter: %s" % errstr)
 
         def setnonblock(self, i):
             # type: (bool) -> None
             pcap_setnonblock(self.pcap, i, self.errbuf)
 
         def send(self, x):
             # type: (bytes) -> int
@@ -427,23 +429,29 @@
             for ifname, dat in conf.cache_pcapiflist.items():
                 description, ips, flags, mac = dat
                 i += 1
                 if not mac:
                     from scapy.arch import get_if_hwaddr
                     try:
                         mac = get_if_hwaddr(ifname)
-                    except Exception:
+                    except Exception as ex:
                         # There are at least 3 different possible exceptions
+                        log_loading.warning(
+                            "Could not get MAC address of interface '%s': %s." % (
+                                ifname,
+                                ex,
+                            )
+                        )
                         continue
                 if_data = {
                     'name': ifname,
                     'description': description or ifname,
                     'network_name': ifname,
                     'index': i,
-                    'mac': mac or '00:00:00:00:00:00',
+                    'mac': mac,
                     'ips': ips,
                     'flags': flags
                 }
                 data[ifname] = NetworkInterface(self, if_data)
             return data
 
         def reload(self):
@@ -498,15 +506,15 @@
                         filter = "(%s) and not (%s)" % (filter, conf.except_filter)  # noqa: E501
                     else:
                         filter = "not (%s)" % conf.except_filter
                 if filter:
                     self.pcap_fd.setfilter(filter)
 
         def send(self, x):
-            # type: (int) -> NoReturn
+            # type: (Packet) -> NoReturn
             raise Scapy_Exception(
                 "Can't send anything with L2pcapListenSocket"
             )
 
     class L2pcapSocket(_L2libpcapSocket):
         desc = "read/write packets at layer 2 using only libpcap"
 
@@ -567,17 +575,17 @@
             except AttributeError:
                 pass
             return self.pcap_fd.send(sx)
 
     class L3pcapSocket(L2pcapSocket):
         desc = "read/write packets at layer 3 using only libpcap"
 
-        def recv(self, x=MTU):
-            # type: (int) -> Optional[Packet]
-            r = L2pcapSocket.recv(self, x)
+        def recv(self, x=MTU, **kwargs):
+            # type: (int, **Any) -> Optional[Packet]
+            r = L2pcapSocket.recv(self, x, **kwargs)
             if r:
                 r.payload.time = r.time
                 return r.payload
             return r
 
         def send(self, x):
             # type: (Packet) -> int
```

### Comparing `scapy-2.5.0rc3/scapy/arch/linux.py` & `scapy-2.6.0rc1/scapy/supersocket.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,700 +1,599 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
-Linux specific functions.
+SuperSocket.
 """
 
-from __future__ import absolute_import
-
-
-from fcntl import ioctl
-from select import select
-
-import array
+from select import select, error as select_error
 import ctypes
-import os
+import errno
 import socket
 import struct
-import subprocess
-import sys
 import time
 
-import scapy.utils
-import scapy.utils6
-from scapy.compat import raw, plain_str
-from scapy.consts import LINUX
-from scapy.arch.common import (
-    _iff_flags,
-    compile_filter,
-)
-from scapy.arch.unix import get_if, get_if_raw_hwaddr
 from scapy.config import conf
-from scapy.data import MTU, ETH_P_ALL, SOL_PACKET, SO_ATTACH_FILTER, \
-    SO_TIMESTAMPNS
-from scapy.error import (
-    ScapyInvalidPlatformException,
-    Scapy_Exception,
-    log_loading,
-    log_runtime,
-    warning,
+from scapy.consts import DARWIN, WINDOWS
+from scapy.data import (
+    MTU,
+    ETH_P_IP,
+    ETH_P_IPV6,
+    SOL_PACKET,
+    SO_TIMESTAMPNS,
 )
-from scapy.interfaces import IFACES, InterfaceProvider, NetworkInterface, \
-    network_name
-from scapy.libs.structures import sock_fprog
-from scapy.packet import Packet, Padding
-from scapy.pton_ntop import inet_ntop
-from scapy.supersocket import SuperSocket
-
-import scapy.libs.six as six
+from scapy.compat import raw
+from scapy.error import warning, log_runtime
+from scapy.interfaces import network_name
+from scapy.packet import Packet, NoPayload
+from scapy.plist import (
+    PacketList,
+    SndRcvList,
+    _PacketIterable,
+)
+from scapy.utils import PcapReader, tcpdump
 
 # Typing imports
-from scapy.compat import (
+from scapy.interfaces import _GlobInterfaceType
+from typing import (
     Any,
-    Callable,
     Dict,
+    Iterator,
     List,
-    NoReturn,
     Optional,
     Tuple,
     Type,
-    Union,
+    cast,
 )
 
-# From sockios.h
-SIOCGIFHWADDR = 0x8927          # Get hardware address
-SIOCGIFADDR = 0x8915          # get PA address
-SIOCGIFNETMASK = 0x891b          # get network PA mask
-SIOCGIFNAME = 0x8910          # get iface name
-SIOCSIFLINK = 0x8911          # set iface channel
-SIOCGIFCONF = 0x8912          # get iface list
-SIOCGIFFLAGS = 0x8913          # get flags
-SIOCSIFFLAGS = 0x8914          # set flags
-SIOCGIFINDEX = 0x8933          # name -> if_index mapping
-SIOCGIFCOUNT = 0x8938          # get number of devices
-SIOCGSTAMP = 0x8906          # get packet timestamp (as a timeval)
-
-# From if.h
-IFF_UP = 0x1               # Interface is up.
-IFF_BROADCAST = 0x2        # Broadcast address valid.
-IFF_DEBUG = 0x4            # Turn on debugging.
-IFF_LOOPBACK = 0x8         # Is a loopback net.
-IFF_POINTOPOINT = 0x10     # Interface is point-to-point link.
-IFF_NOTRAILERS = 0x20      # Avoid use of trailers.
-IFF_RUNNING = 0x40         # Resources allocated.
-IFF_NOARP = 0x80           # No address resolution protocol.
-IFF_PROMISC = 0x100        # Receive all packets.
-
-# From netpacket/packet.h
-PACKET_ADD_MEMBERSHIP = 1
-PACKET_DROP_MEMBERSHIP = 2
-PACKET_RECV_OUTPUT = 3
-PACKET_RX_RING = 5
-PACKET_STATISTICS = 6
-PACKET_MR_MULTICAST = 0
-PACKET_MR_PROMISC = 1
-PACKET_MR_ALLMULTI = 2
-
-# From net/route.h
-RTF_UP = 0x0001  # Route usable
-RTF_REJECT = 0x0200
-
-# From if_packet.h
-PACKET_HOST = 0  # To us
-PACKET_BROADCAST = 1  # To all
-PACKET_MULTICAST = 2  # To group
-PACKET_OTHERHOST = 3  # To someone else
-PACKET_OUTGOING = 4  # Outgoing of any type
-PACKET_LOOPBACK = 5  # MC/BRD frame looped back
-PACKET_USER = 6  # To user space
-PACKET_KERNEL = 7  # To kernel space
-PACKET_AUXDATA = 8
-PACKET_FASTROUTE = 6  # Fastrouted frame
-# Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space
-
 # Utils
 
 
-def get_if_raw_addr(iff):
-    # type: (Union[NetworkInterface, str]) -> bytes
-    r"""
-    Return the raw IPv4 address of an interface.
-    If unavailable, returns b"\0\0\0\0"
-    """
-    try:
-        return get_if(iff, SIOCGIFADDR)[20:24]
-    except IOError:
-        return b"\0\0\0\0"
-
-
-def _get_if_list():
-    # type: () -> List[str]
-    """
-    Function to read the interfaces from /proc/net/dev
-    """
-    try:
-        f = open("/proc/net/dev", "rb")
-    except IOError:
-        try:
-            f.close()
-        except Exception:
-            pass
-        log_loading.critical("Can't open /proc/net/dev !")
-        return []
-    lst = []
-    f.readline()
-    f.readline()
-    for line in f:
-        lst.append(plain_str(line).split(":")[0].strip())
-    f.close()
-    return lst
+class _SuperSocket_metaclass(type):
+    desc = None   # type: Optional[str]
 
+    def __repr__(self):
+        # type: () -> str
+        if self.desc is not None:
+            return "<%s: %s>" % (self.__name__, self.desc)
+        else:
+            return "<%s>" % self.__name__
 
-def attach_filter(sock, bpf_filter, iface):
-    # type: (socket.socket, str, Union[NetworkInterface, str]) -> None
-    """
-    Compile bpf filter and attach it to a socket
-
-    :param sock: the python socket
-    :param bpf_filter: the bpf string filter to compile
-    :param iface: the interface used to compile
-    """
-    bp = compile_filter(bpf_filter, iface)
-    if conf.use_pypy and sys.pypy_version_info <= (7, 3, 2):  # type: ignore
-        # PyPy < 7.3.2 has a broken behavior
-        # https://foss.heptapod.net/pypy/pypy/-/issues/3298
-        bp = struct.pack(
-            'HL',
-            bp.bf_len, ctypes.addressof(bp.bf_insns.contents)
-        )
-    else:
-        bp = sock_fprog(bp.bf_len, bp.bf_insns)
-    sock.setsockopt(socket.SOL_SOCKET, SO_ATTACH_FILTER, bp)
 
+# Used to get ancillary data
+PACKET_AUXDATA = 8
+ETH_P_8021Q = 0x8100
+TP_STATUS_VLAN_VALID = 1 << 4
+TP_STATUS_VLAN_TPID_VALID = 1 << 6
+
+
+class tpacket_auxdata(ctypes.Structure):
+    _fields_ = [
+        ("tp_status", ctypes.c_uint),
+        ("tp_len", ctypes.c_uint),
+        ("tp_snaplen", ctypes.c_uint),
+        ("tp_mac", ctypes.c_ushort),
+        ("tp_net", ctypes.c_ushort),
+        ("tp_vlan_tci", ctypes.c_ushort),
+        ("tp_vlan_tpid", ctypes.c_ushort),
+    ]  # type: List[Tuple[str, Any]]
+
+
+# SuperSocket
+
+class SuperSocket(metaclass=_SuperSocket_metaclass):
+    closed = False  # type: bool
+    nonblocking_socket = False  # type: bool
+    auxdata_available = False   # type: bool
 
-def set_promisc(s, iff, val=1):
-    # type: (socket.socket, Union[NetworkInterface, str], int) -> None
-    mreq = struct.pack("IHH8s", get_if_index(iff), PACKET_MR_PROMISC, 0, b"")
-    if val:
-        cmd = PACKET_ADD_MEMBERSHIP
-    else:
-        cmd = PACKET_DROP_MEMBERSHIP
-    s.setsockopt(SOL_PACKET, cmd, mreq)
+    def __init__(self,
+                 family=socket.AF_INET,  # type: int
+                 type=socket.SOCK_STREAM,  # type: int
+                 proto=0,  # type: int
+                 iface=None,  # type: Optional[_GlobInterfaceType]
+                 **kwargs  # type: Any
+                 ):
+        # type: (...) -> None
+        self.ins = socket.socket(family, type, proto)  # type: socket.socket
+        self.outs = self.ins  # type: Optional[socket.socket]
+        self.promisc = conf.sniff_promisc
+        self.iface = iface or conf.iface
 
+    def send(self, x):
+        # type: (Packet) -> int
+        sx = raw(x)
+        try:
+            x.sent_time = time.time()
+        except AttributeError:
+            pass
 
-def get_alias_address(iface_name,  # type: str
-                      ip_mask,  # type: int
-                      gw_str,  # type: str
-                      metric  # type: int
-                      ):
-    # type: (...) -> Optional[Tuple[int, int, str, str, str, int]]
-    """
-    Get the correct source IP address of an interface alias
-    """
+        if self.outs:
+            return self.outs.send(sx)
+        else:
+            return 0
 
-    # Detect the architecture
-    if scapy.consts.IS_64BITS:
-        offset, name_len = 16, 40
+    if WINDOWS:
+        def _recv_raw(self, sock, x):
+            # type: (socket.socket, int) -> Tuple[bytes, Any, Optional[float]]
+            """Internal function to receive a Packet"""
+            pkt, sa_ll = sock.recvfrom(x)
+            return pkt, sa_ll, None
     else:
-        offset, name_len = 32, 32
+        def _recv_raw(self, sock, x):
+            # type: (socket.socket, int) -> Tuple[bytes, Any, Optional[float]]
+            """Internal function to receive a Packet,
+            and process ancillary data.
+            """
+            timestamp = None
+            if not self.auxdata_available:
+                pkt, _, _, sa_ll = sock.recvmsg(x)
+                return pkt, sa_ll, timestamp
+            flags_len = socket.CMSG_LEN(4096)
+            pkt, ancdata, flags, sa_ll = sock.recvmsg(x, flags_len)
+            if not pkt:
+                return pkt, sa_ll, timestamp
+            for cmsg_lvl, cmsg_type, cmsg_data in ancdata:
+                # Check available ancillary data
+                if (cmsg_lvl == SOL_PACKET and cmsg_type == PACKET_AUXDATA):
+                    # Parse AUXDATA
+                    try:
+                        auxdata = tpacket_auxdata.from_buffer_copy(cmsg_data)
+                    except ValueError:
+                        # Note: according to Python documentation, recvmsg()
+                        #       can return a truncated message. A ValueError
+                        #       exception likely indicates that Auxiliary
+                        #       Data is not supported by the Linux kernel.
+                        return pkt, sa_ll, timestamp
+                    if auxdata.tp_vlan_tci != 0 or \
+                            auxdata.tp_status & TP_STATUS_VLAN_VALID:
+                        # Insert VLAN tag
+                        tpid = ETH_P_8021Q
+                        if auxdata.tp_status & TP_STATUS_VLAN_TPID_VALID:
+                            tpid = auxdata.tp_vlan_tpid
+                        tag = struct.pack(
+                            "!HH",
+                            tpid,
+                            auxdata.tp_vlan_tci
+                        )
+                        pkt = pkt[:12] + tag + pkt[12:]
+                elif cmsg_lvl == socket.SOL_SOCKET and \
+                        cmsg_type == SO_TIMESTAMPNS:
+                    length = len(cmsg_data)
+                    if length == 16:  # __kernel_timespec
+                        tmp = struct.unpack("ll", cmsg_data)
+                    elif length == 8:  # timespec
+                        tmp = struct.unpack("ii", cmsg_data)
+                    else:
+                        log_runtime.warning("Unknown timespec format.. ?!")
+                        continue
+                    timestamp = tmp[0] + tmp[1] * 1e-9
+            return pkt, sa_ll, timestamp
 
-    # Retrieve interfaces structures
-    sck = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
-    names_ar = array.array('B', b'\0' * 4096)
-    ifreq = ioctl(sck.fileno(), SIOCGIFCONF,
-                  struct.pack("iL", len(names_ar), names_ar.buffer_info()[0]))
-
-    # Extract interfaces names
-    out = struct.unpack("iL", ifreq)[0]
-    names_b = names_ar.tobytes() if six.PY3 else names_ar.tostring()  # type: ignore  # noqa: E501
-    names = [names_b[i:i + offset].split(b'\0', 1)[0] for i in range(0, out, name_len)]  # noqa: E501
-
-    # Look for the IP address
-    for ifname_b in names:
-        ifname = plain_str(ifname_b)
-        # Only look for a matching interface name
-        if not ifname.startswith(iface_name):
-            continue
-
-        # Retrieve and convert addresses
-        ifreq = ioctl(sck, SIOCGIFADDR, struct.pack("16s16x", ifname_b))
-        ifaddr = struct.unpack(">I", ifreq[20:24])[0]  # type: int
-        ifreq = ioctl(sck, SIOCGIFNETMASK, struct.pack("16s16x", ifname_b))
-        msk = struct.unpack(">I", ifreq[20:24])[0]  # type: int
-
-        # Get the full interface name
-        if ':' in ifname:
-            ifname = ifname[:ifname.index(':')]
-        else:
-            continue
-
-        # Check if the source address is included in the network
-        if (ifaddr & msk) == ip_mask:
-            sck.close()
-            return (ifaddr & msk, msk, gw_str, ifname,
-                    scapy.utils.ltoa(ifaddr), metric)
-
-    sck.close()
-    return None
-
-
-def read_routes():
-    # type: () -> List[Tuple[int, int, str, str, str, int]]
-    try:
-        f = open("/proc/net/route", "rb")
-    except IOError:
-        log_loading.critical("Can't open /proc/net/route !")
-        return []
-    routes = []
-    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
-    try:
-        ifreq = ioctl(s, SIOCGIFADDR, struct.pack("16s16x", conf.loopback_name.encode("utf8")))  # noqa: E501
-        addrfamily = struct.unpack("h", ifreq[16:18])[0]
-        if addrfamily == socket.AF_INET:
-            ifreq2 = ioctl(s, SIOCGIFNETMASK, struct.pack("16s16x", conf.loopback_name.encode("utf8")))  # noqa: E501
-            msk = socket.ntohl(struct.unpack("I", ifreq2[20:24])[0])
-            dst = socket.ntohl(struct.unpack("I", ifreq[20:24])[0]) & msk
-            ifaddr = scapy.utils.inet_ntoa(ifreq[20:24])
-            routes.append((dst, msk, "0.0.0.0", conf.loopback_name, ifaddr, 1))  # noqa: E501
-        else:
-            warning("Interface %s: unknown address family (%i)" % (conf.loopback_name, addrfamily))  # noqa: E501
-    except IOError as err:
-        if err.errno == 99:
-            warning("Interface %s: no address assigned" % conf.loopback_name)  # noqa: E501
-        else:
-            warning("Interface %s: failed to get address config (%s)" % (conf.loopback_name, str(err)))  # noqa: E501
+    def recv_raw(self, x=MTU):
+        # type: (int) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]  # noqa: E501
+        """Returns a tuple containing (cls, pkt_data, time)"""
+        return conf.raw_layer, self.ins.recv(x), None
 
-    for line_b in f.readlines()[1:]:
-        line = plain_str(line_b)
-        iff, dst_b, gw, flags_b, _, _, metric_b, msk_b, _, _, _ = line.split()
-        flags = int(flags_b, 16)
-        if flags & RTF_UP == 0:
-            continue
-        if flags & RTF_REJECT:
-            continue
+    def recv(self, x=MTU, **kwargs):
+        # type: (int, **Any) -> Optional[Packet]
+        cls, val, ts = self.recv_raw(x)
+        if not val or not cls:
+            return None
         try:
-            ifreq = ioctl(s, SIOCGIFADDR, struct.pack("16s16x", iff.encode("utf8")))  # noqa: E501
-        except IOError:  # interface is present in routing tables but does not have any assigned IP  # noqa: E501
-            ifaddr = "0.0.0.0"
-            ifaddr_int = 0
-        else:
-            addrfamily = struct.unpack("h", ifreq[16:18])[0]
-            if addrfamily == socket.AF_INET:
-                ifaddr = scapy.utils.inet_ntoa(ifreq[20:24])
-                ifaddr_int = struct.unpack("!I", ifreq[20:24])[0]
-            else:
-                warning("Interface %s: unknown address family (%i)", iff, addrfamily)  # noqa: E501
-                continue
-
-        # Attempt to detect an interface alias based on addresses inconsistencies  # noqa: E501
-        dst_int = socket.htonl(int(dst_b, 16)) & 0xffffffff
-        msk_int = socket.htonl(int(msk_b, 16)) & 0xffffffff
-        gw_str = scapy.utils.inet_ntoa(struct.pack("I", int(gw, 16)))
-        metric = int(metric_b)
-
-        route = (dst_int, msk_int, gw_str, iff, ifaddr, metric)
-        if ifaddr_int & msk_int != dst_int:
-            tmp_route = get_alias_address(iff, dst_int, gw_str, metric)
-            if tmp_route:
-                route = tmp_route
-        routes.append(route)
-
-    f.close()
-    s.close()
-    return routes
-
-############
-#   IPv6   #
-############
-
+            pkt = cls(val, **kwargs)  # type: Packet
+        except KeyboardInterrupt:
+            raise
+        except Exception:
+            if conf.debug_dissector:
+                from scapy.sendrecv import debug
+                debug.crashed_on = (cls, val)
+                raise
+            pkt = conf.raw_layer(val)
+        if ts:
+            pkt.time = ts
+        return pkt
 
-def in6_getifaddr():
-    # type: () -> List[Tuple[str, int, str]]
-    """
-    Returns a list of 3-tuples of the form (addr, scope, iface) where
-    'addr' is the address of scope 'scope' associated to the interface
-    'iface'.
+    def fileno(self):
+        # type: () -> int
+        return self.ins.fileno()
 
-    This is the list of all addresses of all interfaces available on
-    the system.
-    """
-    ret = []  # type: List[Tuple[str, int, str]]
-    try:
-        fdesc = open("/proc/net/if_inet6", "rb")
-    except IOError:
-        return ret
-    for line in fdesc:
-        # addr, index, plen, scope, flags, ifname
-        tmp = plain_str(line).split()
-        addr = scapy.utils6.in6_ptop(
-            b':'.join(
-                struct.unpack('4s4s4s4s4s4s4s4s', tmp[0].encode())
-            ).decode()
-        )
-        # (addr, scope, iface)
-        ret.append((addr, int(tmp[3], 16), tmp[5]))
-    fdesc.close()
-    return ret
-
-
-def read_routes6():
-    # type: () -> List[Tuple[str, int, str, str, List[str], int]]
-    try:
-        f = open("/proc/net/ipv6_route", "rb")
-    except IOError:
-        return []
-    # 1. destination network
-    # 2. destination prefix length
-    # 3. source network displayed
-    # 4. source prefix length
-    # 5. next hop
-    # 6. metric
-    # 7. reference counter (?!?)
-    # 8. use counter (?!?)
-    # 9. flags
-    # 10. device name
-    routes = []
-
-    def proc2r(p):
-        # type: (bytes) -> str
-        ret = struct.unpack('4s4s4s4s4s4s4s4s', p)
-        addr = b':'.join(ret).decode()
-        return scapy.utils6.in6_ptop(addr)
-
-    lifaddr = in6_getifaddr()
-    for line in f.readlines():
-        d_b, dp_b, _, _, nh_b, metric_b, rc, us, fl_b, dev_b = line.split()
-        metric = int(metric_b, 16)
-        fl = int(fl_b, 16)
-        dev = plain_str(dev_b)
-
-        if fl & RTF_UP == 0:
-            continue
-        if fl & RTF_REJECT:
-            continue
-
-        d = proc2r(d_b)
-        dp = int(dp_b, 16)
-        nh = proc2r(nh_b)
-
-        cset = []  # candidate set (possible source addresses)
-        if dev == conf.loopback_name:
-            if d == '::':
-                continue
-            cset = ['::1']
+    def close(self):
+        # type: () -> None
+        if self.closed:
+            return
+        self.closed = True
+        if getattr(self, "outs", None):
+            if getattr(self, "ins", None) != self.outs:
+                if self.outs and self.outs.fileno() != -1:
+                    self.outs.close()
+        if getattr(self, "ins", None):
+            if self.ins.fileno() != -1:
+                self.ins.close()
+
+    def sr(self, *args, **kargs):
+        # type: (Any, Any) -> Tuple[SndRcvList, PacketList]
+        from scapy import sendrecv
+        return sendrecv.sndrcv(self, *args, **kargs)
+
+    def sr1(self, *args, **kargs):
+        # type: (Any, Any) -> Optional[Packet]
+        from scapy import sendrecv
+        ans = sendrecv.sndrcv(self, *args, **kargs)[0]  # type: SndRcvList
+        if len(ans) > 0:
+            pkt = ans[0][1]  # type: Packet
+            return pkt
         else:
-            devaddrs = (x for x in lifaddr if x[2] == dev)
-            cset = scapy.utils6.construct_source_candidate_set(d, dp, devaddrs)
+            return None
 
-        if len(cset) != 0:
-            routes.append((d, dp, nh, dev, cset, metric))
-    f.close()
-    return routes
-
-
-def get_if_index(iff):
-    # type: (Union[NetworkInterface, str]) -> int
-    return int(struct.unpack("I", get_if(iff, SIOCGIFINDEX)[16:20])[0])
-
-
-class LinuxInterfaceProvider(InterfaceProvider):
-    name = "sys"
+    def sniff(self, *args, **kargs):
+        # type: (Any, Any) -> PacketList
+        from scapy import sendrecv
+        return sendrecv.sniff(opened_socket=self, *args, **kargs)
+
+    def tshark(self, *args, **kargs):
+        # type: (Any, Any) -> None
+        from scapy import sendrecv
+        sendrecv.tshark(opened_socket=self, *args, **kargs)
+
+    # TODO: use 'scapy.ansmachine.AnsweringMachine' when typed
+    def am(self,
+           cls,  # type: Type[Any]
+           *args,  # type: Any
+           **kwargs  # type: Any
+           ):
+        # type: (...) -> Any
+        """
+        Creates an AnsweringMachine associated with this socket.
 
-    def _is_valid(self, dev):
-        # type: (NetworkInterface) -> bool
-        return bool(dev.flags & IFF_UP)
+        :param cls: A subclass of AnsweringMachine to instantiate
+        """
+        return cls(*args, opened_socket=self, socket=self, **kwargs)
 
-    def load(self):
-        # type: () -> Dict[str, NetworkInterface]
-        from scapy.fields import FlagValue
-        data = {}
-        ips = in6_getifaddr()
-        for i in _get_if_list():
-            try:
-                ifflags = struct.unpack("16xH14x", get_if(i, SIOCGIFFLAGS))[0]
-                index = get_if_index(i)
-                mac = scapy.utils.str2mac(
-                    get_if_raw_hwaddr(i, siocgifhwaddr=SIOCGIFHWADDR)[1]
-                )
-                ip = None  # type: Optional[str]
-                ip = inet_ntop(socket.AF_INET, get_if_raw_addr(i))
-            except IOError:
-                warning("Interface %s does not exist!", i)
-                continue
-            if ip == "0.0.0.0":
-                ip = None
-            ifflags = FlagValue(ifflags, _iff_flags)
-            if_data = {
-                "name": i,
-                "network_name": i,
-                "description": i,
-                "flags": ifflags,
-                "index": index,
-                "ip": ip,
-                "ips": [x[0] for x in ips if x[2] == i] + [ip] if ip else [],
-                "mac": mac
-            }
-            data[i] = NetworkInterface(self, if_data)
-        return data
-
-
-IFACES.register_provider(LinuxInterfaceProvider)
-
-if os.uname()[4] in ['x86_64', 'aarch64']:
-    def get_last_packet_timestamp(sock):
-        # type: (socket.socket) -> float
-        ts = ioctl(sock, SIOCGSTAMP, "1234567890123456")  # type: ignore
-        s, us = struct.unpack("QQ", ts)  # type: Tuple[int, int]
-        return s + us / 1000000.0
-else:
-    def get_last_packet_timestamp(sock):
-        # type: (socket.socket) -> float
-        ts = ioctl(sock, SIOCGSTAMP, "12345678")  # type: ignore
-        s, us = struct.unpack("II", ts)  # type: Tuple[int, int]
-        return s + us / 1000000.0
-
-
-def _flush_fd(fd):
-    # type: (int) -> None
-    while True:
-        r, w, e = select([fd], [], [], 0)
-        if r:
-            os.read(fd, MTU)
-        else:
-            break
+    @staticmethod
+    def select(sockets, remain=conf.recv_poll_rate):
+        # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
+        """This function is called during sendrecv() routine to select
+        the available sockets.
+
+        :param sockets: an array of sockets that need to be selected
+        :returns: an array of sockets that were selected and
+            the function to be called next to get the packets (i.g. recv)
+        """
+        try:
+            inp, _, _ = select(sockets, [], [], remain)
+        except (IOError, select_error) as exc:
+            # select.error has no .errno attribute
+            if not exc.args or exc.args[0] != errno.EINTR:
+                raise
+        return inp
 
+    def __del__(self):
+        # type: () -> None
+        """Close the socket"""
+        self.close()
 
-class L2Socket(SuperSocket):
-    desc = "read/write packets at layer 2 using Linux PF_PACKET sockets"
+    def __enter__(self):
+        # type: () -> SuperSocket
+        return self
 
-    def __init__(self,
-                 iface=None,  # type: Optional[Union[str, NetworkInterface]]
-                 type=ETH_P_ALL,  # type: int
-                 promisc=None,  # type: Optional[Any]
-                 filter=None,  # type: Optional[Any]
-                 nofilter=0,  # type: int
-                 monitor=None,  # type: Optional[Any]
-                 ):
-        # type: (...) -> None
-        self.iface = network_name(iface or conf.iface)
-        self.type = type
-        self.promisc = conf.sniff_promisc if promisc is None else promisc
-        self.ins = socket.socket(
-            socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
-        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
-        if not nofilter:
-            if conf.except_filter:
-                if filter:
-                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
-                else:
-                    filter = "not (%s)" % conf.except_filter
-            if filter is not None:
-                try:
-                    attach_filter(self.ins, filter, self.iface)
-                except (ImportError, Scapy_Exception) as ex:
-                    log_runtime.error("Cannot set filter: %s", ex)
-        if self.promisc:
-            set_promisc(self.ins, self.iface)
-        self.ins.bind((self.iface, type))
-        _flush_fd(self.ins.fileno())
-        self.ins.setsockopt(
-            socket.SOL_SOCKET,
-            socket.SO_RCVBUF,
-            conf.bufsize
-        )
-        if not six.PY2:
-            # Receive Auxiliary Data (VLAN tags)
+    def __exit__(self, exc_type, exc_value, traceback):
+        # type: (Optional[Type[BaseException]], Optional[BaseException], Optional[Any]) -> None  # noqa: E501
+        """Close the socket"""
+        self.close()
+
+
+if not WINDOWS:
+    class L3RawSocket(SuperSocket):
+        desc = "Layer 3 using Raw sockets (PF_INET/SOCK_RAW)"
+
+        def __init__(self,
+                     type=ETH_P_IP,  # type: int
+                     filter=None,  # type: Optional[str]
+                     iface=None,  # type: Optional[_GlobInterfaceType]
+                     promisc=None,  # type: Optional[bool]
+                     nofilter=0  # type: int
+                     ):
+            # type: (...) -> None
+            self.outs = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)  # noqa: E501
+            self.outs.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1)
+            self.ins = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))  # noqa: E501
+            if iface is not None:
+                iface = network_name(iface)
+                self.iface = iface
+                self.ins.bind((iface, type))
+            else:
+                self.iface = "any"
             try:
+                # Receive Auxiliary Data (VLAN tags)
                 self.ins.setsockopt(SOL_PACKET, PACKET_AUXDATA, 1)
                 self.ins.setsockopt(
                     socket.SOL_SOCKET,
                     SO_TIMESTAMPNS,
                     1
                 )
                 self.auxdata_available = True
             except OSError:
                 # Note: Auxiliary Data is only supported since
                 #       Linux 2.6.21
                 msg = "Your Linux Kernel does not support Auxiliary Data!"
                 log_runtime.info(msg)
-        if not isinstance(self, L2ListenSocket):
-            self.outs = self.ins  # type: socket.socket
-            self.outs.setsockopt(
-                socket.SOL_SOCKET,
-                socket.SO_SNDBUF,
-                conf.bufsize
-            )
-        else:
-            self.outs = None  # type: ignore
-        sa_ll = self.ins.getsockname()
-        if sa_ll[3] in conf.l2types:
-            self.LL = conf.l2types.num2layer[sa_ll[3]]
-            self.lvl = 2
-        elif sa_ll[1] in conf.l3types:
-            self.LL = conf.l3types.num2layer[sa_ll[1]]
-            self.lvl = 3
-        else:
-            self.LL = conf.default_l2
-            self.lvl = 2
-            warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using %s", sa_ll[0], sa_ll[1], sa_ll[3], self.LL.name)  # noqa: E501
 
-    def close(self):
-        # type: () -> None
-        if self.closed:
-            return
-        try:
-            if self.promisc and getattr(self, "ins", None):
-                set_promisc(self.ins, self.iface, 0)
-        except (AttributeError, OSError):
-            pass
-        SuperSocket.close(self)
+        def recv(self, x=MTU, **kwargs):
+            # type: (int, **Any) -> Optional[Packet]
+            data, sa_ll, ts = self._recv_raw(self.ins, x)
+            if sa_ll[2] == socket.PACKET_OUTGOING:
+                return None
+            if sa_ll[3] in conf.l2types:
+                cls = conf.l2types.num2layer[sa_ll[3]]  # type: Type[Packet]
+                lvl = 2
+            elif sa_ll[1] in conf.l3types:
+                cls = conf.l3types.num2layer[sa_ll[1]]
+                lvl = 3
+            else:
+                cls = conf.default_l2
+                warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using %s", sa_ll[0], sa_ll[1], sa_ll[3], cls.name)  # noqa: E501
+                lvl = 3
 
-    def recv_raw(self, x=MTU):
-        # type: (int) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]  # noqa: E501
-        """Receives a packet, then returns a tuple containing (cls, pkt_data, time)"""  # noqa: E501
-        pkt, sa_ll, ts = self._recv_raw(self.ins, x)
-        if self.outs and sa_ll[2] == socket.PACKET_OUTGOING:
-            return None, None, None
-        if ts is None:
-            ts = get_last_packet_timestamp(self.ins)
-        return self.LL, pkt, ts
+            try:
+                pkt = cls(data, **kwargs)
+            except KeyboardInterrupt:
+                raise
+            except Exception:
+                if conf.debug_dissector:
+                    raise
+                pkt = conf.raw_layer(data)
+
+            if lvl == 2:
+                pkt = pkt.payload
+
+            if pkt is not None:
+                if ts is None:
+                    from scapy.arch.linux import get_last_packet_timestamp
+                    ts = get_last_packet_timestamp(self.ins)
+                pkt.time = ts
+            return pkt
 
-    def send(self, x):
-        # type: (Packet) -> int
-        try:
-            return SuperSocket.send(self, x)
-        except socket.error as msg:
-            if msg.errno == 22 and len(x) < conf.min_pkt_size:
-                padding = b"\x00" * (conf.min_pkt_size - len(x))
-                if isinstance(x, Packet):
-                    return SuperSocket.send(self, x / Padding(load=padding))
-                else:
-                    return SuperSocket.send(self, raw(x) + padding)
-            raise
+        def send(self, x):
+            # type: (Packet) -> int
+            try:
+                sx = raw(x)
+                if self.outs:
+                    x.sent_time = time.time()
+                    return self.outs.sendto(
+                        sx,
+                        (x.dst, 0)
+                    )
+            except AttributeError:
+                raise ValueError(
+                    "Missing 'dst' attribute in the first layer to be "
+                    "sent using a native L3 socket ! (make sure you passed the "
+                    "IP layer)"
+                )
+            except socket.error as msg:
+                log_runtime.error(msg)
+            return 0
+
+    class L3RawSocket6(L3RawSocket):
+        def __init__(self,
+                     type: int = ETH_P_IPV6,
+                     filter: Optional[str] = None,
+                     iface: Optional[_GlobInterfaceType] = None,
+                     promisc: Optional[bool] = None,
+                     nofilter: bool = False) -> None:
+            # NOTE: if fragmentation is needed, it will be done by the kernel (RFC 2292)  # noqa: E501
+            self.outs = socket.socket(
+                socket.AF_INET6,
+                socket.SOCK_RAW,
+                socket.IPPROTO_RAW
+            )
+            self.ins = socket.socket(
+                socket.AF_PACKET,
+                socket.SOCK_RAW,
+                socket.htons(type)
+            )
+            self.iface = cast(_GlobInterfaceType, iface)
 
 
-class L2ListenSocket(L2Socket):
-    desc = "read packets at layer 2 using Linux PF_PACKET sockets. Also receives the packets going OUT"  # noqa: E501
+class SimpleSocket(SuperSocket):
+    desc = "wrapper around a classic socket"
+    __selectable_force_select__ = True
+
+    def __init__(self, sock, basecls=None):
+        # type: (socket.socket, Optional[Type[Packet]]) -> None
+        self.ins = sock
+        self.outs = sock
+        if basecls is None:
+            basecls = conf.raw_layer
+        self.basecls = basecls
 
-    def send(self, x):
-        # type: (Packet) -> NoReturn
-        raise Scapy_Exception("Can't send anything with L2ListenSocket")
+    def recv_raw(self, x=MTU):
+        # type: (int) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]
+        return self.basecls, self.ins.recv(x), None
 
+    if WINDOWS:
+        @staticmethod
+        def select(sockets, remain=None):
+            # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
+            from scapy.automaton import select_objects
+            return select_objects(sockets, remain)
 
-class L3PacketSocket(L2Socket):
-    desc = "read/write packets at layer 3 using Linux PF_PACKET sockets"
 
-    def recv(self, x=MTU):
-        # type: (int) -> Optional[Packet]
-        pkt = SuperSocket.recv(self, x)
-        if pkt and self.lvl == 2:
-            pkt.payload.time = pkt.time
-            return pkt.payload
-        return pkt
+class StreamSocket(SimpleSocket):
+    """
+    Wrap a stream socket into a layer 2 SuperSocket
 
-    def send(self, x):
-        # type: (Packet) -> int
-        iff = x.route()[0]
-        if iff is None:
-            iff = network_name(conf.iface)
-        sdto = (iff, self.type)
-        self.outs.bind(sdto)
-        sn = self.outs.getsockname()
-        ll = lambda x: x  # type: Callable[[Packet], Packet]
-        type_x = type(x)
-        if type_x in conf.l3types:
-            sdto = (iff, conf.l3types.layer2num[type_x])
-        if sn[3] in conf.l2types:
-            ll = lambda x: conf.l2types.num2layer[sn[3]]() / x
-        if self.lvl == 3 and type_x != self.LL:
-            warning("Incompatible L3 types detected using %s instead of %s !",
-                    type_x, self.LL)
-            self.LL = type_x
-        sx = raw(ll(x))
-        x.sent_time = time.time()
-        try:
-            return self.outs.sendto(sx, sdto)
-        except socket.error as msg:
-            if msg.errno == 22 and len(sx) < conf.min_pkt_size:
-                return self.outs.send(
-                    sx + b"\x00" * (conf.min_pkt_size - len(sx))
-                )
-            elif conf.auto_fragment and msg.errno == 90:
-                i = 0
-                for p in x.fragment():
-                    i += self.outs.sendto(raw(ll(p)), sdto)
-                return i
-            else:
-                raise
+    :param sock: the socket to wrap
+    :param basecls: the base class packet to use to dissect the packet
+    """
+    desc = "transforms a stream socket into a layer 2"
 
+    def __init__(self,
+                 sock,  # type: socket.socket
+                 basecls=None,  # type: Optional[Type[Packet]]
+                 ):
+        # type: (...) -> None
+        from scapy.sessions import streamcls
+        self.rcvcls = streamcls(basecls or conf.raw_layer)
+        self.metadata: Dict[str, Any] = {}
+        self.streamsession: Dict[str, Any] = {}
+        self._buf = b""
+        super(StreamSocket, self).__init__(sock, basecls=basecls)
+
+    def recv(self, x=None, **kwargs):
+        # type: (Optional[int], Any) -> Optional[Packet]
+        if x is None:
+            x = MTU
+        # Block but in PEEK mode
+        data = self.ins.recv(x, socket.MSG_PEEK)
+        if data == b"":
+            raise EOFError
+        x = len(data)
+        pkt = self.rcvcls(self._buf + data, self.metadata, self.streamsession)
+        if pkt is None:  # Incomplete packet.
+            self._buf += self.ins.recv(x)
+            return self.recv(x)
+        self.metadata.clear()
+        # Strip any madding
+        pad = pkt.getlayer(conf.padding_layer)
+        if pad is not None and pad.underlayer is not None:
+            del pad.underlayer.payload
+        while pad is not None and not isinstance(pad, NoPayload):
+            x -= len(pad.load)
+            pad = pad.payload
+        # Only receive the packet length
+        self.ins.recv(x)
+        self._buf = b""
+        return pkt
 
-class VEthPair(object):
-    """
-    encapsulates a virtual Ethernet interface pair
-    """
 
-    def __init__(self, iface_name, peer_name):
-        # type: (str, str) -> None
-        if not LINUX:
-            # ToDo: do we need a kernel version check here?
-            raise ScapyInvalidPlatformException(
-                'Virtual Ethernet interface pair only available on Linux'
-            )
+class SSLStreamSocket(StreamSocket):
+    desc = "similar usage than StreamSocket but specialized for handling SSL-wrapped sockets"  # noqa: E501
 
-        self.ifaces = [iface_name, peer_name]
+    # Basically StreamSocket but we can't PEEK
 
-    def iface(self):
-        # type: () -> str
-        return self.ifaces[0]
+    def __init__(self, sock, basecls=None):
+        # type: (socket.socket, Optional[Type[Packet]]) -> None
+        from scapy.sessions import TCPSession
+        self.sess = TCPSession(app=True)
+        super(SSLStreamSocket, self).__init__(sock, basecls)
+
+    # 65535, the default value of x is the maximum length of a TLS record
+    def recv(self, x=None, **kwargs):
+        # type: (Optional[int], **Any) -> Optional[Packet]
+        if x is None:
+            x = MTU
+        # Block
+        data = self.ins.recv(x)
+        try:
+            pkt = self.sess.process(data, cls=self.basecls)  # type: ignore
+        except struct.error:
+            # Buffer underflow
+            pkt = None
+        if data == b"" and not pkt:
+            raise EOFError
+        if not pkt:
+            return self.recv(x)
+        return pkt
 
-    def peer(self):
-        # type: () -> str
-        return self.ifaces[1]
 
-    def setup(self):
-        # type: () -> None
-        """
-        create veth pair links
-        :raises subprocess.CalledProcessError if operation fails
-        """
-        subprocess.check_call(['ip', 'link', 'add', self.ifaces[0], 'type', 'veth', 'peer', 'name', self.ifaces[1]])  # noqa: E501
+class L2ListenTcpdump(SuperSocket):
+    desc = "read packets at layer 2 using tcpdump"
 
-    def destroy(self):
-        # type: () -> None
-        """
-        remove veth pair links
-        :raises subprocess.CalledProcessError if operation fails
-        """
-        subprocess.check_call(['ip', 'link', 'del', self.ifaces[0]])
+    def __init__(self,
+                 iface=None,  # type: Optional[_GlobInterfaceType]
+                 promisc=None,  # type: Optional[bool]
+                 filter=None,  # type: Optional[str]
+                 nofilter=False,  # type: bool
+                 prog=None,  # type: Optional[str]
+                 quiet=False,  # type: bool
+                 *arg,  # type: Any
+                 **karg  # type: Any
+                 ):
+        # type: (...) -> None
+        self.outs = None
+        args = ['-w', '-', '-s', '65535']
+        self.iface = "any"
+        if iface is None and (WINDOWS or DARWIN):
+            self.iface = iface = conf.iface
+        if promisc is None:
+            promisc = conf.sniff_promisc
+        if iface is not None:
+            args.extend(['-i', network_name(iface)])
+        if not promisc:
+            args.append('-p')
+        if not nofilter:
+            if conf.except_filter:
+                if filter:
+                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
+                else:
+                    filter = "not (%s)" % conf.except_filter
+        if filter is not None:
+            args.append(filter)
+        self.tcpdump_proc = tcpdump(
+            None, prog=prog, args=args, getproc=True, quiet=quiet)
+        self.reader = PcapReader(self.tcpdump_proc.stdout)
+        self.ins = self.reader  # type: ignore
+
+    def recv(self, x=MTU, **kwargs):
+        # type: (int, **Any) -> Optional[Packet]
+        return self.reader.recv(x, **kwargs)
 
-    def up(self):
+    def close(self):
         # type: () -> None
-        """
-        set veth pair links up
-        :raises subprocess.CalledProcessError if operation fails
-        """
-        for idx in [0, 1]:
-            subprocess.check_call(["ip", "link", "set", self.ifaces[idx], "up"])  # noqa: E501
+        SuperSocket.close(self)
+        self.tcpdump_proc.kill()
 
-    def down(self):
-        # type: () -> None
-        """
-        set veth pair links down
-        :raises subprocess.CalledProcessError if operation fails
-        """
-        for idx in [0, 1]:
-            subprocess.check_call(["ip", "link", "set", self.ifaces[idx], "down"])  # noqa: E501
+    @staticmethod
+    def select(sockets, remain=None):
+        # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
+        if (WINDOWS or DARWIN):
+            return sockets
+        return SuperSocket.select(sockets, remain=remain)
+
+
+# More abstract objects
+
+class IterSocket(SuperSocket):
+    desc = "wrapper around an iterable"
+    nonblocking_socket = True
+
+    def __init__(self, obj):
+        # type: (_PacketIterable) -> None
+        if not obj:
+            self.iter = iter([])  # type: Iterator[Packet]
+        elif isinstance(obj, IterSocket):
+            self.iter = obj.iter
+        elif isinstance(obj, SndRcvList):
+            def _iter(obj=cast(SndRcvList, obj)):
+                # type: (SndRcvList) -> Iterator[Packet]
+                for s, r in obj:
+                    if s.sent_time:
+                        s.time = s.sent_time
+                    yield s
+                    yield r
+            self.iter = _iter()
+        elif isinstance(obj, (list, PacketList)):
+            if isinstance(obj[0], bytes):
+                self.iter = iter(obj)
+            else:
+                self.iter = (y for x in obj for y in x)
+        else:
+            self.iter = obj.__iter__()
 
-    def __enter__(self):
-        # type: () -> VEthPair
-        self.setup()
-        self.up()
-        conf.ifaces.reload()
-        return self
+    @staticmethod
+    def select(sockets, remain=None):
+        # type: (List[SuperSocket], Any) -> List[SuperSocket]
+        return sockets
 
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        # type: (Any, Any, Any) -> None
-        self.destroy()
-        conf.ifaces.reload()
+    def recv(self, x=None, **kwargs):
+        # type: (Optional[int], Any) -> Optional[Packet]
+        try:
+            pkt = next(self.iter)
+            return pkt.__class__(bytes(pkt), **kwargs)
+        except StopIteration:
+            raise EOFError
+
+    def close(self):
+        # type: () -> None
+        pass
```

### Comparing `scapy-2.5.0rc3/scapy/arch/solaris.py` & `scapy-2.6.0rc1/scapy/arch/solaris.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/arch/unix.py` & `scapy-2.6.0rc1/scapy/arch/unix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Common customizations for all Unix-like operating systems other than Linux
 """
 
 import os
+import re
 import socket
 import struct
 from fcntl import ioctl
 
 import scapy.config
 import scapy.utils
 from scapy.config import conf
@@ -19,15 +20,15 @@
 from scapy.error import log_runtime, warning
 from scapy.interfaces import network_name, NetworkInterface
 from scapy.pton_ntop import inet_pton
 from scapy.utils6 import in6_getscope, construct_source_candidate_set
 from scapy.utils6 import in6_isvalid, in6_ismlladdr, in6_ismnladdr
 
 # Typing imports
-from scapy.compat import (
+from typing import (
     List,
     Optional,
     Tuple,
     Union,
     cast,
 )
 
@@ -405,7 +406,22 @@
             cset = construct_source_candidate_set(destination, destination_plen, devaddrs)  # noqa: E501
 
         if len(cset):
             routes.append((destination, destination_plen, next_hop, dev, cset, metric))  # noqa: E501
 
     fd_netstat.close()
     return routes
+
+
+#######
+# DNS #
+#######
+
+def read_nameservers() -> List[str]:
+    """Return the nameservers configured by the OS
+    """
+    try:
+        with open('/etc/resolv.conf', 'r') as fd:
+            return re.findall(r"nameserver\s+([^\s]+)", fd.read())
+    except FileNotFoundError:
+        warning("Could not retrieve the OS's nameserver !")
+        return []
```

### Comparing `scapy-2.5.0rc3/scapy/arch/windows/__init__.py` & `scapy-2.6.0rc1/scapy/arch/windows/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,52 +9,60 @@
 
 from glob import glob
 import os
 import platform as platform_lib
 import socket
 import struct
 import subprocess as sp
-
 import warnings
 
-from scapy.arch.windows.structures import _windows_title, \
-    GetAdaptersAddresses, GetIpForwardTable, GetIpForwardTable2, \
-    get_service_status
+import winreg
+
+from scapy.arch.windows.structures import (
+    _windows_title,
+    GetAdaptersAddresses,
+    GetIpForwardTable,
+    GetIpForwardTable2,
+    get_service_status,
+)
 from scapy.consts import WINDOWS, WINDOWS_XP
 from scapy.config import conf, ProgPath
 from scapy.error import (
     Scapy_Exception,
     log_interactive,
     log_loading,
     log_runtime,
     warning,
 )
 from scapy.interfaces import NetworkInterface, InterfaceProvider, \
     dev_from_index, resolve_iface, network_name
-from scapy.pton_ntop import inet_ntop, inet_pton
+from scapy.pton_ntop import inet_ntop
 from scapy.utils import atol, itom, mac2str, str2mac
 from scapy.utils6 import construct_source_candidate_set, in6_getscope
-from scapy.data import ARPHDR_ETHER, load_manuf
-import scapy.libs.six as six
-from scapy.libs.six.moves import input, winreg
+from scapy.data import ARPHDR_ETHER
 from scapy.compat import plain_str
 from scapy.supersocket import SuperSocket
 
+# re-export
+from scapy.arch.common import get_if_raw_addr  # noqa: F401
+
 # Typing imports
-from scapy.compat import (
-    cast,
-    overload,
+from typing import (
     Any,
     Dict,
+    Iterator,
     List,
-    Literal,
     Optional,
     Tuple,
+    Type,
     Union,
+    cast,
+    overload,
 )
+from scapy.compat import Literal
 
 conf.use_pcap = True
 
 # These import must appear after setting conf.use_* variables
 from scapy.arch import libpcap  # noqa: E402
 from scapy.arch.libpcap import (  # noqa: E402
     NPCAP_PATH,
@@ -72,26 +80,26 @@
         else:
             conf.loopback_name = "Microsoft Loopback Adapter"
     except ValueError:
         conf.loopback_name = "Microsoft Loopback Adapter"
 
 # hot-patching socket for missing variables on Windows
 if not hasattr(socket, 'IPPROTO_IPIP'):
-    socket.IPPROTO_IPIP = 4
+    socket.IPPROTO_IPIP = 4  # type: ignore
 if not hasattr(socket, 'IP_RECVTTL'):
     socket.IP_RECVTTL = 12  # type: ignore
 if not hasattr(socket, 'IPV6_HDRINCL'):
     socket.IPV6_HDRINCL = 36  # type: ignore
 # https://github.com/python/cpython/issues/73701
 if not hasattr(socket, 'IPPROTO_IPV6'):
     socket.IPPROTO_IPV6 = 41
 if not hasattr(socket, 'SOL_IPV6'):
     socket.SOL_IPV6 = socket.IPPROTO_IPV6  # type: ignore
 if not hasattr(socket, 'IPPROTO_GRE'):
-    socket.IPPROTO_GRE = 47
+    socket.IPPROTO_GRE = 47  # type: ignore
 if not hasattr(socket, 'IPPROTO_AH'):
     socket.IPPROTO_AH = 51
 if not hasattr(socket, 'IPPROTO_ESP'):
     socket.IPPROTO_ESP = 50
 
 _WlanHelper = NPCAP_PATH + "\\WlanHelper.exe"
 
@@ -182,42 +190,25 @@
         self.tcpdump = win_find_exe("windump")
         self.tshark = win_find_exe("tshark")
         self.tcpreplay = win_find_exe("tcpreplay")
         self.display = self._default
         self.hexedit = win_find_exe("hexer")
         self.sox = win_find_exe("sox")
         self.wireshark = win_find_exe("wireshark", "wireshark")
-        self.usbpcapcmd = win_find_exe(
-            "USBPcapCMD",
-            installsubdir="USBPcap",
-            env="programfiles"
-        )
+        self.extcap_folders = [
+            os.path.join(os.environ.get("appdata", ""), "Wireshark", "extcap"),
+            os.path.join(os.environ.get("programfiles", ""), "Wireshark", "extcap"),
+        ]
         self.powershell = win_find_exe(
             "powershell",
             installsubdir="System32\\WindowsPowerShell\\v1.0",
             env="SystemRoot"
         )
-        self.cscript = win_find_exe("cscript", installsubdir="System32",
-                                    env="SystemRoot")
         self.cmd = win_find_exe("cmd", installsubdir="System32",
                                 env="SystemRoot")
-        if self.wireshark:
-            try:
-                new_manuf = load_manuf(
-                    os.path.sep.join(
-                        self.wireshark.split(os.path.sep)[:-1]
-                    ) + os.path.sep + "manuf"
-                )
-            except (IOError, OSError):  # FileNotFoundError not available on Py2 - using OSError  # noqa: E501
-                log_loading.warning("Wireshark is installed, but cannot read manuf !")  # noqa: E501
-                new_manuf = None
-            if new_manuf:
-                # Inject new ManufDB
-                conf.manufdb.__dict__.clear()
-                conf.manufdb.__dict__.update(new_manuf.__dict__)
 
 
 def _exec_cmd(command):
     # type: (str) -> Tuple[bytes, int]
     """Call a CMD command and return the output and returncode"""
     proc = sp.Popen(command,
                     stdout=sp.PIPE,
@@ -260,62 +251,59 @@
         # type: (Dict[str, Any]) -> str
         size = x["physical_address_length"]
         if size != 6:
             return ""
         data = bytearray(x["physical_address"])
         return str2mac(bytes(data)[:size])
 
+    def _resolve_ips(y):
+        # type: (List[Dict[str, Any]]) -> List[str]
+        if not isinstance(y, list):
+            return []
+        ips = []
+        for ip in y:
+            addr = ip['address']['address'].contents
+            if addr.si_family == socket.AF_INET6:
+                ip_key = "Ipv6"
+                si_key = "sin6_addr"
+            else:
+                ip_key = "Ipv4"
+                si_key = "sin_addr"
+            data = getattr(addr, ip_key)
+            data = getattr(data, si_key)
+            data = bytes(bytearray(data.byte))
+            # Build IP
+            if data:
+                ips.append(inet_ntop(addr.si_family, data))
+        return ips
+
     def _get_ips(x):
         # type: (Dict[str, Any]) -> List[str]
         unicast = x['first_unicast_address']
         anycast = x['first_anycast_address']
         multicast = x['first_multicast_address']
 
-        def _resolve_ips(y):
-            # type: (List[Dict[str, Any]]) -> List[str]
-            if not isinstance(y, list):
-                return []
-            ips = []
-            for ip in y:
-                addr = ip['address']['address'].contents
-                if addr.si_family == socket.AF_INET6:
-                    ip_key = "Ipv6"
-                    si_key = "sin6_addr"
-                else:
-                    ip_key = "Ipv4"
-                    si_key = "sin_addr"
-                data = getattr(addr, ip_key)
-                data = getattr(data, si_key)
-                data = bytes(bytearray(data.byte))
-                # Build IP
-                if data:
-                    ips.append(inet_ntop(addr.si_family, data))
-            return ips
-
         ips = []
         ips.extend(_resolve_ips(unicast))
         if extended:
             ips.extend(_resolve_ips(anycast))
             ips.extend(_resolve_ips(multicast))
         return ips
 
-    if six.PY2:
-        _str_decode = lambda x: x.encode('utf8', errors='ignore')
-    else:
-        _str_decode = plain_str
     return [
         {
-            "name": _str_decode(x["friendly_name"]),
+            "name": plain_str(x["friendly_name"]),
             "index": x["interface_index"],
-            "description": _str_decode(x["description"]),
-            "guid": _str_decode(x["adapter_name"]),
+            "description": plain_str(x["description"]),
+            "guid": plain_str(x["adapter_name"]),
             "mac": _get_mac(x),
             "ipv4_metric": 0 if WINDOWS_XP else x["ipv4_metric"],
             "ipv6_metric": 0 if WINDOWS_XP else x["ipv6_metric"],
-            "ips": _get_ips(x)
+            "ips": _get_ips(x),
+            "nameservers": _resolve_ips(x["first_dns_server_address"])
         } for x in GetAdaptersAddresses()
     ]
 
 
 def _pcapname_to_guid(pcap_name):
     # type: (str) -> str
     """Converts a Winpcap/Npcap pcpaname to its guid counterpart.
@@ -330,14 +318,15 @@
     """A network interface of your local host"""
 
     def __init__(self, provider, data=None):
         # type: (WindowsInterfacesProvider, Optional[Dict[str, Any]]) -> None
         self.cache_mode = None  # type: Optional[bool]
         self.ipv4_metric = None  # type: Optional[int]
         self.ipv6_metric = None  # type: Optional[int]
+        self.nameservers = []  # type: List[str]
         self.guid = None  # type: Optional[str]
         self.raw80211 = None  # type: Optional[bool]
         super(NetworkInterface_Win, self).__init__(provider, data)
 
     def update(self, data):
         # type: (Dict[str, Any]) -> None
         """Update info about a network interface according
@@ -345,14 +334,15 @@
         """
         # Populated early because used below
         self.network_name = data['network_name']
         # Windows specific
         self.guid = data['guid']
         self.ipv4_metric = data['ipv4_metric']
         self.ipv6_metric = data['ipv6_metric']
+        self.nameservers = data['nameservers']
 
         try:
             # Npcap loopback interface
             if conf.use_npcap and self.network_name == NPCAP_LOOPBACK_NAME:
                 # https://nmap.org/npcap/guide/npcap-devguide.html
                 data["mac"] = "00:00:00:00:00:00"
                 data["ip"] = "127.0.0.1"
@@ -477,23 +467,23 @@
         # type: (int) -> bool
         """Set the channel of the interface (1-14):
         Only available with Npcap."""
         # According to https://nmap.org/npcap/guide/npcap-devguide.html#npcap-feature-dot11  # noqa: E501
         self._check_npcap_requirement()
         return self._npcap_set("channel", str(channel))
 
-    def frequence(self):
+    def frequency(self):
         # type: () -> int
-        """Get the frequence of the interface.
+        """Get the frequency of the interface.
         Only available with Npcap."""
         # According to https://nmap.org/npcap/guide/npcap-devguide.html#npcap-feature-dot11  # noqa: E501
         self._check_npcap_requirement()
         return int(self._npcap_get("freq"))
 
-    def setfrequence(self, freq):
+    def setfrequency(self, freq):
         # type: (int) -> bool
         """Set the channel of the interface (1-14):
         Only available with Npcap."""
         # According to https://nmap.org/npcap/guide/npcap-devguide.html#npcap-feature-dot11  # noqa: E501
         self._check_npcap_requirement()
         return self._npcap_set("freq", str(freq))
 
@@ -618,19 +608,32 @@
             if "Loopback" in i['name']:
                 i['name'] = conf.loopback_name
             if i['guid']:
                 if conf.use_npcap and i['name'] == conf.loopback_name:
                     i['guid'] = NPCAP_LOOPBACK_NAME
                 windows_interfaces[i['guid']] = i
 
+        def iterinterfaces() -> Iterator[
+            Tuple[str, Optional[str], List[str], int, str, Optional[Dict[str, Any]]]
+        ]:
+            if conf.use_pcap:
+                # We have a libpcap provider: enrich pcap interfaces with
+                # Windows data
+                for netw, if_data in conf.cache_pcapiflist.items():
+                    name, ips, flags, _ = if_data
+                    guid = _pcapname_to_guid(netw)
+                    data = windows_interfaces.get(guid, None)
+                    yield netw, name, ips, flags, guid, data
+            else:
+                # We don't have a libpcap provider: only use Windows data
+                for guid, data in windows_interfaces.items():
+                    yield guid, None, [], 0, guid, data
+
         index = 0
-        for netw, if_data in six.iteritems(conf.cache_pcapiflist):
-            name, ips, flags, _ = if_data
-            guid = _pcapname_to_guid(netw)
-            data = windows_interfaces.get(guid, None)
+        for netw, name, ips, flags, guid, data in iterinterfaces():
             if data:
                 # Exists in Windows registry
                 data['network_name'] = netw
                 data['ips'] = list(set(data['ips'] + ips))
                 data['flags'] = flags
             else:
                 # Only in [Wi]npcap
@@ -641,60 +644,60 @@
                     'index': index,
                     'guid': guid,
                     'network_name': netw,
                     'mac': '00:00:00:00:00:00',
                     'ipv4_metric': 0,
                     'ipv6_metric': 0,
                     'ips': ips,
-                    'flags': flags
+                    'flags': flags,
+                    'nameservers': [],
                 }
             # No KeyError will happen here, as we get it from cache
-            results[guid] = NetworkInterface_Win(self, data)
+            results[netw] = NetworkInterface_Win(self, data)
         return results
 
     def reload(self):
         # type: () -> Dict[str, NetworkInterface]
         """Reload interface list"""
         self.restarted_adapter = False
         if conf.use_pcap:
             # Reload from Winpcapy
             from scapy.arch.libpcap import load_winpcapy
             load_winpcapy()
         return self.load()
 
+    def _l3socket(self, dev, ipv6):
+        # type: (NetworkInterface, bool) -> Type[SuperSocket]
+        """Return L3 socket used by interfaces of this provider"""
+        if ipv6:
+            return conf.L3socket6
+        else:
+            return conf.L3socket
+
 
 # Register provider
 conf.ifaces.register_provider(WindowsInterfacesProvider)
 
 
 def get_ips(v6=False):
     # type: (bool) -> Dict[NetworkInterface, List[str]]
     """Returns all available IPs matching to interfaces, using the windows system.
     Should only be used as a WinPcapy fallback.
 
     :param v6: IPv6 addresses
     """
     res = {}
-    for iface in six.itervalues(conf.ifaces):
+    for iface in conf.ifaces.values():
         if v6:
             res[iface] = iface.ips[6]
         else:
             res[iface] = iface.ips[4]
     return res
 
 
-def get_if_raw_addr(iff):
-    # type: (Union[NetworkInterface, str]) -> bytes
-    """Return the raw IPv4 address of interface"""
-    iff = resolve_iface(iff)
-    if not iff.ip:
-        return b"\x00" * 4
-    return inet_pton(socket.AF_INET, iff.ip)
-
-
 def get_ip_from_name(ifname, v6=False):
     # type: (str, bool) -> str
     """Backward compatibility: indirectly calls get_ips
     Deprecated.
     """
     warnings.warn(
         "get_ip_from_name is deprecated. Use the `ip` attribute of the iface "
@@ -966,19 +969,19 @@
         return
     # Remove all conf.loopback_name routes
     for route in list(conf.route.routes):
         iface = route[3]
         if iface == conf.loopback_name:
             conf.route.routes.remove(route)
     # Remove conf.loopback_name interface
-    for devname, iface in list(conf.ifaces.items()):
-        if iface == conf.loopback_name:
+    for devname, ifname in list(conf.ifaces.items()):
+        if ifname == conf.loopback_name:
             conf.ifaces.pop(devname)
     # Inject interface
-    conf.ifaces["{0XX00000-X000-0X0X-X00X-00XXXX000XXX}"] = adapter
+    conf.ifaces[r"\Device\NPF_{0XX00000-X000-0X0X-X00X-00XXXX000XXX}"] = adapter
     conf.loopback_name = adapter.network_name
     if isinstance(conf.iface, NetworkInterface):
         if conf.iface.network_name == conf.loopback_name:
             conf.iface = adapter
     conf.netcache.arp_cache["127.0.0.1"] = "ff:ff:ff:ff:ff:ff"  # type: ignore
     conf.netcache.in6_neighbor["::1"] = "ff:ff:ff:ff:ff:ff"  # type: ignore
     # Build the packed network addresses
@@ -1017,7 +1020,22 @@
     def __init__(self, *args, **kargs):
         # type: (*Any, **Any) -> None
         raise RuntimeError(
             "Sniffing and sending packets is not available at layer 2: "
             "winpcap is not installed. You may use conf.L3socket or"
             "conf.L3socket6 to access layer 3"
         )
+
+
+#######
+# DNS #
+#######
+
+def read_nameservers() -> List[str]:
+    """Return the nameservers configured by the OS (on the default interface)
+    """
+    # Windows has support for different DNS servers on each network interface,
+    # but to be cross-platform we only return the servers for the default one.
+    if isinstance(conf.iface, NetworkInterface_Win):
+        return conf.iface.nameservers
+    else:
+        return []
```

### Comparing `scapy-2.5.0rc3/scapy/arch/windows/native.py` & `scapy-2.6.0rc1/scapy/arch/windows/native.py`

 * *Files 6% similar despite different names*

```diff
@@ -48,21 +48,21 @@
 import time
 
 from scapy.automaton import select_objects
 from scapy.arch.windows.structures import GetIcmpStatistics
 from scapy.compat import raw
 from scapy.config import conf
 from scapy.data import MTU
-from scapy.error import Scapy_Exception, warning
+from scapy.error import Scapy_Exception, log_runtime
 from scapy.packet import Packet
 from scapy.interfaces import resolve_iface, _GlobInterfaceType
 from scapy.supersocket import SuperSocket
 
 # Typing imports
-from scapy.compat import (
+from typing import (
     Any,
     List,
     Optional,
     Tuple,
     Type,
 )
 
@@ -73,97 +73,120 @@
     desc = "a native Layer 3 (IPv4) raw socket under Windows"
     nonblocking_socket = True
     __selectable_force_select__ = True  # see automaton.py
     __slots__ = ["promisc", "cls", "ipv6", "proto"]
 
     def __init__(self,
                  iface=None,  # type: Optional[_GlobInterfaceType]
-                 proto=socket.IPPROTO_IP,  # type: int
+                 proto=None,  # type: Optional[int]
                  ttl=128,  # type: int
                  ipv6=False,  # type: bool
                  promisc=True,  # type: bool
                  **kwargs  # type: Any
                  ):
         # type: (...) -> None
         from scapy.layers.inet import IP
         from scapy.layers.inet6 import IPv6
         for kwarg in kwargs:
-            warning("Dropping unsupported option: %s" % kwarg)
+            log_runtime.warning("Dropping unsupported option: %s" % kwarg)
         self.iface = iface and resolve_iface(iface) or conf.iface
         af = socket.AF_INET6 if ipv6 else socket.AF_INET
-        self.proto = proto
-        if ipv6:
-            from scapy.arch import get_if_addr6
-            self.host_ip6 = get_if_addr6(conf.iface) or "::1"
-            if proto == socket.IPPROTO_IP:
-                # We'll restrict ourselves to UDP, as TCP isn't bindable
-                # on AF_INET6
-                self.proto = socket.IPPROTO_UDP
-        # On Windows, with promisc=False, you won't get much
         self.ipv6 = ipv6
+        # Proto and cls
+        if proto is None:
+            if self.ipv6:
+                # On IPv6, the header isn't returned with recvfrom().
+                # We don't want to guess if it's TCP, UDP or SCTP.. so ask for proto
+                # (This would be fixable if Python supported recvmsg() on Windows)
+                log_runtime.warning(
+                    "Due to restrictions, 'proto' must be provided when "
+                    "opening raw IPv6 sockets. Defaulting to socket.IPPROTO_UDP"
+                )
+                self.proto = socket.IPPROTO_UDP
+            else:
+                self.proto = socket.IPPROTO_IP
+        elif self.ipv6 and proto == socket.IPPROTO_TCP:
+            # Ah, sadly this isn't supported either.
+            log_runtime.warning(
+                "Be careful, socket.IPPROTO_TCP doesn't work in raw sockets on "
+                "Windows, so this is equivalent to socket.IPPROTO_IP."
+            )
+            self.proto = socket.IPPROTO_IP
+        else:
+            self.proto = proto
         self.cls = IPv6 if ipv6 else IP
+        # Promisc
         if promisc is None:
             promisc = conf.sniff_promisc
         self.promisc = promisc
         # Notes:
         # - IPPROTO_RAW only works to send packets.
         # - IPPROTO_IPV6 exists in MSDN docs, but using it will result in
         # no packets being received. Same for its options (IPV6_HDRINCL...)
         # However, using IPPROTO_IP with AF_INET6 will still receive
         # the IPv6 packets
         try:
+            # Listening on AF_INET6 IPPROTO_IPV6 is broken. Use IPPROTO_IP
             self.ins = socket.socket(af,
                                      socket.SOCK_RAW,
-                                     self.proto)
+                                     socket.IPPROTO_IP)
             self.outs = socket.socket(af,
                                       socket.SOCK_RAW,
                                       socket.IPPROTO_RAW)
         except OSError as e:
-            if e.errno == 10013:
+            if e.errno == 13:
                 raise OSError("Windows native L3 Raw sockets are only "
                               "usable as administrator ! "
-                              "Install Winpcap/Npcap to workaround !")
+                              "Please install Npcap to workaround !")
             raise
         self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         self.outs.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 2**30)
         self.outs.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 2**30)
-        # IOCTL Include IP headers
-        self.ins.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
-        self.outs.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
         # set TTL
         self.ins.setsockopt(socket.IPPROTO_IP, socket.IP_TTL, ttl)
         self.outs.setsockopt(socket.IPPROTO_IP, socket.IP_TTL, ttl)
-        # Bind on all ports
-        host = self.iface.ip if self.iface.ip else socket.gethostname()
-        self.ins.bind((host, 0))
-        self.ins.setblocking(False)
         # Get as much data as possible: reduce what is cropped
         if ipv6:
+            # IPV6_HDRINCL is broken. Use IP_HDRINCL even on IPv6
+            self.outs.setsockopt(socket.IPPROTO_IPV6, socket.IP_HDRINCL, 1)
             try:  # Not all Windows versions
                 self.ins.setsockopt(socket.IPPROTO_IPV6,
                                     socket.IPV6_RECVTCLASS, 1)
                 self.ins.setsockopt(socket.IPPROTO_IPV6,
                                     socket.IPV6_HOPLIMIT, 1)
             except (OSError, socket.error):
                 pass
         else:
+            # IOCTL Include IP headers
+            self.ins.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
+            self.outs.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
             try:  # Not Windows XP
                 self.ins.setsockopt(socket.IPPROTO_IP,
                                     socket.IP_RECVDSTADDR, 1)
             except (OSError, socket.error):
                 pass
             try:  # Windows 10+ recent builds only
                 self.ins.setsockopt(
                     socket.IPPROTO_IP,
                     socket.IP_RECVTTL,  # type: ignore
                     1
                 )
             except (OSError, socket.error):
                 pass
+        # Bind on all ports
+        if ipv6:
+            from scapy.arch import get_if_addr6
+            host = get_if_addr6(self.iface)
+        else:
+            from scapy.arch import get_if_addr
+            host = get_if_addr(self.iface)
+        self.ins.bind((host or socket.gethostname(), 0))
+        # self.ins.setblocking(False)
+        # Set promisc
         if promisc:
             # IOCTL Receive all packets
             self.ins.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
 
     def send(self, x):
         # type: (Packet) -> int
         data = raw(x)
@@ -193,27 +216,33 @@
 
     def recv_raw(self, x=MTU):
         # type: (int) -> Tuple[Type[Packet], bytes, float]
         try:
             data, address = self.ins.recvfrom(x)
         except io.BlockingIOError:
             return None, None, None  # type: ignore
-        from scapy.layers.inet import IP
-        from scapy.layers.inet6 import IPv6
         if self.ipv6:
+            from scapy.layers.inet6 import IPv6
             # AF_INET6 does not return the IPv6 header. Let's build it
             # (host, port, flowinfo, scopeid)
             host, _, flowinfo, _ = address
-            header = raw(IPv6(src=host,
-                              dst=self.host_ip6,
-                              fl=flowinfo,
-                              nh=self.proto,  # fixed for AF_INET6
-                              plen=len(data)))
+            header = raw(
+                IPv6(
+                    src=host,
+                    dst="::",
+                    fl=flowinfo,
+                    # when IPPROTO_IP (0) is selected, we have no idea what's nh,
+                    # so set an invalid value.
+                    nh=self.proto or 0xFF,
+                    plen=len(data)
+                )
+            )
             return IPv6, header + data, time.time()
         else:
+            from scapy.layers.inet import IP
             return IP, data, time.time()
 
     def close(self):
         # type: () -> None
         if not self.closed and self.promisc:
             self.ins.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
         super(L3WinSocket, self).close()
@@ -225,15 +254,18 @@
 
 
 class L3WinSocket6(L3WinSocket):
     desc = "a native Layer 3 (IPv6) raw socket under Windows"
 
     def __init__(self, **kwargs):
         # type: (**Any) -> None
-        super(L3WinSocket6, self).__init__(ipv6=True, **kwargs)
+        super(L3WinSocket6, self).__init__(
+            ipv6=True,
+            **kwargs,
+        )
 
 
 def open_icmp_firewall(host):
     # type: (str) -> int
     """Temporarily open the ICMP firewall. Tricks Windows into allowing
     ICMP packets for a short period of time (~ 1 minute)"""
     # We call ping with a timeout of 1ms: will return instantly
```

### Comparing `scapy-2.5.0rc3/scapy/arch/windows/structures.py` & `scapy-2.6.0rc1/scapy/arch/windows/structures.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,36 +15,41 @@
 from ctypes import (
     POINTER,
     Structure,
     WINFUNCTYPE,
     byref,
     create_string_buffer,
 )
+from socket import AddressFamily
+
 from scapy.config import conf
 from scapy.consts import WINDOWS_XP
+from scapy.data import MTU
 
 # Typing imports
-from scapy.compat import (
-    AddressFamily,
+from typing import (
     Any,
     Dict,
+    IO,
     List,
     Optional,
+    Tuple,
 )
 
 ANY_SIZE = 65500  # FIXME quite inefficient :/
 NO_ERROR = 0x0
 
 CHAR = ctypes.c_char
 DWORD = ctypes.wintypes.DWORD
 BOOL = ctypes.wintypes.BOOL
 BOOLEAN = ctypes.wintypes.BOOLEAN
 ULONG = ctypes.wintypes.ULONG
 ULONGLONG = ctypes.c_ulonglong
 HANDLE = ctypes.wintypes.HANDLE
+LPVOID = ctypes.wintypes.LPVOID
 LPWSTR = ctypes.wintypes.LPWSTR
 VOID = ctypes.c_void_p
 INT = ctypes.c_int
 UINT = ctypes.wintypes.UINT
 UINT8 = ctypes.c_uint8
 UINT16 = ctypes.c_uint16
 UINT32 = ctypes.c_uint32
@@ -602,7 +607,65 @@
     if res != NO_ERROR:
         raise RuntimeError("Error retrieving table (%d)" % res)
     results = []
     for i in range(table.contents.NumEntries):
         results.append(_struct_to_dict(table.contents.Table[i]))
     _FreeMibTable(table)
     return results
+
+
+##############
+#### FIFO ####
+##############
+
+class _SECURITY_ATTRIBUTES(Structure):
+    _fields_ = [("nLength", DWORD),
+                ("lpSecurityDescriptor", LPVOID),
+                ("bInheritHandle", BOOL)]
+
+
+LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES)
+
+
+def _get_win_fifo() -> Tuple[str, Any]:
+    """Create a windows fifo and returns the (client file, server fd)
+    """
+    from scapy.volatile import RandString
+    f = r"\\.\pipe\scapy%s" % str(RandString(6))
+    buffer = create_string_buffer(ctypes.sizeof(_SECURITY_ATTRIBUTES))
+    sec = ctypes.cast(buffer, LPSECURITY_ATTRIBUTES)
+    sec.contents.nLength = ctypes.sizeof(_SECURITY_ATTRIBUTES)
+    res = ctypes.windll.kernel32.CreateNamedPipeA(
+        create_string_buffer(f.encode()),
+        0x00000003 | 0x40000000,
+        0,
+        1, 65536, 65536,
+        300,
+        sec,
+    )
+    if res == -1:
+        raise OSError(ctypes.FormatError())
+    return f, res
+
+
+def _win_fifo_open(fd: Any) -> IO[bytes]:
+    """Connect NamedPipe and return a fake open() file
+    """
+    ctypes.windll.kernel32.ConnectNamedPipe(fd, None)
+
+    class _opened(IO[bytes]):
+        def read(self, x: int = MTU) -> bytes:
+            buf = ctypes.create_string_buffer(x)
+            res = ctypes.windll.kernel32.ReadFile(
+                fd,
+                buf,
+                x,
+                None,
+                None,
+            )
+            if res == 0:
+                raise OSError(ctypes.FormatError())
+            return buf.raw
+        def close(self) -> None:
+            # ignore failures
+            ctypes.windll.kernel32.CloseHandle(fd)
+    return _opened()  # type: ignore
```

### Comparing `scapy-2.5.0rc3/scapy/as_resolvers.py` & `scapy-2.6.0rc1/scapy/as_resolvers.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,20 +4,19 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Resolve Autonomous Systems (AS).
 """
 
 
-from __future__ import absolute_import
 import socket
 from scapy.config import conf
 from scapy.compat import plain_str
 
-from scapy.compat import (
+from typing import (
     Any,
     Optional,
     Tuple,
     List,
 )
```

### Comparing `scapy-2.5.0rc3/scapy/asn1/asn1.py` & `scapy-2.6.0rc1/scapy/asn1/asn1.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,41 +4,39 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 # Acknowledgment: Maxence Tury <maxence.tury@ssi.gouv.fr>
 
 """
 ASN.1 (Abstract Syntax Notation One)
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 import random
 
 from datetime import datetime, timedelta, tzinfo
 from scapy.config import conf
 from scapy.error import Scapy_Exception, warning
 from scapy.volatile import RandField, RandIP, GeneralizedTime
 from scapy.utils import Enum_metaclass, EnumElement, binrepr
 from scapy.compat import plain_str, bytes_encode, chb, orb
-import scapy.libs.six as six
 
-from scapy.compat import (
+from typing import (
     Any,
     AnyStr,
     Dict,
     Generic,
     List,
     Optional,
     Tuple,
     Type,
-    TypeVar,
     Union,
-    _Generic_metaclass,
     cast,
     TYPE_CHECKING,
 )
+from typing import (
+    TypeVar,
+)
 
 if TYPE_CHECKING:
     from scapy.asn1.ber import BERcodec_Object
 
 try:
     from datetime import timezone
 except ImportError:
@@ -75,17 +73,15 @@
     def __init__(self, objlist=None):
         # type: (Optional[List[Type[ASN1_Object[Any]]]]) -> None
         if objlist:
             self.objlist = objlist
         else:
             self.objlist = [
                 x._asn1_obj
-                for x in six.itervalues(
-                    ASN1_Class_UNIVERSAL.__rdict__  # type: ignore
-                )
+                for x in ASN1_Class_UNIVERSAL.__rdict__.values()  # type: ignore
                 if hasattr(x, "_asn1_obj")
             ]
         self.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"  # noqa: E501
 
     def _fix(self, n=0):
         # type: (int) -> ASN1_Object[Any]
         o = random.choice(self.objlist)
@@ -145,16 +141,15 @@
         return cls._stem
 
 
 class ASN1_Codecs_metaclass(Enum_metaclass):
     element_class = ASN1Codec
 
 
-@six.add_metaclass(ASN1_Codecs_metaclass)
-class ASN1_Codecs:
+class ASN1_Codecs(metaclass=ASN1_Codecs_metaclass):
     BER = cast(ASN1Codec, 1)
     DER = cast(ASN1Codec, 2)
     PER = cast(ASN1Codec, 3)
     CER = cast(ASN1Codec, 4)
     LWER = cast(ASN1Codec, 5)
     BACnet = cast(ASN1Codec, 6)
     OER = cast(ASN1Codec, 7)
@@ -211,39 +206,38 @@
     def __new__(cls,
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
         # type: (...) -> Type[ASN1_Class]
         for b in bases:
-            for k, v in six.iteritems(b.__dict__):
+            for k, v in b.__dict__.items():
                 if k not in dct and isinstance(v, ASN1Tag):
                     dct[k] = v.clone()
 
         rdict = {}
-        for k, v in six.iteritems(dct):
+        for k, v in dct.items():
             if isinstance(v, int):
                 v = ASN1Tag(k, v)
                 dct[k] = v
                 rdict[v] = v
             elif isinstance(v, ASN1Tag):
                 rdict[v] = v
         dct["__rdict__"] = rdict
 
         ncls = cast('Type[ASN1_Class]',
                     type.__new__(cls, name, bases, dct))
-        for v in six.itervalues(ncls.__dict__):
+        for v in ncls.__dict__.values():
             if isinstance(v, ASN1Tag):
                 # overwrite ASN1Tag contexts, even cloned ones
                 v.context = ncls
         return ncls
 
 
-@six.add_metaclass(ASN1_Class_metaclass)
-class ASN1_Class:
+class ASN1_Class(metaclass=ASN1_Class_metaclass):
     pass
 
 
 class ASN1_Class_UNIVERSAL(ASN1_Class):
     name = "UNIVERSAL"
     # Those casts are made so that MyPy understands what the
     # metaclass does in the background.
@@ -277,19 +271,20 @@
     ISO646_STRING = cast(ASN1Tag, 26)       # aka VISIBLE_STRING
     GENERAL_STRING = cast(ASN1Tag, 27)
     UNIVERSAL_STRING = cast(ASN1Tag, 28)
     CHAR_STRING = cast(ASN1Tag, 29)
     BMP_STRING = cast(ASN1Tag, 30)
     IPADDRESS = cast(ASN1Tag, 0 | 0x40)     # application-specific encoding
     COUNTER32 = cast(ASN1Tag, 1 | 0x40)     # application-specific encoding
+    COUNTER64 = cast(ASN1Tag, 6 | 0x40)     # application-specific encoding
     GAUGE32 = cast(ASN1Tag, 2 | 0x40)       # application-specific encoding
     TIME_TICKS = cast(ASN1Tag, 3 | 0x40)    # application-specific encoding
 
 
-class ASN1_Object_metaclass(_Generic_metaclass):
+class ASN1_Object_metaclass(type):
     def __new__(cls,
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
         # type: (...) -> Type[ASN1_Object[Any]]
         c = cast(
@@ -302,16 +297,15 @@
             warning("Error registering %r" % c.tag)
         return c
 
 
 _K = TypeVar('_K')
 
 
-@six.add_metaclass(ASN1_Object_metaclass)
-class ASN1_Object(Generic[_K]):
+class ASN1_Object(Generic[_K], metaclass=ASN1_Object_metaclass):
     tag = ASN1_Class_UNIVERSAL.ANY
 
     def __init__(self, val):
         # type: (_K) -> None
         self.val = val
 
     def enc(self, codec):
@@ -358,17 +352,24 @@
         # type: (Any) -> bool
         return bool(self.val >= other)
 
     def __ne__(self, other):
         # type: (Any) -> bool
         return bool(self.val != other)
 
-    def command(self):
-        # type: () -> str
-        return "%s(%s)" % (self.__class__.__name__, repr(self.val))
+    def command(self, json=False):
+        # type: (bool) -> Union[Dict[str, str], str]
+        if json:
+            if isinstance(self.val, bytes):
+                val = self.val.decode("utf-8", errors="backslashreplace")
+            else:
+                val = repr(self.val)
+            return {"type": self.__class__.__name__, "value": val}
+        else:
+            return "%s(%s)" % (self.__class__.__name__, repr(self.val))
 
 
 #######################
 #     ASN1 objects    #
 #######################
 
 # on the whole, we order the classes by ASN1_Class_UNIVERSAL tag value
@@ -489,14 +490,23 @@
             object.__setattr__(self, "unused_bits", unused_bits)
         elif name == "unused_bits":
             warning("Invalid operation: unused_bits rewriting "
                     "is not supported.")
         else:
             object.__setattr__(self, name, value)
 
+    def set(self, i, val):
+        # type: (int, str) -> None
+        """
+        Sets bit 'i' to value 'val' (starting from 0)
+        """
+        val = str(val)
+        assert val in ['0', '1']
+        self.val = self.val[:i] + val + self.val[i + 1:]
+
     def __repr__(self):
         # type: () -> str
         s = self.val_readable
         if len(s) > 16:
             s = s[:10] + b"..." + s[-10:]
         v = self.val
         if len(v) > 20:
@@ -720,14 +730,18 @@
     tag = ASN1_Class_UNIVERSAL.IPADDRESS
 
 
 class ASN1_COUNTER32(ASN1_INTEGER):
     tag = ASN1_Class_UNIVERSAL.COUNTER32
 
 
+class ASN1_COUNTER64(ASN1_INTEGER):
+    tag = ASN1_Class_UNIVERSAL.COUNTER64
+
+
 class ASN1_GAUGE32(ASN1_INTEGER):
     tag = ASN1_Class_UNIVERSAL.GAUGE32
 
 
 class ASN1_TIME_TICKS(ASN1_INTEGER):
     tag = ASN1_Class_UNIVERSAL.TIME_TICKS
```

### Comparing `scapy-2.5.0rc3/scapy/asn1/ber.py` & `scapy-2.6.0rc1/scapy/asn1/ber.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,45 +7,43 @@
 
 """
 Basic Encoding Rules (BER) for ASN.1
 """
 
 # Good read: https://luca.ntop.org/Teaching/Appunti/asn1.html
 
-from __future__ import absolute_import
 from scapy.error import warning
 from scapy.compat import chb, orb, bytes_encode
 from scapy.utils import binrepr, inet_aton, inet_ntoa
 from scapy.asn1.asn1 import (
+    ASN1Tag,
     ASN1_BADTAG,
     ASN1_BadTag_Decoding_Error,
     ASN1_Class,
     ASN1_Class_UNIVERSAL,
     ASN1_Codecs,
     ASN1_DECODING_ERROR,
     ASN1_Decoding_Error,
     ASN1_Encoding_Error,
     ASN1_Error,
     ASN1_Object,
     _ASN1_ERROR,
 )
-from scapy.libs import six
 
-from scapy.compat import (
+from typing import (
     Any,
     AnyStr,
     Dict,
     Generic,
     List,
     Optional,
     Tuple,
     Type,
     TypeVar,
     Union,
-    _Generic_metaclass,
     cast,
 )
 
 ##################
 #  BER encoding  #
 ##################
 
@@ -103,15 +101,18 @@
 
 class BER_BadTag_Decoding_Error(BER_Decoding_Error,
                                 ASN1_BadTag_Decoding_Error):
     pass
 
 
 def BER_len_enc(ll, size=0):
-    # type: (int, int) -> bytes
+    # type: (int, Optional[int]) -> bytes
+    from scapy.config import conf
+    if size is None:
+        size = conf.ASN1_default_long_size
     if ll <= 127 and size == 0:
         return chb(ll)
     s = b""
     while ll or size > 0:
         s = chb(ll & 0xff) + s
         ll >>= 8
         size -= 1
@@ -212,64 +213,65 @@
         tag |= 0x1f                 # pad with 1s every bit from 5 to 1
         return chb(tag) + s[1:]
 
 # The functions below provide implicit and explicit tagging support.
 
 
 def BER_tagging_dec(s,  # type: bytes
-                    hidden_tag=None,  # type: Optional[Any]
+                    hidden_tag=None,  # type: Optional[int | ASN1Tag]
                     implicit_tag=None,  # type: Optional[int]
                     explicit_tag=None,  # type: Optional[int]
                     safe=False,  # type: Optional[bool]
                     _fname="",  # type: str
                     ):
     # type: (...) -> Tuple[Optional[int], bytes]
     # We output the 'real_tag' if it is different from the (im|ex)plicit_tag.
+    # 'hidden_tag' is the type tag that is implicited when 'implicit_tag' is used.
     real_tag = None
     if len(s) > 0:
         err_msg = (
             "BER_tagging_dec: observed tag 0x%.02x does not "
             "match expected tag 0x%.02x (%s)"
         )
         if implicit_tag is not None:
             ber_id, s = BER_id_dec(s)
             if ber_id != implicit_tag:
-                if not safe and ber_id & 0x1f != implicit_tag & 0x1f:
+                if not safe and ber_id != implicit_tag:
                     raise BER_Decoding_Error(err_msg % (
                         ber_id, implicit_tag, _fname),
                         remaining=s)
                 else:
                     real_tag = ber_id
-            s = chb(hash(hidden_tag)) + s
+            s = chb(int(hidden_tag)) + s  # type: ignore
         elif explicit_tag is not None:
             ber_id, s = BER_id_dec(s)
             if ber_id != explicit_tag:
                 if not safe:
                     raise BER_Decoding_Error(
                         err_msg % (ber_id, explicit_tag, _fname),
                         remaining=s)
                 else:
                     real_tag = ber_id
             l, s = BER_len_dec(s)
     return real_tag, s
 
 
-def BER_tagging_enc(s, hidden_tag=None, implicit_tag=None, explicit_tag=None):
-    # type: (bytes, Optional[Any], Optional[int], Optional[int]) -> bytes
+def BER_tagging_enc(s, implicit_tag=None, explicit_tag=None):
+    # type: (bytes, Optional[int], Optional[int]) -> bytes
     if len(s) > 0:
         if implicit_tag is not None:
-            s = BER_id_enc((hash(hidden_tag) & ~(0x1f)) | implicit_tag) + s[1:]
+            s = BER_id_enc(implicit_tag) + s[1:]
         elif explicit_tag is not None:
             s = BER_id_enc(explicit_tag) + BER_len_enc(len(s)) + s
     return s
 
 #    [ BER classes ]    #
 
 
-class BERcodec_metaclass(_Generic_metaclass):
+class BERcodec_metaclass(type):
     def __new__(cls,
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
         # type: (...) -> Type[BERcodec_Object[Any]]
         c = cast('Type[BERcodec_Object[Any]]',
@@ -280,16 +282,15 @@
             warning("Error registering %r for %r" % (c.tag, c.codec))
         return c
 
 
 _K = TypeVar('_K')
 
 
-@six.add_metaclass(BERcodec_metaclass)
-class BERcodec_Object(Generic[_K]):
+class BERcodec_Object(Generic[_K], metaclass=BERcodec_metaclass):
     codec = ASN1_Codecs.BER
     tag = ASN1_Class_UNIVERSAL.ANY
 
     @classmethod
     def asn1_object(cls, val):
         # type: (_K) -> ASN1_Object[_K]
         return cls.tag.asn1_object(val)
@@ -342,21 +343,21 @@
         # type: (...) -> Tuple[ASN1_Object[Any], bytes]
         if context is not None:
             _context = context
         else:
             _context = cls.tag.context
         cls.check_string(s)
         p, remainder = BER_id_dec(s)
-        if p not in _context:  # type: ignore
+        if p not in _context:
             t = s
             if len(t) > 18:
                 t = t[:15] + b"..."
             raise BER_Decoding_Error("Unknown prefix [%02x] for [%r]" %
                                      (p, t), remaining=s)
-        tag = _context[p]  # type: ignore
+        tag = _context[p]
         codec = cast('Type[BERcodec_Object[_K]]',
                      tag.get_codec(ASN1_Codecs.BER))
         if codec == BERcodec_Object:
             # Value type defined as Unknown
             l, s = BER_num_dec(remainder)
             return ASN1_BADTAG(s[:l]), s[l:]
         return codec.dec(s, _context, safe)
@@ -387,21 +388,21 @@
                 s,  # type: bytes
                 context=None,  # type: Optional[Type[ASN1_Class]]
                 ):
         # type: (...) -> Tuple[Union[_ASN1_ERROR, ASN1_Object[_K]], bytes]
         return cls.dec(s, context, safe=True)
 
     @classmethod
-    def enc(cls, s):
-        # type: (_K) -> bytes
-        if isinstance(s, six.string_types + (bytes,)):
-            return BERcodec_STRING.enc(s)
+    def enc(cls, s, size_len=0):
+        # type: (_K, Optional[int]) -> bytes
+        if isinstance(s, (str, bytes)):
+            return BERcodec_STRING.enc(s, size_len=size_len)
         else:
             try:
-                return BERcodec_INTEGER.enc(int(s))  # type: ignore
+                return BERcodec_INTEGER.enc(int(s), size_len=size_len)  # type: ignore
             except TypeError:
                 raise TypeError("Trying to encode an invalid value !")
 
 
 ASN1_Codecs.BER.register_stem(BERcodec_Object)
 
 
@@ -409,29 +410,29 @@
 #    BERcodec objects    #
 ##########################
 
 class BERcodec_INTEGER(BERcodec_Object[int]):
     tag = ASN1_Class_UNIVERSAL.INTEGER
 
     @classmethod
-    def enc(cls, i):
-        # type: (int) -> bytes
+    def enc(cls, i, size_len=0):
+        # type: (int, Optional[int]) -> bytes
         ls = []
         while True:
             ls.append(i & 0xff)
             if -127 <= i < 0:
                 break
             if 128 <= i <= 255:
                 ls.append(0)
             i >>= 8
             if not i:
                 break
-        s = [chb(hash(c)) for c in ls]
-        s.append(BER_len_enc(len(s)))
-        s.append(chb(hash(cls.tag)))
+        s = [chb(int(c)) for c in ls]
+        s.append(BER_len_enc(len(s), size=size_len))
+        s.append(chb(int(cls.tag)))
         s.reverse()
         return b"".join(s)
 
     @classmethod
     def do_dec(cls,
                s,  # type: bytes
                context=None,  # type: Optional[Type[ASN1_Class]]
@@ -480,38 +481,38 @@
             raise BER_Decoding_Error(
                 "BERcodec_BIT_STRING found no content "
                 "(not even unused_bits byte)",
                 remaining=s
             )
 
     @classmethod
-    def enc(cls, _s):
-        # type: (AnyStr) -> bytes
+    def enc(cls, _s, size_len=0):
+        # type: (AnyStr, Optional[int]) -> bytes
         # /!\ this is DER encoding (bit strings are only zero-bit padded)
         s = bytes_encode(_s)
         if len(s) % 8 == 0:
             unused_bits = 0
         else:
             unused_bits = 8 - len(s) % 8
             s += b"0" * unused_bits
         s = b"".join(chb(int(b"".join(chb(y) for y in x), 2))
                      for x in zip(*[iter(s)] * 8))
         s = chb(unused_bits) + s
-        return chb(hash(cls.tag)) + BER_len_enc(len(s)) + s
+        return chb(int(cls.tag)) + BER_len_enc(len(s), size=size_len) + s
 
 
 class BERcodec_STRING(BERcodec_Object[str]):
     tag = ASN1_Class_UNIVERSAL.STRING
 
     @classmethod
-    def enc(cls, _s):
-        # type: (str) -> bytes
+    def enc(cls, _s, size_len=0):
+        # type: (Union[str, bytes], Optional[int]) -> bytes
         s = bytes_encode(_s)
         # Be sure we are encoding bytes
-        return chb(hash(cls.tag)) + BER_len_enc(len(s)) + s
+        return chb(int(cls.tag)) + BER_len_enc(len(s), size=size_len) + s
 
     @classmethod
     def do_dec(cls,
                s,  # type: bytes
                context=None,  # type: Optional[Type[ASN1_Class]]
                safe=False,  # type: bool
                ):
@@ -520,38 +521,38 @@
         return cls.tag.asn1_object(s), t
 
 
 class BERcodec_NULL(BERcodec_INTEGER):
     tag = ASN1_Class_UNIVERSAL.NULL
 
     @classmethod
-    def enc(cls, i):
-        # type: (int) -> bytes
+    def enc(cls, i, size_len=0):
+        # type: (int, Optional[int]) -> bytes
         if i == 0:
-            return chb(hash(cls.tag)) + b"\0"
+            return chb(int(cls.tag)) + b"\0"
         else:
-            return super(cls, cls).enc(i)
+            return super(cls, cls).enc(i, size_len=size_len)
 
 
 class BERcodec_OID(BERcodec_Object[bytes]):
     tag = ASN1_Class_UNIVERSAL.OID
 
     @classmethod
-    def enc(cls, _oid):
-        # type: (AnyStr) -> bytes
+    def enc(cls, _oid, size_len=0):
+        # type: (AnyStr, Optional[int]) -> bytes
         oid = bytes_encode(_oid)
         if oid:
             lst = [int(x) for x in oid.strip(b".").split(b".")]
         else:
             lst = list()
         if len(lst) >= 2:
             lst[1] += 40 * lst[0]
             del lst[0]
         s = b"".join(BER_num_enc(k) for k in lst)
-        return chb(hash(cls.tag)) + BER_len_enc(len(s)) + s
+        return chb(int(cls.tag)) + BER_len_enc(len(s), size=size_len) + s
 
     @classmethod
     def do_dec(cls,
                s,  # type: bytes
                context=None,  # type: Optional[Type[ASN1_Class]]
                safe=False,  # type: bool
                ):
@@ -622,21 +623,21 @@
     tag = ASN1_Class_UNIVERSAL.BMP_STRING
 
 
 class BERcodec_SEQUENCE(BERcodec_Object[Union[bytes, List[BERcodec_Object[Any]]]]):  # noqa: E501
     tag = ASN1_Class_UNIVERSAL.SEQUENCE
 
     @classmethod
-    def enc(cls, _ll):
-        # type: (Union[bytes, List[BERcodec_Object[Any]]]) -> bytes
+    def enc(cls, _ll, size_len=0):
+        # type: (Union[bytes, List[BERcodec_Object[Any]]], Optional[int]) -> bytes
         if isinstance(_ll, bytes):
             ll = _ll
         else:
             ll = b"".join(x.enc(cls.codec) for x in _ll)
-        return chb(hash(cls.tag)) + BER_len_enc(len(ll)) + ll
+        return chb(int(cls.tag)) + BER_len_enc(len(ll), size=size_len) + ll
 
     @classmethod
     def do_dec(cls,
                s,  # type: bytes
                context=None,  # type: Optional[Type[ASN1_Class]]
                safe=False  # type: bool
                ):
@@ -669,21 +670,21 @@
     tag = ASN1_Class_UNIVERSAL.SET
 
 
 class BERcodec_IPADDRESS(BERcodec_STRING):
     tag = ASN1_Class_UNIVERSAL.IPADDRESS
 
     @classmethod
-    def enc(cls, ipaddr_ascii):
-        # type: (str) -> bytes
+    def enc(cls, ipaddr_ascii, size_len=0):  # type: ignore
+        # type: (str, Optional[int]) -> bytes
         try:
             s = inet_aton(ipaddr_ascii)
         except Exception:
             raise BER_Encoding_Error("IPv4 address could not be encoded")
-        return chb(hash(cls.tag)) + BER_len_enc(len(s)) + s
+        return chb(int(cls.tag)) + BER_len_enc(len(s), size=size_len) + s
 
     @classmethod
     def do_dec(cls, s, context=None, safe=False):
         # type: (bytes, Optional[Any], bool) -> Tuple[ASN1_Object[str], bytes]
         l, s, t = cls.check_type_check_len(s)
         try:
             ipaddr_ascii = inet_ntoa(s)
@@ -693,13 +694,17 @@
         return cls.asn1_object(ipaddr_ascii), t
 
 
 class BERcodec_COUNTER32(BERcodec_INTEGER):
     tag = ASN1_Class_UNIVERSAL.COUNTER32
 
 
+class BERcodec_COUNTER64(BERcodec_INTEGER):
+    tag = ASN1_Class_UNIVERSAL.COUNTER64
+
+
 class BERcodec_GAUGE32(BERcodec_INTEGER):
     tag = ASN1_Class_UNIVERSAL.GAUGE32
 
 
 class BERcodec_TIME_TICKS(BERcodec_INTEGER):
     tag = ASN1_Class_UNIVERSAL.TIME_TICKS
```

### Comparing `scapy-2.5.0rc3/scapy/asn1/mib.py` & `scapy-2.6.0rc1/scapy/asn1/mib.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,24 +4,22 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 # Acknowledgment: Maxence Tury <maxence.tury@ssi.gouv.fr>
 
 """
 Management Information Base (MIB) parsing
 """
 
-from __future__ import absolute_import
 import re
 from glob import glob
 from scapy.dadict import DADict, fixname
 from scapy.config import conf
 from scapy.utils import do_graph
-import scapy.libs.six as six
 from scapy.compat import plain_str
 
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     List,
     Optional,
     Tuple,
 )
 
@@ -44,15 +42,15 @@
         if x.startswith("."):
             x = x[1:]
         if not x.endswith("."):
             x += "."
         max = 0
         root = "."
         root_key = ""
-        for k in six.iterkeys(self):
+        for k in self:
             if x.startswith(k + "."):
                 if max < len(k):
                     max = len(k)
                     root = self[k]
                     root_key = k
         return root, root_key, x[max:-1]
 
@@ -65,17 +63,17 @@
     def _oid(self, x):
         # type: (str) -> str
         """Parse the OID id/OID generator, and return real OID"""
         xl = x.strip(".").split(".")
         p = len(xl) - 1
         while p >= 0 and _mib_re_integer.match(xl[p]):
             p -= 1
-        if p != 0 or xl[p] not in six.itervalues(self.d):
+        if p != 0 or xl[p] not in self.d.values():
             return x
-        xl[p] = next(k for k, v in six.iteritems(self.d) if v == xl[p])
+        xl[p] = next(k for k, v in self.d.items() if v == xl[p])
         return ".".join(xl[p:])
 
     def _make_graph(self, other_keys=None, **kargs):
         # type: (Optional[Any], **Any) -> None
         if other_keys is None:
             other_keys = []
         nodes = [(self[key], key) for key in self.iterkeys()]
@@ -160,15 +158,15 @@
     """
     Load the conf.mib dict from a list of filenames
     """
     the_mib = {'iso': ['1']}
     unresolved = {}  # type: Dict[str, List[str]]
     alias = {}  # type: Dict[str, str]
     # Export the current MIB to a working dictionary
-    for k in six.iterkeys(conf.mib):
+    for k in conf.mib:
         _mib_register(conf.mib[k], k.split("."), the_mib, unresolved, alias)
 
     # Read the files
     if isinstance(filenames, (str, bytes)):
         files_list = [filenames]
     else:
         files_list = filenames
@@ -189,22 +187,22 @@
                     if m2:
                         oid_l[i] = m2.groups()[1]
                 _mib_register(ident, oid_l, the_mib, unresolved, alias)
 
     # Create the new MIB
     newmib = MIBDict(_name="MIB")
     # Add resolved values
-    for oid, key in six.iteritems(the_mib):
+    for oid, key in the_mib.items():
         newmib[".".join(key)] = oid
     # Add unresolved values
-    for oid, key in six.iteritems(unresolved):
+    for oid, key in unresolved.items():
         newmib[".".join(key)] = oid
     # Add aliases
-    for key, oid in six.iteritems(alias):
-        newmib[key] = oid
+    for key_s, oid in alias.items():
+        newmib[key_s] = oid
 
     conf.mib = newmib
 
 
 ####################
 #  OID references  #
 ####################
@@ -610,19 +608,21 @@
     '2.16.840.1.114404.1.1.2.4.1': 'EV XRamp Global Certification Authority',
     '2.16.840.1.114412.2.1': 'EV DigiCert High Assurance EV Root CA',
     '2.16.840.1.114413.1.7.23.3': 'EV ValiCert Class 2 Policy Validation Authority',
     '2.16.840.1.114414.1.7.23.3': 'EV Starfield Certificate Authority',
     '2.16.840.1.114414.1.7.24.3': 'EV Starfield Service Certificate Authority'
 }
 
-#
+#       gssapi       #
 
 gssapi_oids = {
     '1.2.840.48018.1.2.2': 'MS KRB5 - Microsoft Kerberos 5',
     '1.2.840.113554.1.2.2': 'Kerberos 5',
+    '1.2.840.113554.1.2.2.3': 'Kerberos 5 - User to User',
+    '1.3.6.1.5.2.5': 'Kerberos 5 - IAKERB',
     '1.3.6.1.5.5.2': 'SPNEGO - Simple Protected Negotiation',
     '1.3.6.1.4.1.311.2.2.10': 'NTLMSSP - Microsoft NTLM Security Support Provider',
     '1.3.6.1.4.1.311.2.2.30': 'NEGOEX - SPNEGO Extended Negotiation Security Mechanism',
 }
 
 
 x509_oids_sets = [
```

### Comparing `scapy-2.5.0rc3/scapy/asn1fields.py` & `scapy-2.6.0rc1/scapy/asn1fields.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,14 +4,16 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 # Acknowledgment: Maxence Tury <maxence.tury@ssi.gouv.fr>
 
 """
 Classes that implement ASN.1 data structures.
 """
 
+import copy
+
 from functools import reduce
 
 from scapy.asn1.asn1 import (
     ASN1_BIT_STRING,
     ASN1_BOOLEAN,
     ASN1_Class,
     ASN1_Class_UNIVERSAL,
@@ -37,17 +39,16 @@
     RandNum,
     RandOID,
     RandString,
     RandField,
 )
 
 from scapy import packet
-import scapy.libs.six as six
 
-from scapy.compat import (
+from typing import (
     Any,
     AnyStr,
     Callable,
     Dict,
     Generic,
     List,
     Optional,
@@ -88,33 +89,40 @@
     def __init__(self,
                  name,  # type: str
                  default,  # type: Optional[_A]
                  context=None,  # type: Optional[Type[ASN1_Class]]
                  implicit_tag=None,  # type: Optional[int]
                  explicit_tag=None,  # type: Optional[int]
                  flexible_tag=False,  # type: Optional[bool]
+                 size_len=None,  # type: Optional[int]
                  ):
         # type: (...) -> None
         if context is not None:
             self.context = context
         self.name = name
         if default is None:
             self.default = default  # type: Optional[_A]
         elif isinstance(default, ASN1_NULL):
             self.default = default  # type: ignore
         else:
             self.default = self.ASN1_tag.asn1_object(default)  # type: ignore
+        self.size_len = size_len
         self.flexible_tag = flexible_tag
         if (implicit_tag is not None) and (explicit_tag is not None):
             err_msg = "field cannot be both implicitly and explicitly tagged"
             raise ASN1_Error(err_msg)
-        self.implicit_tag = implicit_tag
-        self.explicit_tag = explicit_tag
+        self.implicit_tag = implicit_tag and int(implicit_tag)
+        self.explicit_tag = explicit_tag and int(explicit_tag)
         # network_tag gets useful for ASN1F_CHOICE
         self.network_tag = int(implicit_tag or explicit_tag or self.ASN1_tag)
+        self.owners = []  # type: List[Type[ASN1_Packet]]
+
+    def register_owner(self, cls):
+        # type: (Type[ASN1_Packet]) -> None
+        self.owners.append(cls)
 
     def i2repr(self, pkt, x):
         # type: (ASN1_Packet, _I) -> str
         return repr(x)
 
     def i2h(self, pkt, x):
         # type: (ASN1_Packet, _I) -> Any
@@ -160,16 +168,16 @@
                 x.tag == ASN1_Class_UNIVERSAL.RAW or
                 x.tag == ASN1_Class_UNIVERSAL.ERROR or
                self.ASN1_tag == x.tag):
                 s = x.enc(pkt.ASN1_codec)
             else:
                 raise ASN1_Error("Encoding Error: got %r instead of an %r for field [%s]" % (x, self.ASN1_tag, self.name))  # noqa: E501
         else:
-            s = self.ASN1_tag.get_codec(pkt.ASN1_codec).enc(x)
-        return BER_tagging_enc(s, hidden_tag=self.ASN1_tag,
+            s = self.ASN1_tag.get_codec(pkt.ASN1_codec).enc(x, size_len=self.size_len)
+        return BER_tagging_enc(s,
                                implicit_tag=self.implicit_tag,
                                explicit_tag=self.explicit_tag)
 
     def any2i(self, pkt, x):
         # type: (ASN1_Packet, Any) -> _I
         return cast(_I, x)
 
@@ -178,15 +186,15 @@
                        s,  # type: bytes
                        _underlayer=None  # type: Optional[ASN1_Packet]
                        ):
         # type: (...) -> Tuple[ASN1_Packet, bytes]
         try:
             c = cls(s, _underlayer=_underlayer)
         except ASN1F_badsequence:
-            c = packet.Raw(s, _underlayer=_underlayer)
+            c = packet.Raw(s, _underlayer=_underlayer)  # type: ignore
         cpad = c.getlayer(packet.Raw)
         s = b""
         if cpad is not None:
             s = cpad.load
             if cpad.underlayer:
                 del cpad.underlayer.payload
         return c, s
@@ -226,16 +234,20 @@
         return [self]
 
     def __str__(self):
         # type: () -> str
         return repr(self)
 
     def randval(self):
-        # type: () -> RandField[Any]
-        return RandInt()
+        # type: () -> RandField[_I]
+        return cast(RandField[_I], RandInt())
+
+    def copy(self):
+        # type: () -> ASN1F_field[_I, _A]
+        return copy.copy(self)
 
 
 ############################
 #    Simple ASN1 Fields    #
 ############################
 
 class ASN1F_BOOLEAN(ASN1F_field[bool, ASN1_BOOLEAN]):
@@ -271,15 +283,15 @@
         )
         i2s = self.i2s = {}  # type: Dict[int, str]
         s2i = self.s2i = {}  # type: Dict[str, int]
         if isinstance(enum, list):
             keys = range(len(enum))
         else:
             keys = list(enum)
-        if any(isinstance(x, six.string_types) for x in keys):
+        if any(isinstance(x, str) for x in keys):
             i2s, s2i = s2i, i2s  # type: ignore
         for k in keys:
             i2s[k] = enum[k]
             s2i[enum[k]] = k
 
     def i2m(self,
             pkt,  # type: ASN1_Packet
@@ -427,37 +439,31 @@
     ASN1_tag = ASN1_Class_UNIVERSAL.SEQUENCE
     holds_packets = 1
 
     def __init__(self, *seq, **kwargs):
         # type: (*Any, **Any) -> None
         name = "dummy_seq_name"
         default = [field.default for field in seq]
-        for kwarg in ["context", "implicit_tag",
-                      "explicit_tag", "flexible_tag"]:
-            setattr(self, kwarg, kwargs.get(kwarg))
         super(ASN1F_SEQUENCE, self).__init__(
-            name, default, context=self.context,
-            implicit_tag=self.implicit_tag,
-            explicit_tag=self.explicit_tag,
-            flexible_tag=self.flexible_tag
+            name, default, **kwargs
         )
         self.seq = seq
         self.islist = len(seq) > 1
 
     def __repr__(self):
         # type: () -> str
         return "<%s%r>" % (self.__class__.__name__, self.seq)
 
     def is_empty(self, pkt):
         # type: (ASN1_Packet) -> bool
         return all(f.is_empty(pkt) for f in self.seq)
 
     def get_fields_list(self):
         # type: () -> List[ASN1F_field[Any, Any]]
-        return reduce(lambda x, y: x + y.get_fields_list(),  # type: ignore
+        return reduce(lambda x, y: x + y.get_fields_list(),
                       self.seq, [])
 
     def m2i(self, pkt, s):
         # type: (Any, bytes) -> Tuple[Any, bytes]
         """
         ASN1F_SEQUENCE behaves transparently, with nested ASN1_objects being
         dissected one by one. Because we use obj.dissect (see loop below)
@@ -494,24 +500,24 @@
     def dissect(self, pkt, s):
         # type: (Any, bytes) -> bytes
         _, x = self.m2i(pkt, s)
         return x
 
     def build(self, pkt):
         # type: (ASN1_Packet) -> bytes
-        s = reduce(lambda x, y: x + y.build(pkt),  # type: ignore
+        s = reduce(lambda x, y: x + y.build(pkt),
                    self.seq, b"")
         return super(ASN1F_SEQUENCE, self).i2m(pkt, s)
 
 
 class ASN1F_SET(ASN1F_SEQUENCE):
     ASN1_tag = ASN1_Class_UNIVERSAL.SET
 
 
-_SEQ_T = Union['ASN1_Packet', Type[ASN1F_field], 'ASN1F_PACKET']
+_SEQ_T = Union['ASN1_Packet', Type[ASN1F_field[Any, Any]], 'ASN1F_PACKET']
 
 
 class ASN1F_SEQUENCE_OF(ASN1F_field[List[_SEQ_T],
                                     List[ASN1_Object[Any]]]):
     """
     Two types are allowed as cls: ASN1_Packet, ASN1F_field
     """
@@ -524,15 +530,15 @@
                  cls,  # type: _SEQ_T
                  context=None,  # type: Optional[Any]
                  implicit_tag=None,  # type: Optional[Any]
                  explicit_tag=None,  # type: Optional[Any]
                  ):
         # type: (...) -> None
         if isinstance(cls, type) and issubclass(cls, ASN1F_field):
-            self.fld = cast(Type[ASN1F_field[Any, Any]], cls)
+            self.fld = cls
             self._extract_packet = lambda s, pkt: self.fld(
                 self.name, b"").m2i(pkt, s)
             self.holds_packets = 0
         elif hasattr(cls, "ASN1_root") or callable(cls):
             self.cls = cast("Type[ASN1_Packet]", cls)
             self._extract_packet = lambda s, pkt: self.extract_packet(
                 self.cls, s, _underlayer=pkt)
@@ -653,15 +659,15 @@
         return self._field.any2i(pkt, x)
 
     def i2repr(self, pkt, x):
         # type: (ASN1_Packet, Any) -> str
         return self._field.i2repr(pkt, x)
 
 
-_CHOICE_T = Union['ASN1_Packet', Type[ASN1F_field], 'ASN1F_PACKET']
+_CHOICE_T = Union['ASN1_Packet', Type[ASN1F_field[Any, Any]], 'ASN1F_PACKET']
 
 
 class ASN1F_CHOICE(ASN1F_field[_CHOICE_T, ASN1_Object[Any]]):
     """
     Multiple types are allowed: ASN1_Packet, ASN1F_field and ASN1F_PACKET(),
     See layers/x509.py for examples.
     Other ASN1F_field instances than ASN1F_PACKET instances must not be used.
@@ -687,29 +693,26 @@
         self.pktchoices = {}
         for p in args:
             if hasattr(p, "ASN1_root"):
                 p = cast('ASN1_Packet', p)
                 # should be ASN1_Packet
                 if hasattr(p.ASN1_root, "choices"):
                     root = cast(ASN1F_CHOICE, p.ASN1_root)
-                    for k, v in six.iteritems(root.choices):
+                    for k, v in root.choices.items():
                         # ASN1F_CHOICE recursion
                         self.choices[k] = v
                 else:
                     self.choices[p.ASN1_root.network_tag] = p
             elif hasattr(p, "ASN1_tag"):
-                p = cast(Union[ASN1F_PACKET, Type[ASN1F_field[Any, Any]]], p)
                 if isinstance(p, type):
                     # should be ASN1F_field class
                     self.choices[int(p.ASN1_tag)] = p
                 else:
                     # should be ASN1F_field instance
                     self.choices[p.network_tag] = p
-                    if p.implicit_tag is not None:
-                        self.choices[p.implicit_tag & 0x1f] = p
                     self.pktchoices[hash(p.cls)] = (p.implicit_tag, p.explicit_tag)  # noqa: E501
             else:
                 raise ASN1_Error("ASN1F_CHOICE: no tag found for one field")
 
     def m2i(self, pkt, s):
         # type: (ASN1_Packet, bytes) -> Tuple[ASN1_Object[Any], bytes]
         """
@@ -720,55 +723,52 @@
             raise ASN1_Error("ASN1F_CHOICE: got empty string")
         _, s = BER_tagging_dec(s, hidden_tag=self.ASN1_tag,
                                explicit_tag=self.explicit_tag)
         tag, _ = BER_id_dec(s)
         if tag in self.choices:
             choice = self.choices[tag]
         else:
-            if tag & 0x1f in self.choices:  # Try resolve only the tag number
-                choice = self.choices[tag & 0x1f]
-            elif self.flexible_tag:
+            if self.flexible_tag:
                 choice = ASN1F_field
             else:
                 raise ASN1_Error(
                     "ASN1F_CHOICE: unexpected field in '%s' "
                     "(tag %s not in possible tags %s)" % (
                         self.name, tag, list(self.choices.keys())
                     )
                 )
         if hasattr(choice, "ASN1_root"):
-            choice = cast('ASN1_Packet', choice)
             # we don't want to import ASN1_Packet in this module...
-            return self.extract_packet(choice, s, _underlayer=pkt)
+            return self.extract_packet(choice, s, _underlayer=pkt)  # type: ignore
         elif isinstance(choice, type):
             return choice(self.name, b"").m2i(pkt, s)
         else:
             # XXX check properly if this is an ASN1F_PACKET
             return choice.m2i(pkt, s)
 
     def i2m(self, pkt, x):
         # type: (ASN1_Packet, Any) -> bytes
         if x is None:
             s = b""
         else:
             s = raw(x)
             if hash(type(x)) in self.pktchoices:
                 imp, exp = self.pktchoices[hash(type(x))]
-                s = BER_tagging_enc(s, hidden_tag=self.ASN1_tag,
+                s = BER_tagging_enc(s,
                                     implicit_tag=imp,
                                     explicit_tag=exp)
         return BER_tagging_enc(s, explicit_tag=self.explicit_tag)
 
     def randval(self):
         # type: () -> RandChoice
         randchoices = []
-        for p in six.itervalues(self.choices):
+        for p in self.choices.values():
             if hasattr(p, "ASN1_root"):
                 # should be ASN1_Packet class
-                randchoices.append(packet.fuzz(p()))
+                randchoices.append(packet.fuzz(p()))  # type: ignore
             elif hasattr(p, "ASN1_tag"):
                 if isinstance(p, type):
                     # should be (basic) ASN1F_field class
                     randchoices.append(p("dummy", None).randval())
                 else:
                     # should be ASN1F_PACKET instance
                     randchoices.append(p.randval())
@@ -790,17 +790,17 @@
         # type: (...) -> None
         self.cls = cls
         self.next_cls_cb = next_cls_cb
         super(ASN1F_PACKET, self).__init__(
             name, None, context=context,
             implicit_tag=implicit_tag, explicit_tag=explicit_tag
         )
-        if implicit_tag is None and explicit_tag is None:
+        if implicit_tag is None and explicit_tag is None and cls is not None:
             if cls.ASN1_root.ASN1_tag == ASN1_Class_UNIVERSAL.SEQUENCE:
-                self.network_tag = 16 | 0x20
+                self.network_tag = 16 | 0x20  # 16 + CONSTRUCTED
         self.default = default
 
     def m2i(self, pkt, s):
         # type: (ASN1_Packet, bytes) -> Tuple[Any, bytes]
         if self.next_cls_cb:
             cls = self.next_cls_cb(pkt) or self.cls
         else:
@@ -834,19 +834,31 @@
         elif isinstance(x, ASN1_Object):
             if x.val:
                 s = raw(x.val)
             else:
                 s = b""
         else:
             s = raw(x)
-        return BER_tagging_enc(s, hidden_tag=self.ASN1_tag,
+            if not hasattr(x, "ASN1_root"):
+                # A normal Packet (!= ASN1)
+                return s
+        return BER_tagging_enc(s,
                                implicit_tag=self.implicit_tag,
                                explicit_tag=self.explicit_tag)
 
-    def randval(self):
+    def any2i(self,
+              pkt,  # type: ASN1_Packet
+              x  # type: Union[bytes, ASN1_Packet, None, ASN1_Object[Optional[ASN1_Packet]]]  # noqa: E501
+              ):
+        # type: (...) -> 'ASN1_Packet'
+        if hasattr(x, "add_underlayer"):
+            x.add_underlayer(pkt)  # type: ignore
+        return super(ASN1F_PACKET, self).any2i(pkt, x)
+
+    def randval(self):  # type: ignore
         # type: () -> ASN1_Packet
         return packet.fuzz(self.cls())
 
 
 class ASN1F_BIT_STRING_ENCAPS(ASN1F_BIT_STRING):
     """
     We may emulate simple string encapsulation with explicit_tag=0x04,
@@ -860,16 +872,18 @@
                  cls,  # type: Type[ASN1_Packet]
                  context=None,  # type: Optional[Any]
                  implicit_tag=None,  # type: Optional[int]
                  explicit_tag=None,  # type: Optional[int]
                  ):
         # type: (...) -> None
         self.cls = cls
-        super(ASN1F_BIT_STRING_ENCAPS, self).__init__(
-            name, default and raw(default), context=context,
+        super(ASN1F_BIT_STRING_ENCAPS, self).__init__(  # type: ignore
+            name,
+            default and raw(default),
+            context=context,
             implicit_tag=implicit_tag,
             explicit_tag=explicit_tag
         )
 
     def m2i(self, pkt, s):  # type: ignore
         # type: (ASN1_Packet, bytes) -> Tuple[Optional[ASN1_Packet], bytes]
         bit_string, remain = super(ASN1F_BIT_STRING_ENCAPS, self).m2i(pkt, s)
@@ -881,20 +895,21 @@
         else:
             return None, bit_string.val_readable
         if len(s) > 0:
             raise BER_Decoding_Error("unexpected remainder", remaining=s)
         return p, remain
 
     def i2m(self, pkt, x):  # type: ignore
-        # type: (ASN1_Packet, Optional[ASN1_Packet]) -> bytes
-        s = b"" if x is None else raw(x)
-        return super(ASN1F_BIT_STRING_ENCAPS, self).i2m(
-            pkt,
-            ASN1_BIT_STRING(s, readable=True)
-        )
+        # type: (ASN1_Packet, Optional[ASN1_BIT_STRING]) -> bytes
+        if not isinstance(x, ASN1_BIT_STRING):
+            x = ASN1_BIT_STRING(
+                b"" if x is None else bytes(x),  # type: ignore
+                readable=True,
+            )
+        return super(ASN1F_BIT_STRING_ENCAPS, self).i2m(pkt, x)
 
 
 class ASN1F_FLAGS(ASN1F_BIT_STRING):
     def __init__(self,
                  name,  # type: str
                  default,  # type: Optional[str]
                  mapping,  # type: List[str]
@@ -908,14 +923,26 @@
             name, default,
             default_readable=False,
             context=context,
             implicit_tag=implicit_tag,
             explicit_tag=explicit_tag
         )
 
+    def any2i(self, pkt, x):
+        # type: (ASN1_Packet, Any) -> str
+        if isinstance(x, str):
+            if any(y not in ["0", "1"] for y in x):
+                # resolve the flags
+                value = ["0"] * len(self.mapping)
+                for i in x.split("+"):
+                    value[self.mapping.index(i)] = "1"
+                x = "".join(value)
+            x = ASN1_BIT_STRING(x)
+        return super(ASN1F_FLAGS, self).any2i(pkt, x)
+
     def get_flags(self, pkt):
         # type: (ASN1_Packet) -> List[str]
         fbytes = getattr(pkt, self.name).val
         return [self.mapping[i] for i, positional in enumerate(fbytes)
                 if positional == '1' and i < len(self.mapping)]
 
     def i2repr(self, pkt, x):
```

### Comparing `scapy-2.5.0rc3/scapy/asn1packet.py` & `scapy-2.6.0rc1/scapy/asn1packet.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,20 +5,18 @@
 
 """
 ASN.1 Packet
 
 Packet holding data in Abstract Syntax Notation (ASN.1).
 """
 
-from __future__ import absolute_import
 from scapy.base_classes import Packet_metaclass
 from scapy.packet import Packet
-import scapy.libs.six as six
 
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     Tuple,
     Type,
     cast,
     TYPE_CHECKING,
 )
@@ -32,19 +30,21 @@
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
         # type: (...) -> Type[ASN1_Packet]
         if dct["ASN1_root"] is not None:
             dct["fields_desc"] = dct["ASN1_root"].get_fields_list()
-        return super(ASN1Packet_metaclass, cls).__new__(cls, name, bases, dct)
+        return cast(
+            'Type[ASN1_Packet]',
+            super(ASN1Packet_metaclass, cls).__new__(cls, name, bases, dct),
+        )
 
 
-@six.add_metaclass(ASN1Packet_metaclass)
-class ASN1_Packet(Packet):
+class ASN1_Packet(Packet, metaclass=ASN1Packet_metaclass):
     ASN1_root = cast('ASN1F_field[Any, Any]', None)
     ASN1_codec = None
 
     def self_build(self):
         # type: () -> bytes
         if self.raw_packet_cache is not None:
             return self.raw_packet_cache
```

### Comparing `scapy-2.5.0rc3/scapy/automaton.py` & `scapy-2.6.0rc1/scapy/automaton.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,63 +1,64 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
-# Copyright (C) Gabriel Potter <gabriel[]potter[]fr>
+# Copyright (C) Gabriel Potter
 
 """
 Automata with states, transitions and actions.
 
 TODO:
     - add documentation for ioevent, as_supersocket...
 """
 
 import ctypes
 import itertools
 import logging
 import os
 import random
+import socket
 import sys
 import threading
 import time
 import traceback
 import types
 
 import select
 from collections import deque
 
 from scapy.config import conf
-from scapy.utils import do_graph
-from scapy.error import log_runtime, warning
-from scapy.plist import PacketList
+from scapy.consts import WINDOWS
 from scapy.data import MTU
-from scapy.supersocket import SuperSocket
+from scapy.error import log_runtime, warning
+from scapy.interfaces import _GlobInterfaceType
 from scapy.packet import Packet
-from scapy.consts import WINDOWS
-import scapy.libs.six as six
+from scapy.plist import PacketList
+from scapy.supersocket import SuperSocket, StreamSocket
+from scapy.utils import do_graph
 
-from scapy.compat import (
+# Typing imports
+from typing import (
     Any,
     Callable,
-    DecoratorCallable,
     Deque,
     Dict,
     Generic,
     Iterable,
     Iterator,
     List,
     Optional,
     Set,
     Tuple,
     Type,
     TypeVar,
     Union,
-    _Generic_metaclass,
     cast,
 )
+from scapy.compat import DecoratorCallable
 
 
 def select_objects(inputs, remain):
     # type: (Iterable[Any], Union[float, int, None]) -> List[Any]
     """
     Select objects. Same than:
     ``select.select(inputs, [], [], remain)``
@@ -74,15 +75,15 @@
 
         >>> a, b = ObjectPipe("a"), ObjectPipe("b")
         >>> b.send("test")
         >>> select_objects([a, b], 1)
         [b]
 
     :param inputs: objects to process
-    :param remain: timeout. If 0, return [].
+    :param remain: timeout. If 0, poll. If None, block.
     """
     if not WINDOWS:
         return select.select(inputs, [], [], remain)[0]
     natives = []
     events = []
     results = set()
     for i in list(inputs):
@@ -94,14 +95,17 @@
             # in very few places but important (e.g. PcapReader), where we have
             # no valid fileno (and will stop on EOFError).
             results.add(i)
         else:
             events.append(i)
     if natives:
         results = results.union(set(select.select(natives, [], [], remain)[0]))
+        if results:
+            # We have native results, poll.
+            remain = 0
     if events:
         # 0xFFFFFFFF = INFINITE
         remainms = int(remain * 1000 if remain is not None else 0xFFFFFFFF)
         if len(events) == 1:
             res = ctypes.windll.kernel32.WaitForSingleObject(
                 ctypes.c_void_p(events[0].fileno()),
                 remainms
@@ -131,15 +135,14 @@
                         results.add(evt)
     return list(results)
 
 
 _T = TypeVar("_T")
 
 
-@six.add_metaclass(_Generic_metaclass)
 class ObjectPipe(Generic[_T]):
     def __init__(self, name=None):
         # type: (Optional[str]) -> None
         self.name = name or "ObjectPipe"
         self.closed = False
         self.__rd, self.__wr = os.pipe()
         self.__queue = deque()  # type: Deque[_T]
@@ -172,15 +175,15 @@
     def fileno(self):
         # type: () -> int
         if WINDOWS:
             return self._fd
         return self.__rd
 
     def send(self, obj):
-        # type: (Union[_T]) -> int
+        # type: (_T) -> int
         self.__queue.append(obj)
         if WINDOWS:
             self._winset()
         os.write(self.__wr, b"X")
         return 1
 
     def write(self, obj):
@@ -191,19 +194,21 @@
         # type: () -> bool
         return not bool(self.__queue)
 
     def flush(self):
         # type: () -> None
         pass
 
-    def recv(self, n=0):
-        # type: (Optional[int]) -> Optional[_T]
+    def recv(self, n=0, options=socket.MsgFlag(0)):
+        # type: (Optional[int], socket.MsgFlag) -> Optional[_T]
         if self.closed:
+            raise EOFError
+        if options & socket.MSG_PEEK:
             if self.__queue:
-                return self.__queue.popleft()
+                return self.__queue[0]
             return None
         os.read(self.__rd, 1)
         elt = self.__queue.popleft()
         if WINDOWS and not self.__queue:
             self._winreset()
         return elt
 
@@ -216,19 +221,23 @@
         if not self.closed:
             while not self.empty():
                 self.recv()
 
     def close(self):
         # type: () -> None
         if not self.closed:
+            self.closed = True
             os.close(self.__rd)
             os.close(self.__wr)
             if WINDOWS:
-                self._winclose()
-            self.closed = True
+                try:
+                    self._winclose()
+                except ImportError:
+                    # Python is shutting down
+                    pass
 
     def __repr__(self):
         # type: () -> str
         return "<%s at %s>" % (self.name, id(self))
 
     def __del__(self):
         # type: () -> None
@@ -236,15 +245,15 @@
 
     @staticmethod
     def select(sockets, remain=conf.recv_poll_rate):
         # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
         # Only handle ObjectPipes
         results = []
         for s in sockets:
-            if s.closed:
+            if s.closed:  # allow read to trigger EOF
                 results.append(s)
         if results:
             return results
         return select_objects(sockets, remain)
 
 
 class Message:
@@ -256,17 +265,19 @@
 
     def __init__(self, **args):
         # type: (Any) -> None
         self.__dict__.update(args)
 
     def __repr__(self):
         # type: () -> str
-        return "<Message %s>" % " ".join("%s=%r" % (k, v)
-                                         for (k, v) in six.iteritems(self.__dict__)  # noqa: E501
-                                         if not k.startswith("_"))
+        return "<Message %s>" % " ".join(
+            "%s=%r" % (k, v)
+            for k, v in self.__dict__.items()
+            if not k.startswith("_")
+        )
 
 
 class Timer():
     def __init__(self, time, prio=0, autoreload=False):
         # type: (Union[int, float], int, bool) -> None
         self._timeout = float(time)  # type: float
         self._time = 0  # type: float
@@ -360,19 +371,19 @@
         lst = [t for t in self.timers if t._just_expired]
         lst.sort(key=lambda x: x._prio, reverse=True)
         for t in lst:
             t._reset_just_expired()
         return lst
 
     def until_next(self):
-        # type: () -> float
+        # type: () -> Optional[float]
         try:
             return min([t._remaining() for t in self.timers if t._running()])
         except ValueError:
-            return 0
+            return None  # None means blocking
 
     def count(self):
         # type: () -> int
         return len(self.timers)
 
     def __iter__(self):
         # type: () -> Iterator[Timer]
@@ -440,14 +451,15 @@
 
 class ATMT:
     STATE = "State"
     ACTION = "Action"
     CONDITION = "Condition"
     RECV = "Receive condition"
     TIMEOUT = "Timeout condition"
+    EOF = "EOF condition"
     IOEVENT = "I/O event"
 
     class NewStateRequested(Exception):
         def __init__(self, state_func, automaton, *args, **kargs):
             # type: (Any, ATMT, Any, Any) -> None
             self.func = state_func
             self.state = state_func.atmt_state
@@ -573,24 +585,35 @@
             f.atmt_condname = f.__name__
             return f
         return deco
 
     @staticmethod
     def timer(state, timeout, prio=0):
         # type: (_StateWrapper, Union[float, int], int) -> Callable[[_StateWrapper, _StateWrapper, Timer], _StateWrapper]  # noqa: E501
-        def deco(f, state=state, timeout=Timer(timeout, prio=prio, autoreload=True)):  # noqa: E501
+        def deco(f, state=state, timeout=Timer(timeout, prio=prio, autoreload=True)):
             # type: (_StateWrapper, _StateWrapper, Timer) -> _StateWrapper
             f.atmt_type = ATMT.TIMEOUT
             f.atmt_state = state.atmt_state
             f.atmt_timeout = timeout
             f.atmt_timeout._func = f
             f.atmt_condname = f.__name__
             return f
         return deco
 
+    @staticmethod
+    def eof(state):
+        # type: (_StateWrapper) -> Callable[[_StateWrapper, _StateWrapper], _StateWrapper]  # noqa: E501
+        def deco(f, state=state):
+            # type: (_StateWrapper, _StateWrapper) -> _StateWrapper
+            f.atmt_type = ATMT.EOF
+            f.atmt_state = state.atmt_state
+            f.atmt_condname = f.__name__
+            return f
+        return deco
+
 
 class _ATMT_Command:
     RUN = "RUN"
     NEXT = "NEXT"
     FREEZE = "FREEZE"
     STOP = "STOP"
     FORCESTOP = "FORCESTOP"
@@ -614,36 +637,37 @@
                  **kargs        # type: Any
                  ):
         # type: (...) -> None
         self.name = name
         self.ioevent = ioevent
         self.proto = proto
         # write, read
-        self.spa, self.spb = ObjectPipe[bytes]("spa"), \
-            ObjectPipe[bytes]("spb")
+        self.spa, self.spb = ObjectPipe[Any]("spa"), \
+            ObjectPipe[Any]("spb")
         kargs["external_fd"] = {ioevent: (self.spa, self.spb)}
         kargs["is_atmt_socket"] = True
+        kargs["atmt_socket"] = self.name
         self.atmt = automaton(*args, **kargs)
         self.atmt.runbg()
 
     def send(self, s):
-        # type: (bytes) -> int
-        if not isinstance(s, bytes):
-            s = bytes(s)
+        # type: (Any) -> int
         return self.spa.send(s)
 
     def fileno(self):
         # type: () -> int
         return self.spb.fileno()
 
-    def recv(self, n=MTU):
-        # type: (Optional[int]) -> Any
+    # note: _ATMT_supersocket may return bytes in certain cases, which
+    # is expected. We cheat on typing.
+    def recv(self, n=MTU, **kwargs):  # type: ignore
+        # type: (int, **Any) -> Any
         r = self.spb.recv(n)
         if self.proto is not None and r is not None:
-            r = self.proto(r)
+            r = self.proto(r, **kwargs)
         return r
 
     def close(self):
         # type: () -> None
         if not self.closed:
             self.atmt.stop()
             self.atmt.destroy()
@@ -679,68 +703,75 @@
             cls, name, bases, dct
         )
         cls.states = {}
         cls.recv_conditions = {}    # type: Dict[str, List[_StateWrapper]]
         cls.conditions = {}         # type: Dict[str, List[_StateWrapper]]
         cls.ioevents = {}           # type: Dict[str, List[_StateWrapper]]
         cls.timeout = {}            # type: Dict[str, _TimerList]
+        cls.eofs = {}               # type: Dict[str, _StateWrapper]
         cls.actions = {}            # type: Dict[str, List[_StateWrapper]]
         cls.initial_states = []     # type: List[_StateWrapper]
-        cls.stop_states = []        # type: List[_StateWrapper]
+        cls.stop_state = None       # type: Optional[_StateWrapper]
         cls.ionames = []
         cls.iosupersockets = []
 
         members = {}
         classes = [cls]
         while classes:
             c = classes.pop(0)  # order is important to avoid breaking method overloading  # noqa: E501
             classes += list(c.__bases__)
-            for k, v in six.iteritems(c.__dict__):
+            for k, v in c.__dict__.items():  # type: ignore
                 if k not in members:
                     members[k] = v
 
-        decorated = [v for v in six.itervalues(members)
+        decorated = [v for v in members.values()
                      if hasattr(v, "atmt_type")]
 
         for m in decorated:
             if m.atmt_type == ATMT.STATE:
                 s = m.atmt_state
                 cls.states[s] = m
                 cls.recv_conditions[s] = []
                 cls.ioevents[s] = []
                 cls.conditions[s] = []
                 cls.timeout[s] = _TimerList()
                 if m.atmt_initial:
                     cls.initial_states.append(m)
                 if m.atmt_stop:
-                    cls.stop_states.append(m)
-            elif m.atmt_type in [ATMT.CONDITION, ATMT.RECV, ATMT.TIMEOUT, ATMT.IOEVENT]:  # noqa: E501
+                    if cls.stop_state is not None:
+                        raise ValueError("There can only be a single stop state !")
+                    cls.stop_state = m
+            elif m.atmt_type in [ATMT.CONDITION, ATMT.RECV, ATMT.TIMEOUT, ATMT.IOEVENT, ATMT.EOF]:  # noqa: E501
                 cls.actions[m.atmt_condname] = []
 
         for m in decorated:
             if m.atmt_type == ATMT.CONDITION:
                 cls.conditions[m.atmt_state].append(m)
             elif m.atmt_type == ATMT.RECV:
                 cls.recv_conditions[m.atmt_state].append(m)
+            elif m.atmt_type == ATMT.EOF:
+                cls.eofs[m.atmt_state] = m
             elif m.atmt_type == ATMT.IOEVENT:
                 cls.ioevents[m.atmt_state].append(m)
                 cls.ionames.append(m.atmt_ioname)
                 if m.atmt_as_supersocket is not None:
                     cls.iosupersockets.append(m)
             elif m.atmt_type == ATMT.TIMEOUT:
                 cls.timeout[m.atmt_state].add_timer(m.atmt_timeout)
             elif m.atmt_type == ATMT.ACTION:
                 for co in m.atmt_cond:
                     cls.actions[co].append(m)
 
-        for v in itertools.chain(six.itervalues(cls.conditions),
-                                 six.itervalues(cls.recv_conditions),
-                                 six.itervalues(cls.ioevents)):
+        for v in itertools.chain(
+            cls.conditions.values(),
+            cls.recv_conditions.values(),
+            cls.ioevents.values()
+        ):
             v.sort(key=lambda x: x.atmt_prio)
-        for condname, actlst in six.iteritems(cls.actions):
+        for condname, actlst in cls.actions.items():
             actlst.sort(key=lambda x: x.atmt_cond[condname])
 
         for ioev in cls.iosupersockets:
             setattr(cls, ioev.atmt_as_supersocket,
                     _ATMT_to_supersocket(
                         ioev.atmt_as_supersocket,
                         ioev.atmt_ioname,
@@ -756,41 +787,67 @@
         return cast(Type["Automaton"], cls)
 
     def build_graph(self):
         # type: () -> str
         s = 'digraph "%s" {\n' % self.__class__.__name__
 
         se = ""  # Keep initial nodes at the beginning for better rendering
-        for st in six.itervalues(self.states):
+        for st in self.states.values():
             if st.atmt_initial:
                 se = ('\t"%s" [ style=filled, fillcolor=blue, shape=box, root=true];\n' % st.atmt_state) + se  # noqa: E501
             elif st.atmt_final:
                 se += '\t"%s" [ style=filled, fillcolor=green, shape=octagon ];\n' % st.atmt_state  # noqa: E501
             elif st.atmt_error:
                 se += '\t"%s" [ style=filled, fillcolor=red, shape=octagon ];\n' % st.atmt_state  # noqa: E501
             elif st.atmt_stop:
                 se += '\t"%s" [ style=filled, fillcolor=orange, shape=box, root=true ];\n' % st.atmt_state  # noqa: E501
         s += se
 
-        for st in six.itervalues(self.states):
-            for n in st.atmt_origfunc.__code__.co_names + st.atmt_origfunc.__code__.co_consts:  # noqa: E501
+        for st in self.states.values():
+            names = list(
+                st.atmt_origfunc.__code__.co_names +
+                st.atmt_origfunc.__code__.co_consts
+            )
+            while names:
+                n = names.pop()
                 if n in self.states:
-                    s += '\t"%s" -> "%s" [ color=green ];\n' % (st.atmt_state, n)  # noqa: E501
-
-        for c, k, v in ([("purple", k, v) for k, v in self.conditions.items()] +  # noqa: E501
-                        [("red", k, v) for k, v in self.recv_conditions.items()] +  # noqa: E501
-                        [("orange", k, v) for k, v in self.ioevents.items()]):
+                    s += '\t"%s" -> "%s" [ color=green ];\n' % (st.atmt_state, n)
+                elif n in self.__dict__:
+                    # function indirection
+                    if callable(self.__dict__[n]):
+                        names.extend(self.__dict__[n].__code__.co_names)
+                        names.extend(self.__dict__[n].__code__.co_consts)
+
+        for c, sty, k, v in (
+            [("purple", "solid", k, v) for k, v in self.conditions.items()] +
+            [("red", "solid", k, v) for k, v in self.recv_conditions.items()] +
+            [("orange", "solid", k, v) for k, v in self.ioevents.items()] +
+            [("black", "dashed", k, [v]) for k, v in self.eofs.items()]
+        ):
             for f in v:
-                for n in f.__code__.co_names + f.__code__.co_consts:
+                names = list(f.__code__.co_names + f.__code__.co_consts)
+                while names:
+                    n = names.pop()
                     if n in self.states:
                         line = f.atmt_condname
                         for x in self.actions[f.atmt_condname]:
                             line += "\\l>[%s]" % x.__name__
-                        s += '\t"%s" -> "%s" [label="%s", color=%s];\n' % (k, n, line, c)  # noqa: E501
-        for k, timers in six.iteritems(self.timeout):
+                        s += '\t"%s" -> "%s" [label="%s", color=%s, style=%s];\n' % (
+                            k,
+                            n,
+                            line,
+                            c,
+                            sty,
+                        )
+                    elif n in self.__dict__:
+                        # function indirection
+                        if callable(self.__dict__[n]) and hasattr(self.__dict__[n], "__code__"):  # noqa: E501
+                            names.extend(self.__dict__[n].__code__.co_names)
+                            names.extend(self.__dict__[n].__code__.co_consts)
+        for k, timers in self.timeout.items():
             for timer in timers:
                 for n in (timer._func.__code__.co_names +
                           timer._func.__code__.co_consts):
                     if n in self.states:
                         line = "%s/%.1fs" % (timer._func.atmt_condname,
                                              timer.get())
                         for x in self.actions[timer._func.atmt_condname]:
@@ -801,35 +858,48 @@
 
     def graph(self, **kargs):
         # type: (Any) -> Optional[str]
         s = self.build_graph()
         return do_graph(s, **kargs)
 
 
-@six.add_metaclass(Automaton_metaclass)
-class Automaton:
+class Automaton(metaclass=Automaton_metaclass):
     states = {}             # type: Dict[str, _StateWrapper]
     state = None            # type: ATMT.NewStateRequested
     recv_conditions = {}    # type: Dict[str, List[_StateWrapper]]
     conditions = {}         # type: Dict[str, List[_StateWrapper]]
+    eofs = {}               # type: Dict[str, _StateWrapper]
     ioevents = {}           # type: Dict[str, List[_StateWrapper]]
     timeout = {}            # type: Dict[str, _TimerList]
     actions = {}            # type: Dict[str, List[_StateWrapper]]
     initial_states = []     # type: List[_StateWrapper]
-    stop_states = []        # type: List[_StateWrapper]
+    stop_state = None       # type: Optional[_StateWrapper]
     ionames = []            # type: List[str]
     iosupersockets = []     # type: List[SuperSocket]
 
+    # used for spawn()
+    pkt_cls = conf.raw_layer
+    socketcls = StreamSocket
+
     # Internals
     def __init__(self, *args, **kargs):
         # type: (Any, Any) -> None
         external_fd = kargs.pop("external_fd", {})
-        self.send_sock_class = kargs.pop("ll", conf.L3socket)
-        self.recv_sock_class = kargs.pop("recvsock", conf.L2listen)
+        if "sock" in kargs:
+            # We use a bi-directional sock
+            self.sock = kargs["sock"]
+        else:
+            # Separate sockets
+            self.sock = None
+            self.send_sock_class = kargs.pop("ll", conf.L3socket)
+            self.recv_sock_class = kargs.pop("recvsock", conf.L2listen)
+        self.listen_sock = None  # type: Optional[SuperSocket]
+        self.send_sock = None  # type: Optional[SuperSocket]
         self.is_atmt_socket = kargs.pop("is_atmt_socket", False)
+        self.atmt_socket = kargs.pop("atmt_socket", None)
         self.started = threading.Lock()
         self.threadid = None                # type: Optional[int]
         self.breakpointed = None
         self.breakpoints = set()            # type: Set[_StateWrapper]
         self.interception_points = set()    # type: Set[_StateWrapper]
         self.intercepted_packet = None      # type: Union[None, Packet]
         self.debug_level = 0
@@ -865,74 +935,162 @@
 
         for stname in self.states:
             setattr(self, stname,
                     _instance_state(getattr(self, stname)))
 
         self.start()
 
-    def parse_args(self, debug=0, store=1, **kargs):
+    def parse_args(self, debug=0, store=0, **kargs):
         # type: (int, int, Any) -> None
         self.debug_level = debug
         if debug:
             conf.logLevel = logging.DEBUG
         self.socket_kargs = kargs
         self.store_packets = store
 
+    @classmethod
+    def spawn(cls,
+              port: int,
+              iface: Optional[_GlobInterfaceType] = None,
+              bg: bool = False,
+              **kwargs: Any) -> Optional[socket.socket]:
+        """
+        Spawn a TCP server that listens for connections and start the automaton
+        for each new client.
+
+        :param port: the port to listen to
+        :param bg: background mode? (default: False)
+        """
+        from scapy.arch import get_if_addr
+        # create server sock and bind it
+        ssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        local_ip = get_if_addr(iface or conf.iface)
+        try:
+            ssock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        except OSError:
+            pass
+        ssock.bind((local_ip, port))
+        ssock.listen(5)
+        clients = []
+        if kwargs.get("verb", True):
+            print(conf.color_theme.green(
+                "Server %s started listening on %s" % (
+                    cls.__name__,
+                    (local_ip, port),
+                )
+            ))
+
+        def _run() -> None:
+            # Wait for clients forever
+            try:
+                while True:
+                    clientsocket, address = ssock.accept()
+                    if kwargs.get("verb", True):
+                        print(conf.color_theme.gold(
+                            "\u2503 Connection received from %s" % repr(address)
+                        ))
+                    # Start atmt class with socket
+                    sock = cls.socketcls(clientsocket, cls.pkt_cls)
+                    atmt_server = cls(
+                        sock=sock,
+                        iface=iface, **kwargs
+                    )
+                    clients.append((atmt_server, clientsocket))
+                    # start atmt
+                    atmt_server.runbg()
+            except KeyboardInterrupt:
+                print("X Exiting.")
+                ssock.shutdown(socket.SHUT_RDWR)
+            except OSError:
+                print("X Server closed.")
+            finally:
+                for atmt, clientsocket in clients:
+                    try:
+                        atmt.forcestop(wait=False)
+                    except Exception:
+                        pass
+                    try:
+                        clientsocket.shutdown(socket.SHUT_RDWR)
+                        clientsocket.close()
+                    except Exception:
+                        pass
+                ssock.close()
+        if bg:
+            # Background
+            threading.Thread(target=_run).start()
+            return ssock
+        else:
+            # Non-background
+            _run()
+            return None
+
     def master_filter(self, pkt):
         # type: (Packet) -> bool
         return True
 
-    def my_send(self, pkt):
-        # type: (Packet) -> None
-        self.send_sock.send(pkt)
+    def my_send(self, pkt, **kwargs):
+        # type: (Packet, **Any) -> None
+        if not self.send_sock:
+            raise ValueError("send_sock is None !")
+        self.send_sock.send(pkt, **kwargs)
+
+    def update_sock(self, sock):
+        # type: (SuperSocket) -> None
+        """
+        Update the socket used by the automata.
+        Typically used in an eof event to reconnect.
+        """
+        self.sock = sock
+        if self.listen_sock is not None:
+            self.listen_sock = self.sock
+        if self.send_sock:
+            self.send_sock = self.sock
 
     def timer_by_name(self, name):
         # type: (str) -> Optional[Timer]
-        for _, timers in six.iteritems(self.timeout):
+        for _, timers in self.timeout.items():
             for timer in timers:  # type: Timer
                 if timer._func.atmt_condname == name:
                     return timer
         return None
 
     # Utility classes and exceptions
     class _IO_fdwrapper:
         def __init__(self,
                      rd,  # type: Union[int, ObjectPipe[bytes], None]
                      wr  # type: Union[int, ObjectPipe[bytes], None]
                      ):
             # type: (...) -> None
-            if rd is not None and not isinstance(rd, (int, ObjectPipe)):
-                rd = rd.fileno()  # type: ignore
-            if wr is not None and not isinstance(wr, (int, ObjectPipe)):
-                wr = wr.fileno()  # type: ignore
             self.rd = rd
             self.wr = wr
+            if isinstance(self.rd, socket.socket):
+                self.__selectable_force_select__ = True
 
         def fileno(self):
             # type: () -> int
-            if isinstance(self.rd, ObjectPipe):
-                return self.rd.fileno()
-            elif isinstance(self.rd, int):
+            if isinstance(self.rd, int):
                 return self.rd
+            elif self.rd:
+                return self.rd.fileno()
             return 0
 
         def read(self, n=65535):
             # type: (int) -> Optional[bytes]
-            if isinstance(self.rd, ObjectPipe):
-                return self.rd.recv(n)
-            elif isinstance(self.rd, int):
+            if isinstance(self.rd, int):
                 return os.read(self.rd, n)
+            elif self.rd:
+                return self.rd.recv(n)
             return None
 
         def write(self, msg):
             # type: (bytes) -> int
-            if isinstance(self.wr, ObjectPipe):
-                return self.wr.send(msg)
-            elif isinstance(self.wr, int):
+            if isinstance(self.wr, int):
                 return os.write(self.wr, msg)
+            elif self.wr:
+                return self.wr.send(msg)
             return 0
 
         def recv(self, n=65535):
             # type: (int) -> Optional[bytes]
             return self.read(n)
 
         def send(self, msg):
@@ -993,29 +1151,33 @@
         pass
 
     class Singlestep(AutomatonStopped):
         pass
 
     class InterceptionPoint(AutomatonStopped):
         def __init__(self, msg, state=None, result=None, packet=None):
-            # type: (str, Optional[Message], Optional[str], Optional[str]) -> None  # noqa: E501
-            Automaton.AutomatonStopped.__init__(self, msg, state=state, result=result)  # noqa: E501
+            # type: (str, Optional[Message], Optional[str], Optional[Packet]) -> None
+            Automaton.AutomatonStopped.__init__(self, msg, state=state, result=result)
             self.packet = packet
 
     class CommandMessage(AutomatonException):
         pass
 
     # Services
     def debug(self, lvl, msg):
         # type: (int, str) -> None
         if self.debug_level >= lvl:
             log_runtime.debug(msg)
 
-    def send(self, pkt):
-        # type: (Packet) -> None
+    def isrunning(self):
+        # type: () -> bool
+        return self.started.locked()
+
+    def send(self, pkt, **kwargs):
+        # type: (Packet, **Any) -> None
         if self.state.state in self.interception_points:
             self.debug(3, "INTERCEPT: packet intercepted: %s" % pkt.summary())
             self.intercepted_packet = pkt
             self.cmdout.send(
                 Message(type=_ATMT_Command.INTERCEPT,
                         state=self.state, pkt=pkt)
             )
@@ -1030,27 +1192,26 @@
             elif cmd.type == _ATMT_Command.REPLACE:
                 pkt = cmd.pkt
                 self.debug(3, "INTERCEPT: packet replaced by: %s" % pkt.summary())  # noqa: E501
             elif cmd.type == _ATMT_Command.ACCEPT:
                 self.debug(3, "INTERCEPT: packet accepted")
             else:
                 raise self.AutomatonError("INTERCEPT: unknown verdict: %r" % cmd.type)  # noqa: E501
-        self.my_send(pkt)
+        self.my_send(pkt, **kwargs)
         self.debug(3, "SENT : %s" % pkt.summary())
 
         if self.store_packets:
             self.packets.append(pkt.copy())
 
     def __iter__(self):
         # type: () -> Automaton
         return self
 
     def __del__(self):
         # type: () -> None
-        self.stop()
         self.destroy()
 
     def _run_condition(self, cond, *args, **kargs):
         # type: (_StateWrapper, Any, Any) -> None
         try:
             self.debug(5, "Trying %s [%s]" % (cond.atmt_type, cond.atmt_condname))  # noqa: E501
             cond(self, *args, **kargs)
@@ -1093,20 +1254,18 @@
             a = args + self.init_args[len(args):]
             k = self.init_kargs.copy()
             k.update(kargs)
             self.parse_args(*a, **k)
 
             # Start the automaton
             self.state = self.initial_states[0](self)
-            self.send_sock = self.send_sock_class(**self.socket_kargs)
+            self.send_sock = self.sock or self.send_sock_class(**self.socket_kargs)
             if self.recv_conditions:
                 # Only start a receiving socket if we have at least one recv_conditions
-                self.listen_sock = self.recv_sock_class(**self.socket_kargs)
-            else:
-                self.listen_sock = None
+                self.listen_sock = self.sock or self.recv_sock_class(**self.socket_kargs)  # noqa: E501
             self.packets = PacketList(name="session[%s]" % self.__class__.__name__)
 
             singlestep = True
             iterator = self._do_iter()
             self.debug(3, "Starting control thread [tid=%i]" % self.threadid)
             # Sync threads
             ready.set()
@@ -1119,17 +1278,17 @@
                     if c.type == _ATMT_Command.RUN:
                         singlestep = False
                     elif c.type == _ATMT_Command.NEXT:
                         singlestep = True
                     elif c.type == _ATMT_Command.FREEZE:
                         continue
                     elif c.type == _ATMT_Command.STOP:
-                        if self.stop_states:
+                        if self.stop_state:
                             # There is a stop state
-                            self.state = self.stop_states[0](self)
+                            self.state = self.stop_state()
                             iterator = self._do_iter()
                         else:
                             # Act as FORCESTOP
                             break
                     elif c.type == _ATMT_Command.FORCESTOP:
                         break
                     while True:
@@ -1151,17 +1310,17 @@
             except Exception as e:
                 exc_info = sys.exc_info()
                 self.debug(3, "Transferring exception from tid=%i:\n%s" % (self.threadid, "".join(traceback.format_exception(*exc_info))))  # noqa: E501
                 m = Message(type=_ATMT_Command.EXCEPTION, exception=e, exc_info=exc_info)  # noqa: E501
                 self.cmdout.send(m)
             self.debug(3, "Stopping control thread (tid=%i)" % self.threadid)
             self.threadid = None
-            if getattr(self, "listen_sock", None):
+            if self.listen_sock:
                 self.listen_sock.close()
-            if getattr(self, "send_sock", None):
+            if self.send_sock:
                 self.send_sock.close()
 
     def _do_iter(self):
         # type: () -> Iterator[Union[Automaton.AutomatonException, Automaton.AutomatonStopped, ATMT.NewStateRequested, None]] # noqa: E501
         while True:
             try:
                 self.debug(1, "## state=[%s]" % self.state.state)
@@ -1201,36 +1360,56 @@
                                          state=self.state.state,
                                          result=state_output)
 
                 # Finally listen and pay attention to timeouts
                 timers.reset()
                 time_previous = time.time()
 
-                fds = [self.cmdin]
+                fds = [self.cmdin]  # type: List[Union[SuperSocket, ObjectPipe[Any]]]
+                select_func = select_objects
                 if self.listen_sock and self.recv_conditions[self.state.state]:
                     fds.append(self.listen_sock)
+                    select_func = self.listen_sock.select  # type: ignore
                 for ioev in self.ioevents[self.state.state]:
                     fds.append(self.ioin[ioev.atmt_ioname])
                 while True:
                     time_current = time.time()
                     timers.decrement(time_current - time_previous)
                     time_previous = time_current
                     for timer in timers.expired():
                         self._run_condition(timer._func, *state_output)
                     remain = timers.until_next()
 
                     self.debug(5, "Select on %r" % fds)
-                    r = select_objects(fds, remain)
+                    r = select_func(fds, remain)
                     self.debug(5, "Selected %r" % r)
                     for fd in r:
                         self.debug(5, "Looking at %r" % fd)
                         if fd == self.cmdin:
                             yield self.CommandMessage("Received command message")  # noqa: E501
                         elif fd == self.listen_sock:
-                            pkt = self.listen_sock.recv(MTU)
+                            try:
+                                pkt = self.listen_sock.recv()
+                            except EOFError:
+                                # Socket was closed abruptly. This will likely only
+                                # ever happen when a client socket is passed to the
+                                # automaton (not the case when the automaton is
+                                # listening on a promiscuous conf.L2sniff)
+                                self.listen_sock.close()
+                                # False so that it is still reset by update_sock
+                                self.listen_sock = False  # type: ignore
+                                fds.remove(fd)
+                                if self.state.state in self.eofs:
+                                    # There is an eof state
+                                    eof = self.eofs[self.state.state]
+                                    self.debug(2, "Condition EOF [%s] taken" % eof.__name__)  # noqa: E501
+                                    raise self.eofs[self.state.state](self)
+                                else:
+                                    # There isn't. Therefore, it's a closing condition.
+                                    raise EOFError("Socket ended arbruptly.")
                             if pkt is not None:
                                 if self.master_filter(pkt):
                                     self.debug(3, "RECVD: %s" % pkt.summary())  # noqa: E501
                                     for rcvcond in self.recv_conditions[self.state.state]:  # noqa: E501
                                         self._run_condition(rcvcond, pkt, *state_output)  # noqa: E501
                                 else:
                                     self.debug(4, "FILTR: %s" % pkt.summary())  # noqa: E501
@@ -1245,15 +1424,15 @@
                 self.state = state_req
                 yield state_req
 
     def __repr__(self):
         # type: () -> str
         return "<Automaton %s [%s]>" % (
             self.__class__.__name__,
-            ["HALTED", "RUNNING"][self.started.locked()]
+            ["HALTED", "RUNNING"][self.isrunning()]
         )
 
     # Public API
     def add_interception_points(self, *ipts):
         # type: (Any) -> None
         for ipt in ipts:
             if hasattr(ipt, "atmt_state"):
@@ -1279,15 +1458,15 @@
         for bp in bps:
             if hasattr(bp, "atmt_state"):
                 bp = bp.atmt_state
             self.breakpoints.discard(bp)
 
     def start(self, *args, **kargs):
         # type: (Any, Any) -> None
-        if self.started.locked():
+        if self.isrunning():
             raise ValueError("Already started")
         # Start the control thread
         self._do_start(*args, **kargs)
 
     def run(self,
             resume=None,    # type: Optional[Message]
             wait=True       # type: Optional[bool]
@@ -1309,44 +1488,48 @@
             elif c.type == _ATMT_Command.INTERCEPT:
                 raise self.InterceptionPoint("packet intercepted", state=c.state.state, packet=c.pkt)  # noqa: E501
             elif c.type == _ATMT_Command.SINGLESTEP:
                 raise self.Singlestep("singlestep state=[%s]" % c.state.state, state=c.state.state)  # noqa: E501
             elif c.type == _ATMT_Command.BREAKPOINT:
                 raise self.Breakpoint("breakpoint triggered on state [%s]" % c.state.state, state=c.state.state)  # noqa: E501
             elif c.type == _ATMT_Command.EXCEPTION:
-                six.reraise(c.exc_info[0], c.exc_info[1], c.exc_info[2])
+                # this code comes from the `six` module (`.reraise()`)
+                # to raise an exception with specified exc_info.
+                value = c.exc_info[0]() if c.exc_info[1] is None else c.exc_info[1]  # type: ignore  # noqa: E501
+                if value.__traceback__ is not c.exc_info[2]:
+                    raise value.with_traceback(c.exc_info[2])
+                raise value
         return None
 
     def runbg(self, resume=None, wait=False):
         # type: (Optional[Message], Optional[bool]) -> None
         self.run(resume, wait)
 
-    def next(self):
+    def __next__(self):
         # type: () -> Any
         return self.run(resume=Message(type=_ATMT_Command.NEXT))
-    __next__ = next
 
     def _flush_inout(self):
         # type: () -> None
         # Flush command pipes
         for cmd in [self.cmdin, self.cmdout]:
             cmd.clear()
 
     def destroy(self):
         # type: () -> None
         """
         Destroys a stopped Automaton: this cleanups all opened file descriptors.
         Required on PyPy for instance where the garbage collector behaves differently.
         """
-        if self.started.locked():
+        if self.isrunning():
             raise ValueError("Can't close running Automaton ! Call stop() beforehand")
-        self._flush_inout()
         # Close command pipes
         self.cmdin.close()
         self.cmdout.close()
+        self._flush_inout()
         # Close opened ioins/ioouts
         for i in itertools.chain(self.ioin.values(), self.ioout.values()):
             if isinstance(i, ObjectPipe):
                 i.close()
 
     def stop(self, wait=True):
         # type: (bool) -> None
```

### Comparing `scapy-2.5.0rc3/scapy/autorun.py` & `scapy-2.6.0rc1/scapy/autorun.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,37 +3,36 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Run commands when the Scapy interpreter starts.
 """
 
-from __future__ import print_function
+import builtins
 import code
+from io import StringIO
 import logging
+from queue import Queue
 import sys
 import threading
 import traceback
 
 from scapy.config import conf
 from scapy.themes import NoTheme, DefaultTheme, HTMLTheme2, LatexTheme2
 from scapy.error import log_scapy, Scapy_Exception
 from scapy.utils import tex_escape
 
-from scapy.compat import (
+from typing import (
     Any,
     Optional,
     TextIO,
     Dict,
     Tuple,
 )
 
-from scapy.libs.six.moves import queue
-import scapy.libs.six as six
-
 
 #########################
 #     Autorun stuff     #
 #########################
 
 class StopAutorun(Scapy_Exception):
     code_run = ""
@@ -59,15 +58,15 @@
     try:
         try:
             if my_globals is None:
                 from scapy.main import _scapy_builtins
                 my_globals = _scapy_builtins()
             interp = ScapyAutorunInterpreter(locals=my_globals)
             try:
-                del six.moves.builtins.__dict__["scapy_session"]["_"]
+                del builtins.__dict__["scapy_session"]["_"]
             except KeyError:
                 pass
             if verb is not None:
                 conf.verb = verb
             cmd = ""
             cmds = _cmds.splitlines()
             cmds.append("")  # ensure we finish multi-line commands
@@ -95,50 +94,50 @@
                 if len(cmds) <= 1:
                     break
         except SystemExit:
             pass
     finally:
         conf.verb = sv
     try:
-        return six.moves.builtins.__dict__["scapy_session"]["_"]
+        return builtins.__dict__["scapy_session"]["_"]
     except KeyError:
-        return six.moves.builtins.__dict__.get("_", None)
+        return builtins.__dict__.get("_", None)
 
 
 def autorun_commands_timeout(cmds, timeout=None, **kwargs):
     # type: (str, Optional[int], **Any) -> Any
     """
     Wraps autorun_commands with a timeout that raises StopAutorunTimeout
     on expiration.
     """
     if timeout is None:
         return autorun_commands(cmds, **kwargs)
 
-    q = queue.Queue()
+    q = Queue()  # type: Queue[Any]
 
     def _runner():
         # type: () -> None
         q.put(autorun_commands(cmds, **kwargs))
     th = threading.Thread(target=_runner)
     th.daemon = True
     th.start()
     th.join(timeout)
     if th.is_alive():
         raise StopAutorunTimeout
     return q.get()
 
 
-class StringWriter(six.StringIO):
+class StringWriter(StringIO):
     """Util to mock sys.stdout and sys.stderr, and
     store their output in a 's' var."""
     def __init__(self, debug=None):
         # type: (Optional[TextIO]) -> None
         self.s = ""
         self.debug = debug
-        six.StringIO.__init__(self)
+        super().__init__()
 
     def write(self, x):
         # type: (str) -> int
         # Object can be in the middle of being destroyed.
         if getattr(self, "debug", None) and self.debug:
             self.debug.write(x)
         if getattr(self, "s", None) is not None:
@@ -164,15 +163,15 @@
     sw = StringWriter()
     h_old = log_scapy.handlers[0]
     log_scapy.removeHandler(h_old)
     log_scapy.addHandler(logging.StreamHandler(stream=sw))
     try:
         try:
             sys.stdout = sys.stderr = sw
-            sys.excepthook = sys.__excepthook__  # type: ignore
+            sys.excepthook = sys.__excepthook__
             res = autorun_commands_timeout(cmds, **kargs)
         except StopAutorun as e:
             e.code_run = sw.s
             raise
     finally:
         sys.stdout, sys.stderr, sys.excepthook = sstdout, sstderr, sexcepthook
         log_scapy.removeHandler(log_scapy.handlers[0])
```

### Comparing `scapy-2.5.0rc3/scapy/base_classes.py` & `scapy-2.6.0rc1/scapy/base_classes.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,52 +7,52 @@
 Generators and packet meta classes.
 """
 
 ################
 #  Generators  #
 ################
 
-from __future__ import absolute_import
 
 from functools import reduce
+import abc
 import operator
 import os
 import random
 import re
 import socket
 import struct
 import subprocess
 import types
 import warnings
 
 import scapy
 from scapy.error import Scapy_Exception
 from scapy.consts import WINDOWS
 
-from scapy.libs.six.moves import range
-
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     Generic,
     Iterator,
     List,
     Optional,
     Tuple,
     Type,
     TypeVar,
     Union,
-    _Generic_metaclass,
     cast,
+    TYPE_CHECKING,
 )
 
-try:
-    import pyx
-except ImportError:
-    pass
+if TYPE_CHECKING:
+    try:
+        import pyx
+    except ImportError:
+        pass
+    from scapy.packet import Packet
 
 _T = TypeVar("_T")
 
 
 class Gen(Generic[_T]):
     __slots__ = []  # type: List[str]
 
@@ -274,36 +274,36 @@
         return reduce(operator.mul, (max(y - x, 0) + 1 for (x, y) in self.cmpt), 1)  # noqa: E501
 
 
 ######################################
 #  Packet abstract and base classes  #
 ######################################
 
-class Packet_metaclass(_Generic_metaclass):
-    def __new__(cls,
+class Packet_metaclass(type):
+    def __new__(cls: Type[_T],
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
-        # type: (...) -> Type['scapy.packet.Packet']
+        # type: (...) -> Type['Packet']
         if "fields_desc" in dct:  # perform resolution of references to other packets  # noqa: E501
             current_fld = dct["fields_desc"]  # type: List[Union[scapy.fields.Field[Any, Any], Packet_metaclass]]  # noqa: E501
             resolved_fld = []  # type: List[scapy.fields.Field[Any, Any]]
             for fld_or_pkt in current_fld:
                 if isinstance(fld_or_pkt, Packet_metaclass):
                     # reference to another fields_desc
-                    for pkt_fld in fld_or_pkt.fields_desc:  # type: ignore
+                    for pkt_fld in fld_or_pkt.fields_desc:
                         resolved_fld.append(pkt_fld)
                 else:
                     resolved_fld.append(fld_or_pkt)
         else:  # look for a fields_desc in parent classes
             resolved_fld = []
             for b in bases:
                 if hasattr(b, "fields_desc"):
-                    resolved_fld = b.fields_desc  # type: ignore
+                    resolved_fld = b.fields_desc
                     break
 
         if resolved_fld:  # perform default value replacements
             final_fld = []  # type: List[scapy.fields.Field[Any, Any]]
             names = []
             for f in resolved_fld:
                 if f.name in names:
@@ -342,100 +342,100 @@
                 inspect.Parameter(f.name,
                                   inspect.Parameter.KEYWORD_ONLY,
                                   default=f.default)
                 for f in dct["fields_desc"]
             ])
         except (ImportError, AttributeError, KeyError):
             pass
-        newcls = cast('Type[scapy.packet.Packet]',
-                      type.__new__(cls, name, bases, dct))
+        newcls = cast(Type['Packet'], type.__new__(cls, name, bases, dct))
         # Note: below can't be typed because we use attributes
         # created dynamically..
-        newcls.__all_slots__ = set(
+        newcls.__all_slots__ = set(  # type: ignore
             attr
             for cls in newcls.__mro__ if hasattr(cls, "__slots__")
             for attr in cls.__slots__
         )
 
-        newcls.aliastypes = (
+        newcls.aliastypes = (  # type: ignore
             [newcls] + getattr(newcls, "aliastypes", [])
         )
 
         if hasattr(newcls, "register_variant"):
             newcls.register_variant()
         for _f in newcls.fields_desc:
             if hasattr(_f, "register_owner"):
                 _f.register_owner(newcls)
         if newcls.__name__[0] != "_":
             from scapy import config
             config.conf.layers.register(newcls)
         return newcls
 
     def __getattr__(self, attr):
-        # type: (str) -> scapy.fields.Field[Any, Any]
-        for k in self.fields_desc:  # type: ignore
+        # type: (str) -> Any
+        for k in self.fields_desc:
             if k.name == attr:
-                return k  # type: ignore
+                return k
         raise AttributeError(attr)
 
     def __call__(cls,
                  *args,  # type: Any
                  **kargs  # type: Any
                  ):
-        # type: (...) -> 'scapy.packet.Packet'
+        # type: (...) -> 'Packet'
         if "dispatch_hook" in cls.__dict__:
             try:
-                cls = cls.dispatch_hook(*args, **kargs)  # type: ignore
+                cls = cls.dispatch_hook(*args, **kargs)
             except Exception:
                 from scapy import config
                 if config.conf.debug_dissector:
                     raise
-                cls = config.conf.raw_layer  # type: ignore
+                cls = config.conf.raw_layer
         i = cls.__new__(
             cls,  # type: ignore
             cls.__name__,
             cls.__bases__,
-            cls.__dict__
+            cls.__dict__  # type: ignore
         )
         i.__init__(*args, **kargs)
         return i  # type: ignore
 
 
 # Note: see compat.py for an explanation
 
-class Field_metaclass(_Generic_metaclass):
-    def __new__(cls,
+class Field_metaclass(type):
+    def __new__(cls: Type[_T],
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
-        # type: (...) -> Type[scapy.fields.Field[Any, Any]]
+        # type: (...) -> Type[_T]
         dct.setdefault("__slots__", [])
-        newcls = super(Field_metaclass, cls).__new__(cls, name, bases, dct)
+        newcls = type.__new__(cls, name, bases, dct)
         return newcls  # type: ignore
 
 
 PacketList_metaclass = Field_metaclass
 
 
-class BasePacket(Gen['scapy.packet.Packet']):
+class BasePacket(Gen['Packet']):
     __slots__ = []  # type: List[str]
 
 
 #############################
 #  Packet list base class   #
 #############################
 
 class BasePacketList(Gen[_T]):
     __slots__ = []  # type: List[str]
 
 
 class _CanvasDumpExtended(object):
-    def canvas_dump(self, **kwargs):
-        # type: (**Any) -> 'pyx.canvas.canvas'
+    @abc.abstractmethod
+    def canvas_dump(self, layer_shift=0, rebuild=1):
+        # type: (int, int) -> pyx.canvas.canvas
         pass
 
     def psdump(self, filename=None, **kargs):
         # type: (Optional[str], **Any) -> None
         """
         psdump(filename=None, layer_shift=0, rebuild=1)
```

### Comparing `scapy-2.5.0rc3/scapy/compat.py` & `scapy-2.6.0rc1/scapy/contrib/isotp/isotp_utils.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,411 +1,361 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
+# Copyright (C) Nils Weiss <nils@we155.de>
+# Copyright (C) Enrico Pozzobon <enricopozzobon@gmail.com>
+# Copyright (C) Alexander Schroeder <alexander1.schroeder@st.othr.de>
+
+# scapy.contrib.description = ISO-TP (ISO 15765-2) Utilities
+# scapy.contrib.status = library
 
-"""
-Python 2 and 3 link classes.
-"""
-
-from __future__ import absolute_import
-import base64
-import binascii
-import collections
-import gzip
-import socket
 import struct
-import sys
 
-import scapy.libs.six as six
+from scapy.config import conf
+from scapy.utils import EDecimal
+from scapy.packet import Packet
+from scapy.sessions import DefaultSession
+from scapy.supersocket import SuperSocket
+from scapy.contrib.isotp.isotp_packet import ISOTP, N_PCI_CF, N_PCI_SF, \
+    N_PCI_FF, N_PCI_FC
+
+# Typing imports
+from typing import (
+    cast,
+    Iterable,
+    Iterator,
+    Optional,
+    Union,
+    List,
+    Tuple,
+    Dict,
+    Any,
+    Type,
+)
+
+
+class ISOTPMessageBuilderIter(object):
+    """
+    Iterator class for ISOTPMessageBuilder
+    """
+    slots = ["builder"]
 
-# Very important: will issue typing errors otherwise
-__all__ = [
-    # typing
-    'Any',
-    'AnyStr',
-    'Callable',
-    'DefaultDict',
-    'Deque',
-    'Dict',
-    'Generic',
-    'IO',
-    'Iterable',
-    'Iterable',
-    'Iterator',
-    'List',
-    'Literal',
-    'NamedTuple',
-    'NewType',
-    'NoReturn',
-    'Optional',
-    'Pattern',
-    'Sequence',
-    'Set',
-    'Sized',
-    'TextIO',
-    'Tuple',
-    'Type',
-    'TypeVar',
-    'Union',
-    'ValuesView',
-    'cast',
-    'overload',
-    'FAKE_TYPING',
-    'TYPE_CHECKING',
-    # compat
-    'AddressFamily',
-    'base64_bytes',
-    'bytes_base64',
-    'bytes_encode',
-    'bytes_hex',
-    'chb',
-    'gzip_compress',
-    'gzip_decompress',
-    'hex_bytes',
-    'lambda_tuple_converter',
-    'orb',
-    'plain_str',
-    'raw',
-]
-
-# Typing compatibility
-
-# Note:
-# supporting typing on multiple python versions is a nightmare.
-# Since Python 3.7, Generic is a type instead of a metaclass,
-# therefore we can't support both at the same time. Our strategy
-# is to only use the typing module if the Python version is >= 3.7
-# and use totally fake replacements otherwise.
-# HOWEVER, when using the fake ones, to emulate stub Generic
-# fields (e.g. _PacketField[str]) we need to add a fake
-# __getitem__ to Field_metaclass
-
-try:
-    import typing  # noqa: F401
-    from typing import TYPE_CHECKING
-    if sys.version_info[0:2] <= (3, 6):
-        # Generic is messed up before Python 3.7
-        # https://github.com/python/typing/issues/449
-        raise ImportError
-    FAKE_TYPING = False
-except ImportError:
-    FAKE_TYPING = True
-    TYPE_CHECKING = False
-
-# Import or create fake types
-
-
-# If your class uses a metaclass AND Generic, you'll need to
-# extend this class in the metaclass to avoid conflicts...
-# Of course we wouldn't need this on Python 3 :/
-class _Generic_metaclass(type):
-    if FAKE_TYPING:
-        def __getitem__(self, typ):
-            # type: (Any) -> Any
-            return self
-
-
-def _FakeType(name, cls=object):
-    # type: (str, Optional[type]) -> Any
-    class _FT(object):
-        def __init__(self, name):
-            # type: (str) -> None
-            self.name = name
-
-        # make the objects subscriptable indefinitely
-        def __getitem__(self, item):  # type: ignore
-            return cls
-
-        def __call__(self, *args, **kargs):
-            # type: (*Any, **Any) -> Any
-            if isinstance(args[0], str):
-                self.name = args[0]
-            return self
-
-        def __repr__(self):
-            # type: () -> str
-            return "<Fake typing.%s>" % self.name
-    return _FT(name)
-
-
-if not FAKE_TYPING:
-    # Only required if using mypy-lang for static typing
-    from typing import (
-        Any,
-        AnyStr,
-        Callable,
-        DefaultDict,
-        Deque,
-        Dict,
-        Generic,
-        IO,
-        Iterable,
-        Iterator,
-        List,
-        NewType,
-        NoReturn,
-        Optional,
-        Pattern,
-        Sequence,
-        Set,
-        Sized,
-        TextIO,
-        Tuple,
-        Type,
-        TypeVar,
-        Union,
-        ValuesView,
-        cast,
-        overload,
-    )
-else:
-    # Let's be creative and make some fake ones.
-    def cast(_type, obj):  # type: ignore
-        return obj
-
-    Any = _FakeType("Any")
-    AnyStr = _FakeType("AnyStr")  # type: ignore
-    Callable = _FakeType("Callable")
-    DefaultDict = _FakeType("DefaultDict",  # type: ignore
-                            collections.defaultdict)
-    Deque = _FakeType("Deque")  # type: ignore
-    Dict = _FakeType("Dict", dict)  # type: ignore
-    IO = _FakeType("IO")  # type: ignore
-    Iterable = _FakeType("Iterable")  # type: ignore
-    Iterator = _FakeType("Iterator")  # type: ignore
-    List = _FakeType("List", list)  # type: ignore
-    NewType = _FakeType("NewType")
-    NoReturn = _FakeType("NoReturn")
-    Optional = _FakeType("Optional")
-    Pattern = _FakeType("Pattern")  # type: ignore
-    Sequence = _FakeType("Sequence", list)  # type: ignore
-    Set = _FakeType("Set", set)  # type: ignore
-    TextIO = _FakeType("TextIO")  # type: ignore
-    Tuple = _FakeType("Tuple")
-    Type = _FakeType("Type", type)
-    TypeVar = _FakeType("TypeVar")  # type: ignore
-    Union = _FakeType("Union")
-    ValuesView = _FakeType("List", list)  # type: ignore
-
-    class Sized(object):  # type: ignore
-        pass
-
-    @six.add_metaclass(_Generic_metaclass)
-    class Generic(object):  # type: ignore
-        pass
-
-    overload = lambda x: x
-
-
-# Broken < Python 3.7
-if sys.version_info >= (3, 7):
-    from typing import NamedTuple
-else:
-    # Hack for Python < 3.7 - Implement NamedTuple pickling
-    def _unpickleNamedTuple(name, len_params, *args):
-        return collections.namedtuple(
-            name,
-            args[:len_params]
-        )(*args[len_params:])
-
-    def NamedTuple(name, params):
-        tup_params = tuple(x[0] for x in params)
-        cls = collections.namedtuple(name, tup_params)
-
-        class _NT(cls):
-            def __reduce__(self):
-                """Used by pickling methods"""
-                return (_unpickleNamedTuple,
-                        (name, len(tup_params)) + tup_params + tuple(self))
-        _NT.__name__ = cls.__name__
-        return _NT
-
-# Python 3.8 Only
-if sys.version_info >= (3, 8):
-    from typing import Literal
-else:
-    Literal = _FakeType("Literal")
-
-# Python 3.4
-if sys.version_info >= (3, 4):
-    from socket import AddressFamily
-else:
-    class AddressFamily:
-        AF_INET = socket.AF_INET
-        AF_INET6 = socket.AF_INET6
-        AF_UNSPEC = socket.AF_UNSPEC
-
-
-###########
-# Python3 #
-###########
+    def __init__(self, builder):
+        # type: (ISOTPMessageBuilder) -> None
+        self.builder = builder
+
+    def __iter__(self):
+        # type: () -> ISOTPMessageBuilderIter
+        return self
+
+    def __next__(self):
+        # type: () -> ISOTP
+        while self.builder.count:
+            p = self.builder.pop()
+            if p is None:
+                break
+            else:
+                return p
+        raise StopIteration
 
-# https://mypy.readthedocs.io/en/stable/generics.html#declaring-decorators
-DecoratorCallable = TypeVar("DecoratorCallable", bound=Callable[..., Any])
+    next = __next__
 
 
-def lambda_tuple_converter(func):
-    # type: (DecoratorCallable) -> DecoratorCallable
+class ISOTPMessageBuilder(object):
     """
-    Converts a Python 2 function as
-      lambda (x,y): x + y
-    In the Python 3 format:
-      lambda x,y : x + y
+    Initialize a ISOTPMessageBuilder object
+
+    Utility class to build ISOTP messages out of CAN frames, used by both
+    ISOTP.defragment() and ISOTPSession.
+
+    This class attempts to interpret some CAN frames as ISOTP frames, both with
+    and without extended addressing at the same time. For example, if an
+    extended address of 07 is being used, all frames will also be interpreted
+    as ISOTP single-frame messages.
+
+    CAN frames are fed to an ISOTPMessageBuilder object with the feed() method
+    and the resulting ISOTP frames can be extracted using the pop() method.
+
+    :param use_ext_address: True for only attempting to defragment with
+                         extended addressing, False for only attempting
+                         to defragment without extended addressing,
+                         or None for both
+    :param rx_id: Destination Identifier
+    :param basecls: The class of packets that will be returned,
+                    defaults to ISOTP
     """
-    if func is not None and func.__code__.co_argcount == 1:
-        return lambda *args: func(  # type: ignore
-            args[0] if len(args) == 1 else args
-        )
-    else:
-        return func
-
-
-# This is ugly, but we don't want to move raw() out of compat.py
-# and it makes it much clearer
-if TYPE_CHECKING:
-    from scapy.packet import Packet
-
-
-if six.PY2:
-    bytes_encode = plain_str = str  # type: Callable[[Any], bytes]
-    orb = ord  # type: Callable[[bytes], int]
-
-    def chb(x):
-        # type: (int) -> bytes
-        if isinstance(x, str):
-            return x
-        return chr(x)
 
-    def raw(x):
-        # type: (Union[Packet]) -> bytes
+    class Bucket(object):
         """
-        Builds a packet and returns its bytes representation.
-        This function is and will always be cross-version compatible
+        Helper class to store not finished ISOTP messages while building.
         """
-        if hasattr(x, "__bytes__"):
-            return x.__bytes__()
-        return bytes(x)
-else:
-    def raw(x):
-        # type: (Union[Packet]) -> bytes
+
+        def __init__(self, total_len, first_piece, ts):
+            # type: (int, bytes, Union[EDecimal, float]) -> None
+            self.pieces = list()  # type: List[bytes]
+            self.total_len = total_len
+            self.current_len = 0
+            self.ready = None  # type: Optional[bytes]
+            self.tx_id = None  # type: Optional[int]
+            self.ext_address = None  # type: Optional[int]
+            self.time = ts  # type: Union[float, EDecimal]
+            self.push(first_piece)
+
+        def push(self, piece):
+            # type: (bytes) -> None
+            self.pieces.append(piece)
+            self.current_len += len(piece)
+            if self.current_len >= self.total_len:
+                isotp_data = b"".join(self.pieces)
+                self.ready = isotp_data[:self.total_len]
+
+    def __init__(
+            self,
+            use_ext_address=None,  # type: Optional[bool]
+            rx_id=None,  # type: Optional[Union[int, List[int], Iterable[int]]]
+            basecls=ISOTP  # type: Type[ISOTP]
+    ):
+        # type: (...) -> None
+        self.ready = []  # type: List[Tuple[int, Optional[int], ISOTPMessageBuilder.Bucket]]  # noqa: E501
+        self.buckets = {}  # type: Dict[Tuple[Optional[int], int, int], ISOTPMessageBuilder.Bucket]  # noqa: E501
+        self.use_ext_addr = use_ext_address
+        self.basecls = basecls
+        self.rx_ids = None  # type: Optional[Iterable[int]]
+        self.last_ff = None  # type: Optional[Tuple[Optional[int], int, int]]
+        self.last_ff_ex = None  # type: Optional[Tuple[Optional[int], int, int]]  # noqa: E501
+        if rx_id is not None:
+            if isinstance(rx_id, list):
+                self.rx_ids = rx_id
+            elif isinstance(rx_id, int):
+                self.rx_ids = [rx_id]
+            elif hasattr(rx_id, "__iter__"):
+                self.rx_ids = rx_id
+            else:
+                raise TypeError("Invalid type for argument rx_id!")
+
+    def feed(self, can):
+        # type: (Union[Iterable[Packet], Packet]) -> None
+        """Attempt to feed an incoming CAN frame into the state machine"""
+        if not isinstance(can, Packet) and hasattr(can, "__iter__"):
+            for p in can:
+                self.feed(p)
+            return
+
+        if not isinstance(can, Packet):
+            return
+
+        if self.rx_ids is not None and can.identifier not in self.rx_ids:
+            return
+
+        data = bytes(can.data)
+
+        if len(data) > 1 and self.use_ext_addr is not True:
+            self._try_feed(can.identifier, None, data, can.time)
+        if len(data) > 2 and self.use_ext_addr is not False:
+            ea = data[0]
+            self._try_feed(can.identifier, ea, data[1:], can.time)
+
+    @property
+    def count(self):
+        # type: () -> int
+        """Returns the number of ready ISOTP messages built from the provided
+        can frames
+
+        :return: Number of ready ISOTP messages
         """
-        Builds a packet and returns its bytes representation.
-        This function is and will always be cross-version compatible
+        return len(self.ready)
+
+    def __len__(self):
+        # type: () -> int
+        return self.count
+
+    def pop(self, identifier=None, ext_addr=None):
+        # type: (Optional[int], Optional[int]) -> Optional[ISOTP]
+        """Returns a built ISOTP message
+
+        :param identifier: if not None, only return isotp messages with this
+                           destination
+        :param ext_addr: if identifier is not None, only return isotp messages
+                         with this extended address for destination
+        :returns: an ISOTP packet, or None if no message is ready
         """
-        return bytes(x)
 
-    def bytes_encode(x):
-        # type: (Any) -> bytes
-        """Ensure that the given object is bytes.
-        If the parameter is a packet, raw() should be preferred.
+        if identifier is not None:
+            for i in range(len(self.ready)):
+                b = self.ready[i]
+                iden = b[0]
+                ea = b[1]
+                if iden == identifier and ext_addr == ea:
+                    return ISOTPMessageBuilder._build(self.ready.pop(i),
+                                                      self.basecls)
+            return None
+
+        if len(self.ready) > 0:
+            return ISOTPMessageBuilder._build(self.ready.pop(0), self.basecls)
+        return None
+
+    def __iter__(self):
+        # type: () -> ISOTPMessageBuilderIter
+        return ISOTPMessageBuilderIter(self)
+
+    @staticmethod
+    def _build(
+            t,  # type: Tuple[int, Optional[int], ISOTPMessageBuilder.Bucket]
+            basecls=ISOTP  # type: Type[ISOTP]
+    ):
+        # type: (...) -> ISOTP
+        bucket = t[2]
+        data = bucket.ready or b""
+        try:
+            p = basecls(data)
+        except Exception:
+            if conf.debug_dissector:
+                from scapy.sendrecv import debug
+                debug.crashed_on = (basecls, data)
+            raise
+        if hasattr(p, "rx_id"):
+            p.rx_id = t[0]
+        if hasattr(p, "rx_ext_address"):
+            p.rx_ext_address = t[1]
+        if hasattr(p, "tx_id"):
+            p.tx_id = bucket.tx_id
+        if hasattr(p, "ext_address"):
+            p.ext_address = bucket.ext_address
+        if hasattr(p, "time"):
+            p.time = bucket.time
+        return p
+
+    def _feed_first_frame(self, identifier, ea, data, ts):
+        # type: (int, Optional[int], bytes, Union[EDecimal, float]) -> bool
+        if len(data) < 3:
+            # At least 3 bytes are necessary: 2 for length and 1 for data
+            return False
+
+        header = struct.unpack('>H', bytes(data[:2]))[0]
+        expected_length = header & 0x0fff
+        isotp_data = data[2:]
+        if expected_length == 0 and len(data) >= 6:
+            expected_length = struct.unpack('>I', bytes(data[2:6]))[0]
+            isotp_data = data[6:]
+
+        key = (ea, identifier, 1)
+        if ea is None:
+            self.last_ff = key
+        else:
+            self.last_ff_ex = key
+        self.buckets[key] = self.Bucket(expected_length, isotp_data, ts)
+        return True
+
+    def _feed_single_frame(self, identifier, ea, data, ts):
+        # type: (int, Optional[int], bytes, Union[EDecimal, float]) -> bool
+        if len(data) < 2:
+            # At least 2 bytes are necessary: 1 for length and 1 for data
+            return False
+
+        length = data[0] & 0x0f
+        isotp_data = data[1:length + 1]
+
+        if length > len(isotp_data):
+            # CAN frame has less data than expected
+            return False
+
+        self.ready.append((identifier, ea,
+                           self.Bucket(length, isotp_data, ts)))
+        return True
+
+    def _feed_consecutive_frame(self, identifier, ea, data):
+        # type: (int, Optional[int], bytes) -> bool
+        if len(data) < 2:
+            # At least 2 bytes are necessary: 1 for sequence number and
+            # 1 for data
+            return False
+
+        first_byte = data[0]
+        seq_no = first_byte & 0x0f
+        isotp_data = data[1:]
+
+        key = (ea, identifier, seq_no)
+        bucket = self.buckets.pop(key, None)
+
+        if bucket is None:
+            # There is no message constructor waiting for this frame
+            return False
+
+        bucket.push(isotp_data)
+        if bucket.ready is None:
+            # full ISOTP message is not ready yet, put it back in
+            # buckets list
+            next_seq = (seq_no + 1) % 16
+            key = (ea, identifier, next_seq)
+            self.buckets[key] = bucket
+        else:
+            self.ready.append((identifier, ea, bucket))
+
+        return True
+
+    def _feed_flow_control_frame(self, identifier, ea, data):
+        # type: (int, Optional[int], bytes) -> bool
+        if len(data) < 3:
+            # At least 2 bytes are necessary: 1 for sequence number and
+            # 1 for data
+            return False
+
+        keys = [x for x in (self.last_ff, self.last_ff_ex) if x is not None]
+        buckets = [self.buckets.pop(k, None) for k in keys]
+
+        self.last_ff = None
+        self.last_ff_ex = None
+
+        if not any(buckets) or not any(keys):
+            # There is no message constructor waiting for this frame
+            return False
+
+        for key, bucket in zip(keys, buckets):
+            if bucket is None:
+                continue
+            bucket.tx_id = identifier
+            bucket.ext_address = ea
+            self.buckets[key] = bucket
+        return True
+
+    def _try_feed(self, identifier, ea, data, ts):
+        # type: (int, Optional[int], bytes, Union[EDecimal, float]) -> None
+        first_byte = data[0]
+        if len(data) > 1 and first_byte & 0xf0 == N_PCI_SF:
+            self._feed_single_frame(identifier, ea, data, ts)
+        if len(data) > 2 and first_byte & 0xf0 == N_PCI_FF:
+            self._feed_first_frame(identifier, ea, data, ts)
+        if len(data) > 1 and first_byte & 0xf0 == N_PCI_CF:
+            self._feed_consecutive_frame(identifier, ea, data)
+        if len(data) > 1 and first_byte & 0xf0 == N_PCI_FC:
+            self._feed_flow_control_frame(identifier, ea, data)
+
+
+class ISOTPSession(DefaultSession):
+    """Defragment ISOTP packets 'on-the-flow'.
+
+    Usage:
+        >>> sniff(session=ISOTPSession)
+    """
+
+    def __init__(self, *args, **kwargs):
+        # type: (Any, Any) -> None
+        self.m = ISOTPMessageBuilder(
+            use_ext_address=kwargs.pop("use_ext_address", None),
+            rx_id=kwargs.pop("rx_id", None),
+            basecls=kwargs.pop("basecls", ISOTP))
+        super(ISOTPSession, self).__init__(*args, **kwargs)
+
+    def recv(self, sock: SuperSocket) -> Iterator[Packet]:
+        """
+        Will be called by sniff() to ask for a packet
         """
-        if isinstance(x, str):
-            return x.encode()
-        return bytes(x)
-
-    if sys.version_info[0:2] <= (3, 4):
-        def plain_str(x):
-            # type: (AnyStr) -> str
-            """Convert basic byte objects to str"""
-            if isinstance(x, bytes):
-                return x.decode(errors="ignore")
-            return str(x)
-    else:
-        # Python 3.5+
-        def plain_str(x):
-            # type: (Any) -> str
-            """Convert basic byte objects to str"""
-            if isinstance(x, bytes):
-                return x.decode(errors="backslashreplace")
-            return str(x)
-
-    def chb(x):
-        # type: (int) -> bytes
-        """Same than chr() but encode as bytes."""
-        return struct.pack("!B", x)
-
-    def orb(x):
-        # type: (Union[int, str, bytes]) -> int
-        """Return ord(x) when not already an int."""
-        if isinstance(x, int):
-            return x
-        return ord(x)
-
-
-def bytes_hex(x):
-    # type: (AnyStr) -> bytes
-    """Hexify a str or a bytes object"""
-    return binascii.b2a_hex(bytes_encode(x))
-
-
-def hex_bytes(x):
-    # type: (AnyStr) -> bytes
-    """De-hexify a str or a byte object"""
-    return binascii.a2b_hex(bytes_encode(x))
-
-
-if six.PY2:
-    def int_bytes(x, size):
-        # type: (int, int) -> bytes
-        """Convert an int to an arbitrary sized bytes string"""
-        _hx = hex(x)[2:].strip("L")
-        return binascii.unhexlify("0" * (size * 2 - len(_hx)) + _hx)
-
-    def bytes_int(x):
-        # type: (bytes) -> int
-        """Convert an arbitrary sized bytes string to an int"""
-        return int(x.encode('hex'), 16)
-else:
-    def int_bytes(x, size):
-        # type: (int, int) -> bytes
-        """Convert an int to an arbitrary sized bytes string"""
-        return x.to_bytes(size, byteorder='big')
-
-    def bytes_int(x):
-        # type: (bytes) -> int
-        """Convert an arbitrary sized bytes string to an int"""
-        return int.from_bytes(x, "big")
-
-
-def base64_bytes(x):
-    # type: (AnyStr) -> bytes
-    """Turn base64 into bytes"""
-    if six.PY2:
-        return base64.decodestring(x)  # type: ignore
-    return base64.decodebytes(bytes_encode(x))
-
-
-def bytes_base64(x):
-    # type: (AnyStr) -> bytes
-    """Turn bytes into base64"""
-    if six.PY2:
-        return base64.encodestring(x).replace('\n', '')  # type: ignore
-    return base64.encodebytes(bytes_encode(x)).replace(b'\n', b'')
-
-
-if six.PY2:
-    import cgi
-    html_escape = cgi.escape
-else:
-    import html
-    html_escape = html.escape
-
-
-if six.PY2:
-    from StringIO import StringIO
-
-    def gzip_decompress(x):
-        # type: (AnyStr) -> bytes
-        """Decompress using gzip"""
-        with gzip.GzipFile(fileobj=StringIO(x), mode='rb') as fdesc:
-            return fdesc.read()
-
-    def gzip_compress(x):
-        # type: (AnyStr) -> bytes
-        """Compress using gzip"""
-        buf = StringIO()
-        with gzip.GzipFile(fileobj=buf, mode='wb') as fdesc:
-            fdesc.write(x)
-        return buf.getvalue()
-else:
-    gzip_decompress = gzip.decompress
-    gzip_compress = gzip.compress
+        pkt = sock.recv()
+        if not pkt:
+            return
+        self.m.feed(pkt)
+        while len(self.m) > 0:
+            rcvd = cast(Optional[Packet], self.m.pop())
+            if rcvd:
+                rcvd = self.process(rcvd)
+            if rcvd:
+                yield rcvd
```

### Comparing `scapy-2.5.0rc3/scapy/config.py` & `scapy-2.6.0rc1/scapy/config.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,58 +3,68 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Implementation of the configuration object.
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 
 import atexit
 import copy
 import functools
 import os
 import re
 import socket
 import sys
 import time
 import warnings
 
+from dataclasses import dataclass
+from enum import Enum
+
+import importlib
+import importlib.abc
+import importlib.util
+
 import scapy
 from scapy import VERSION
 from scapy.base_classes import BasePacket
 from scapy.consts import DARWIN, WINDOWS, LINUX, BSD, SOLARIS
-from scapy.error import log_scapy, warning, ScapyInvalidPlatformException
-from scapy.libs import six
-from scapy.themes import NoTheme, apply_ipython_style
+from scapy.error import (
+    log_loading,
+    log_scapy,
+    ScapyInvalidPlatformException,
+    warning,
+)
+from scapy.themes import ColorTheme, NoTheme, apply_ipython_style
 
-from scapy.compat import (
+# Typing imports
+from typing import (
     cast,
     Any,
     Callable,
-    DecoratorCallable,
     Dict,
     Iterator,
     List,
     NoReturn,
     Optional,
     Set,
     Tuple,
     Type,
     Union,
     overload,
     TYPE_CHECKING,
 )
 from types import ModuleType
+from scapy.compat import DecoratorCallable
 
 if TYPE_CHECKING:
     # Do not import at runtime
     import scapy.as_resolvers
-    from scapy.nmap import NmapKnowledgeBase
+    from scapy.modules.nmap import NmapKnowledgeBase
     from scapy.packet import Packet
     from scapy.supersocket import SuperSocket  # noqa: F401
     import scapy.asn1.asn1
     import scapy.asn1.mib
 
 ############
 #  Config  #
@@ -133,27 +143,31 @@
     Interceptor,
     hook=(lambda name, *args, **kwargs: _readonly(name))
 )
 ReadOnlyAttribute.__doc__ = "Read-only class attribute"
 
 
 class ProgPath(ConfClass):
-    _default = "<System default>"
-    universal_open = "open" if DARWIN else "xdg-open"
-    pdfreader = universal_open
-    psreader = universal_open
-    svgreader = universal_open
-    dot = "dot"
-    display = "display"
-    tcpdump = "tcpdump"
-    tcpreplay = "tcpreplay"
-    hexedit = "hexer"
-    tshark = "tshark"
-    wireshark = "wireshark"
-    ifconfig = "ifconfig"
+    _default: str = "<System default>"
+    universal_open: str = "open" if DARWIN else "xdg-open"
+    pdfreader: str = universal_open
+    psreader: str = universal_open
+    svgreader: str = universal_open
+    dot: str = "dot"
+    display: str = "display"
+    tcpdump: str = "tcpdump"
+    tcpreplay: str = "tcpreplay"
+    hexedit: str = "hexer"
+    tshark: str = "tshark"
+    wireshark: str = "wireshark"
+    ifconfig: str = "ifconfig"
+    extcap_folders: List[str] = [
+        os.path.join(os.path.expanduser("~"), ".config", "wireshark", "extcap"),
+        "/usr/lib/x86_64-linux-gnu/wireshark/extcap",
+    ]
 
 
 class ConfigFieldList:
     def __init__(self):
         # type: () -> None
         self.fields = set()  # type: Set[Any]
         self.layers = set()  # type: Set[Any]
@@ -245,22 +259,22 @@
             ):
         # type: (...) -> Optional[Union[int, Type[Packet]]]
         return self[item] if item in self else default
 
     def __repr__(self):
         # type: () -> str
         lst = []
-        for num, layer in six.iteritems(self.num2layer):
+        for num, layer in self.num2layer.items():
             if layer in self.layer2num and self.layer2num[layer] == num:
                 dir = "<->"
             else:
                 dir = " ->"
             lst.append((num, "%#6x %s %-20s (%s)" % (num, dir, layer.__name__,
                                                      layer._name)))
-        for layer, num in six.iteritems(self.layer2num):
+        for layer, num in self.layer2num.items():
             if num not in self.num2layer or self.num2layer[num] != layer:
                 lst.append((num, "%#6x <-  %-20s (%s)" % (num, layer.__name__,
                                                           layer._name)))
         lst.sort()
         return "\n".join(y for x, y in lst)
 
 
@@ -299,29 +313,29 @@
         return result
 
     def filter(self, items):
         # type: (List[Type[Packet]]) -> None
         """Disable dissection of unused layers to speed up dissection"""
         if self.filtered:
             raise ValueError("Already filtered. Please disable it first")
-        for lay in six.itervalues(self.ldict):
+        for lay in self.ldict.values():
             for cls in lay:
                 if cls not in self._backup_dict:
                     self._backup_dict[cls] = cls.payload_guess[:]
                     cls.payload_guess = [
                         y for y in cls.payload_guess if y[1] in items
                     ]
         self.filtered = True
 
     def unfilter(self):
         # type: () -> None
         """Re-enable dissection for all layers"""
         if not self.filtered:
             raise ValueError("Not filtered. Please filter first")
-        for lay in six.itervalues(self.ldict):
+        for lay in self.ldict.values():
             for cls in lay:
                 cls.payload_guess = self._backup_dict[cls]
         self._backup_dict.clear()
         self.filtered = False
 
 
 class CommandsList(List[Callable[..., Any]]):
@@ -342,41 +356,44 @@
 
 def lsc():
     # type: () -> None
     """Displays Scapy's default commands"""
     print(repr(conf.commands))
 
 
-class CacheInstance(Dict[str, Any], object):
-    __slots__ = ["timeout", "name", "_timetable", "__dict__"]
+class CacheInstance(Dict[str, Any]):
+    __slots__ = ["timeout", "name", "_timetable"]
 
     def __init__(self, name="noname", timeout=None):
         # type: (str, Optional[int]) -> None
         self.timeout = timeout
         self.name = name
         self._timetable = {}  # type: Dict[str, float]
 
     def flush(self):
         # type: () -> None
-        CacheInstance.__init__(
-            self,
-            name=self.name,
-            timeout=self.timeout
-        )
+        self._timetable.clear()
+        self.clear()
 
     def __getitem__(self, item):
         # type: (str) -> Any
         if item in self.__slots__:
             return object.__getattribute__(self, item)
-        val = super(CacheInstance, self).__getitem__(item)
+        if not self.__contains__(item):
+            raise KeyError(item)
+        return super(CacheInstance, self).__getitem__(item)
+
+    def __contains__(self, item):
+        if not super(CacheInstance, self).__contains__(item):
+            return False
         if self.timeout is not None:
             t = self._timetable[item]
             if time.time() - t > self.timeout:
-                raise KeyError(item)
-        return val
+                return False
+        return True
 
     def get(self, item, default=None):
         # type: (str, Optional[Any]) -> Any
         # overloading this method is needed to force the dict to go through
         # the timetable check
         try:
             return self[item]
@@ -386,71 +403,74 @@
     def __setitem__(self, item, v):
         # type: (str, str) -> None
         if item in self.__slots__:
             return object.__setattr__(self, item, v)
         self._timetable[item] = time.time()
         super(CacheInstance, self).__setitem__(item, v)
 
-    def update(self,  # type: ignore
+    def update(self,
                other,  # type: Any
                **kwargs  # type: Any
                ):
         # type: (...) -> None
-        for key, value in six.iteritems(other):
+        for key, value in other.items():
             # We only update an element from `other` either if it does
             # not exist in `self` or if the entry in `self` is older.
             if key not in self or self._timetable[key] < other._timetable[key]:
                 dict.__setitem__(self, key, value)
                 self._timetable[key] = other._timetable[key]
 
     def iteritems(self):
         # type: () -> Iterator[Tuple[str, Any]]
         if self.timeout is None:
-            return six.iteritems(self.__dict__)  # type: ignore
+            return super(CacheInstance, self).items()
         t0 = time.time()
-        return ((k, v) for (k, v) in six.iteritems(self.__dict__) if t0 - self._timetable[k] < self.timeout)  # noqa: E501
+        return (
+            (k, v)
+            for (k, v) in super(CacheInstance, self).items()
+            if t0 - self._timetable[k] < self.timeout
+        )
 
     def iterkeys(self):
         # type: () -> Iterator[str]
         if self.timeout is None:
-            return six.iterkeys(self.__dict__)  # type: ignore
+            return super(CacheInstance, self).keys()
         t0 = time.time()
-        return (k for k in six.iterkeys(self.__dict__) if t0 - self._timetable[k] < self.timeout)  # noqa: E501
+        return (
+            k
+            for k in super(CacheInstance, self).keys()
+            if t0 - self._timetable[k] < self.timeout
+        )
 
     def __iter__(self):
         # type: () -> Iterator[str]
         return self.iterkeys()
 
     def itervalues(self):
         # type: () -> Iterator[Tuple[str, Any]]
         if self.timeout is None:
-            return six.itervalues(self.__dict__)  # type: ignore
+            return super(CacheInstance, self).values()
         t0 = time.time()
-        return (v for (k, v) in six.iteritems(self.__dict__) if t0 - self._timetable[k] < self.timeout)  # noqa: E501
+        return (
+            v
+            for (k, v) in super(CacheInstance, self).items()
+            if t0 - self._timetable[k] < self.timeout
+        )
 
     def items(self):
         # type: () -> Any
-        if self.timeout is None:
-            return super(CacheInstance, self).items()
-        t0 = time.time()
-        return [(k, v) for (k, v) in six.iteritems(self.__dict__) if t0 - self._timetable[k] < self.timeout]  # noqa: E501
+        return list(self.iteritems())
 
     def keys(self):
         # type: () -> Any
-        if self.timeout is None:
-            return super(CacheInstance, self).keys()
-        t0 = time.time()
-        return [k for k in six.iterkeys(self.__dict__) if t0 - self._timetable[k] < self.timeout]  # noqa: E501
+        return list(self.iterkeys())
 
     def values(self):
         # type: () -> Any
-        if self.timeout is None:
-            return list(six.itervalues(self))
-        t0 = time.time()
-        return [v for (k, v) in six.iteritems(self.__dict__) if t0 - self._timetable[k] < self.timeout]  # noqa: E501
+        return list(self.itervalues())
 
     def __len__(self):
         # type: () -> int
         if self.timeout is None:
             return super(CacheInstance, self).__len__()
         return len(self.keys())
 
@@ -458,17 +478,17 @@
         # type: () -> str
         return "%s: %i valid items. Timeout=%rs" % (self.name, len(self), self.timeout)  # noqa: E501
 
     def __repr__(self):
         # type: () -> str
         s = []
         if self:
-            mk = max(len(k) for k in six.iterkeys(self.__dict__))
+            mk = max(len(k) for k in self)
             fmt = "%%-%is %%s" % (mk + 1)
-            for item in six.iteritems(self.__dict__):
+            for item in self.items():
                 s.append(fmt % item)
         return "\n".join(s)
 
     def copy(self):
         # type: () -> CacheInstance
         return copy.copy(self)
 
@@ -507,14 +527,167 @@
             c.flush()
 
     def __repr__(self):
         # type: () -> str
         return "\n".join(c.summary() for c in self._caches_list)
 
 
+class ScapyExt:
+    __slots__ = ["specs", "name", "version"]
+
+    class MODE(Enum):
+        LAYERS = "layers"
+        CONTRIB = "contrib"
+        MODULES = "modules"
+
+    @dataclass
+    class ScapyExtSpec:
+        fullname: str
+        mode: 'ScapyExt.MODE'
+        spec: Any
+        default: bool
+
+    def __init__(self):
+        self.specs: Dict[str, 'ScapyExt.ScapyExtSpec'] = {}
+
+    def config(self, name, version):
+        self.name = name
+        self.version = version
+
+    def register(self, name, mode, path, default=None):
+        assert mode in self.MODE, "mode must be one of ScapyExt.MODE !"
+        fullname = f"scapy.{mode.value}.{name}"
+        spec = importlib.util.spec_from_file_location(
+            fullname,
+            str(path),
+        )
+        spec = self.ScapyExtSpec(
+            fullname=fullname,
+            mode=mode,
+            spec=spec,
+            default=default or False,
+        )
+        if default is None:
+            spec.default = bool(importlib.util.find_spec(spec.fullname))
+        self.specs[fullname] = spec
+
+    def __repr__(self):
+        return "<ScapyExt %s %s (%s specs)>" % (
+            self.name,
+            self.version,
+            len(self.specs),
+        )
+
+
+class ExtsManager(importlib.abc.MetaPathFinder):
+    __slots__ = ["exts", "_loaded", "all_specs"]
+
+    SCAPY_PLUGIN_CLASSIFIER = 'Framework :: Scapy'
+    GPLV2_CLASSIFIERS = [
+        'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',
+        'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)',
+    ]
+
+    def __init__(self):
+        self.exts: List[ScapyExt] = []
+        self.all_specs: Dict[str, ScapyExt.ScapyExtSpec] = {}
+        self._loaded = []
+
+    def find_spec(self, fullname, path, target=None):
+        if fullname in self.all_specs:
+            return self.all_specs[fullname].spec
+
+    def invalidate_caches(self):
+        pass
+
+    def _register_spec(self, spec):
+        self.all_specs[spec.fullname] = spec
+        if spec.default:
+            loader = importlib.util.LazyLoader(spec.spec.loader)
+            spec.spec.loader = loader
+            module = importlib.util.module_from_spec(spec.spec)
+            sys.modules[spec.fullname] = module
+            loader.exec_module(module)
+
+    def load(self):
+        try:
+            import importlib.metadata
+        except ImportError:
+            return
+        for distr in importlib.metadata.distributions():
+            if any(
+                v == self.SCAPY_PLUGIN_CLASSIFIER
+                for k, v in distr.metadata.items() if k == 'Classifier'
+            ):
+                try:
+                    pkg = next(
+                        k
+                        for k, v in importlib.metadata.packages_distributions().items()
+                        if distr.name in v
+                    )
+                except KeyError:
+                    pkg = distr.name
+                if pkg in self._loaded:
+                    continue
+                if not any(
+                    v in self.GPLV2_CLASSIFIERS
+                    for k, v in distr.metadata.items() if k == 'Classifier'
+                ):
+                    log_loading.warning(
+                        "'%s' has no GPLv2 classifier therefore cannot be loaded." % pkg  # noqa: E501
+                    )
+                    continue
+                self._loaded.append(pkg)
+                ext = ScapyExt()
+                try:
+                    scapy_ext = importlib.import_module(pkg)
+                except Exception as ex:
+                    log_loading.warning(
+                        "'%s' failed during import with %s" % (
+                            pkg,
+                            ex
+                        )
+                    )
+                    continue
+                try:
+                    scapy_ext_func = scapy_ext.scapy_ext
+                except AttributeError:
+                    log_loading.info(
+                        "'%s' included the Scapy Framework specifier "
+                        "but did not include a scapy_ext" % pkg
+                    )
+                    continue
+                try:
+                    scapy_ext_func(ext)
+                except Exception as ex:
+                    log_loading.warning(
+                        "'%s' failed during initialization with %s" % (
+                            pkg,
+                            ex
+                        )
+                    )
+                    continue
+                for spec in ext.specs.values():
+                    self._register_spec(spec)
+                self.exts.append(ext)
+        if self not in sys.meta_path:
+            sys.meta_path.append(self)
+
+    def __repr__(self):
+        from scapy.utils import pretty_list
+        return pretty_list(
+            [
+                (x.name, x.version, [y.fullname for y in x.specs.values()])
+                for x in self.exts
+            ],
+            [("Name", "Version", "Specs")],
+            sortBy=0,
+        )
+
+
 def _version_checker(module, minver):
     # type: (ModuleType, Tuple[int, ...]) -> bool
     """Checks that module has a higher version that minver.
 
     params:
      - module: a module to test
      - minver: a tuple of versions
@@ -606,63 +779,55 @@
         )
     # we are already in an Interceptor hook, use Interceptor.set_from_hook
     if conf.use_pcap:
         try:
             from scapy.arch.libpcap import L2pcapListenSocket, L2pcapSocket, \
                 L3pcapSocket
         except (OSError, ImportError):
-            warning("No libpcap provider available ! pcap won't be used")
+            log_loading.warning("No libpcap provider available ! pcap won't be used")
             Interceptor.set_from_hook(conf, "use_pcap", False)
         else:
             conf.L3socket = L3pcapSocket
-            conf.L3socket6 = functools.partial(  # type: ignore
+            conf.L3socket6 = functools.partial(
                 L3pcapSocket, filter="ip6")
             conf.L2socket = L2pcapSocket
             conf.L2listen = L2pcapListenSocket
-            conf.ifaces.reload()
-            return
-    if conf.use_bpf:
+    elif conf.use_bpf:
         from scapy.arch.bpf.supersocket import L2bpfListenSocket, \
             L2bpfSocket, L3bpfSocket
         conf.L3socket = L3bpfSocket
-        conf.L3socket6 = functools.partial(  # type: ignore
+        conf.L3socket6 = functools.partial(
             L3bpfSocket, filter="ip6")
         conf.L2socket = L2bpfSocket
         conf.L2listen = L2bpfListenSocket
-        conf.ifaces.reload()
-        return
-    if LINUX:
+    elif LINUX:
         from scapy.arch.linux import L3PacketSocket, L2Socket, L2ListenSocket
         conf.L3socket = L3PacketSocket
         conf.L3socket6 = cast(
             "Type[SuperSocket]",
             functools.partial(
                 L3PacketSocket,
                 filter="ip6"
             )
         )
         conf.L2socket = L2Socket
         conf.L2listen = L2ListenSocket
-        conf.ifaces.reload()
-        return
-    if WINDOWS:
+    elif WINDOWS:
         from scapy.arch.windows import _NotAvailableSocket
         from scapy.arch.windows.native import L3WinSocket, L3WinSocket6
         conf.L3socket = L3WinSocket
         conf.L3socket6 = L3WinSocket6
         conf.L2socket = _NotAvailableSocket
         conf.L2listen = _NotAvailableSocket
-        conf.ifaces.reload()
-        # No need to update globals on Windows
-        return
     else:
-        from scapy.supersocket import L3RawSocket
-        from scapy.layers.inet6 import L3RawSocket6
+        from scapy.supersocket import L3RawSocket, L3RawSocket6
         conf.L3socket = L3RawSocket
         conf.L3socket6 = L3RawSocket6
+    # Reload the interfaces
+    conf.ifaces.reload()
 
 
 def _socket_changer(attr, val, old):
     # type: (str, bool, bool) -> Any
     if not isinstance(val, bool):
         raise TypeError("This argument should be a boolean")
     Interceptor.set_from_hook(conf, attr, val)
@@ -700,38 +865,50 @@
         iface = resolve_iface(val)
         if old and iface.dummy:
             warning(
                 "This interface is not specified in any provider ! "
                 "See conf.ifaces output"
             )
         return iface
-    return val  # type: ignore
+    return val
+
+
+def _reset_tls_nss_keys(attr, val, old):
+    # type: (str, Any, Any) -> Any
+    """Reset conf.tls_nss_keys when conf.tls_nss_filename changes"""
+    conf.tls_nss_keys = None
+    return val
 
 
 class Conf(ConfClass):
     """
     This object contains the configuration of Scapy.
     """
-    version = ReadOnlyAttribute("version", VERSION)
-    session = ""  #: filename where the session will be saved
+    version: str = ReadOnlyAttribute("version", VERSION)
+    session: str = ""  #: filename where the session will be saved
     interactive = False
-    #: can be "ipython", "python" or "auto". Default: Auto
-    interactive_shell = ""
+    #: can be "ipython", "bpython", "ptpython", "ptipython", "python" or "auto".
+    #: Default: Auto
+    interactive_shell = "auto"
+    #: Configuration for "ipython" to use jedi (disabled by default)
+    ipython_use_jedi = False
     #: if 1, prevents any unwanted packet to go out (ARP, DNS, ...)
     stealth = "not implemented"
     #: selects the default output interface for srp() and sendp().
-    iface = Interceptor("iface", None, _iface_changer)  # type: 'scapy.interfaces.NetworkInterface'  # type: ignore  # noqa: E501
-    layers = LayersList()
+    iface = Interceptor("iface", None, _iface_changer)  # type: 'scapy.interfaces.NetworkInterface'  # noqa: E501
+    layers: LayersList = LayersList()
     commands = CommandsList()  # type: CommandsList
     #: Codec used by default for ASN1 objects
     ASN1_default_codec = None  # type: 'scapy.asn1.asn1.ASN1Codec'
+    #: Default size for ASN1 objects
+    ASN1_default_long_size = 0
     #: choose the AS resolver class to use
     AS_resolver = None  # type: scapy.as_resolvers.AS_resolver
     dot15d4_protocol = None  # Used in dot15d4.py
-    logLevel = Interceptor("logLevel", log_scapy.level, _loglevel_changer)
+    logLevel: int = Interceptor("logLevel", log_scapy.level, _loglevel_changer)
     #: if 0, doesn't check that IPID matches between IP sent and
     #: ICMP IP citation received
     #: if 1, checks that they either are equal or byte swapped
     #: equals (bug in some IP stacks)
     #: if 2, strictly checks that they are equals
     checkIPID = False
     #: if 1, checks IP src in IP and ICMP IP citation match
@@ -741,128 +918,142 @@
     #: if True, checks that IP-in-IP layers match. If False, do
     #: not check IP layers that encapsulates another IP layer
     checkIPinIP = True
     #: if 1, also check that TCP seq and ack match the
     #: ones in ICMP citation
     check_TCPerror_seqack = False
     verb = 2  #: level of verbosity, from 0 (almost mute) to 3 (verbose)
-    prompt = Interceptor("prompt", ">>> ", _prompt_changer)
-    #: default mode for listening socket (to get answers if you
+    prompt: str = Interceptor("prompt", ">>> ", _prompt_changer)
+    #: default mode for the promiscuous mode of a socket (to get answers if you
     #: spoof on a lan)
-    promisc = True
-    #: default mode for sniff()
     sniff_promisc = True  # type: bool
     raw_layer = None  # type: Type[Packet]
     raw_summary = False  # type: Union[bool, Callable[[bytes], Any]]
     padding_layer = None  # type: Type[Packet]
     default_l2 = None  # type: Type[Packet]
-    l2types = Num2Layer()
-    l3types = Num2Layer()
+    l2types: Num2Layer = Num2Layer()
+    l3types: Num2Layer = Num2Layer()
     L3socket = None  # type: Type[scapy.supersocket.SuperSocket]
     L3socket6 = None  # type: Type[scapy.supersocket.SuperSocket]
     L2socket = None  # type: Type[scapy.supersocket.SuperSocket]
     L2listen = None  # type: Type[scapy.supersocket.SuperSocket]
     BTsocket = None  # type: Type[scapy.supersocket.SuperSocket]
-    USBsocket = None  # type: Type[scapy.supersocket.SuperSocket]
     min_pkt_size = 60
     #: holds MIB direct access dictionary
     mib = None  # type: 'scapy.asn1.mib.MIBDict'
     bufsize = 2**16
     #: history file
-    histfile = os.getenv('SCAPY_HISTFILE',
-                         os.path.join(os.path.expanduser("~"),
-                                      ".scapy_history"))
+    histfile: str = os.getenv(
+        'SCAPY_HISTFILE',
+        os.path.join(
+            os.path.expanduser("~"),
+            ".config", "scapy", "history"
+        )
+    )
     #: includes padding in disassembled packets
     padding = 1
     #: BPF filter for packets to ignore
     except_filter = ""
     #: bpf filter added to every sniffing socket to exclude traffic
     #: from analysis
     filter = ""
     #: when 1, store received packet that are not matched into `debug.recv`
     debug_match = False
-    #: When 1, print some TLS session secrets when they are computed.
+    #: When 1, print some TLS session secrets when they are computed, and
+    #: warn about the session recognition.
     debug_tls = False
     wepkey = ""
     #: holds the Scapy interface list and manager
     ifaces = None  # type: 'scapy.interfaces.NetworkInterfaceDict'
     #: holds the cache of interfaces loaded from Libpcap
     cache_pcapiflist = {}  # type: Dict[str, Tuple[str, List[str], Any, str]]
-    neighbor = None  # type: 'scapy.layers.l2.Neighbor'
     # `neighbor` will be filed by scapy.layers.l2
+    neighbor = None  # type: 'scapy.layers.l2.Neighbor'
+    #: holds the name servers IP/hosts used for custom DNS resolution
+    nameservers = None  # type: str
+    #: automatically load IPv4 routes on startup. Disable this if your
+    #: routing table is too big.
+    route_autoload = True
+    #: automatically load IPv6 routes on startup. Disable this if your
+    #: routing table is too big.
+    route6_autoload = True
     #: holds the Scapy IPv4 routing table and provides methods to
     #: manipulate it
     route = None  # type: 'scapy.route.Route'
     # `route` will be filed by route.py
     #: holds the Scapy IPv6 routing table and provides methods to
     #: manipulate it
     route6 = None  # type: 'scapy.route6.Route6'
     manufdb = None  # type: 'scapy.data.ManufDA'
+    ethertypes = None  # type: 'scapy.data.EtherDA'
+    protocols = None  # type: 'scapy.dadict.DADict[int, str]'
+    services_udp = None  # type: 'scapy.dadict.DADict[int, str]'
+    services_tcp = None  # type: 'scapy.dadict.DADict[int, str]'
+    services_sctp = None  # type: 'scapy.dadict.DADict[int, str]'
     # 'route6' will be filed by route6.py
     teredoPrefix = ""  # type: str
     teredoServerPort = None  # type: int
     auto_fragment = True
     #: raise exception when a packet dissector raises an exception
     debug_dissector = False
-    color_theme = Interceptor("color_theme", NoTheme(), _prompt_changer)
+    color_theme: ColorTheme = Interceptor("color_theme", NoTheme(), _prompt_changer)
     #: how much time between warnings from the same place
     warning_threshold = 5
-    prog = ProgPath()
+    prog: ProgPath = ProgPath()
     #: holds list of fields for which resolution should be done
-    resolve = Resolve()
+    resolve: Resolve = Resolve()
     #: holds list of enum fields for which conversion to string
     #: should NOT be done
-    noenum = Resolve()
-    emph = Emphasize()
+    noenum: Resolve = Resolve()
+    emph: Emphasize = Emphasize()
     #: read only attribute to show if PyPy is in use
-    use_pypy = ReadOnlyAttribute("use_pypy", isPyPy())
+    use_pypy: bool = ReadOnlyAttribute("use_pypy", isPyPy())
     #: use libpcap integration or not. Changing this value will update
     #: the conf.L[2/3] sockets
-    use_pcap = Interceptor(
+    use_pcap: bool = Interceptor(
         "use_pcap",
         os.getenv("SCAPY_USE_LIBPCAP", "").lower().startswith("y"),
         _socket_changer
     )
-    use_bpf = Interceptor("use_bpf", False, _socket_changer)
+    use_bpf: bool = Interceptor("use_bpf", False, _socket_changer)
     use_npcap = False
-    ipv6_enabled = socket.has_ipv6
-    #: path or list of paths where extensions are to be looked for
-    extensions_paths = "."
+    ipv6_enabled: bool = socket.has_ipv6
     stats_classic_protocols = []  # type: List[Type[Packet]]
     stats_dot11_protocols = []  # type: List[Type[Packet]]
     temp_files = []  # type: List[str]
-    netcache = NetCache()
+    #: netcache holds time-based caches for net operations
+    netcache: NetCache = NetCache()
     geoip_city = None
     # can, tls, http and a few others are not loaded by default
-    load_layers = [
+    load_layers: List[str] = [
         'bluetooth',
         'bluetooth4LE',
         'dcerpc',
         'dhcp',
         'dhcp6',
         'dns',
         'dot11',
         'dot15d4',
         'eap',
         'gprs',
+        'gssapi',
         'hsrp',
         'inet',
         'inet6',
         'ipsec',
         'ir',
         'isakmp',
         'kerberos',
         'l2',
         'l2tp',
         'ldap',
         'llmnr',
         'lltd',
         'mgcp',
         'mobileip',
-        'mspac',
         'netbios',
         'netflow',
         'ntlm',
         'ntp',
         'ppi',
         'ppp',
         'pptp',
@@ -873,36 +1064,63 @@
         'sixlowpan',
         'skinny',
         'smb',
         'smb2',
         'smbclient',
         'smbserver',
         'snmp',
+        'spnego',
         'tftp',
         'vrrp',
         'vxlan',
         'x509',
         'zigbee'
     ]
     #: a dict which can be used by contrib layers to store local
     #: configuration
     contribs = dict()  # type: Dict[str, Any]
+    exts: ExtsManager = ExtsManager()
     crypto_valid = isCryptographyValid()
     crypto_valid_advanced = isCryptographyAdvanced()
-    fancy_prompt = True
+    #: controls whether or not to display the fancy banner
+    fancy_banner = True
+    #: controls whether tables (conf.iface, conf.route...) should be cropped
+    #: to fit the terminal
     auto_crop_tables = True
     #: how often to check for new packets.
     #: Defaults to 0.05s.
     recv_poll_rate = 0.05
     #: When True, raise exception if no dst MAC found otherwise broadcast.
     #: Default is False.
     raise_no_dst_mac = False
-    loopback_name = "lo" if LINUX else "lo0"
+    loopback_name: str = "lo" if LINUX else "lo0"
     nmap_base = ""  # type: str
     nmap_kdb = None  # type: Optional[NmapKnowledgeBase]
+    #: a safety mechanism: the maximum amount of items included in a PacketListField
+    #: or a FieldListField
+    max_list_count = 100
+    #: When the TLS module is loaded (not by default), the following turns on sessions
+    tls_session_enable = False
+    #: Filename containing NSS Keys Log
+    tls_nss_filename = Interceptor(
+        "tls_nss_filename",
+        None,
+        _reset_tls_nss_keys
+    )
+    #: Dictionary containing parsed NSS Keys
+    tls_nss_keys: Dict[str, bytes] = None
+    #: When TCPSession is used, parse DCE/RPC sessions automatically.
+    #: This should be used for passive sniffing.
+    dcerpc_session_enable = False
+    #: If a capture is missing the first DCE/RPC bindin message, we might incorrectly
+    #: assume that header signing isn't used. This forces it on.
+    dcerpc_force_header_signing = False
+    #: Windows SSPs for sniffing. This is used with
+    #: dcerpc_session_enable
+    winssps_passive = []
 
     def __getattribute__(self, attr):
         # type: (str) -> Any
         # Those are loaded on runtime to avoid import loops
         if attr == "manufdb":
             from scapy.data import MANUFDB
             return MANUFDB
@@ -928,34 +1146,38 @@
             )
             attr = "iface"
         return object.__getattribute__(self, attr)
 
 
 if not Conf.ipv6_enabled:
     log_scapy.warning("IPv6 support disabled in Python. Cannot load Scapy IPv6 layers.")  # noqa: E501
-    for m in ["inet6", "dhcp6"]:
+    for m in ["inet6", "dhcp6", "sixlowpan"]:
         if m in Conf.load_layers:
             Conf.load_layers.remove(m)
 
 conf = Conf()  # type: Conf
 
+# Python 3.8 Only
+if sys.version_info >= (3, 8):
+    conf.exts.load()
+
 
 def crypto_validator(func):
     # type: (DecoratorCallable) -> DecoratorCallable
     """
     This a decorator to be used for any method relying on the cryptography library.  # noqa: E501
     Its behaviour depends on the 'crypto_valid' attribute of the global 'conf'.
     """
     def func_in(*args, **kwargs):
         # type: (*Any, **Any) -> Any
         if not conf.crypto_valid:
             raise ImportError("Cannot execute crypto-related method! "
                               "Please install python-cryptography v1.7 or later.")  # noqa: E501
         return func(*args, **kwargs)
-    return func_in  # type: ignore
+    return func_in
 
 
 def scapy_delete_temp_files():
     # type: () -> None
     for f in conf.temp_files:
         try:
             os.unlink(f)
```

### Comparing `scapy-2.5.0rc3/scapy/consts.py` & `scapy-2.6.0rc1/scapy/consts.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/altbeacon.py` & `scapy-2.6.0rc1/scapy/contrib/altbeacon.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,16 +7,21 @@
 # scapy.contrib.status = loads
 """
 scapy.contrib.altbeacon - AltBeacon Bluetooth LE proximity beacons.
 
 The AltBeacon specification can be found at: https://github.com/AltBeacon/spec
 """
 
-from scapy.fields import ByteField, ShortField, SignedByteField, \
-    StrFixedLenField
+from scapy.fields import (
+    ByteField,
+    MayEnd,
+    ShortField,
+    SignedByteField,
+    StrFixedLenField,
+)
 from scapy.layers.bluetooth import EIR_Hdr, EIR_Manufacturer_Specific_Data, \
     UUIDField, LowEnergyBeaconHelper
 from scapy.packet import Packet
 
 
 # When building beacon frames, one should use their own manufacturer ID.
 #
@@ -50,15 +55,15 @@
         # treats this as UUID + uint16 + uint16.
         UUIDField("id1", None),
 
         # Local identifier
         ShortField("id2", None),
         ShortField("id3", None),
 
-        SignedByteField("tx_power", None),
+        MayEnd(SignedByteField("tx_power", None)),
         ByteField("mfg_reserved", None),
     ]
 
     @classmethod
     def magic_check(cls, payload):
         """
         Checks if the given payload is for us (starts with our magic string).
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/aoe.py` & `scapy-2.6.0rc1/scapy/contrib/aoe.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/bmw/definitions.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/bmw/definitions.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 from scapy.fields import ByteField, ShortField, ByteEnumField, X3BytesField, \
     StrField, StrFixedLenField, LEIntField, LEThreeBytesField, \
     PacketListField, IntField, IPField, ThreeBytesField, ShortEnumField, \
     XStrFixedLenField
 from scapy.contrib.automotive.uds import UDS, UDS_RDBI, UDS_DSC, UDS_IOCBI, \
     UDS_RC, UDS_RD, UDS_RSDBI, UDS_RDBIPR
 
-
 BMW_specific_enum = {
     0: "requestIdentifiedBCDDTCAndStatus",
     1: "requestSupportedBCDDTCAndStatus",
     2: "requestIdentified2ByteHexDTCAndStatus",
     3: "requestSupported2ByteHexDTCAndStatus",
     128: "ECUIdentificationDataTable",
     129: "ECUIdentificationScalingTable",
@@ -248,18 +247,68 @@
 class SVK_DateField(LEThreeBytesField):
     def i2repr(self, pkt, x):
         x = self.addfield(pkt, b"", x)
         return "%02X.%02X.20%02X" % (x[2], x[1], x[0])
 
 
 class SVK_Entry(Packet):
+    process_classes = {
+        0x01: "HWEL",
+        0x02: "HWAP",
+        0x03: "HWFR",
+        0x05: "CAFD",
+        0x06: "BTLD",
+        0x08: "SWFL",
+        0x09: "SWFF",
+        0x0A: "SWPF",
+        0x0B: "ONPS",
+        0x0F: "FAFP",
+        0x1A: "TLRT",
+        0x1B: "TPRG",
+        0x07: "FLSL",
+        0x0C: "IBAD",
+        0x10: "FCFA",
+        0x1C: "BLUP",
+        0x1D: "FLUP",
+        0xC0: "SWUP",
+        0xC1: "SWIP",
+        0xA0: "ENTD",
+        0xA1: "NAVD",
+        0xA2: "FCFN",
+        0x04: "GWTB",
+        0x0D: "SWFK",
+    }
+    """
+        HWEL - Hardware (Elektronik) - Hardware (Electronics)
+        HWAP - Hardwareauspraegung - Hardware Configuration
+        HWFR - Hardwarefarbe - Hardware Color
+        CAFD - Codierdaten - Coding Data
+        BTLD - Bootloader - Bootloader
+        SWFL - Software ECU Speicherimage - Software ECU Storage Image
+        SWFF - Flash File Software - Flash File Software
+        SWPF - Pruefsoftware - Testing Software
+        ONPS - Onboard Programmiersystem - Onboard Programming System
+        FAFP - FA2FP - FA2FP
+        TLRT - Temporaere Loeschroutine - Temporary Deletion Routine
+        TPRG - Temporaere Programmierroutine - Temporary Programming Routine
+        FLSL - Flashloader Slave - Flashloader Slave
+        IBAD - Interaktive Betriebsanleitung Daten - Interactive Operating Manual Data
+        FCFA - Freischaltcode Fahrzeug-Auftrag - Vehicle Order Unlock Code
+        BLUP - Bootloader-Update Applikation - Bootloader Update Application
+        FLUP - Flashloader-Update Applikation - Flashloader Update Application
+        SWUP - Software-Update Package - Software Update Package
+        SWIP - Index Software-Update Package - Software Update Package Index
+        ENTD - Entertainment Daten - Entertainment Data
+        NAVD - Navigation Daten - Navigation Data
+        FCFN - Freischaltcode Funktion - Function Unlock Code
+        GWTB - Gateway-Tabelle - Gateway Table
+        SWFK - BEGU: Detaillierung auf SWE-Ebene - BEGU: Detailing at SWE Level
+    """
     fields_desc = [
-        ByteEnumField("processClass", 0, {1: "HWEL", 2: "HWAP", 4: "GWTB",
-                                          5: "CAFD", 6: "BTLD", 7: "FLSL",
-                                          8: "SWFL"}),
+        ByteEnumField("processClass", 0, process_classes),
         XStrFixedLenField("svk_id", b"", length=4),
         ByteField("mainVersion", 0),
         ByteField("subVersion", 0),
         ByteField("patchVersion", 0)]
 
     def extract_padding(self, p):
         return b"", p
@@ -368,15 +417,14 @@
 
 
 bind_layers(DEV_JOB, WEBSERVER, identifier=0xff66)
 bind_layers(DEV_JOB_PR, WEBSERVER, identifier=0xff66)
 bind_layers(DEV_JOB, READ_MEM, identifier=0xffff)
 bind_layers(DEV_JOB_PR, READ_MEM_PR, identifier=0xffff)
 
-
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf101)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf102)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf103)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf104)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf105)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf106)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf107)
@@ -434,15 +482,14 @@
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf13b)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf13c)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf13d)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf13e)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf13f)
 bind_layers(UDS_RDBIPR, SVK, dataIdentifier=0xf140)
 
-
 UDS_RDBI.dataIdentifiers[0x0014] = "RDBCI_IS_LESEN_DETAIL_REQ"
 UDS_RDBI.dataIdentifiers[0x0015] = "RDBCI_HS_LESEN_DETAIL_REQ"
 UDS_RDBI.dataIdentifiers[0x0e80] = "AirbagLock"
 UDS_RDBI.dataIdentifiers[0x1000] = "TestStamp"
 UDS_RDBI.dataIdentifiers[0x1001] = "CBSdata"
 UDS_RDBI.dataIdentifiers[0x1002] = "smallUserInformationField"
 UDS_RDBI.dataIdentifiers[0x1003] = "smallUserInformationField"
@@ -1501,15 +1548,15 @@
 UDS_RDBI.dataIdentifiers[0x22f9] = "afterSalesServiceData_2200_22FF"
 UDS_RDBI.dataIdentifiers[0x22fa] = "afterSalesServiceData_2200_22FF"
 UDS_RDBI.dataIdentifiers[0x22fb] = "afterSalesServiceData_2200_22FF"
 UDS_RDBI.dataIdentifiers[0x22fc] = "afterSalesServiceData_2200_22FF"
 UDS_RDBI.dataIdentifiers[0x22fd] = "afterSalesServiceData_2200_22FF"
 UDS_RDBI.dataIdentifiers[0x22fe] = "afterSalesServiceData_2200_22FF"
 UDS_RDBI.dataIdentifiers[0x22ff] = "afterSalesServiceData_2200_22FF"
-UDS_RDBI.dataIdentifiers[0x2300] = "operatingData"       # or RDBCI_BETRIEBSDATEN_LESEN_REQ  # noqa E501
+UDS_RDBI.dataIdentifiers[0x2300] = "operatingData"  # or RDBCI_BETRIEBSDATEN_LESEN_REQ  # noqa E501
 UDS_RDBI.dataIdentifiers[0x2301] = "additionalOperatingData 2301-23FF"
 UDS_RDBI.dataIdentifiers[0x2302] = "additionalOperatingData 2301-23FF"
 UDS_RDBI.dataIdentifiers[0x2303] = "additionalOperatingData 2301-23FF"
 UDS_RDBI.dataIdentifiers[0x2304] = "additionalOperatingData 2301-23FF"
 UDS_RDBI.dataIdentifiers[0x2305] = "additionalOperatingData 2301-23FF"
 UDS_RDBI.dataIdentifiers[0x2306] = "additionalOperatingData 2301-23FF"
 UDS_RDBI.dataIdentifiers[0x2307] = "additionalOperatingData 2301-23FF"
@@ -1827,21 +1874,21 @@
 UDS_RDBI.dataIdentifiers[0x243f] = "additionalPersonalizationDataDriver3"
 UDS_RDBI.dataIdentifiers[0x2500] = "programmReferenzBackup/vehicleManufacturerECUHW_NrBackup"  # noqa E501
 UDS_RDBI.dataIdentifiers[0x2501] = "MemorySegmentationTable"
 UDS_RDBI.dataIdentifiers[0x2502] = "ProgrammingCounter"
 UDS_RDBI.dataIdentifiers[0x2503] = "ProgrammingCounterMax"
 UDS_RDBI.dataIdentifiers[0x2504] = "FlashTimings"
 UDS_RDBI.dataIdentifiers[0x2505] = "MaxBlocklength"
-UDS_RDBI.dataIdentifiers[0x2506] = "ReadMemoryAddress"       # or maximaleBlockLaenge  # noqa E501
+UDS_RDBI.dataIdentifiers[0x2506] = "ReadMemoryAddress"  # or maximaleBlockLaenge  # noqa E501
 UDS_RDBI.dataIdentifiers[0x2507] = "EcuSupportsDeleteSwe"
 UDS_RDBI.dataIdentifiers[0x2508] = "GWRoutingStatus"
 UDS_RDBI.dataIdentifiers[0x2509] = "RoutingTable"
 UDS_RDBI.dataIdentifiers[0x2530] = "SubnetStatus"
 UDS_RDBI.dataIdentifiers[0x2541] = "STATUS_CALCVN"
-UDS_RDBI.dataIdentifiers[0x3000] = "RDBI_CD_REQ"       # or WDBI_CD_REQ
+UDS_RDBI.dataIdentifiers[0x3000] = "RDBI_CD_REQ"  # or WDBI_CD_REQ
 UDS_RDBI.dataIdentifiers[0x300a] = "Codier-VIN"
 UDS_RDBI.dataIdentifiers[0x37fe] = "Codierpruefstempel"
 UDS_RDBI.dataIdentifiers[0x3f00] = "SVT-Ist"
 UDS_RDBI.dataIdentifiers[0x3f01] = "SVT-Soll"
 UDS_RDBI.dataIdentifiers[0x3F02] = "VcmEcuListSecurity"
 UDS_RDBI.dataIdentifiers[0x3F03] = "VcmEcuListSwt"
 UDS_RDBI.dataIdentifiers[0x3F04] = "VcmNotificationTimeStamp"
@@ -4860,15 +4907,15 @@
 UDS_RC.routineControlIdentifiers[0x0f05] = "powerDown"
 UDS_RC.routineControlIdentifiers[0x0f06] = "clearDTCSecondaryMemory"
 UDS_RC.routineControlIdentifiers[0x0f07] = "requestForAuthentication"
 UDS_RC.routineControlIdentifiers[0x0f08] = "releaseAuthentication"
 UDS_RC.routineControlIdentifiers[0x0f09] = "checkSignature"
 UDS_RC.routineControlIdentifiers[0x0f0a] = "checkProgrammingStatus"
 UDS_RC.routineControlIdentifiers[0x0f0b] = "ExecuteDiagnosticService"
-UDS_RC.routineControlIdentifiers[0x0f0c] = "SetEnergyMode"       # or controlEnergySavingMode  # noqa E501
+UDS_RC.routineControlIdentifiers[0x0f0c] = "SetEnergyMode"  # or controlEnergySavingMode  # noqa E501
 UDS_RC.routineControlIdentifiers[0x0f0d] = "resetSystemFaultMessage"
 UDS_RC.routineControlIdentifiers[0x0f0e] = "timeControlledPowerDown"
 UDS_RC.routineControlIdentifiers[0x0f0f] = "disableCommunicationOverGateway"
 UDS_RC.routineControlIdentifiers[0x0f1f] = "SwtRoutine"
 UDS_RC.routineControlIdentifiers[0x1002] = "Individualdatenrettung"
 UDS_RC.routineControlIdentifiers[0x1003] = "SetExtendedMode"
 UDS_RC.routineControlIdentifiers[0x1007] = "MasterVIN"
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/bmw/enumerator.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/bmw/enumerator.py`

 * *Files 10% similar despite different names*

```diff
@@ -4,20 +4,24 @@
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = BMW specific enumerators
 # scapy.contrib.status = loads
 
 
 from scapy.packet import Packet
-from scapy.compat import Any, Iterable
 from scapy.contrib.automotive.scanner.enumerator import _AutomotiveTestCaseScanResult  # noqa: E501
 from scapy.contrib.automotive.uds import UDS
 from scapy.contrib.automotive.bmw.definitions import DEV_JOB
 from scapy.contrib.automotive.uds_scan import UDS_Enumerator
 
+from typing import (
+    Any,
+    Iterable,
+)
+
 
 class BMW_DevJobEnumerator(UDS_Enumerator):
     _description = "Available DevelopmentJobs by Identifier " \
                    "and negative response per state"
 
     def _get_initial_requests(self, **kwargs):
         # type: (Any) -> Iterable[Packet]
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/bmw/hsfz.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/bmw/hsfz.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,23 +6,32 @@
 # scapy.contrib.description = HSFZ - BMW High-Speed-Fahrzeug-Zugang
 # scapy.contrib.status = loads
 import logging
 import struct
 import socket
 import time
 
-from scapy.compat import Optional, Tuple, Type, Iterable, List, Union
 from scapy.contrib.automotive import log_automotive
 from scapy.packet import Packet, bind_layers, bind_bottom_up
 from scapy.fields import IntField, ShortEnumField, XByteField
 from scapy.layers.inet import TCP
 from scapy.supersocket import StreamSocket
 from scapy.contrib.automotive.uds import UDS, UDS_TP
 from scapy.data import MTU
 
+from typing import (
+    Any,
+    Optional,
+    Tuple,
+    Type,
+    Iterable,
+    List,
+    Union,
+)
+
 
 """
 BMW HSFZ (High-Speed-Fahrzeug-Zugang / High-Speed-Car-Access).
 BMW specific diagnostic over IP protocol implementation.
 The physical interface for this connection is called ENET.
 """
 
@@ -74,14 +83,35 @@
         self.ip = ip
         self.port = port
         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
         s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         s.connect((self.ip, self.port))
         StreamSocket.__init__(self, s, HSFZ)
+        self.buffer = b""
+
+    def recv(self, x=MTU, **kwargs):
+        # type: (Optional[int], **Any) -> Optional[Packet]
+        if self.buffer:
+            len_data = self.buffer[:4]
+        else:
+            len_data = self.ins.recv(4, socket.MSG_PEEK)
+            if len(len_data) != 4:
+                return None
+
+        len_int = struct.unpack(">I", len_data)[0]
+        len_int += 6
+        self.buffer += self.ins.recv(len_int - len(self.buffer))
+
+        if len(self.buffer) != len_int:
+            return None
+
+        pkt = self.basecls(self.buffer, **kwargs)  # type: Packet
+        self.buffer = b""
+        return pkt
 
 
 class UDS_HSFZSocket(HSFZSocket):
     def __init__(self, src, dst, ip='127.0.0.1', port=6801, basecls=UDS):
         # type: (int, int, str, int, Type[Packet]) -> None
         super(UDS_HSFZSocket, self).__init__(ip, port)
         self.src = src
@@ -108,19 +138,19 @@
             # in the send part. This means, a caller of the SndRcvHandler
             # can not detect if an error occurred. This workaround closes
             # the socket if a send error was detected.
             log_automotive.exception("Exception: %s", e)
             self.close()
             return 0
 
-    def recv(self, x=MTU):
-        # type: (int) -> Optional[Packet]
+    def recv(self, x=MTU, **kwargs):
+        # type: (Optional[int], **Any) -> Optional[Packet]
         pkt = super(UDS_HSFZSocket, self).recv(x)
         if pkt:
-            return self.outputcls(bytes(pkt.payload))
+            return self.outputcls(bytes(pkt.payload), **kwargs)
         else:
             return pkt
 
 
 def hsfz_scan(ip,  # type: str
               scan_range=range(0x100),  # type: Iterable[int]
               src=0xf4,  # type: int
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/ccp.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/ccp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/doip.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/doip.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,23 +9,41 @@
 # scapy.contrib.status = loads
 
 import struct
 import socket
 import time
 
 from scapy.contrib.automotive import log_automotive
-from scapy.fields import ByteEnumField, ConditionalField, \
-    XByteField, XShortField, XIntField, XShortEnumField, XByteEnumField, \
-    IntField, StrFixedLenField, XStrField
+from scapy.fields import (
+    ByteEnumField,
+    ConditionalField,
+    IntField,
+    MayEnd,
+    StrFixedLenField,
+    XByteEnumField,
+    XByteField,
+    XIntField,
+    XShortEnumField,
+    XShortField,
+    XStrField,
+)
 from scapy.packet import Packet, bind_layers, bind_bottom_up
 from scapy.supersocket import StreamSocket
 from scapy.layers.inet import TCP, UDP
 from scapy.contrib.automotive.uds import UDS
 from scapy.data import MTU
-from scapy.compat import Union, Tuple, Optional
+
+from typing import (
+    Any,
+    Union,
+    Tuple,
+    Optional,
+)
+
+# ISO 13400-2 sect 9.2
 
 
 class DoIP(Packet):
     """
     Implementation of the DoIP (ISO 13400) protocol. DoIP packets can be sent
     via UDP and TCP. Depending on the payload type, the correct connection
     need to be chosen:
@@ -112,26 +130,28 @@
                          lambda p: p.payload_type in [3, 4]),
         ConditionalField(XShortField("logical_address", 0),
                          lambda p: p.payload_type in [4]),
         ConditionalField(StrFixedLenField("eid", b"", 6),
                          lambda p: p.payload_type in [2, 4]),
         ConditionalField(StrFixedLenField("gid", b"", 6),
                          lambda p: p.payload_type in [4]),
-        ConditionalField(XByteEnumField("further_action", 0, {
+        ConditionalField(MayEnd(XByteEnumField("further_action", 0, {
             0x00: "No further action required",
             0x01: "Reserved by ISO 13400", 0x02: "Reserved by ISO 13400",
             0x03: "Reserved by ISO 13400", 0x04: "Reserved by ISO 13400",
             0x05: "Reserved by ISO 13400", 0x06: "Reserved by ISO 13400",
             0x07: "Reserved by ISO 13400", 0x08: "Reserved by ISO 13400",
             0x09: "Reserved by ISO 13400", 0x0a: "Reserved by ISO 13400",
             0x0b: "Reserved by ISO 13400", 0x0c: "Reserved by ISO 13400",
             0x0d: "Reserved by ISO 13400", 0x0e: "Reserved by ISO 13400",
             0x0f: "Reserved by ISO 13400",
             0x10: "Routing activation required to initiate central security",
-        }), lambda p: p.payload_type in [4]),
+        })), lambda p: p.payload_type in [4]),
+        # VIN/GID sync. status is marked as optional, so the packet MayEnd
+        # on further_action
         ConditionalField(XByteEnumField("vin_gid_status", 0, {
             0x00: "VIN and/or GID are synchronized",
             0x01: "Reserved by ISO 13400", 0x02: "Reserved by ISO 13400",
             0x03: "Reserved by ISO 13400", 0x04: "Reserved by ISO 13400",
             0x05: "Reserved by ISO 13400", 0x06: "Reserved by ISO 13400",
             0x07: "Reserved by ISO 13400", 0x08: "Reserved by ISO 13400",
             0x09: "Reserved by ISO 13400", 0x0a: "Reserved by ISO 13400",
@@ -264,26 +284,48 @@
     def __init__(self, ip='127.0.0.1', port=13400, activate_routing=True,
                  source_address=0xe80, target_address=0,
                  activation_type=0, reserved_oem=b""):
         # type: (str, int, bool, int, int, int, bytes) -> None
         self.ip = ip
         self.port = port
         self.source_address = source_address
+        self.buffer = b""
         self._init_socket()
 
         if activate_routing:
             self._activate_routing(
                 source_address, target_address, activation_type, reserved_oem)
 
+    def recv(self, x=MTU, **kwargs):
+        # type: (Optional[int], **Any) -> Optional[Packet]
+        if self.buffer:
+            len_data = self.buffer[:8]
+        else:
+            len_data = self.ins.recv(8, socket.MSG_PEEK)
+            if len(len_data) != 8:
+                return None
+
+        len_int = struct.unpack(">I", len_data[4:8])[0]
+        len_int += 8
+        self.buffer += self.ins.recv(len_int - len(self.buffer))
+
+        if len(self.buffer) != len_int:
+            return None
+
+        pkt = self.basecls(self.buffer, **kwargs)  # type: Packet
+        self.buffer = b""
+        return pkt
+
     def _init_socket(self, sock_family=socket.AF_INET):
         # type: (int) -> None
         s = socket.socket(sock_family, socket.SOCK_STREAM)
         s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
         s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-        s.connect((self.ip, self.port))
+        addrinfo = socket.getaddrinfo(self.ip, self.port, proto=socket.IPPROTO_TCP)
+        s.connect(addrinfo[0][-1])
         StreamSocket.__init__(self, s, DoIP)
 
     def _activate_routing(self,
                           source_address,  # type: int
                           target_address,  # type: int
                           activation_type,  # type: int
                           reserved_oem=b""  # type: bytes
@@ -319,24 +361,26 @@
     :param activation_type: This allows to set a different activation type for
                             the routing activation request
     :param reserved_oem: Optional parameter to set value for reserved_oem field
                          of routing activation request
 
     Example:
         >>> socket = DoIPSocket6("2001:16b8:3f0e:2f00:21a:37ff:febf:edb9")
+        >>> socket_link_local = DoIPSocket6("fe80::30e8:80ff:fe07:6d43%eth1")
         >>> pkt = DoIP(payload_type=0x8001, source_address=0xe80, target_address=0x1000) / UDS() / UDS_RDBI(identifiers=[0x1000])
         >>> resp = socket.sr1(pkt, timeout=1)
     """  # noqa: E501
     def __init__(self, ip='::1', port=13400, activate_routing=True,
                  source_address=0xe80, target_address=0,
                  activation_type=0, reserved_oem=b""):
         # type: (str, int, bool, int, int, int, bytes) -> None
         self.ip = ip
         self.port = port
         self.source_address = source_address
+        self.buffer = b""
         super(DoIPSocket6, self)._init_socket(socket.AF_INET6)
 
         if activate_routing:
             super(DoIPSocket6, self)._activate_routing(
                 source_address, target_address, activation_type, reserved_oem)
 
 
@@ -361,17 +405,17 @@
         try:
             x.sent_time = time.time()  # type: ignore
         except AttributeError:
             pass
 
         return super(UDS_DoIPSocket, self).send(pkt)
 
-    def recv(self, x=MTU):
-        # type: (int) -> Optional[Packet]
-        pkt = super(UDS_DoIPSocket, self).recv(x)
+    def recv(self, x=MTU, **kwargs):
+        # type: (Optional[int], **Any) -> Optional[Packet]
+        pkt = super(UDS_DoIPSocket, self).recv(x, **kwargs)
         if pkt and pkt.payload_type == 0x8001:
             return pkt.payload
         else:
             return pkt
 
 
 class UDS_DoIPSocket6(DoIPSocket6, UDS_DoIPSocket):
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/ecu.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/ecu.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,24 +11,36 @@
 import copy
 import itertools
 
 from collections import defaultdict
 from types import GeneratorType
 from threading import Lock
 
-import scapy.libs.six as six
-from scapy.compat import Any, Union, Iterable, Callable, List, Optional, \
-    Tuple, Type, cast, Dict, orb, ValuesView
+from scapy.compat import orb
 from scapy.packet import Raw, Packet
 from scapy.plist import PacketList
 from scapy.sessions import DefaultSession
 from scapy.ansmachine import AnsweringMachine
 from scapy.supersocket import SuperSocket
 from scapy.error import Scapy_Exception
 
+# Typing imports
+from typing import (
+    Any,
+    Union,
+    Iterable,
+    Callable,
+    List,
+    Optional,
+    Tuple,
+    Type,
+    cast,
+    Dict,
+)
+
 
 __all__ = ["EcuState", "Ecu", "EcuResponse", "EcuSession",
            "EcuAnsweringMachine"]
 
 
 class EcuState(object):
     """
@@ -36,40 +48,40 @@
     example UDS or GMLAN.
     A EcuState supports comparison and serialization (command()).
     """
     __slots__ = ["__dict__", "__cache__"]
 
     def __init__(self, **kwargs):
         # type: (Any) -> None
-        self.__cache__ = None  # type: Optional[Tuple[List[EcuState], ValuesView[Any]]]  # noqa: E501
+        self.__cache__ = None  # type: Optional[Tuple[List[EcuState], List[Any]]]  # noqa: E501
         for k, v in kwargs.items():
             if isinstance(v, GeneratorType):
                 v = list(v)
             self.__setitem__(k, v)
 
     def _expand(self):
         # type: () -> List[EcuState]
-        if self.__cache__ is None or \
-                self.__cache__[1] != self.__dict__.values():
+        values = list(self.__dict__.values())
+        keys = list(self.__dict__.keys())
+        if self.__cache__ is None or self.__cache__[1] != values:
             expanded = list()
-            for x in itertools.product(
-                    *[self._flatten(v) for v in self.__dict__.values()]):
+            for x in itertools.product(*[self._flatten(v) for v in values]):
                 kwargs = {}
-                for i, k in enumerate(self.__dict__.keys()):
+                for i, k in enumerate(keys):
                     if x[i] is None:
                         continue
                     kwargs[k] = x[i]
                 expanded.append(EcuState(**kwargs))
-            self.__cache__ = (expanded, self.__dict__.values())
+            self.__cache__ = (expanded, values)
         return self.__cache__[0]
 
     @staticmethod
     def _flatten(x):
         # type: (Any) -> List[Any]
-        if isinstance(x, (six.string_types, bytes)):
+        if isinstance(x, (str, bytes)):
             return [x]
         elif hasattr(x, "__iter__") and hasattr(x, "__len__") and len(x) == 1:
             return list(*x)
         elif not hasattr(x, "__iter__"):
             return [x]
         flattened = list()
         for y in x:
@@ -453,25 +465,24 @@
 
     Example:
         >>> sniff(session=EcuSession)
 
     """
     def __init__(self, *args, **kwargs):
         # type: (Any, Any) -> None
-        DefaultSession.__init__(self, *args, **kwargs)
         self.ecu = Ecu(logging=kwargs.pop("logging", True),
                        verbose=kwargs.pop("verbose", True),
                        store_supported_responses=kwargs.pop("store_supported_responses", True))  # noqa: E501
+        super(EcuSession, self).__init__(*args, **kwargs)
 
-    def on_packet_received(self, pkt):
-        # type: (Optional[Packet]) -> None
+    def process(self, pkt: Packet) -> Optional[Packet]:
         if not pkt:
-            return
+            return None
         self.ecu.update(pkt)
-        DefaultSession.on_packet_received(self, pkt)
+        return pkt
 
 
 class EcuResponse:
     """Encapsulates responses and the according EcuStates.
     A list of this objects can be used to configure an EcuAnsweringMachine.
     This is useful, if you want to clone the behaviour of a real Ecu.
 
@@ -501,15 +512,14 @@
         if state is None:
             self.__states = None  # type: Optional[List[EcuState]]
         else:
             if hasattr(state, "__iter__"):
                 state = cast(List[EcuState], state)
                 self.__states = state
             else:
-                state = cast(EcuState, state)
                 self.__states = [state]
 
         if isinstance(responses, PacketList):
             self.__responses = responses  # type: PacketList
         elif isinstance(responses, Packet):
             self.__responses = PacketList([responses])
         elif hasattr(responses, "__iter__"):
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,18 +6,33 @@
 
 # scapy.contrib.description = General Motors Local Area Network (GMLAN)
 # scapy.contrib.status = loads
 
 import struct
 
 from scapy.contrib.automotive import log_automotive
-from scapy.fields import ObservableDict, XByteEnumField, ByteEnumField, \
-    ConditionalField, XByteField, StrField, XShortEnumField, XShortField, \
-    X3BytesField, XIntField, ShortField, PacketField, PacketListField, \
-    FieldListField, MultipleTypeField, StrFixedLenField
+from scapy.fields import (
+    ByteEnumField,
+    ConditionalField,
+    FieldListField,
+    MayEnd,
+    MultipleTypeField,
+    ObservableDict,
+    PacketField,
+    PacketListField,
+    ShortField,
+    StrField,
+    StrFixedLenField,
+    X3BytesField,
+    XByteEnumField,
+    XByteField,
+    XIntField,
+    XShortEnumField,
+    XShortField,
+)
 from scapy.packet import Packet, bind_layers, NoPayload
 from scapy.config import conf
 from scapy.contrib.isotp import ISOTP
 
 """
 GMLAN
 """
@@ -108,15 +123,15 @@
                 return True
             else:
                 return self.payload.answers(other.payload)
         return False
 
     def hashret(self):
         if self.service == 0x7f:
-            return struct.pack('B', self.requestServiceId)
+            return struct.pack('B', self.requestServiceId & ~0x40)
         return struct.pack('B', self.service & ~0x40)
 
 
 # ########################IDO###################################
 class GMLAN_IDO(Packet):
     subfunctions = {
         0x02: 'disableAllDTCs',
@@ -721,15 +736,16 @@
         0x89: 'DeviceTypeError',
         0x99: 'ReadyForDownload-DTCStored',
         0xe3: 'DeviceControlLimitsExceeded',
     }
     name = 'NegativeResponse'
     fields_desc = [
         XByteEnumField('requestServiceId', 0, GMLAN.services),
-        ByteEnumField('returnCode', 0, negativeResponseCodes),
+        MayEnd(ByteEnumField('returnCode', 0, negativeResponseCodes)),
+        # XXX Is this MayEnd correct? Why is the field below also 0xe3 ?
         ShortField('deviceControlLimitExceeded', 0)
     ]
 
     def answers(self, other):
         return self.requestServiceId == other.service and \
             (self.returnCode != 0x78 or
              conf.contribs['GMLAN']['treat-response-pending-as-answer'])
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan_ecu_states.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan_ecu_states.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan_logging.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan_logging.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,17 +9,22 @@
 
 from scapy.contrib.automotive.gm.gmlan import GMLAN_SA, GMLAN_IDO, GMLAN_DC, \
     GMLAN_NR, GMLAN_RD, GMLAN_TD, GMLAN_DCPR, GMLAN_DPBA, GMLAN_DPBAPR, \
     GMLAN_RPSPR, GMLAN_RDI, GMLAN_WDBI, GMLAN_WDBIPR, GMLAN_PM, GMLAN_SAPR, \
     GMLAN_RDBI, GMLAN_RDBIPR, GMLAN_RDBPI, GMLAN_RDBPIPR, GMLAN_RDBPKTI, \
     GMLAN_RFRD, GMLAN_RFRDPR, GMLAN_RMBA, GMLAN_RMBAPR, GMLAN_DDM, GMLAN_DDMPR
 from scapy.packet import Packet
-from scapy.compat import Tuple, Any
 from scapy.contrib.automotive.ecu import Ecu
 
+# Typing imports
+from typing import (
+    Any,
+    Tuple,
+)
+
 
 @Ecu.extend_pkt_with_logging(GMLAN_IDO)
 def GMLAN_IDO_get_log(self):
     # type: (Packet) -> Tuple[str, Any]
     return self.sprintf("%GMLAN.service%"), \
         self.sprintf("%GMLAN_IDO.subfunction%")
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlan_scanner.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlan_scanner.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,19 +9,17 @@
 import abc
 import random
 import time
 import copy
 
 from collections import defaultdict
 
-from scapy.compat import Optional, List, Type, Any, Tuple, Iterable, Dict, \
-    cast, Callable, orb
+from scapy.compat import orb
 from scapy.contrib.automotive import log_automotive
 from scapy.packet import Packet
-import scapy.libs.six as six
 from scapy.config import conf
 from scapy.supersocket import SuperSocket
 from scapy.error import Scapy_Exception
 from scapy.contrib.automotive.gm.gmlanutils import GMLAN_InitDiagnostics, \
     GMLAN_TesterPresentSender
 from scapy.contrib.automotive.gm.gmlan import GMLAN, GMLAN_SA, GMLAN_RD, \
     GMLAN_TD, GMLAN_RMBA, GMLAN_RDBI, GMLAN_RDBPI, GMLAN_IDO, \
@@ -39,25 +37,36 @@
     StagedAutomotiveTestCase
 from scapy.contrib.automotive.scanner.executor import \
     AutomotiveTestCaseExecutor
 
 # TODO: Refactor this import
 from scapy.contrib.automotive.gm.gmlan_ecu_states import *  # noqa: F401, F403
 
+# Typing imports
+from typing import (
+    Optional,
+    List,
+    Type,
+    Any,
+    Tuple,
+    Iterable,
+    Dict,
+    cast,
+    Callable,
+)
 
 __all__ = ["GMLAN_Scanner", "GMLAN_ServiceEnumerator", "GMLAN_RDBIEnumerator",
            "GMLAN_RDBPIEnumerator", "GMLAN_RMBAEnumerator",
            "GMLAN_TPEnumerator", "GMLAN_IDOEnumerator", "GMLAN_PMEnumerator",
            "GMLAN_RDEnumerator", "GMLAN_TDEnumerator", "GMLAN_WDBIEnumerator",
            "GMLAN_SAEnumerator", "GMLAN_WDBISelectiveEnumerator",
            "GMLAN_DCEnumerator"]
 
 
-@six.add_metaclass(abc.ABCMeta)
-class GMLAN_Enumerator(ServiceEnumerator):
+class GMLAN_Enumerator(ServiceEnumerator, metaclass=abc.ABCMeta):
     """
     Abstract base class for GMLAN service enumerators. This class
     implements GMLAN specific functions.
     """
     @staticmethod
     def _get_negative_response_code(resp):
         # type: (Packet) -> int
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/gm/gmlanutils.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/gm/gmlanutils.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,25 +5,30 @@
 # Copyright (C) Markus Schroetter <project.m.schroetter@gmail.com>
 
 # scapy.contrib.description = GMLAN Utilities
 # scapy.contrib.status = loads
 
 import time
 
-from scapy.compat import Optional, cast, Callable
 from scapy.contrib.automotive import log_automotive
 
 from scapy.contrib.automotive.gm.gmlan import GMLAN, GMLAN_SA, GMLAN_RD, \
     GMLAN_TD, GMLAN_PM, GMLAN_RMBA
 from scapy.config import conf
 from scapy.packet import Packet
 from scapy.supersocket import SuperSocket
 from scapy.contrib.isotp import ISOTPSocket
 from scapy.utils import PeriodicSenderThread
 
+from typing import (
+    Optional,
+    cast,
+    Callable,
+)
+
 __all__ = ["GMLAN_TesterPresentSender", "GMLAN_InitDiagnostics",
            "GMLAN_GetSecurityAccess", "GMLAN_RequestDownload",
            "GMLAN_TransferData", "GMLAN_TransferPayload",
            "GMLAN_ReadMemoryByAddress", "GMLAN_BroadcastSocket"]
 
 log_automotive.info("\"conf.contribs['GMLAN']"
                     "['treat-response-pending-as-answer']\" set to True). This "
@@ -58,15 +63,15 @@
         PeriodicSenderThread.__init__(self, sock, pkt, interval)
 
     def run(self):
         # type: () -> None
         while not self._stopped.is_set() and not self._socket.closed:
             for p in self._pkts:
                 self._socket.sr1(p, verbose=False, timeout=0.1)
-                time.sleep(self._interval)
+                self._stopped.wait(timeout=self._interval)
                 if self._stopped.is_set() or self._socket.closed:
                     break
 
 
 def GMLAN_InitDiagnostics(
         sock,  # type: SuperSocket
         broadcast_socket=None,  # type: Optional[SuperSocket]
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/kwp.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/kwp.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,26 +3,39 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = Keyword Protocol 2000 (KWP2000) / ISO 14230
 # scapy.contrib.status = loads
 
 import struct
-import time
 
-from scapy.fields import ByteEnumField, StrField, ConditionalField, \
-    BitField, XByteField, X3BytesField, ByteField, \
-    ObservableDict, XShortEnumField, XByteEnumField
+from scapy.fields import (
+    BitField,
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    MayEnd,
+    ObservableDict,
+    StrField,
+    X3BytesField,
+    XByteEnumField,
+    XByteField,
+    XShortEnumField,
+)
 from scapy.packet import Packet, bind_layers, NoPayload
 from scapy.config import conf
 from scapy.error import log_loading
 from scapy.utils import PeriodicSenderThread
 from scapy.plist import _PacketIterable
 from scapy.contrib.isotp import ISOTP
-from scapy.compat import Dict, Any
+
+from typing import (
+    Dict,
+    Any,
+)
 
 
 try:
     if conf.contribs['KWP']['treat-response-pending-as-answer']:
         pass
 except KeyError:
     log_loading.info("Specify \"conf.contribs['KWP'] = "
@@ -108,15 +121,15 @@
             else:
                 return self.payload.answers(other.payload)
         return False
 
     def hashret(self):
         # type: () -> bytes
         if self.service == 0x7f:
-            return struct.pack('B', self.requestServiceId)
+            return struct.pack('B', self.requestServiceId & ~0x40)
         else:
             return struct.pack('B', self.service & ~0x40)
 
 
 # ########################SDS###################################
 class KWP_SDS(Packet):
     diagnosticSessionTypes = ObservableDict({
@@ -384,29 +397,31 @@
         0x84: 'onChangeOfRecordValue',
         0xA0: 'onComparisonOfValues'
     }
     name = 'ResponseOnEvent'
     fields_desc = [
         ByteEnumField('responseRequired', 1, responseTypes),
         ByteEnumField('eventWindowTime', 0, eventWindowTimes),
-        ByteEnumField('eventType', 0, eventTypes),
+        MayEnd(ByteEnumField('eventType', 0, eventTypes)),
+        # XXX Is this MayEnd correct?
         ByteField('eventParameter', 0),
         ByteEnumField('serviceToRespond', 0, KWP.services),
         ByteField('serviceParameter', 0)
     ]
 
 
 bind_layers(KWP, KWP_ROE, service=0x86)
 
 
 class KWP_ROEPR(Packet):
     name = 'ResponseOnEventPositiveResponse'
     fields_desc = [
         ByteField("numberOfActivatedEvents", 0),
-        ByteEnumField('eventWindowTime', 0, KWP_ROE.eventWindowTimes),
+        MayEnd(ByteEnumField('eventWindowTime', 0, KWP_ROE.eventWindowTimes)),
+        # XXX Is this MayEnd correct?
         ByteEnumField('eventType', 0, KWP_ROE.eventTypes),
     ]
 
     def answers(self, other):
         # type: (Packet) -> int
         return isinstance(other, KWP_ROE) \
             and other.eventType == self.eventType
@@ -951,15 +966,16 @@
         0x9A: 'dataDecompressionFailed',
         0x9B: 'dataDecryptionFailed',
         0xA0: 'EcuNotResponding',
         0xA1: 'EcuAddressUnknown'
     }
     name = 'NegativeResponse'
     fields_desc = [
-        XByteEnumField('requestServiceId', 0, KWP.services),
+        MayEnd(XByteEnumField('requestServiceId', 0, KWP.services)),
+        # XXX Is this MayEnd correct?
         ByteEnumField('negativeResponseCode', 0, negativeResponseCodes)
     ]
 
     def answers(self, other):
         # type: (Packet) -> int
         return self.requestServiceId == other.service and \
             (self.negativeResponseCode != 0x78 or
@@ -970,23 +986,26 @@
 
 
 # ##################################################################
 # ######################## UTILS ###################################
 # ##################################################################
 
 class KWP_TesterPresentSender(PeriodicSenderThread):
-    def __init__(self, sock, pkt=KWP() / KWP_TP(), interval=2):
+    def __init__(self, sock, pkt=KWP() / KWP_TP(responseRequired=0x02),
+                 interval=2):
         # type: (Any, _PacketIterable, float) -> None
         """ Thread that sends TesterPresent packets periodically
 
         :param sock: socket where packet is sent periodically
         :param pkt: packet to send
         :param interval: interval between two packets
         """
         PeriodicSenderThread.__init__(self, sock, pkt, interval)
 
     def run(self):
         # type: () -> None
         while not self._stopped.is_set():
             for p in self._pkts:
                 self._socket.sr1(p, timeout=0.3, verbose=False)
-                time.sleep(self._interval)
+                self._stopped.wait(timeout=self._interval)
+                if self._stopped.is_set() or self._socket.closed:
+                    break
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/iid/iids.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/iid/iids.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/mid/mids.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/mid/mids.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/obd.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/obd.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_00_1F.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_00_1F.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_20_3F.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_20_3F.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_40_5F.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_40_5F.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_60_7F.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_60_7F.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_80_9F.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_80_9F.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/pid/pids_A0_C0.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/pid/pids_A0_C0.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/scanner.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/scanner.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,29 +6,36 @@
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = OnBoardDiagnosticScanner
 # scapy.contrib.status = loads
 
 import copy
 
-from scapy.compat import List, Type, Any, Iterable
 from scapy.contrib.automotive.obd.obd import OBD, OBD_S03, OBD_S07, OBD_S0A, \
     OBD_S01, OBD_S06, OBD_S08, OBD_S09, OBD_NR, OBD_S02, OBD_S02_Record
 from scapy.config import conf
 from scapy.packet import Packet
 from scapy.themes import BlackAndWhite
 
 from scapy.contrib.automotive.scanner.enumerator import ServiceEnumerator, \
     _AutomotiveTestCaseScanResult, _AutomotiveTestCaseFilteredScanResult
 from scapy.contrib.automotive.scanner.executor import \
     AutomotiveTestCaseExecutor
 from scapy.contrib.automotive.ecu import EcuState
 from scapy.contrib.automotive.scanner.test_case import AutomotiveTestCaseABC, \
     _SocketUnion
 
+# Typing imports
+from typing import (
+    List,
+    Type,
+    Any,
+    Iterable,
+)
+
 
 class OBD_Enumerator(ServiceEnumerator):
     _supported_kwargs = copy.copy(ServiceEnumerator._supported_kwargs)
     _supported_kwargs.update({
         'full_scan': (bool, None),
     })
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/services.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/services.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/obd/tid/tids.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/obd/tid/tids.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/scanner/configuration.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/scanner/configuration.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,21 +3,31 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = AutomotiveTestCaseExecutorConfiguration
 # scapy.contrib.status = library
 
 import inspect
+from threading import Event
 
-from scapy.compat import Any, Union, List, Type, Set, cast
 from scapy.contrib.automotive import log_automotive
 from scapy.contrib.automotive.scanner.graph import Graph
 from scapy.contrib.automotive.scanner.test_case import AutomotiveTestCaseABC
 from scapy.contrib.automotive.scanner.staged_test_case import StagedAutomotiveTestCase  # noqa: E501
 
+# Typing imports
+from typing import (
+    Any,
+    Union,
+    List,
+    Type,
+    Set,
+    cast,
+)
+
 
 class AutomotiveTestCaseExecutorConfiguration(object):
     """
     Configuration storage for AutomotiveTestCaseExecutor.
 
     The following keywords are used in the AutomotiveTestCaseExecutor:
         verbose: Enables verbose output and logging
@@ -101,19 +111,59 @@
                 "StagedAutomotiveTestCase or AutomotiveTestCaseABC")
 
     def __init__(self, test_cases, **kwargs):
         # type: (Union[List[Union[AutomotiveTestCaseABC, Type[AutomotiveTestCaseABC]]], List[Type[AutomotiveTestCaseABC]]], Any) -> None  # noqa: E501
         self.verbose = kwargs.get("verbose", False)
         self.debug = kwargs.get("debug", False)
         self.unittest = kwargs.pop("unittest", False)
+        self.delay_enter_state = kwargs.pop("delay_enter_state", 0)
         self.state_graph = Graph()
         self.test_cases = list()  # type: List[AutomotiveTestCaseABC]
         self.stages = list()  # type: List[StagedAutomotiveTestCase]
         self.staged_test_cases = list()  # type: List[AutomotiveTestCaseABC]
         self.test_case_clss = set()  # type: Set[Type[AutomotiveTestCaseABC]]
+        self.stop_event = Event()
         self.global_kwargs = kwargs
+        self.global_kwargs["stop_event"] = self.stop_event
 
         for tc in test_cases:
             self.add_test_case(tc)
 
         log_automotive.debug("The following configuration was created")
         log_automotive.debug(self.__dict__)
+
+    def __reduce__(self):  # type: ignore
+        f, t, d = super(AutomotiveTestCaseExecutorConfiguration, self).__reduce__()  # type: ignore  # noqa: E501
+
+        try:
+            del d["tps"]
+        except KeyError:
+            pass
+
+        try:
+            del d["stop_event"]
+        except KeyError:
+            pass
+
+        try:
+            del d["global_kwargs"]["stop_event"]
+        except KeyError:
+            pass
+
+        for tc in d["test_cases"]:
+            try:
+                del d[tc.__class__.__name__]["stop_event"]
+            except KeyError:
+                pass
+
+        for tc in d["staged_test_cases"]:
+            try:
+                del d[tc.__class__.__name__]["stop_event"]
+            except KeyError:
+                pass
+
+        try:
+            del d["global_kwargs"]["stop_event"]
+        except KeyError:
+            pass
+
+        return f, t, d
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/scanner/enumerator.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/scanner/enumerator.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,29 +9,42 @@
 
 import abc
 import threading
 import time
 import copy
 from collections import defaultdict, OrderedDict
 from itertools import chain
+from typing import NamedTuple
 
-from scapy.compat import Any, Union, List, Optional, Iterable, \
-    Dict, Tuple, Set, Callable, cast, NamedTuple, orb
+from scapy.compat import orb
 from scapy.contrib.automotive import log_automotive
 from scapy.error import Scapy_Exception
-from scapy.utils import make_lined_table, EDecimal
-import scapy.libs.six as six
+from scapy.utils import make_lined_table, EDecimal, PeriodicSenderThread
 from scapy.packet import Packet
 from scapy.contrib.automotive.ecu import EcuState, EcuResponse
 from scapy.contrib.automotive.scanner.test_case import AutomotiveTestCase, \
     StateGenerator, _SocketUnion, _TransitionTuple
 from scapy.contrib.automotive.scanner.configuration import \
     AutomotiveTestCaseExecutorConfiguration
 from scapy.contrib.automotive.scanner.graph import _Edge
 
+# Typing imports
+from typing import (
+    Any,
+    Union,
+    List,
+    Optional,
+    Iterable,
+    Dict,
+    Tuple,
+    Set,
+    Callable,
+    cast,
+)
+
 # Definition outside the class ServiceEnumerator to allow pickling
 _AutomotiveTestCaseScanResult = NamedTuple(
     "_AutomotiveTestCaseScanResult",
     [("state", EcuState),
      ("req", Packet),
      ("resp", Optional[Packet]),
      ("req_ts", Union[EDecimal, float]),
@@ -42,16 +55,15 @@
     [("state", EcuState),
      ("req", Packet),
      ("resp", Packet),
      ("req_ts", Union[EDecimal, float]),
      ("resp_ts", Union[EDecimal, float])])
 
 
-@six.add_metaclass(abc.ABCMeta)
-class ServiceEnumerator(AutomotiveTestCase):
+class ServiceEnumerator(AutomotiveTestCase, metaclass=abc.ABCMeta):
     """
     Base class for ServiceEnumerators of automotive diagnostic protocols
     """
 
     _supported_kwargs = copy.copy(AutomotiveTestCase._supported_kwargs)
     _supported_kwargs.update({
         'timeout': ((int, float), lambda x: x > 0),
@@ -60,18 +72,20 @@
         'state_allow_list': ((list, EcuState), None),
         'state_block_list': ((list, EcuState), None),
         'retry_if_none_received': (bool, None),
         'exit_if_no_answer_received': (bool, None),
         'exit_if_service_not_supported': (bool, None),
         'exit_scan_on_first_negative_response': (bool, None),
         'retry_if_busy_returncode': (bool, None),
-        'stop_event': (threading._Event if six.PY2 else threading.Event, None),  # type: ignore  # noqa: E501
+        'stop_event': (threading.Event, None),
         'debug': (bool, None),
         'scan_range': ((list, tuple, range), None),
-        'unittest': (bool, None)
+        'unittest': (bool, None),
+        'disable_tps_while_sending': (bool, None),
+        'inter': ((int, float), lambda x: x >= 0),
     })
 
     _supported_kwargs_doc = AutomotiveTestCase._supported_kwargs_doc + """
         :param timeout: Timeout until a response will arrive after a request
         :type timeout: integer or float
         :param integer count: Number of request to be sent in one execution
         :param int execution_time: Time in seconds until the execution of
@@ -103,25 +117,31 @@
                                                           received.
         :param bool retry_if_busy_returncode: Specifies to retry a request, if
                                               the 'busyRepeatRequest' negative
                                               response code is received.
         :param bool debug: Enables debug functions during execute.
         :param Event stop_event: Signals immediate stop of the execution.
         :param scan_range: Specifies the identifiers to be scanned.
-        :type scan_range: list or tuple or range or iterable"""
+        :type scan_range: list or tuple or range or iterable
+        :param disable_tps_while_sending: Temporary disables a TesterPresentSender
+                                          to not interact with a seed request.
+        :type disable_tps_while_sending: bool
+        :param inter: delay between two packets during sending
+        :type inter: int or float"""
 
     def __init__(self):
         # type: () -> None
         super(ServiceEnumerator, self).__init__()
         self._result_packets = OrderedDict()  # type: Dict[bytes, Packet]
         self._results = list()  # type: List[_AutomotiveTestCaseScanResult]
         self._request_iterators = dict()  # type: Dict[EcuState, Iterable[Packet]]  # noqa: E501
         self._retry_pkt = defaultdict(list)  # type: Dict[EcuState, Union[Packet, Iterable[Packet]]]  # noqa: E501
         self._negative_response_blacklist = [0x10, 0x11]  # type: List[int]
         self._requests_per_state_estimated = None  # type: Optional[int]
+        self._tester_present_sender = None  # type: Optional[PeriodicSenderThread]
 
     @staticmethod
     @abc.abstractmethod
     def _get_negative_response_code(resp):
         # type: (Packet) -> int
         raise NotImplementedError()
 
@@ -168,15 +188,15 @@
     def _get_initial_requests(self, **kwargs):
         # type: (Any) -> Iterable[Packet]
         raise NotImplementedError("Overwrite this method")
 
     def __reduce__(self):  # type: ignore
         f, t, d = super(ServiceEnumerator, self).__reduce__()  # type: ignore
         try:
-            for k, v in six.iteritems(d["_request_iterators"]):
+            for k, v in d["_request_iterators"].items():
                 d["_request_iterators"][k] = list(v)
         except KeyError:
             pass
 
         try:
             for k in d["_retry_pkt"]:
                 d["_retry_pkt"][k] = list(self._get_retry_iterator(k))
@@ -214,18 +234,22 @@
 
     def _get_retry_iterator(self, state):
         # type: (EcuState) -> Iterable[Packet]
         retry_entry = self._retry_pkt[state]
         if isinstance(retry_entry, Packet):
             log_automotive.debug("Provide retry packet")
             return [retry_entry]
+        elif isinstance(retry_entry, list):
+            if len(retry_entry):
+                log_automotive.debug("Provide retry list")
         else:
             log_automotive.debug("Provide retry iterator")
             # assume self.retry_pkt is a generator or list
-            return retry_entry
+
+        return retry_entry
 
     def _get_initial_request_iterator(self, state, **kwargs):
         # type: (EcuState, Any) -> Iterable[Packet]
         if state not in self._request_iterators:
             self._request_iterators[state] = iter(
                 self._get_initial_requests(**kwargs))
 
@@ -252,21 +276,30 @@
 
         pkts_tbs = max(
             len(self.scanned_states) * self._requests_per_state_estimated, 1)
         pkts_snt = len(self.results)
 
         return pkts_tbs, pkts_snt, float(pkts_snt) / pkts_tbs
 
+    def pre_execute(self, socket, state, global_configuration):
+        # type: (_SocketUnion, EcuState, AutomotiveTestCaseExecutorConfiguration) -> None  # noqa: E501
+        try:
+            self._tester_present_sender = global_configuration["tps"]
+        except KeyError:
+            self._tester_present_sender = None
+
     def execute(self, socket, state, **kwargs):
         # type: (_SocketUnion, EcuState, Any) -> None
         self.check_kwargs(kwargs)
         timeout = kwargs.pop('timeout', 1)
         count = kwargs.pop('count', None)
         execution_time = kwargs.pop("execution_time", 1200)
         stop_event = kwargs.pop("stop_event", None)  # type: Optional[threading.Event]  # noqa: E501
+        disable_tps = kwargs.pop("disable_tps_while_sending", False)
+        inter = kwargs.pop("inter", 0)
 
         self._prepare_runtime_estimation(**kwargs)
 
         state_block_list = kwargs.get('state_block_list', list())
 
         if state_block_list and state in state_block_list:
             self._state_completed[state] = True
@@ -281,36 +314,47 @@
                                  repr(state))
             return
 
         it = self._get_request_iterator(state, **kwargs)
 
         # log_automotive.debug("[i] Using iterator %s in state %s", it, state)
 
-        start_time = time.time()
+        start_time = time.monotonic()
         log_automotive.debug(
-            "Start execution of enumerator: %s", time.ctime(start_time))
+            "Start execution of enumerator: %s", time.ctime())
 
         for req in it:
+            if stop_event:
+                stop_event.wait(timeout=inter)
+            else:
+                time.sleep(inter)
+
+            if disable_tps and self._tester_present_sender:
+                self._tester_present_sender.disable()
+
             res = self.sr1_with_retry_on_error(req, socket, state, timeout)
 
+            if disable_tps and self._tester_present_sender:
+                self._tester_present_sender.enable()
+
             self._store_result(state, req, res)
 
             if self._evaluate_response(state, req, res, **kwargs):
                 log_automotive.debug(
                     "Stop test_case execution because of response evaluation")
                 return
 
             if count is not None:
                 count -= 1
                 if count <= 0:
                     log_automotive.debug(
                         "Finished execution count of enumerator")
                     return
 
-            if (start_time + execution_time) < time.time():
+            if (start_time + execution_time) < time.monotonic():
                 log_automotive.debug(
                     "[i] Finished execution time of enumerator: %s",
                     time.ctime())
                 return
 
             if stop_event is not None and stop_event.is_set():
                 log_automotive.info(
@@ -519,15 +563,15 @@
 
         s = "%d requests were sent, %d answered, %d unanswered" % \
             (len(self._results),
              len(self.results_with_response),
              len(self.results_without_response)) + "\n"
 
         s += "Statistics per state\n"
-        s += make_lined_table(stats, lambda x: x, dump=True, sortx=str,
+        s += make_lined_table(stats, lambda *x: x, dump=True, sortx=str,
                               sorty=str) or ""
 
         return s + "\n"
 
     def _prepare_negative_response_blacklist(self):
         # type: () -> None
         nrc_dict = defaultdict(int)  # type: Dict[int, int]
@@ -642,16 +686,17 @@
                     for nr in self.negative_response_blacklist]
 
         return s + "\n"
 
     def _show_results_information(self, **kwargs):
         # type: (Any) -> str
         def _get_table_entry(
-                tup  # type: _AutomotiveTestCaseScanResult
+            *args: Any
         ):  # type: (...) -> Tuple[str, str, str]
+            tup = cast(_AutomotiveTestCaseScanResult, args)
             return self._get_table_entry_x(tup), \
                 self._get_table_entry_y(tup), \
                 self._get_table_entry_z(tup)
 
         filtered = kwargs.get("filtered", True)
         s = "=== No data to display ===\n"
         data = self._results if not filtered else self.filtered_results  # type: Union[List[_AutomotiveTestCaseScanResult], List[_AutomotiveTestCaseFilteredScanResult]]  # noqa: E501
@@ -685,16 +730,16 @@
     def _get_label(self, response, positive_case="PR: PositiveResponse"):
         # type: (Optional[Packet], Union[Callable[[Packet], str], str]) -> str
         if response is None:
             return "Timeout"
         elif orb(bytes(response)[0]) == 0x7f:
             return self._get_negative_response_label(response)
         else:
-            if isinstance(positive_case, six.string_types):
-                return cast(str, positive_case)
+            if isinstance(positive_case, str):
+                return positive_case
             elif callable(positive_case):
                 return positive_case(response)
             else:
                 raise Scapy_Exception("Unsupported Type for positive_case. "
                                       "Provide a string or a function.")
 
     @property
@@ -706,16 +751,19 @@
         for resp in all_responses:
             states = list(set([t.state for t in self.results_with_response
                                if t.resp == resp]))
             supported_resps.append(EcuResponse(state=states, responses=resp))
         return supported_resps
 
 
-@six.add_metaclass(abc.ABCMeta)
-class StateGeneratingServiceEnumerator(ServiceEnumerator, StateGenerator):
+class StateGeneratingServiceEnumerator(
+    ServiceEnumerator,
+    StateGenerator,
+    metaclass=abc.ABCMeta
+):
     def __init__(self):
         # type: () -> None
         super(StateGeneratingServiceEnumerator, self).__init__()
 
         # Internal storage of request packets for a certain Edge. If an edge
         # is found during the evaluation of the last result of the
         # ServiceEnumerator, the according request of the result tuple is
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/scanner/executor.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/scanner/executor.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,34 +6,44 @@
 # scapy.contrib.description = AutomotiveTestCaseExecutor base class
 # scapy.contrib.status = library
 
 import abc
 import time
 
 from itertools import product
-from threading import Event
 
-from scapy.compat import Any, Union, List, Optional, \
-    Dict, Callable, Type, cast
 from scapy.contrib.automotive import log_automotive
 from scapy.contrib.automotive.scanner.graph import Graph
 from scapy.error import Scapy_Exception
 from scapy.supersocket import SuperSocket
 from scapy.utils import make_lined_table, SingleConversationSocket
-import scapy.libs.six as six
 from scapy.contrib.automotive.ecu import EcuState, EcuResponse, Ecu
 from scapy.contrib.automotive.scanner.configuration import \
     AutomotiveTestCaseExecutorConfiguration
 from scapy.contrib.automotive.scanner.test_case import AutomotiveTestCaseABC, \
     _SocketUnion, _CleanupCallable, StateGenerator, TestCaseGenerator, \
     AutomotiveTestCase
 
+# Typing imports
+from typing import (
+    Any,
+    Union,
+    List,
+    Optional,
+    Dict,
+    Callable,
+    Type,
+    cast,
+    TypeVar,
+)
 
-@six.add_metaclass(abc.ABCMeta)
-class AutomotiveTestCaseExecutor:
+T = TypeVar("T")
+
+
+class AutomotiveTestCaseExecutor(metaclass=abc.ABCMeta):
     """
     Base class for different automotive scanners. This class handles
     the connection to a scan target, ensures the execution of all it's
     test cases, and stores the system state machine
 
 
     :param socket: A socket object to communicate with the scan target
@@ -49,40 +59,39 @@
     @property
     def _initial_ecu_state(self):
         # type: () -> EcuState
         return EcuState(session=1)
 
     def __init__(
             self,
-            socket,  # type: _SocketUnion
+            socket,  # type: Optional[_SocketUnion]
             reset_handler=None,  # type: Optional[Callable[[], None]]
             reconnect_handler=None,  # type: Optional[Callable[[], _SocketUnion]]  # noqa: E501
             test_cases=None,
             # type: Optional[List[Union[AutomotiveTestCaseABC, Type[AutomotiveTestCaseABC]]]]  # noqa: E501
             **kwargs  # type: Optional[Dict[str, Any]]
     ):  # type: (...) -> None
 
         # The TesterPresentSender can interfere with a test_case, since a
         # target may only allow one request at a time.
         # The SingleConversationSocket prevents interleaving requests.
-        if not isinstance(socket, SingleConversationSocket):
-            self.socket = SingleConversationSocket(socket)
+        if socket and not isinstance(socket, SingleConversationSocket):
+            self.socket = SingleConversationSocket(socket)  # type: Optional[_SocketUnion]  # noqa: E501
         else:
             self.socket = socket
 
         self.target_state = self._initial_ecu_state
         self.reset_handler = reset_handler
         self.reconnect_handler = reconnect_handler
 
         self.cleanup_functions = list()  # type: List[_CleanupCallable]
 
         self.configuration = AutomotiveTestCaseExecutorConfiguration(
             test_cases or self.default_test_case_clss, **kwargs)
         self.validate_test_case_kwargs()
-        self._stop_scan_event = Event()
 
     def __reduce__(self):  # type: ignore
         f, t, d = super(AutomotiveTestCaseExecutor, self).__reduce__()  # type: ignore  # noqa: E501
         try:
             del d["socket"]
         except KeyError:
             pass
@@ -90,18 +99,14 @@
             del d["reset_handler"]
         except KeyError:
             pass
         try:
             del d["reconnect_handler"]
         except KeyError:
             pass
-        try:
-            del d["_stop_scan_event"]
-        except KeyError:
-            pass
         return f, t, d
 
     @property
     @abc.abstractmethod
     def default_test_case_clss(self):
         # type: () -> List[Type[AutomotiveTestCaseABC]]
         raise NotImplementedError()
@@ -149,72 +154,75 @@
             self.reset_handler()
         self.target_state = self._initial_ecu_state
 
     def reconnect(self):
         # type: () -> None
         if self.reconnect_handler:
             try:
-                self.socket.close()
+                if self.socket:
+                    self.socket.close()
             except Exception as e:
                 log_automotive.exception(
                     "Exception '%s' during socket.close", e)
 
             log_automotive.info("Target reconnect")
             socket = self.reconnect_handler()
             if not isinstance(socket, SingleConversationSocket):
                 self.socket = SingleConversationSocket(socket)
             else:
                 self.socket = socket
 
-        if self.socket.closed:
+        if self.socket and self.socket.closed:
             raise Scapy_Exception(
                 "Socket closed even after reconnect. Stop scan!")
 
     def execute_test_case(self, test_case, kill_time=None):
         # type: (AutomotiveTestCaseABC, Optional[float]) -> None
         """
         This function ensures the correct execution of a testcase, including
         the pre_execute, execute and post_execute.
-        Finally the testcase is asked if a new edge or a new testcase was
+        Finally, the testcase is asked if a new edge or a new testcase was
         generated.
 
         :param test_case: A test case to be executed
         :param kill_time: If set, this defines the maximum execution time for
                           the current test_case
         :return: None
         """
 
+        if not self.socket:
+            log_automotive.warning("Socket is None! Leaving execute_test_case")
+            return
+
         test_case.pre_execute(
             self.socket, self.target_state, self.configuration)
 
         try:
             test_case_kwargs = self.configuration[test_case.__class__.__name__]
         except KeyError:
             test_case_kwargs = dict()
 
         if kill_time:
-            max_execution_time = max(int(kill_time - time.time()), 5)
+            max_execution_time = max(int(kill_time - time.monotonic()), 5)
             cur_execution_time = test_case_kwargs.get("execution_time", 1200)
             test_case_kwargs["execution_time"] = min(max_execution_time,
                                                      cur_execution_time)
 
         log_automotive.debug("Execute test_case %s with args %s",
                              test_case.__class__.__name__, test_case_kwargs)
 
-        test_case.execute(self.socket, self.target_state,
-                          stop_event=self._stop_scan_event,
-                          **test_case_kwargs)
+        test_case.execute(self.socket, self.target_state, **test_case_kwargs)
         test_case.post_execute(
             self.socket, self.target_state, self.configuration)
 
         self.check_new_states(test_case)
         self.check_new_testcases(test_case)
 
         if hasattr(test_case, "runtime_estimation"):
-            estimation = test_case.runtime_estimation()  # type: ignore
+            estimation = test_case.runtime_estimation()
             if estimation is not None:
                 log_automotive.debug(
                     "[i] Test_case %s: TODO %d, "
                     "DONE %d, TOTAL %0.2f",
                     test_case.__class__.__name__, estimation[0],
                     estimation[1], estimation[2])
 
@@ -224,14 +232,18 @@
             new_test_case = test_case.get_generated_test_case()
             if new_test_case:
                 log_automotive.debug("Testcase generated %s", new_test_case)
                 self.configuration.add_test_case(new_test_case)
 
     def check_new_states(self, test_case):
         # type: (AutomotiveTestCaseABC) -> None
+        if not self.socket:
+            log_automotive.warning("Socket is None! Leaving check_new_states")
+            return
+
         if isinstance(test_case, StateGenerator):
             edge = test_case.get_new_edge(self.socket, self.configuration)
             if edge:
                 log_automotive.debug("Edge found %s", edge)
                 tf = test_case.get_transition_function(self.socket, edge)
                 self.state_graph.add_edge(edge, tf)
 
@@ -240,48 +252,51 @@
         for test_case in self.configuration.test_cases:
             if isinstance(test_case, AutomotiveTestCase):
                 test_case_kwargs = self.configuration[test_case.__class__.__name__]
                 test_case.check_kwargs(test_case_kwargs)
 
     def stop_scan(self):
         # type: () -> None
-        self._stop_scan_event.set()
+        self.configuration.stop_event.set()
+        log_automotive.debug("Internal stop event set!")
 
     def progress(self):
         # type: () -> float
         progress = []
         for tc in self.configuration.test_cases:
             if not hasattr(tc, "runtime_estimation"):
                 continue
-            est = tc.runtime_estimation()  # type: ignore
+            est = tc.runtime_estimation()
             if est is None:
                 continue
             progress.append(est[2])
 
         return sum(progress) / len(progress) if len(progress) else 0.0
 
     def scan(self, timeout=None):
         # type: (Optional[int]) -> None
         """
         Executes all testcases for a given time.
         :param timeout: Time for execution.
         :return: None
         """
-        self._stop_scan_event.clear()
-        kill_time = time.time() + (timeout or 0xffffffff)
-        log_automotive.debug("Set kill_time to %s" % time.ctime(kill_time))
-        while kill_time > time.time():
+        self.configuration.stop_event.clear()
+        if timeout is None:
+            kill_time = None
+        else:
+            kill_time = time.monotonic() + timeout
+        while kill_time is None or kill_time > time.monotonic():
             test_case_executed = False
             log_automotive.info("[i] Scan progress %0.2f", self.progress())
             log_automotive.debug("[i] Scan paths %s", self.state_paths)
             for p, test_case in product(
                     self.state_paths, self.configuration.test_cases):
                 log_automotive.info("Scan path %s", p)
-                terminate = kill_time <= time.time()
-                if terminate or self._stop_scan_event.is_set():
+                terminate = kill_time and kill_time <= time.monotonic()
+                if terminate or self.configuration.stop_event.is_set():
                     log_automotive.debug(
                         "Execution time exceeded. Terminating scan!")
                     break
 
                 final_state = p[-1]
                 if test_case.has_completed(final_state):
                     log_automotive.debug("State %s for %s completed",
@@ -300,17 +315,19 @@
                 except (OSError, ValueError, Scapy_Exception) as e:
                     log_automotive.exception("Exception: %s", e)
                     if self.configuration.debug:
                         raise e
                     if isinstance(e, OSError):
                         log_automotive.exception(
                             "OSError occurred, closing socket")
-                        self.socket.close()
-                    if cast(SuperSocket, self.socket).closed and \
-                            self.reconnect_handler is None:
+                        if self.socket:
+                            self.socket.close()
+                    if (self.socket
+                            and cast(SuperSocket, self.socket).closed
+                            and self.reconnect_handler is None):
                         log_automotive.critical(
                             "Socket went down. Need to leave scan")
                         raise e
                 finally:
                     self.cleanup_state()
 
             if not test_case_executed:
@@ -336,15 +353,21 @@
         self.reset_target()
         self.reconnect()
 
         if len(path) == 1:
             return True
 
         for next_state in path[1:]:
+            if self.configuration.stop_event.is_set():
+                self.cleanup_state()
+                return False
+
             edge = (self.target_state, next_state)
+            self.configuration.stop_event.wait(
+                timeout=self.configuration.delay_enter_state)
             if not self.enter_state(*edge):
                 self.state_graph.downrate_edge(edge)
                 self.cleanup_state()
                 return False
         return True
 
     def enter_state(self, prev_state, next_state):
@@ -353,14 +376,18 @@
         Obtains a transition function from the system state graph and executes
         it. On success, the cleanup function is added for a later cleanup of
         the new state.
         :param prev_state: Current state
         :param next_state: Desired state
         :return: True, if state could be changed successful
         """
+        if not self.socket:
+            log_automotive.warning("Socket is None! Leaving enter_state")
+            return False
+
         edge = (prev_state, next_state)
         funcs = self.state_graph.get_transition_tuple_for_edge(edge)
 
         if funcs is None:
             log_automotive.error("No transition function for %s", edge)
             return False
 
@@ -379,14 +406,18 @@
 
     def cleanup_state(self):
         # type: () -> None
         """
         Executes all collected cleanup functions from a traversed path
         :return: None
         """
+        if not self.socket:
+            log_automotive.warning("Socket is None! Leaving cleanup_state")
+            return
+
         for f in self.cleanup_functions:
             if not callable(f):
                 continue
             try:
                 if not f(self.socket, self.configuration):
                     log_automotive.info(
                         "Cleanup function %s failed", repr(f))
@@ -402,15 +433,19 @@
 
     def show_testcases_status(self):
         # type: () -> None
         data = list()
         for t in self.configuration.test_cases:
             for s in self.state_graph.nodes:
                 data += [(repr(s), t.__class__.__name__, t.has_completed(s))]
-        make_lined_table(data, lambda tup: (tup[0], tup[1], tup[2]))
+        make_lined_table(data, lambda *tup: (tup[0], tup[1], tup[2]))
+
+    def get_test_cases_by_class(self, cls):
+        # type: (Type[T]) -> List[T]
+        return [x for x in self.configuration.test_cases if isinstance(x, cls)]
 
     @property
     def supported_responses(self):
         # type: () -> List[EcuResponse]
         """
         Returns a sorted list of supported responses, gathered from all
         enumerators. The sort is done in a way
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/scanner/graph.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/scanner/graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,18 +4,28 @@
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = Graph library for AutomotiveTestCaseExecutor
 # scapy.contrib.status = library
 
 from collections import defaultdict
 
-from scapy.compat import Union, List, Optional, Dict, Tuple, Set, TYPE_CHECKING
 from scapy.contrib.automotive import log_automotive
 from scapy.contrib.automotive.ecu import EcuState
 
+# Typing imports
+from typing import (
+    Union,
+    List,
+    Optional,
+    Dict,
+    Tuple,
+    Set,
+    TYPE_CHECKING,
+)
+
 _Edge = Tuple[EcuState, EcuState]
 
 if TYPE_CHECKING:
     from scapy.contrib.automotive.scanner.test_case import _TransitionTuple
 
 
 class Graph(object):
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/scanner/staged_test_case.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/scanner/staged_test_case.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,22 +3,31 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = Staged AutomotiveTestCase base classes
 # scapy.contrib.status = library
 
 
-from scapy.compat import Any, List, Optional, Dict, Callable, cast, \
-    TYPE_CHECKING, Tuple
 from scapy.contrib.automotive import log_automotive
 from scapy.contrib.automotive.scanner.graph import _Edge
 from scapy.contrib.automotive.ecu import EcuState, EcuResponse, Ecu
 from scapy.contrib.automotive.scanner.test_case import AutomotiveTestCaseABC, \
     TestCaseGenerator, StateGenerator, _SocketUnion
 
+# Typing imports
+from typing import (
+    Any,
+    List,
+    Optional,
+    Dict,
+    Callable,
+    cast,
+    Tuple,
+    TYPE_CHECKING,
+)
 if TYPE_CHECKING:
     from scapy.contrib.automotive.scanner.test_case import _TransitionTuple
     from scapy.contrib.automotive.scanner.configuration import \
         AutomotiveTestCaseExecutorConfiguration
 
 # type definitions
 _TestCaseConnectorCallable = \
@@ -197,15 +206,15 @@
                              self.current_test_case.__class__.__name__,
                              self.__current_kwargs)
 
         self.current_test_case.pre_execute(socket, state, global_configuration)
 
     def execute(self, socket, state, **kwargs):
         # type: (_SocketUnion, EcuState, Any) -> None
-        kwargs = self.__current_kwargs or dict()
+        kwargs.update(self.__current_kwargs or dict())
         self.current_test_case.execute(socket, state, **kwargs)
 
     def post_execute(self,
                      socket,  # type: _SocketUnion
                      state,  # type: EcuState
                      global_configuration  # type: AutomotiveTestCaseExecutorConfiguration  # noqa: E501
                      ):  # type: (...) -> None
@@ -250,15 +259,15 @@
         supported_responses.sort(key=Ecu.sort_key_func)
         return supported_responses
 
     def runtime_estimation(self):
         # type: () -> Optional[Tuple[int, int, float]]
 
         if hasattr(self.current_test_case, "runtime_estimation"):
-            cur_est = self.current_test_case.runtime_estimation()  # type: ignore
+            cur_est = self.current_test_case.runtime_estimation()
             if cur_est:
                 return len(self.test_cases), \
                     self.__stage_index, \
                     float(self.__stage_index) / len(self.test_cases) + \
                     cur_est[2] / len(self.test_cases)
 
         return len(self.test_cases), \
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/scanner/test_case.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/scanner/test_case.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,37 +6,45 @@
 # scapy.contrib.description = TestCase base class definitions
 # scapy.contrib.status = library
 
 
 import abc
 from collections import defaultdict
 
-from scapy.compat import Any, Union, List, Optional, \
-    Dict, Tuple, Set, Callable, TYPE_CHECKING
 from scapy.utils import make_lined_table, SingleConversationSocket
-import scapy.libs.six as six
 from scapy.supersocket import SuperSocket
 from scapy.contrib.automotive.scanner.graph import _Edge
 from scapy.contrib.automotive.ecu import EcuState, EcuResponse
 from scapy.error import Scapy_Exception
 
 
+# Typing imports
+from typing import (
+    Any,
+    Union,
+    List,
+    Optional,
+    Dict,
+    Tuple,
+    Set,
+    Callable,
+    TYPE_CHECKING,
+)
 if TYPE_CHECKING:
     from scapy.contrib.automotive.scanner.configuration import AutomotiveTestCaseExecutorConfiguration  # noqa: E501
 
 
 # type definitions
 _SocketUnion = Union[SuperSocket, SingleConversationSocket]
 _TransitionCallable = Callable[[_SocketUnion, "AutomotiveTestCaseExecutorConfiguration", Dict[str, Any]], bool]  # noqa: E501
 _CleanupCallable = Callable[[_SocketUnion, "AutomotiveTestCaseExecutorConfiguration"], bool]  # noqa: E501
 _TransitionTuple = Tuple[_TransitionCallable, Dict[str, Any], Optional[_CleanupCallable]]  # noqa: E501
 
 
-@six.add_metaclass(abc.ABCMeta)
-class AutomotiveTestCaseABC:
+class AutomotiveTestCaseABC(metaclass=abc.ABCMeta):
     """
     Base class for "TestCase" objects. In automotive scanners, these TestCase
     objects are used for individual tasks, for example enumerating over one
     kind of functionality of the protocol. It is also possible, that
     these TestCase objects execute complex tests on an ECU.
     The TestCaseExecuter object has a list of TestCases. The executer
     manipulates a device under test (DUT), to enter a certain state. In this
@@ -207,15 +215,15 @@
         return s + "\n"
 
     def _show_state_information(self, **kwargs):
         # type: (Any) -> str
         completed = [(state, self._state_completed[state])
                      for state in self.scanned_states]
         return make_lined_table(
-            completed, lambda tup: ("Scan state completed", tup[0], tup[1]),
+            completed, lambda x, y: ("Scan state completed", x, y),
             dump=True) or ""
 
     def show(self, dump=False, filtered=True, verbose=False):
         # type: (bool, bool, bool) -> Optional[str]
 
         s = self._show_header()
 
@@ -225,24 +233,22 @@
         if dump:
             return s + "\n"
         else:
             print(s)
             return None
 
 
-@six.add_metaclass(abc.ABCMeta)
-class TestCaseGenerator:
+class TestCaseGenerator(metaclass=abc.ABCMeta):
     @abc.abstractmethod
     def get_generated_test_case(self):
         # type: () -> Optional[AutomotiveTestCaseABC]
         raise NotImplementedError()
 
 
-@six.add_metaclass(abc.ABCMeta)
-class StateGenerator:
+class StateGenerator(metaclass=abc.ABCMeta):
 
     @abc.abstractmethod
     def get_new_edge(self, socket, config):
         # type: (_SocketUnion, AutomotiveTestCaseExecutorConfiguration) -> Optional[_Edge]  # noqa: E501
         raise NotImplementedError
 
     @abc.abstractmethod
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/someip.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/someip.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,27 +3,27 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Sebastian Baar <sebastian.baar@gmx.de>
 # Copyright (c) 2018 Jose Amores
 
 # scapy.contrib.description = Scalable service-Oriented MiddlewarE/IP (SOME/IP)
 # scapy.contrib.status = loads
 
-import ctypes
-import collections
 import struct
 
 from scapy.layers.inet import TCP, UDP
 from scapy.layers.inet6 import IP6Field
 from scapy.compat import raw, orb
 from scapy.config import conf
 from scapy.packet import Packet, Raw, bind_top_down, bind_bottom_up
-from scapy.fields import XShortField, BitEnumField, ConditionalField, \
-    BitField, XBitField, IntField, XByteField, ByteEnumField, \
-    ShortField, X3BytesField, StrLenField, IPField, FieldLenField, \
-    PacketListField, XIntField
+from scapy.fields import (XShortField, ConditionalField,
+                          BitField, XBitField, XByteField, ByteEnumField,
+                          ShortField, X3BytesField, StrLenField, IPField,
+                          FieldLenField, PacketListField, XIntField,
+                          MultipleTypeField, FlagsField, IntField,
+                          XByteEnumField, BitScalingField)
 
 
 class SOMEIP(Packet):
     """ SOME/IP Packet."""
 
     PROTOCOL_VERSION = 0x01
     INTERFACE_VERSION = 0x01
@@ -58,19 +58,25 @@
 
     _OVERALL_LEN_NOPAYLOAD = 16
 
     name = "SOME/IP"
 
     fields_desc = [
         XShortField("srv_id", 0),
-        BitEnumField("sub_id", 0, 1, {0: "METHOD_ID", 1: "EVENT_ID"}),
-        ConditionalField(XBitField("method_id", 0, 15),
-                         lambda pkt: pkt.sub_id == 0),
-        ConditionalField(XBitField("event_id", 0, 15),
-                         lambda pkt: pkt.sub_id == 1),
+        MultipleTypeField(
+            [
+                (XShortField("sub_id", 0),
+                 (lambda pkt: False,
+                  lambda pkt, val: val < 0x8000), "method_id"),
+                (XShortField("sub_id", 0),
+                 (lambda pkt: False,
+                  lambda pkt, val: val >= 0x8000), "event_id"),
+            ],
+            XShortField("sub_id", 0),
+        ),
         IntField("len", None),
         XShortField("client_id", 0),
         XShortField("session_id", 0),
         XByteField("proto_ver", PROTOCOL_VERSION),
         XByteField("iface_ver", INTERFACE_VERSION),
         ByteEnumField("msg_type", TYPE_REQUEST, {
             TYPE_REQUEST: "REQUEST",
@@ -98,22 +104,37 @@
             RET_E_NOT_REACHABLE: "E_NOT_REACHABLE",
             RET_E_TIMEOUT: "E_TIMEOUT",
             RET_E_WRONG_PROTOCOL_V: "E_WRONG_PROTOCOL_VERSION",
             RET_E_WRONG_INTERFACE_V: "E_WRONG_INTERFACE_VERSION",
             RET_E_MALFORMED_MSG: "E_MALFORMED_MESSAGE",
             RET_E_WRONG_MESSAGE_TYPE: "E_WRONG_MESSAGE_TYPE",
         }),
-        ConditionalField(BitField("offset", 0, 28),
-                         lambda pkt: SOMEIP._is_tp(pkt)),
-        ConditionalField(BitField("res", 0, 3),
-                         lambda pkt: SOMEIP._is_tp(pkt)),
-        ConditionalField(BitField("more_seg", 0, 1),
-                         lambda pkt: SOMEIP._is_tp(pkt))
+        ConditionalField(
+            BitScalingField("offset", 0, 28, scaling=16, unit="bytes"),
+            lambda pkt: SOMEIP._is_tp(pkt)),  # noqa: E501
+        ConditionalField(
+            BitField("res", 0, 3),
+            lambda pkt: SOMEIP._is_tp(pkt)),  # noqa: E501
+        ConditionalField(
+            BitField("more_seg", 0, 1),
+            lambda pkt: SOMEIP._is_tp(pkt)),  # noqa: E501
+        ConditionalField(PacketListField(
+            "data", [Raw()], Raw,
+            length_from=lambda pkt: pkt.len - (SOMEIP.LEN_OFFSET_TP if (SOMEIP._is_tp(pkt) and (pkt.len is None or pkt.len >= SOMEIP.LEN_OFFSET_TP)) else SOMEIP.LEN_OFFSET),  # noqa: E501
+            next_cls_cb=lambda pkt, lst, cur, remain:
+                SOMEIP.get_payload_cls_by_srv_id(pkt, lst, cur, remain)),
+            lambda pkt: SOMEIP._is_tp(pkt))  # noqa: E501
     ]
 
+    payload_cls_by_srv_id = dict()  # To be customized
+
+    @staticmethod
+    def get_payload_cls_by_srv_id(pkt, lst, cur, remain):
+        return SOMEIP.payload_cls_by_srv_id.get(pkt.srv_id, Raw)
+
     def post_build(self, pkt, pay):
         length = self.len
         if length is None:
             if SOMEIP._is_tp(self):
                 length = SOMEIP.LEN_OFFSET_TP + len(pay)
             else:
                 length = SOMEIP.LEN_OFFSET + len(pay)
@@ -131,22 +152,26 @@
                 return 0
             return self.payload.answers(other.payload)
         return 0
 
     @staticmethod
     def _is_tp(pkt):
         """Returns true if pkt is using SOMEIP-TP, else returns false."""
+        if isinstance(pkt, Packet):
+            return pkt.msg_type & 0x20
+        else:
+            return pkt[15] & 0x20
 
-        tp = [SOMEIP.TYPE_TP_REQUEST, SOMEIP.TYPE_TP_REQUEST_NO_RET,
-              SOMEIP.TYPE_TP_NOTIFICATION, SOMEIP.TYPE_TP_RESPONSE,
-              SOMEIP.TYPE_TP_ERROR]
+    @staticmethod
+    def _is_sd(pkt):
+        """Returns true if pkt is using SOMEIP-SD, else returns false."""
         if isinstance(pkt, Packet):
-            return pkt.msg_type in tp
+            return pkt.srv_id == 0xffff and pkt.sub_id == 0x8100
         else:
-            return pkt[15] in tp
+            return pkt[:4] == b"\xff\xff\x81\x00"
 
     def fragment(self, fragsize=1392):
         """Fragment SOME/IP-TP"""
         fnb = 0
         fl = self
         lst = list()
         while fl.underlayer is not None:
@@ -184,14 +209,15 @@
 
 
 _bind_someip_layers()
 
 
 class _SDPacketBase(Packet):
     """ base class to be used among all SD Packet definitions."""
+
     def extract_padding(self, s):
         return "", s
 
 
 SDENTRY_TYPE_SRV_FINDSERVICE = 0x00
 SDENTRY_TYPE_SRV_OFFERSERVICE = 0x01
 SDENTRY_TYPE_SRV = (SDENTRY_TYPE_SRV_FINDSERVICE,
@@ -201,15 +227,19 @@
 SDENTRY_TYPE_EVTGRP = (SDENTRY_TYPE_EVTGRP_SUBSCRIBE,
                        SDENTRY_TYPE_EVTGRP_SUBSCRIBE_ACK)
 SDENTRY_OVERALL_LEN = 16
 
 
 def _MAKE_SDENTRY_COMMON_FIELDS_DESC(type):
     return [
-        XByteField("type", type),
+        XByteEnumField("type", type, {
+            0: "FindService",
+            1: "OfferService",
+            6: "SubscribeEventgroup",
+            7: "SubscribeEventgroupACK"}),
         XByteField("index_1", 0),
         XByteField("index_2", 0),
         XBitField("n_opt_1", 0, 4),
         XBitField("n_opt_2", 0, 4),
         XShortField("srv_id", 0),
         XShortField("inst_id", 0),
         XByteField("major_ver", 0),
@@ -284,15 +314,23 @@
 SDOPTION_IP6_SDENDPOINT_TYPE = 0x26
 SDOPTION_IP6_SDENDPOINT_LEN = 0x0015
 
 
 def _MAKE_COMMON_SDOPTION_FIELDS_DESC(type, length=None):
     return [
         ShortField("len", length),
-        XByteField("type", type),
+        XByteEnumField("type", type, {
+            SDOPTION_CFG_TYPE: "Configuration",
+            SDOPTION_LOADBALANCE_TYPE: "LoadBalancing",
+            SDOPTION_IP4_ENDPOINT_TYPE: "IPv4Endpoint",
+            SDOPTION_IP4_MCAST_TYPE: "IPv4MultiCast",
+            SDOPTION_IP4_SDENDPOINT_TYPE: "IPv4SDEndpoint",
+            SDOPTION_IP6_ENDPOINT_TYPE: "IPv6Endpoint",
+            SDOPTION_IP6_MCAST_TYPE: "IPv6MultiCast",
+            SDOPTION_IP6_SDENDPOINT_TYPE: "IPv6SDEndpoint"}),
         XByteField("res_hdr", 0)
     ]
 
 
 def _MAKE_COMMON_IP_SDOPTION_FIELDS_DESC():
     return [
         XByteField("res_tail", 0),
@@ -300,15 +338,15 @@
         ShortField("port", 0)
     ]
 
 
 class SDOption_Config(_SDPacketBase):
     name = "Config Option"
     fields_desc = _MAKE_COMMON_SDOPTION_FIELDS_DESC(SDOPTION_CFG_TYPE) + [
-        StrLenField("cfg_str", "\x00", length_from=lambda pkt: pkt.len - 1)
+        StrLenField("cfg_str", b"\x00", length_from=lambda pkt: pkt.len - 1)
     ]
 
     def post_build(self, pkt, pay):
         if self.len is None:
             length = len(self.cfg_str) + 1  # res_hdr field takes 1 byte
             pkt = struct.pack("!H", length) + pkt[2:]
         return pkt + pay
@@ -416,58 +454,38 @@
 
     NOTE :   when adding 'entries' or 'options', do not use list.append()
         method but create a new list
     e.g. :  p = SD()
             p.option_array = [SDOption_Config(),SDOption_IP6_EndPoint()]
     """
     SOMEIP_MSGID_SRVID = 0xffff
-    SOMEIP_MSGID_SUBID = 0x1
-    SOMEIP_MSGID_EVENTID = 0x100
+    SOMEIP_MSGID_SUBID = 0x8100
     SOMEIP_CLIENT_ID = 0x0000
     SOMEIP_MINIMUM_SESSION_ID = 0x0001
     SOMEIP_PROTO_VER = 0x01
     SOMEIP_IFACE_VER = 0x01
     SOMEIP_MSG_TYPE = SOMEIP.TYPE_NOTIFICATION
     SOMEIP_RETCODE = SOMEIP.RET_E_OK
 
-    _sdFlag = collections.namedtuple('Flag', 'mask offset')
-    FLAGSDEF = {
-        "REBOOT": _sdFlag(mask=0x80, offset=7),
-        "UNICAST": _sdFlag(mask=0x40, offset=6)
-    }
-
     name = "SD"
     fields_desc = [
-        XByteField("flags", 0),
+        FlagsField("flags", 0, 8, [
+            "res0", "res1", "res2", "res3", "res4",
+            "EXPLICIT_INITIAL_DATA_CONTROL", "UNICAST", "REBOOT"]),
         X3BytesField("res", 0),
         FieldLenField("len_entry_array", None,
                       length_of="entry_array", fmt="!I"),
         PacketListField("entry_array", None, _sdentry_class,
                         length_from=lambda pkt: pkt.len_entry_array),
         FieldLenField("len_option_array", None,
                       length_of="option_array", fmt="!I"),
         PacketListField("option_array", None, _sdoption_class,
                         length_from=lambda pkt: pkt.len_option_array)
     ]
 
-    def get_flag(self, name):
-        name = name.upper()
-        if name in self.FLAGSDEF:
-            return ((self.flags & self.FLAGSDEF[name].mask) >>
-                    self.FLAGSDEF[name].offset)
-        else:
-            return None
-
-    def set_flag(self, name, value):
-        name = name.upper()
-        if name in self.FLAGSDEF:
-            self.flags = (self.flags &
-                          (ctypes.c_ubyte(~self.FLAGSDEF[name].mask).value)) \
-                | ((value & 0x01) << self.FLAGSDEF[name].offset)
-
     def set_entryArray(self, entry_list):
         if isinstance(entry_list, list):
             self.entry_array = entry_list
         else:
             self.entry_array = [entry_list]
 
     def set_optionArray(self, option_list):
@@ -478,24 +496,22 @@
 
 
 bind_top_down(SOMEIP, SD,
               srv_id=SD.SOMEIP_MSGID_SRVID,
               sub_id=SD.SOMEIP_MSGID_SUBID,
               client_id=SD.SOMEIP_CLIENT_ID,
               session_id=SD.SOMEIP_MINIMUM_SESSION_ID,
-              event_id=SD.SOMEIP_MSGID_EVENTID,
               proto_ver=SD.SOMEIP_PROTO_VER,
               iface_ver=SD.SOMEIP_IFACE_VER,
               msg_type=SD.SOMEIP_MSG_TYPE,
               retcode=SD.SOMEIP_RETCODE)
 
 bind_bottom_up(SOMEIP, SD,
                srv_id=SD.SOMEIP_MSGID_SRVID,
                sub_id=SD.SOMEIP_MSGID_SUBID,
-               event_id=SD.SOMEIP_MSGID_EVENTID,
                proto_ver=SD.SOMEIP_PROTO_VER,
                iface_ver=SD.SOMEIP_IFACE_VER,
                msg_type=SD.SOMEIP_MSG_TYPE,
                retcode=SD.SOMEIP_RETCODE)
 
 # FIXME: Service Discovery messages shall be transported over UDP
 #        (TR_SOMEIP_00248)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/uds.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/uds.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,46 +2,54 @@
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = Unified Diagnostic Service (UDS)
 # scapy.contrib.status = loads
 
+"""
+UDS
+"""
+
 import struct
-import time
+from collections import defaultdict
 
-from scapy.contrib.automotive import log_automotive
 from scapy.fields import ByteEnumField, StrField, ConditionalField, \
     BitEnumField, BitField, XByteField, FieldListField, \
     XShortField, X3BytesField, XIntField, ByteField, \
     ShortField, ObservableDict, XShortEnumField, XByteEnumField, StrLenField, \
-    FieldLenField, XStrFixedLenField, XStrLenField
-from scapy.packet import Packet, bind_layers, NoPayload
+    FieldLenField, XStrFixedLenField, XStrLenField, FlagsField, PacketListField, \
+    PacketField
+from scapy.packet import Packet, bind_layers, NoPayload, Raw
 from scapy.config import conf
-from scapy.error import log_loading, Scapy_Exception
+from scapy.error import log_loading
 from scapy.utils import PeriodicSenderThread
 from scapy.contrib.isotp import ISOTP
-from scapy.compat import Dict, Union
 
-"""
-UDS
-"""
+# Typing imports
+from typing import (
+    Dict,
+    Union,
+)
 
 try:
     if conf.contribs['UDS']['treat-response-pending-as-answer']:
         pass
 except KeyError:
     log_loading.info("Specify \"conf.contribs['UDS'] = "
                      "{'treat-response-pending-as-answer': True}\" to treat "
                      "a negative response 'requestCorrectlyReceived-"
                      "ResponsePending' as answer of a request. \n"
                      "The default value is False.")
     conf.contribs['UDS'] = {'treat-response-pending-as-answer': False}
 
 
+conf.debug_dissector = True
+
+
 class UDS(ISOTP):
     services = ObservableDict(
         {0x10: 'DiagnosticSessionControl',
          0x11: 'ECUReset',
          0x14: 'ClearDiagnosticInformation',
          0x19: 'ReadDTCInformation',
          0x22: 'ReadDataByIdentifier',
@@ -112,16 +120,16 @@
                 return len(self) <= len(other)
             else:
                 return self.payload.answers(other.payload)
         return False
 
     def hashret(self):
         # type: () -> bytes
-        if self.service == 0x7f:
-            return struct.pack('B', self.requestServiceId)
+        if self.service == 0x7f and len(self) >= 3:
+            return struct.pack('B', bytes(self)[1] & ~0x40)
         return struct.pack('B', self.service & ~0x40)
 
 
 # ########################DSC###################################
 class UDS_DSC(Packet):
     diagnosticSessionTypes = ObservableDict({
         0x00: 'ISOSAEReserved',
@@ -900,14 +908,38 @@
             and other.memorySizeLen == self.memorySizeLen \
             and other.memoryAddressLen == self.memoryAddressLen
 
 
 bind_layers(UDS, UDS_WMBAPR, service=0x7D)
 
 
+# ##########################DTC#####################################
+class DTC(Packet):
+    name = 'Diagnostic Trouble Code'
+    dtc_descriptions = {}  # Customize this dictionary for each individual ECU / OEM
+
+    fields_desc = [
+        BitEnumField("system", 0, 2, {
+            0: "Powertrain",
+            1: "Chassis",
+            2: "Body",
+            3: "Network"}),
+        BitEnumField("type", 0, 2, {
+            0: "Generic",
+            1: "ManufacturerSpecific",
+            2: "Generic",
+            3: "Generic"}),
+        BitField("numeric_value_code", 0, 12),
+        ByteField("additional_information_code", 0),
+    ]
+
+    def extract_padding(self, s):
+        return '', s
+
+
 # #########################CDTCI###################################
 class UDS_CDTCI(Packet):
     name = 'ClearDiagnosticInformation'
     fields_desc = [
         ByteField('groupOfDTCHighByte', 0),
         ByteField('groupOfDTCMiddleByte', 0),
         ByteField('groupOfDTCLowByte', 0),
@@ -949,74 +981,164 @@
         16: 'reportMirrorMemoryDTCExtendedDataRecordByDTCNumber',
         17: 'reportNumberOfMirrorMemoryDTCByStatusMask',
         18: 'reportNumberOfEmissionsRelatedOBDDTCByStatusMask',
         19: 'reportEmissionsRelatedOBDDTCByStatusMask',
         20: 'reportDTCFaultDetectionCounter',
         21: 'reportDTCWithPermanentStatus'
     }
+    dtcStatus = {
+        1: 'TestFailed',
+        2: 'TestFailedThisOperationCycle',
+        4: 'PendingDTC',
+        8: 'ConfirmedDTC',
+        16: 'TestNotCompletedSinceLastClear',
+        32: 'TestFailedSinceLastClear',
+        64: 'TestNotCompletedThisOperationCycle',
+        128: 'WarningIndicatorRequested'
+    }
+    dtcStatusMask = {
+        1: 'ActiveDTCs',
+        4: 'PendingDTCs',
+        8: 'ConfirmedOrStoredDTCs',
+        255: 'AllRecordDTCs'
+    }
+    dtcSeverityMask = {
+        # 0: 'NoSeverityInformation',
+        1: 'NoClassInformation',
+        2: 'WWH-OBDClassA',
+        4: 'WWH-OBDClassB1',
+        8: 'WWH-OBDClassB2',
+        16: 'WWH-OBDClassC',
+        32: 'MaintenanceRequired',
+        64: 'CheckAtNextHalt',
+        128: 'CheckImmediately'
+    }
     name = 'ReadDTCInformation'
     fields_desc = [
         ByteEnumField('reportType', 0, reportTypes),
-        ConditionalField(ByteField('DTCSeverityMask', 0),
+        ConditionalField(FlagsField('DTCSeverityMask', 0, 8, dtcSeverityMask),
                          lambda pkt: pkt.reportType in [0x07, 0x08]),
-        ConditionalField(XByteField('DTCStatusMask', 0),
+        ConditionalField(FlagsField('DTCStatusMask', 0, 8, dtcStatusMask),
                          lambda pkt: pkt.reportType in [
                              0x01, 0x02, 0x07, 0x08, 0x0f, 0x11, 0x12, 0x13]),
-        ConditionalField(ByteField('DTCHighByte', 0),
-                         lambda pkt: pkt.reportType in [0x3, 0x4, 0x6,
-                                                        0x10, 0x09]),
-        ConditionalField(ByteField('DTCMiddleByte', 0),
-                         lambda pkt: pkt.reportType in [0x3, 0x4, 0x6,
-                                                        0x10, 0x09]),
-        ConditionalField(ByteField('DTCLowByte', 0),
+        ConditionalField(PacketField("dtc", None, pkt_cls=DTC),
                          lambda pkt: pkt.reportType in [0x3, 0x4, 0x6,
                                                         0x10, 0x09]),
         ConditionalField(ByteField('DTCSnapshotRecordNumber', 0),
                          lambda pkt: pkt.reportType in [0x3, 0x4, 0x5]),
         ConditionalField(ByteField('DTCExtendedDataRecordNumber', 0),
                          lambda pkt: pkt.reportType in [0x6, 0x10])
     ]
 
 
 bind_layers(UDS, UDS_RDTCI, service=0x19)
 
 
+class DTCAndStatusRecord(Packet):
+    name = 'DTC and status record'
+    fields_desc = [
+        PacketField("dtc", None, pkt_cls=DTC),
+        FlagsField("status", 0, 8, UDS_RDTCI.dtcStatus)
+    ]
+
+    def extract_padding(self, s):
+        return '', s
+
+
+class DTCExtendedData(Packet):
+    name = 'Diagnostic Trouble Code Extended Data'
+    dataTypes = ObservableDict()
+    fields_desc = [
+        ByteEnumField("data_type", 0, dataTypes),
+        XByteField("record", 0)
+    ]
+
+    def extract_padding(self, s):
+        return '', s
+
+
+class DTCExtendedDataRecord(Packet):
+    fields_desc = [
+        PacketField("dtcAndStatus", None, pkt_cls=DTCAndStatusRecord),
+        PacketListField("extendedData", None, pkt_cls=DTCExtendedData)
+    ]
+
+
+class DTCSnapshot(Packet):
+    identifiers = defaultdict(list)  # for later extension
+
+    @staticmethod
+    def next_identifier_cb(pkt, lst, cur, remain):
+        return Raw
+
+    fields_desc = [
+        ByteField("record_number", 0),
+        ByteField("record_number_of_identifiers", 0),
+        PacketListField(
+            "snapshotData", None,
+            next_cls_cb=lambda pkt, lst, cur, remain: DTCSnapshot.next_identifier_cb(
+                pkt, lst, cur, remain))
+    ]
+
+    def extract_padding(self, s):
+        return '', s
+
+
+class DTCSnapshotRecord(Packet):
+    fields_desc = [
+        PacketField("dtcAndStatus", None, pkt_cls=DTCAndStatusRecord),
+        PacketListField("snapshots", None, pkt_cls=DTCSnapshot)
+    ]
+
+
 class UDS_RDTCIPR(Packet):
     name = 'ReadDTCInformationPositiveResponse'
     fields_desc = [
         ByteEnumField('reportType', 0, UDS_RDTCI.reportTypes),
-        ConditionalField(XByteField('DTCStatusAvailabilityMask', 0),
-                         lambda pkt: pkt.reportType in [0x01, 0x07, 0x11,
-                                                        0x12, 0x02, 0x0A,
-                                                        0x0B, 0x0C, 0x0D,
-                                                        0x0E, 0x0F, 0x13,
-                                                        0x15]),
+        ConditionalField(
+            FlagsField('DTCStatusAvailabilityMask', 0, 8, UDS_RDTCI.dtcStatus),
+            lambda pkt: pkt.reportType in [0x01, 0x07, 0x11, 0x12, 0x02, 0x0A,
+                                           0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x13,
+                                           0x15]),
         ConditionalField(ByteEnumField('DTCFormatIdentifier', 0,
                                        {0: 'ISO15031-6DTCFormat',
                                         1: 'UDS-1DTCFormat',
                                         2: 'SAEJ1939-73DTCFormat',
                                         3: 'ISO11992-4DTCFormat'}),
                          lambda pkt: pkt.reportType in [0x01, 0x07,
                                                         0x11, 0x12]),
         ConditionalField(ShortField('DTCCount', 0),
                          lambda pkt: pkt.reportType in [0x01, 0x07,
                                                         0x11, 0x12]),
-        ConditionalField(StrField('DTCAndStatusRecord', b""),
+        ConditionalField(PacketListField('DTCAndStatusRecord', None,
+                                         pkt_cls=DTCAndStatusRecord),
                          lambda pkt: pkt.reportType in [0x02, 0x0A, 0x0B,
                                                         0x0C, 0x0D, 0x0E,
                                                         0x0F, 0x13, 0x15]),
         ConditionalField(StrField('dataRecord', b""),
-                         lambda pkt: pkt.reportType in [0x03, 0x04, 0x05,
-                                                        0x06, 0x08, 0x09,
-                                                        0x10, 0x14])
+                         lambda pkt: pkt.reportType in [0x03, 0x08, 0x09,
+                                                        0x10, 0x14]),
+        ConditionalField(PacketField('snapshotRecord', None,
+                                     pkt_cls=DTCSnapshotRecord),
+                         lambda pkt: pkt.reportType in [0x04]),
+        ConditionalField(PacketField('extendedDataRecord', None,
+                                     pkt_cls=DTCExtendedDataRecord),
+                         lambda pkt: pkt.reportType in [0x06])
     ]
 
     def answers(self, other):
-        return isinstance(other, UDS_RDTCI) \
-            and other.reportType == self.reportType
+        if not isinstance(other, UDS_RDTCI):
+            return False
+        if not other.reportType == self.reportType:
+            return False
+        if self.reportType == 0x06:
+            return other.dtc == self.extendedDataRecord.dtcAndStatus.dtc
+        if self.reportType == 0x04:
+            return other.dtc == self.snapshotRecord.dtcAndStatus.dtc
+        return True
 
 
 bind_layers(UDS, UDS_RDTCIPR, service=0x59)
 
 
 # #########################RC###################################
 class UDS_RC(Packet):
@@ -1252,61 +1374,57 @@
     fields_desc = [
         XByteEnumField('modeOfOperation', 0, UDS_RFT.modeOfOperations),
         ConditionalField(FieldLenField('lengthFormatIdentifier', None,
                                        length_of='maxNumberOfBlockLength',
                                        fmt='B'),
                          lambda p: p.modeOfOperation != 2),
         ConditionalField(StrLenField('maxNumberOfBlockLength', b"",
-                         length_from=lambda p: p.lengthFormatIdentifier),
+                                     length_from=lambda p: p.lengthFormatIdentifier),
                          lambda p: p.modeOfOperation != 2),
         ConditionalField(BitField('compressionMethod', 0, 4),
                          lambda p: p.modeOfOperation != 0x02),
         ConditionalField(BitField('encryptingMethod', 0, 4),
                          lambda p: p.modeOfOperation != 0x02),
         ConditionalField(FieldLenField('fileSizeOrDirInfoParameterLength',
-                         None,
-                         length_of='fileSizeUncompressedOrDirInfoLength'),
+                                       None,
+                                       length_of='fileSizeUncompressedOrDirInfoLength'),
                          lambda p: p.modeOfOperation not in [1, 2, 3]),
         ConditionalField(StrLenField('fileSizeUncompressedOrDirInfoLength',
                                      b"",
                                      length_from=lambda p:
                                      p.fileSizeOrDirInfoParameterLength),
                          lambda p: p.modeOfOperation not in [1, 2, 3]),
         ConditionalField(StrLenField('fileSizeCompressed', b"",
-                         length_from=lambda p:
-                         p.fileSizeOrDirInfoParameterLength),
+                                     length_from=lambda p:
+                                     p.fileSizeOrDirInfoParameterLength),
                          lambda p: p.modeOfOperation not in [1, 2, 3, 5]),
     ]
 
     def answers(self, other):
         return isinstance(other, UDS_RFT)
 
 
 bind_layers(UDS, UDS_RFTPR, service=0x78)
 
 
 # #########################IOCBI###################################
 class UDS_IOCBI(Packet):
     name = 'InputOutputControlByIdentifier'
-    dataIdentifiers = ObservableDict()
     fields_desc = [
-        XShortEnumField('dataIdentifier', 0, dataIdentifiers),
-        ByteField('controlOptionRecord', 0),
-        StrField('controlEnableMaskRecord', b"", fmt="B")
+        XShortEnumField('dataIdentifier', 0, UDS_RDBI.dataIdentifiers),
     ]
 
 
 bind_layers(UDS, UDS_IOCBI, service=0x2F)
 
 
 class UDS_IOCBIPR(Packet):
     name = 'InputOutputControlByIdentifierPositiveResponse'
     fields_desc = [
-        XShortField('dataIdentifier', 0),
-        StrField('controlStatusRecord', b"", fmt="B")
+        XShortEnumField('dataIdentifier', 0, UDS_RDBI.dataIdentifiers),
     ]
 
     def answers(self, other):
         return isinstance(other, UDS_IOCBI) \
             and other.dataIdentifier == self.dataIdentifier
 
 
@@ -1327,14 +1445,15 @@
         0x22: 'conditionsNotCorrect',
         0x23: 'ISOSAEReserved',
         0x24: 'requestSequenceError',
         0x25: 'noResponseFromSubnetComponent',
         0x26: 'failurePreventsExecutionOfRequestedAction',
         0x31: 'requestOutOfRange',
         0x33: 'securityAccessDenied',
+        0x34: 'authenticationRequired',
         0x35: 'invalidKey',
         0x36: 'exceedNumberOfAttempts',
         0x37: 'requiredTimeDelayNotExpired',
         0x3A: 'secureDataVerificationFailed',
         0x70: 'uploadDownloadNotAccepted',
         0x71: 'transferDataSuspended',
         0x72: 'generalProgrammingFailure',
@@ -1380,30 +1499,16 @@
 
 # ##################################################################
 # ######################## UTILS ###################################
 # ##################################################################
 
 
 class UDS_TesterPresentSender(PeriodicSenderThread):
-    def __init__(self, sock, pkt=UDS() / UDS_TP(), interval=2):
+    def __init__(self, sock, pkt=UDS() / UDS_TP(subFunction=0x80), interval=2):
         """ Thread to send TesterPresent messages packets periodically
 
         Args:
             sock: socket where packet is sent periodically
             pkt: packet to send
             interval: interval between two packets
         """
         PeriodicSenderThread.__init__(self, sock, pkt, interval)
-
-    def run(self):
-        # type: () -> None
-        while not self._stopped.is_set() and not self._socket.closed:
-            for p in self._pkts:
-                try:
-                    self._socket.sr1(p, timeout=0.3, verbose=False)
-                except (OSError, ValueError, Scapy_Exception) as e:
-                    log_automotive.exception(
-                        "Exception in TesterPresentSender: %s", e)
-                    break
-                time.sleep(self._interval)
-                if self._stopped.is_set() or self._socket.closed:
-                    break
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/uds_ecu_states.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/uds_ecu_states.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/uds_logging.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/uds_logging.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,17 +10,21 @@
     UDS_CCPR, UDS_TPPR, UDS_DSC, UDS_ER, UDS_RDPR, UDS_TDPR, UDS_RD, UDS_TD, \
     UDS_CC, UDS_NR, UDS_SA, UDS_RDBIPR, UDS_LC, UDS_RC, UDS_TP, UDS_RU, \
     UDS_IOCBIPR, UDS_WDBIPR, UDS_CDTCIPR, UDS_CDTCI, UDS_RDTCIPR, \
     UDS_RDTCI, UDS_RMBAPR, UDS_WMBAPR, UDS_WMBA, UDS_LCPR, UDS_RCPR, UDS_RFT, \
     UDS_RTE, UDS_RTEPR, UDS_RFTPR, UDS_IOCBI, UDS_RDBI, UDS_RMBA, UDS_WDBI, \
     UDS_CDTCS, UDS_CDTCSPR, UDS_SDT, UDS_SDTPR, UDS_RUPR
 from scapy.packet import Packet
-from scapy.compat import Tuple, Any
 from scapy.contrib.automotive.ecu import Ecu
 
+from typing import (
+    Any,
+    Tuple,
+)
+
 
 @Ecu.extend_pkt_with_logging(UDS_DSC)
 def UDS_DSC_get_log(self):
     # type: (Packet) -> Tuple[str, Any]
     return self.sprintf("%UDS.service%"), \
         self.sprintf("%UDS_DSC.diagnosticSessionType%")
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/uds_scan.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/uds_scan.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,29 +2,27 @@
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 
 # scapy.contrib.description = UDS AutomotiveTestCaseExecutor
 # scapy.contrib.status = loads
 
+from abc import ABC
 import struct
 import random
 import time
 import itertools
 import copy
 import inspect
 
 from collections import defaultdict
-from typing import Sequence
 
-from scapy.compat import Dict, Optional, List, Type, Any, Iterable, \
-    cast, Union, NamedTuple, orb, Set
+from scapy.compat import orb
 from scapy.contrib.automotive import log_automotive
 from scapy.packet import Raw, Packet
-import scapy.libs.six as six
 from scapy.error import Scapy_Exception
 from scapy.contrib.automotive.uds import UDS, UDS_NR, UDS_DSC, UDS_TP, \
     UDS_RDBI, UDS_WDBI, UDS_SA, UDS_RC, UDS_IOCBI, UDS_RMBA, UDS_ER, \
     UDS_TesterPresentSender, UDS_CC, UDS_RDBPI, UDS_RD, UDS_TD
 
 from scapy.contrib.automotive.ecu import EcuState
 from scapy.contrib.automotive.scanner.enumerator import ServiceEnumerator, \
@@ -37,20 +35,29 @@
 from scapy.contrib.automotive.scanner.graph import _Edge
 from scapy.contrib.automotive.scanner.staged_test_case import StagedAutomotiveTestCase  # noqa: E501
 from scapy.contrib.automotive.scanner.executor import AutomotiveTestCaseExecutor  # noqa: E501
 
 # TODO: Refactor this import
 from scapy.contrib.automotive.uds_ecu_states import *  # noqa: F401, F403
 
-if six.PY34:
-    from abc import ABC
-else:
-    from abc import ABCMeta
+# typing imports
+from typing import (
+    Dict,
+    Optional,
+    NamedTuple,
+    List,
+    Type,
+    Any,
+    Iterable,
+    cast,
+    Union,
+    Set,
+    Sequence,
+)
 
-    ABC = ABCMeta('ABC', (), {})  # type: ignore
 
 # Definition outside the class UDS_RMBASequentialEnumerator
 # to allow pickling
 _PointOfInterest = NamedTuple("_PointOfInterest", [
     ("memory_address", int),
     ("direction", bool),
     # True = increasing / upward, False = decreasing / downward  # noqa: E501
@@ -173,15 +180,15 @@
         UDS_TPEnumerator.enter(sock, conf, kwargs)
         # Wait 5 seconds, since some ECUs require time
         # to switch to the bootloader
         try:
             delay = conf[UDS_DSCEnumerator.__name__]["delay_state_change"]
         except KeyError:
             delay = 5
-        time.sleep(delay)
+        conf.stop_event.wait(delay)
         state_changed = UDS_DSCEnumerator.enter_state(
             sock, conf, kwargs["req"])
         if not state_changed:
             UDS_TPEnumerator.cleanup(sock, conf)
         return state_changed
 
     def get_transition_function(self, socket, edge):
@@ -210,26 +217,27 @@
               ):  # type: (...) -> bool
         if configuration.unittest:
             configuration["tps"] = None
             socket.sr1(UDS() / UDS_TP(), timeout=0.1, verbose=False)
             return True
 
         UDS_TPEnumerator.cleanup(socket, configuration)
-        configuration["tps"] = UDS_TesterPresentSender(socket)
+        configuration["tps"] = UDS_TesterPresentSender(socket, interval=3)
         configuration["tps"].start()
         return True
 
     @staticmethod
     def cleanup(_, configuration):
         # type: (_SocketUnion, AutomotiveTestCaseExecutorConfiguration) -> bool
         try:
             configuration["tps"].stop()
             configuration["tps"] = None
-        except (AttributeError, KeyError) as e:
-            log_automotive.debug("Cleanup TP-Sender Error: %s", e)
+        except (AttributeError, KeyError):
+            pass
+            # log_automotive.debug("Cleanup TP-Sender Error: %s", e)
         return True
 
     def get_transition_function(self, socket, edge):
         # type: (_SocketUnion, _Edge) -> Optional[_TransitionTuple]
         return self.enter, {"desc": "TP"}, self.cleanup
 
 
@@ -294,24 +302,43 @@
                 tup[1].periodicDataIdentifier,
                 tup[1].sprintf("%UDS_RDBPI.periodicDataIdentifier%"))
 
 
 class UDS_ServiceEnumerator(UDS_Enumerator):
     _description = "Available services and negative response per state"
     _supported_kwargs = copy.copy(ServiceEnumerator._supported_kwargs)
+    _supported_kwargs.update({
+        "request_length": (int, lambda x: 1 <= x < 5)
+    })
     _supported_kwargs["scan_range"] = \
         ((list, tuple, range), lambda x: max(x) < 0x100 and min(x) >= 0)
 
+    _supported_kwargs_doc = ServiceEnumerator._supported_kwargs_doc + """
+        :param int request_length: Specifies the maximum length of arequest
+                                   packet. The enumerator will generate all
+                                   packets from a length of 1 (UDS Service
+                                   ID only) up to the specified
+                                   `request_length`."""
+
+    def execute(self, socket, state, **kwargs):
+        # type: (_SocketUnion, EcuState, Any) -> None
+        super(UDS_ServiceEnumerator, self).execute(socket, state, **kwargs)
+
+    execute.__doc__ = _supported_kwargs_doc
+
     def _get_initial_requests(self, **kwargs):
         # type: (Any) -> Iterable[Packet]
         # Only generate services with unset positive response bit (0x40) as
         # default scan_range
         scan_range = kwargs.pop("scan_range",
                                 (x for x in range(0x100) if not x & 0x40))
-        return (UDS(service=x) for x in scan_range)
+        request_length = kwargs.pop("request_length", 1)
+        return itertools.chain.from_iterable(
+            ([UDS(service=x) / Raw(b"\x00" * req_len)
+              for req_len in range(request_length)] for x in scan_range))
 
     def _evaluate_response(self,
                            state,  # type: EcuState
                            request,  # type: Packet
                            response,  # type: Optional[Packet]
                            **kwargs  # type: Optional[Dict[str, Any]]
                            ):  # type: (...) -> bool
@@ -324,15 +351,16 @@
         kwargs["exit_if_service_not_supported"] = False  # type: ignore
 
         return super(UDS_ServiceEnumerator, self)._evaluate_response(
             state, request, response, **kwargs)
 
     def _get_table_entry_y(self, tup):
         # type: (_AutomotiveTestCaseScanResult) -> str
-        return "0x%02x: %s" % (tup[1].service, tup[1].sprintf("%UDS.service%"))
+        return "0x%02x-%d: %s" % (
+            tup[1].service, len(tup[1]), tup[1].sprintf("%UDS.service%"))
 
 
 class UDS_RDBIEnumerator(UDS_Enumerator):
     _description = "Readable data identifier per state"
     _supported_kwargs = copy.copy(ServiceEnumerator._supported_kwargs)
     _supported_kwargs["scan_range"] = \
         ((list, tuple, range), lambda x: max(x) < 0x10000 and min(x) >= 0)
@@ -545,15 +573,15 @@
     def pre_execute(self, socket, state, global_configuration):
         # type: (_SocketUnion, EcuState, AutomotiveTestCaseExecutorConfiguration) -> None  # noqa: E501
         if cast(ServiceEnumerator, self)._retry_pkt[state]:
             # this is a retry execute. Wait much longer than usual because
             # a required time delay not expired could have been received
             # on the previous attempt
             if not global_configuration.unittest:
-                time.sleep(11)
+                global_configuration.stop_event.wait(11)
 
     def _evaluate_retry(self,
                         state,  # type: EcuState
                         request,  # type: Packet
                         response,  # type: Packet
                         **kwargs  # type: Optional[Dict[str, Any]]
                         ):  # type: (...) -> bool
@@ -700,18 +728,15 @@
             raise e
 
         return self.evaluate_security_access_response(
             res, seed_pkt, key_pkt)
 
     def transition_function(self, sock, _, kwargs):
         # type: (_SocketUnion, AutomotiveTestCaseExecutorConfiguration, Dict[str, Any]) -> bool  # noqa: E501
-        if six.PY3:
-            spec = inspect.getfullargspec(self.get_security_access)
-        else:
-            spec = inspect.getargspec(self.get_security_access)
+        spec = inspect.getfullargspec(self.get_security_access)
 
         func_kwargs = {k: kwargs[k] for k in spec.args if k in kwargs.keys()}
         return self.get_security_access(sock, **func_kwargs)
 
     def get_new_edge(self, socket, config):
         # type: (_SocketUnion, AutomotiveTestCaseExecutorConfiguration) -> Optional[_Edge]  # noqa: E501
         last_resp = self._results[-1].resp
@@ -844,15 +869,15 @@
 
     def _get_table_entry_y(self, tup):
         # type: (_AutomotiveTestCaseScanResult) -> str
         resp = tup[2]
         if resp is not None:
             return "0x%04x: %s" % \
                    (tup[1].dataIdentifier,
-                    resp.controlStatusRecord)
+                    repr(resp.payload))
         else:
             return "0x%04x: No response" % tup[1].dataIdentifier
 
 
 class UDS_RMBAEnumeratorABC(UDS_Enumerator):
     _description = "Readable Memory Addresses " \
                    "and negative response per state"
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/volkswagen/definitions.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/volkswagen/definitions.py`

 * *Files 0% similar despite different names*

```diff
@@ -3151,24 +3151,24 @@
 UDS_RDBI.dataIdentifiers[0xf1b5] = "Busmaster_description"
 UDS_RDBI.dataIdentifiers[0xf1b6] = "System_identification"
 UDS_RDBI.dataIdentifiers[0xf1b7] = "Gateway_component_list_ECU_node_address"
 UDS_RDBI.dataIdentifiers[0xf1d5] = "FDS_project_data"
 UDS_RDBI.dataIdentifiers[0xf1df] = "ECU Programming Information"
 
 
-UDS_RC.routineControlTypes[0x0202] = "Check Memory"
-UDS_RC.routineControlTypes[0x0203] = "Check Programming Preconditions"
-UDS_RC.routineControlTypes[0x0317] = "Reset of Adaption Values"
-UDS_RC.routineControlTypes[0x0366] = "Reset of all Adaptions"
-UDS_RC.routineControlTypes[0x03e7] = "Reset to Factory Settings"
-UDS_RC.routineControlTypes[0x045a] = "Clear user defined DTC information"
-UDS_RC.routineControlTypes[0x0544] = "Verify partial software checksum"
-UDS_RC.routineControlTypes[0x0594] = "Check upload preconditions"
-UDS_RC.routineControlTypes[0xff00] = "Erase Memory"
-UDS_RC.routineControlTypes[0xff01] = "Check Programming Dependencies"
+UDS_RC.routineControlIdentifiers[0x0202] = "Check Memory"
+UDS_RC.routineControlIdentifiers[0x0203] = "Check Programming Preconditions"
+UDS_RC.routineControlIdentifiers[0x0317] = "Reset of Adaption Values"
+UDS_RC.routineControlIdentifiers[0x0366] = "Reset of all Adaptions"
+UDS_RC.routineControlIdentifiers[0x03e7] = "Reset to Factory Settings"
+UDS_RC.routineControlIdentifiers[0x045a] = "Clear user defined DTC information"
+UDS_RC.routineControlIdentifiers[0x0544] = "Verify partial software checksum"
+UDS_RC.routineControlIdentifiers[0x0594] = "Check upload preconditions"
+UDS_RC.routineControlIdentifiers[0xff00] = "Erase Memory"
+UDS_RC.routineControlIdentifiers[0xff01] = "Check Programming Dependencies"
 
 
 UDS_RD.dataFormatIdentifiers[0x0000] = "Uncompressed"
 UDS_RD.dataFormatIdentifiers[0x0001] = "Compression Method 1"
 UDS_RD.dataFormatIdentifiers[0x0002] = "Compression Method 2"
 UDS_RD.dataFormatIdentifiers[0x0003] = "Compression Method 3"
 UDS_RD.dataFormatIdentifiers[0x0004] = "Compression Method 4"
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/xcp/cto_commands_master.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/xcp/cto_commands_master.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/xcp/cto_commands_slave.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/xcp/cto_commands_slave.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/xcp/scanner.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/xcp/scanner.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,25 +3,32 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Tabea Spahn <tabea.spahn@e-mundo.de>
 
 # scapy.contrib.description = XCPScanner
 # scapy.contrib.status = loads
 import logging
 from collections import namedtuple
-from scapy.compat import Optional, List, Type, Iterator
 
 from scapy.config import conf
 from scapy.contrib.automotive import log_automotive
 from scapy.contrib.automotive.xcp.cto_commands_master import \
     TransportLayerCmd, TransportLayerCmdGetSlaveId, Connect
 from scapy.contrib.automotive.xcp.cto_commands_slave import \
     ConnectPositiveResponse, TransportLayerCmdGetSlaveIdResponse
 from scapy.contrib.automotive.xcp.xcp import CTORequest, XCPOnCAN
 from scapy.contrib.cansocket_native import CANSocket
 
+# Typing imports
+from typing import (
+    Optional,
+    List,
+    Type,
+    Iterator,
+)
+
 XCPScannerResult = namedtuple('XCPScannerResult', 'request_id response_id')
 
 
 class XCPOnCANScanner:
     """
     Scans for XCP Slave on CAN
     """
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/xcp/utils.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/xcp/utils.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/automotive/xcp/xcp.py` & `scapy-2.6.0rc1/scapy/contrib/automotive/xcp/xcp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/avs.py` & `scapy-2.6.0rc1/scapy/contrib/avs.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/bgp.py` & `scapy-2.6.0rc1/scapy/contrib/bgp.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,14 @@
 # scapy.contrib.description = BGP v0.1
 # scapy.contrib.status = loads
 
 """
 BGP (Border Gateway Protocol).
 """
 
-from __future__ import absolute_import
 import struct
 import re
 import socket
 
 from scapy import pton_ntop
 from scapy.packet import Packet, Packet_metaclass, bind_layers
 from scapy.fields import (Field, BitField, BitEnumField, XBitField, ByteField,
@@ -24,15 +23,14 @@
                           IPField, FlagsField, ConditionalField,
                           MultiEnumField)
 from scapy.layers.inet import TCP
 from scapy.layers.inet6 import IP6Field
 from scapy.config import conf, ConfClass
 from scapy.compat import orb, chb
 from scapy.error import log_runtime
-import scapy.libs.six as six
 
 
 #
 # Module configuration
 #
 
 
@@ -631,15 +629,15 @@
         return newclass
 
 
 class _BGPCapability_metaclass(_BGPCap_metaclass, Packet_metaclass):
     pass
 
 
-class BGPCapability(six.with_metaclass(_BGPCapability_metaclass, Packet)):
+class BGPCapability(Packet, metaclass=_BGPCapability_metaclass):
     """
     Generic BGP capability.
     """
 
     @classmethod
     def dispatch_hook(cls, _pkt=None, *args, **kargs):
         """
@@ -1040,14 +1038,15 @@
     23: "Tunnel Encapsulation Attribute",  # RFC 5512
     24: "Traffic Engineering",  # RFC 5543
     25: "IPv6 Address Specific Extended Community",  # RFC 5701
     26: "AIGP",  # RFC 7311
     27: "PE Distinguisher Labels",  # RFC 6514
     28: "BGP Entropy Label Capability Attribute (deprecated)",  # RFC 6790, RFC 7447  # noqa: E501
     29: "BGP-LS Attribute",  # RFC 7752
+    32: "LARGE_COMMUNITY",  # RFC 8092, RFC 8195
     40: "BGP Prefix-SID",  # (TEMPORARY - registered 2015-09-30, expires 2016-09-30)  # noqa: E501
     # draft-ietf-idr-bgp-prefix-sid
     128: "ATTR_SET",  # RFC 6368
     255: "Reserved for development"
 }
 
 # http://www.iana.org/assignments/bgp-parameters/bgp-parameters.xml
@@ -1077,14 +1076,15 @@
     23: 0xc0,   # Tunnel Encapsulation (RFC 5512)
     24: 0x80,   # Traffic Engineering (RFC 5543)
     25: 0xc0,   # IPv6 Address Specific Extended Community (RFC 5701)
     26: 0x80,   # AIGP (RFC 7311)
     27: 0xc0,   # PE Distinguisher Labels (RFC 6514)
     28: 0xc0,   # BGP Entropy Label Capability Attribute
     29: 0x80,   # BGP-LS Attribute
+    32: 0xc0,   # LARGE_COMMUNITY
     40: 0xc0,   # BGP Prefix-SID
     128: 0xc0   # ATTR_SET (RFC 6368)
 }
 
 
 class BGPPathAttrPacketListField(PacketListField):
     """
@@ -1991,17 +1991,44 @@
             segment_len = len(self.segment_value)
             p = p[:1] + chb(segment_len) + p[2:]
 
         return p + pay
 
 
 #
+# LARGE_COMMUNITY
+#
+
+class BGPLargeCommunitySegment(Packet):
+    """
+    Provides an implementation for LARGE_COMMUNITY segments
+    which holds 3*4 bytes integers.
+    """
+
+    fields_desc = [
+        IntField("global_administrator", None),
+        IntField("local_data_part1", None),
+        IntField("local_data_part2", None)
+    ]
+
+
+class BGPPALargeCommunity(Packet):
+    """
+    Provides an implementation of the LARGE_COMMUNITY attribute.
+    References: RFC 8092, RFC 8195
+    """
+
+    name = "LARGE_COMMUNITY"
+    fields_desc = [PacketListField("segments", [], BGPLargeCommunitySegment)]
+
+#
 # AS4_AGGREGATOR
 #
 
+
 class BGPPAAS4Aggregator(Packet):
     """
     Provides an implementation of the AS4_AGGREGATOR attribute
     "value part".
     References: RFC 4893
     """
 
@@ -2021,15 +2048,16 @@
     0x08: "BGPPACommunity",
     0x09: "BGPPAOriginatorID",
     0x0A: "BGPPAClusterList",
     0x0E: "BGPPAMPReachNLRI",
     0x0F: "BGPPAMPUnreachNLRI",
     0x10: "BGPPAExtComms",
     0x11: "BGPPAAS4Path",
-    0x19: "BGPPAIPv6AddressSpecificExtComm"
+    0x19: "BGPPAIPv6AddressSpecificExtComm",
+    0x20: "BGPPALargeCommunity"
 }
 
 
 class _PathAttrPacketField(PacketField):
     """
     PacketField handling path attribute value parts.
     """
@@ -2038,22 +2066,24 @@
         ret = None
         type_code = pkt.type_code
 
         # Reserved
         if type_code == 0 or type_code == 255:
             ret = conf.raw_layer(m)
         # Unassigned
-        elif (type_code >= 30 and type_code <= 39) or\
+        elif (type_code >= 33 and type_code <= 39) or\
             (type_code >= 41 and type_code <= 127) or\
                 (type_code >= 129 and type_code <= 254):
             ret = conf.raw_layer(m)
         # Known path attributes
         else:
             if type_code == 0x02 and not bgp_module_conf.use_2_bytes_asn:
                 ret = BGPPAAS4BytesPath(m)
+            elif type_code == 0x20:
+                ret = BGPPALargeCommunity(m)
             else:
                 ret = _get_cls(
                     _path_attr_objects.get(type_code, conf.raw_layer))(m)
 
         return ret
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/bier.py` & `scapy-2.6.0rc1/scapy/contrib/bier.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/bp.py` & `scapy-2.6.0rc1/scapy/contrib/bp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/cansocket.py` & `scapy-2.6.0rc1/scapy/contrib/cansocket.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,15 +9,14 @@
 """
 CANSocket.
 """
 
 from scapy.error import log_loading
 from scapy.consts import LINUX
 from scapy.config import conf
-import scapy.libs.six as six
 
 PYTHON_CAN = False
 
 try:
     if conf.contribs['CANSocket']['use-python-can']:
         from can import BusABC as can_BusABC    # noqa: F401
         PYTHON_CAN = True
@@ -27,13 +26,13 @@
     log_loading.info("Configuration 'conf.contribs['CANSocket'] not found.")
 
 
 if PYTHON_CAN:
     log_loading.info("Using python-can CANSockets.\nSpecify 'conf.contribs['CANSocket'] = {'use-python-can': False}' to enable native CANSockets.")  # noqa: E501
     from scapy.contrib.cansocket_python_can import (PythonCANSocket, CANSocket)  # noqa: E501 F401
 
-elif LINUX and six.PY3 and not conf.use_pypy:
+elif LINUX and not conf.use_pypy:
     log_loading.info("Using native CANSockets.\nSpecify 'conf.contribs['CANSocket'] = {'use-python-can': True}' to enable python-can CANSockets.")  # noqa: E501
     from scapy.contrib.cansocket_native import (NativeCANSocket, CANSocket)  # noqa: E501 F401
 
 else:
     log_loading.info("No CAN support available. Install python-can or use Linux and python3.")  # noqa: E501
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/cansocket_native.py` & `scapy-2.6.0rc1/scapy/contrib/cansocket_native.py`

 * *Files 9% similar despite different names*

```diff
@@ -11,20 +11,30 @@
 """
 
 import struct
 import socket
 import time
 
 from scapy.config import conf
+from scapy.data import SO_TIMESTAMPNS
 from scapy.supersocket import SuperSocket
-from scapy.error import Scapy_Exception, warning
+from scapy.error import Scapy_Exception, warning, log_runtime
 from scapy.packet import Packet
 from scapy.layers.can import CAN, CAN_MTU, CAN_FD_MTU
-from scapy.arch.linux import get_last_packet_timestamp
-from scapy.compat import List, Dict, Type, Any, Optional, Tuple, raw, cast
+from scapy.compat import raw
+
+from typing import (
+    List,
+    Dict,
+    Type,
+    Any,
+    Optional,
+    Tuple,
+    cast,
+)
 
 conf.contribs['NativeCANSocket'] = {'channel': "can0"}
 
 
 class NativeCANSocket(SuperSocket):
     """Initializes a Linux PF_CAN socket object.
 
@@ -70,14 +80,28 @@
                                 socket.CAN_RAW_RECV_OWN_MSGS,
                                 struct.pack("i", receive_own_messages))
         except Exception as exception:
             raise Scapy_Exception(
                 "Could not modify receive own messages (%s)", exception
             )
 
+        try:
+            # Receive Auxiliary Data (Timestamps)
+            self.ins.setsockopt(
+                socket.SOL_SOCKET,
+                SO_TIMESTAMPNS,
+                1
+            )
+            self.auxdata_available = True
+        except OSError:
+            # Note: Auxiliary Data is only supported since
+            #       Linux 2.6.21
+            msg = "Your Linux Kernel does not support Auxiliary Data!"
+            log_runtime.info(msg)
+
         if self.fd:
             try:
                 self.ins.setsockopt(socket.SOL_CAN_RAW,
                                     socket.CAN_RAW_FD_FRAMES,
                                     1)
                 self.MTU = CAN_FD_MTU
             except Exception as exception:
@@ -104,34 +128,43 @@
         self.ins.bind((self.channel,))
         self.outs = self.ins
 
     def recv_raw(self, x=CAN_MTU):
         # type: (int) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]  # noqa: E501
         """Returns a tuple containing (cls, pkt_data, time)"""
         pkt = None
+        ts = None
         try:
-            pkt = self.ins.recv(self.MTU)
+            pkt, _, ts = self._recv_raw(self.ins, self.MTU)
         except BlockingIOError:  # noqa: F821
             warning("Captured no data, socket in non-blocking mode.")
         except socket.timeout:
             warning("Captured no data, socket read timed out.")
         except OSError:
             # something bad happened (e.g. the interface went down)
             warning("Captured no data.")
 
         # need to change the byte order of the first four bytes,
         # required by the underlying Linux SocketCAN frame format
-        if not conf.contribs['CAN']['swap-bytes'] and pkt is not None:
+        if not conf.contribs['CAN']['swap-bytes'] and pkt:
             pack_fmt = "<I%ds" % (len(pkt) - 4)
             unpack_fmt = ">I%ds" % (len(pkt) - 4)
             pkt = struct.pack(pack_fmt, *struct.unpack(unpack_fmt, pkt))
-        return self.basecls, pkt, get_last_packet_timestamp(self.ins)
+
+        if pkt and ts is None:
+            from scapy.arch.linux import get_last_packet_timestamp
+            ts = get_last_packet_timestamp(self.ins)
+
+        return self.basecls, pkt, ts
 
     def send(self, x):
         # type: (Packet) -> int
+        if x is None:
+            return 0
+
         try:
             x.sent_time = time.time()
         except AttributeError:
             pass
 
         # need to change the byte order of the first four bytes,
         # required by the underlying Linux SocketCAN frame format
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/cansocket_python_can.py` & `scapy-2.6.0rc1/scapy/contrib/cansocket_python_can.py`

 * *Files 11% similar despite different names*

```diff
@@ -12,73 +12,40 @@
 
 import time
 import struct
 import threading
 
 from functools import reduce
 from operator import add
+from collections import deque
 
 from scapy.config import conf
 from scapy.supersocket import SuperSocket
 from scapy.layers.can import CAN
 from scapy.packet import Packet
 from scapy.error import warning
-from scapy.compat import List, Type, Tuple, Dict, Any, \
-    Optional, cast, orb
-from scapy.libs.six.moves import queue
+from typing import (
+    List,
+    Type,
+    Tuple,
+    Dict,
+    Any,
+    Optional,
+    cast,
+)
 
 from can import Message as can_Message
 from can import CanError as can_CanError
 from can import BusABC as can_BusABC
 from can.interface import Bus as can_Bus
 
 __all__ = ["CANSocket", "PythonCANSocket"]
 
 
-class PriotizedCanMessage(object):
-    """Helper object for comparison of CAN messages. If the timestamps of two
-    messages are equal, the counter value of a priority counter, is used
-    for comparison. It's only important that this priority counter always
-    get increased for every CAN message in the receive heapq. This compensates
-    a low resolution of `time.time()` on some operating systems.
-    """
-    def __init__(self, msg, count):
-        # type: (can_Message, int) -> None
-        self.msg = msg
-        self.count = count
-
-    def __eq__(self, other):
-        # type: (Any) -> bool
-        if not isinstance(other, PriotizedCanMessage):
-            return False
-        return self.msg.timestamp == other.msg.timestamp and \
-            self.count == other.count
-
-    def __lt__(self, other):
-        # type: (Any) -> bool
-        if not isinstance(other, PriotizedCanMessage):
-            return False
-        return self.msg.timestamp < other.msg.timestamp or \
-            (self.msg.timestamp == other.msg.timestamp and
-             self.count < other.count)
-
-    def __le__(self, other):
-        # type: (Any) -> bool
-        return self == other or self < other
-
-    def __gt__(self, other):
-        # type: (Any) -> bool
-        return not self <= other
-
-    def __ge__(self, other):
-        # type: (Any) -> bool
-        return not self < other
-
-
-class SocketMapper:
+class SocketMapper(object):
     """Internal Helper class to map a python-can bus object to
     a list of SocketWrapper instances
     """
     def __init__(self, bus, sockets):
         # type: (can_BusABC, List[SocketWrapper]) -> None
         """Initializes the SocketMapper helper class
 
@@ -91,77 +58,88 @@
 
     def mux(self):
         # type: () -> None
         """Multiplexer function. Tries to receive from its python-can bus
         object. If a message is received, this message gets forwarded to
         all receive queues of the SocketWrapper objects.
         """
+        msgs = []
         while True:
-            prio_count = 0
             try:
                 msg = self.bus.recv(timeout=0)
                 if msg is None:
-                    return
-                for sock in self.sockets:
-                    if sock._matches_filters(msg):
-                        prio_count += 1
-                        sock.rx_queue.put(PriotizedCanMessage(msg, prio_count))
+                    break
+                else:
+                    msgs.append(msg)
             except Exception as e:
                 warning("[MUX] python-can exception caught: %s" % e)
 
+        for sock in self.sockets:
+            with sock.lock:
+                for msg in msgs:
+                    if sock._matches_filters(msg):
+                        sock.rx_queue.append(msg)
+
 
 class _SocketsPool(object):
     """Helper class to organize all SocketWrapper and SocketMapper objects"""
     def __init__(self):
         # type: () -> None
         self.pool = dict()  # type: Dict[str, SocketMapper]
         self.pool_mutex = threading.Lock()
+        self.last_call = 0.0
 
-    def internal_send(self, sender, msg, prio=0):
-        # type: (SocketWrapper, can_Message, int) -> None
+    def internal_send(self, sender, msg):
+        # type: (SocketWrapper, can_Message) -> None
         """Internal send function.
 
         A given SocketWrapper wants to send a CAN message. The python-can
         Bus object is obtained from an internal pool of SocketMapper objects.
         The given message is sent on the python-can Bus object and also
         inserted into the message queues of all other SocketWrapper objects
         which are connected to the same python-can bus object
         by the SocketMapper.
 
         :param sender: SocketWrapper which initiated a send of a CAN message
         :param msg: CAN message to be sent
-        :param prio: Priority count for internal heapq
         """
         if sender.name is None:
             raise TypeError("SocketWrapper.name should never be None")
 
         with self.pool_mutex:
             try:
                 mapper = self.pool[sender.name]
                 mapper.bus.send(msg)
                 for sock in mapper.sockets:
                     if sock == sender:
                         continue
                     if not sock._matches_filters(msg):
                         continue
 
-                    sock.rx_queue.put(PriotizedCanMessage(msg, prio))
+                    with sock.lock:
+                        sock.rx_queue.append(msg)
             except KeyError:
                 warning("[SND] Socket %s not found in pool" % sender.name)
             except can_CanError as e:
                 warning("[SND] python-can exception caught: %s" % e)
 
     def multiplex_rx_packets(self):
         # type: () -> None
         """This calls the mux() function of all SocketMapper
         objects in this SocketPool
         """
+        if time.monotonic() - self.last_call < 0.001:
+            # Avoid starvation if multiple threads are doing selects, since
+            # this object is singleton and all python-CAN sockets are using
+            # the same instance and locking the same locks.
+            return
         with self.pool_mutex:
             for t in self.pool.values():
                 t.mux()
+        self.last_call = time.monotonic()
 
     def register(self, socket, *args, **kwargs):
         # type: (SocketWrapper, Tuple[Any, ...], Dict[str, Any]) -> None
         """Registers a SocketWrapper object. Every SocketWrapper describes to
         a python-can bus object. This python-can bus object can only exist
         once. In case this object already exists in this SocketsPool, organized
         by a SocketMapper object, the new SocketWrapper is inserted in the
@@ -169,16 +147,20 @@
         Bus object is created from the provided args and kwargs and inserted,
         encapsulated in a SocketMapper, into this SocketsPool.
 
         :param socket: SocketWrapper object which needs to be registered.
         :param args: Arguments for the python-can Bus object
         :param kwargs: Keyword arguments for the python-can Bus object
         """
-        k = str(kwargs.get("bustype", "unknown_bustype")) + "_" + \
-            str(kwargs.get("channel", "unknown_channel"))
+        if "interface" in kwargs.keys():
+            k = str(kwargs.get("interface", "unknown_interface")) + "_" + \
+                str(kwargs.get("channel", "unknown_channel"))
+        else:
+            k = str(kwargs.get("bustype", "unknown_bustype")) + "_" + \
+                str(kwargs.get("channel", "unknown_channel"))
         with self.pool_mutex:
             if k in self.pool:
                 t = self.pool[k]
                 t.sockets.append(socket)
                 filters = [s.filters for s in t.sockets
                            if s.filters is not None]
                 if filters:
@@ -224,53 +206,59 @@
         arguments and keyword arguments. This SocketWrapper gets automatically
         registered in the SocketsPool.
 
         :param args: Arguments for the python-can Bus object
         :param kwargs: Keyword arguments for the python-can Bus object
         """
         super(SocketWrapper, self).__init__(*args, **kwargs)
-        self.rx_queue = queue.PriorityQueue()  # type: queue.PriorityQueue[PriotizedCanMessage]  # noqa: E501
+        self.lock = threading.Lock()
+        self.rx_queue = deque()  # type: deque[can_Message]
         self.name = None  # type: Optional[str]
-        self.prio_counter = 0
         SocketsPool.register(self, *args, **kwargs)
 
     def _recv_internal(self, timeout):
         # type: (int) -> Tuple[Optional[can_Message], bool]
         """Internal blocking receive method,
         following the ``can_BusABC`` interface of python-can.
 
         This triggers the multiplex function of the general SocketsPool.
 
         :param timeout: Time to wait for a packet
         :return: Returns a tuple of either a can_Message or None and a bool to
                  indicate if filtering was already applied.
         """
-        SocketsPool.multiplex_rx_packets()
-        try:
-            pm = self.rx_queue.get(block=True, timeout=timeout)
-            return pm.msg, True
-        except queue.Empty:
+        if not self.rx_queue:
+            # Early return without locking if it looks like rx_queue is empty
             return None, True
 
+        with self.lock:
+            # It could be that 2 threads are using this same socket, so it's
+            # necessary to check again if the queue was emptied between the
+            # previous check and now
+            if len(self.rx_queue) == 0:
+                return None, True
+            msg = self.rx_queue.popleft()
+            return msg, True
+
     def send(self, msg, timeout=None):
         # type: (can_Message, Optional[int]) -> None
         """Send function, following the ``can_BusABC`` interface of python-can.
 
         :param msg: Message to be sent.
         :param timeout: Not used.
         """
-        self.prio_counter += 1
-        SocketsPool.internal_send(self, msg, self.prio_counter)
+        SocketsPool.internal_send(self, msg)
 
     def shutdown(self):
         # type: () -> None
         """Shutdown function, following the ``can_BusABC`` interface of
         python-can.
         """
         SocketsPool.unregister(self)
+        super().shutdown()
 
 
 class PythonCANSocket(SuperSocket):
     """Initializes a python-can bus object as Scapy PythonCANSocket.
 
     All provided keyword arguments, except *basecls* are forwarded to
     the python-can can_Bus init function. For further details on python-can
@@ -307,17 +295,17 @@
     def send(self, x):
         # type: (Packet) -> int
         bx = bytes(x)
         msg = can_Message(is_remote_frame=x.flags == 0x2,
                           is_extended_id=x.flags == 0x4,
                           is_error_frame=x.flags == 0x1,
                           arbitration_id=x.identifier,
-                          is_fd=orb(bx[5]) & 4 > 0,
-                          error_state_indicator=orb(bx[5]) & 2 > 0,
-                          bitrate_switch=orb(bx[5]) & 1 > 0,
+                          is_fd=bx[5] & 4 > 0,
+                          error_state_indicator=bx[5] & 2 > 0,
+                          bitrate_switch=bx[5] & 1 > 0,
                           dlc=x.length,
                           data=bx[8:])
         msg.timestamp = time.time()
         try:
             x.sent_time = msg.timestamp
         except AttributeError:
             pass
@@ -330,17 +318,27 @@
         """This function is called during sendrecv() routine to select
         the available sockets.
 
         :param sockets: an array of sockets that need to be selected
         :returns: an array of sockets that were selected and
             the function to be called next to get the packets (i.g. recv)
         """
+        ready_sockets = \
+            [s for s in sockets if isinstance(s, PythonCANSocket) and
+             len(s.can_iface.rx_queue)]
+        # checking the queue length without locking might sound
+        # dangerous, but for the purpose of this select, if another
+        # thread is reading the same socket, then even proper locking
+        # wouldn't help
+        if not ready_sockets:
+            # yield this thread to avoid starvation
+            time.sleep(0)
+
         SocketsPool.multiplex_rx_packets()
-        return [s for s in sockets if isinstance(s, PythonCANSocket) and
-                not s.can_iface.rx_queue.empty()]
+        return cast(List[SuperSocket], ready_sockets)
 
     def close(self):
         # type: () -> None
         """Closes this socket"""
         if self.closed:
             return
         super(PythonCANSocket, self).close()
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/carp.py` & `scapy-2.6.0rc1/scapy/contrib/carp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/cdp.py` & `scapy-2.6.0rc1/scapy/contrib/cdp.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,24 @@
 # scapy.contrib.description = Cisco Discovery Protocol (CDP)
 # scapy.contrib.status = loads
 
 """
 Cisco Discovery Protocol (CDP) extension for Scapy
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.packet import Packet, bind_layers
 from scapy.fields import (
     ByteEnumField,
     ByteField,
     FieldLenField,
+    FieldListField,
     FlagsField,
+    IntField,
     IP6Field,
     IPField,
     OUIField,
     PacketListField,
     ShortField,
     StrLenField,
     XByteField,
@@ -60,16 +61,16 @@
                 0x0011: "CDPMsgMTU",
                 0x0012: "CDPMsgTrustBitmap",
                 0x0013: "CDPMsgUntrustedPortCoS",
                 #                 0x0014: "CDPMsgSystemName",
                 #                 0x0015: "CDPMsgSystemOID",
                 0x0016: "CDPMsgMgmtAddr",
                 #                 0x0017: "CDPMsgLocation",
-                0x0019: "CDPMsgUnknown19",
-                #                 0x001a: "CDPPowerAvailable"
+                0x0019: "CDPMsgPowerRequest",
+                0x001a: "CDPMsgPowerAvailable"
                 }
 
 _cdp_tlv_types = {0x0001: "Device ID",
                   0x0002: "Addresses",
                   0x0003: "Port ID",
                   0x0004: "Capabilities",
                   0x0005: "Software Version",
@@ -88,15 +89,15 @@
                   0x0012: "Trust Bitmap",
                   0x0013: "Untrusted Port CoS",
                   0x0014: "System Name",
                   0x0015: "System OID",
                   0x0016: "Management Address",
                   0x0017: "Location",
                   0x0018: "CDP Unknown command (send us a pcap file)",
-                  0x0019: "CDP Unknown command (send us a pcap file)",
+                  0x0019: "Power Request",
                   0x001a: "Power Available"}
 
 
 def _CDPGuessPayloadClass(p, **kargs):
     cls = conf.raw_layer
     if len(p) >= 2:
         t = struct.unpack("!H", p[:2])[0]
@@ -348,17 +349,36 @@
 
 
 class CDPMsgMgmtAddr(CDPMsgAddr):
     name = "Management Address"
     type = 0x0016
 
 
-class CDPMsgUnknown19(CDPMsgGeneric):
-    name = "Unknown CDP Message"
-    type = 0x0019
+class CDPMsgPowerRequest(CDPMsgGeneric):
+    name = "Power Request"
+    fields_desc = [XShortEnumField("type", 0x0019, _cdp_tlv_types),
+                   FieldLenField("len", None, "power_requested_list", fmt="!H",
+                                 adjust=lambda pkt, x: x + 8),
+                   ShortField("req_id", 0),
+                   ShortField("mgmt_id", 0),
+                   FieldListField("power_requested_list", [],
+                                  IntField("power_requested", 0),
+                                  count_from=lambda pkt: (pkt.len - 8) // 4)]
+
+
+class CDPMsgPowerAvailable(CDPMsgGeneric):
+    name = "Power Available"
+    fields_desc = [XShortEnumField("type", 0x001a, _cdp_tlv_types),
+                   FieldLenField("len", None, "power_available_list", fmt="!H",
+                                 adjust=lambda pkt, x: x + 8),
+                   ShortField("req_id", 0),
+                   ShortField("mgmt_id", 0),
+                   FieldListField("power_available_list", [],
+                                  IntField("power_available", 0),
+                                  count_from=lambda pkt: (pkt.len - 8) // 4)]
 
 
 class CDPMsg(CDPMsgGeneric):
     name = "CDP "
     fields_desc = [XShortEnumField("type", None, _cdp_tlv_types),
                    FieldLenField("len", None, "val", fmt="!H",
                                  adjust=lambda pkt, x: x + 4),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/chdlc.py` & `scapy-2.6.0rc1/scapy/contrib/chdlc.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/coap.py` & `scapy-2.6.0rc1/scapy/contrib/coap.py`

 * *Files 2% similar despite different names*

```diff
@@ -103,35 +103,35 @@
     return _get_ext_field_size(pkt.len)
 
 
 def _get_abs_val(val, ext_val):
     if val >= 15:
         warning("Invalid Option Length or Delta %d" % val)
     if val == 14:
-        return 269 + struct.unpack('H', ext_val)[0]
+        return 269 + struct.unpack('!H', ext_val)[0]
     if val == 13:
         return 13 + struct.unpack('B', ext_val)[0]
     return val
 
 
 def _get_opt_val_size(pkt):
     return _get_abs_val(pkt.len, pkt.len_ext)
 
 
 class _CoAPOpt(Packet):
     fields_desc = [BitField("delta", 0, 4),
                    BitField("len", 0, 4),
-                   StrLenField("delta_ext", None, length_from=_get_delta_ext_size),  # noqa: E501
-                   StrLenField("len_ext", None, length_from=_get_len_ext_size),
-                   StrLenField("opt_val", None, length_from=_get_opt_val_size)]
+                   StrLenField("delta_ext", "", length_from=_get_delta_ext_size),  # noqa: E501
+                   StrLenField("len_ext", "", length_from=_get_len_ext_size),
+                   StrLenField("opt_val", "", length_from=_get_opt_val_size)]
 
     @staticmethod
     def _populate_extended(val):
         if val >= 269:
-            return struct.pack('H', val - 269), 14
+            return struct.pack('!H', val - 269), 14
         if val >= 13:
             return struct.pack('B', val - 13), 13
         return None, val
 
     def do_build(self):
         self.delta_ext, self.delta = self._populate_extended(self.delta)
         self.len_ext, self.len = self._populate_extended(len(self.opt_val))
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/concox.py` & `scapy-2.6.0rc1/scapy/contrib/concox.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/diameter.py` & `scapy-2.6.0rc1/scapy/contrib/diameter.py`

 * *Files 0% similar despite different names*

```diff
@@ -29,15 +29,14 @@
 from scapy.packet import Packet, bind_layers
 from scapy.fields import ConditionalField, EnumField, Field, FieldLenField, \
     FlagsField, IEEEDoubleField, IEEEFloatField, IntEnumField, IntField, \
     LongField, PacketListField, SignedIntField, StrLenField, X3BytesField, \
     XByteField, XIntField
 from scapy.layers.inet import TCP
 from scapy.layers.sctp import SCTPChunkData
-import scapy.libs.six as six
 from scapy.compat import chb, orb, raw, bytes_hex, plain_str
 from scapy.error import warning
 from scapy.utils import inet_ntoa, inet_aton
 from scapy.pton_ntop import inet_pton, inet_ntop
 
 #####################################################################
 #####################################################################
@@ -4777,15 +4776,15 @@
     # The drCode is set/overridden in any case
     fields['drCode'] = drCode
     # Processing of drAppId
     if 'drAppId' in fields:
         val = fields['drAppId']
         if isinstance(val, str):   # Translate into application Id code
             found = False
-            for k, v in six.iteritems(AppIDsEnum):
+            for k, v in AppIDsEnum.items():
                 if v.find(val) != -1:
                     drAppId = k
                     fields['drAppId'] = drAppId
                     found = True
                     break
             if not found:
                 del fields['drAppId']
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/dtp.py` & `scapy-2.6.0rc1/scapy/contrib/dtp.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,16 +13,14 @@
     :author: Jochen Bartl <lobo@c3a.de>
 
     :Thanks:
 
     - TLV code derived from the CDP implementation of scapy. (Thanks to Nicolas Bareil and Arnaud Ebalard)  # noqa: E501
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 import struct
 
 from scapy.packet import Packet, bind_layers
 from scapy.fields import ByteField, FieldLenField, MACField, PacketListField, \
     ShortField, StrLenField, XShortField
 from scapy.layers.l2 import SNAP, Dot3, LLC
 from scapy.sendrecv import sendp
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/eddystone.py` & `scapy-2.6.0rc1/scapy/contrib/eddystone.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 """
 
 from scapy.compat import orb
 from scapy.fields import IntField, SignedByteField, StrField, BitField, \
     StrFixedLenField, ShortField, FixedPointField, ByteEnumField
 from scapy.layers.bluetooth import EIR_Hdr, EIR_ServiceData16BitUUID, \
     EIR_CompleteList16BitServiceUUIDs, LowEnergyBeaconHelper
-import scapy.libs.six as six
 from scapy.packet import bind_layers, Packet
 
 EDDYSTONE_UUID = 0xfeaa
 
 EDDYSTONE_URL_SCHEMES = {
     0: b"http://www.",
     1: b"https://www.",
@@ -90,15 +89,15 @@
             if r is None:
                 o.append(i)
             else:
                 o.extend(r)
         return bytes(o)
 
     def any2i(self, pkt, x):
-        if isinstance(x, six.text_type):
+        if isinstance(x, str):
             x = x.encode("ascii")
         return x
 
 
 class Eddystone_Frame(Packet, LowEnergyBeaconHelper):
     """
     The base Eddystone frame on which all Eddystone messages are built.
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/eigrp.py` & `scapy-2.6.0rc1/scapy/contrib/eigrp.py`

 * *Files 0% similar despite different names*

```diff
@@ -21,15 +21,14 @@
 
     :Thanks:
 
     - TLV code derived from the CDP implementation of scapy. (Thanks to Nicolas Bareil and Arnaud Ebalard)
         http://trac.secdev.org/scapy/ticket/18
     - IOS / EIGRP Version Representation FIX by Dirk Loss
 """
-from __future__ import absolute_import
 import socket
 import struct
 
 from scapy.packet import Packet
 from scapy.fields import StrField, IPField, XShortField, FieldLenField, \
     StrLenField, IntField, ByteEnumField, ByteField, ConditionalField, \
     FlagsField, IP6Field, PacketListField, ShortEnumField, \
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/erspan.py` & `scapy-2.6.0rc1/scapy/contrib/erspan.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 
 """
 ERSPAN - Encapsulated Remote SPAN
+
+https://datatracker.ietf.org/doc/html/draft-foschiano-erspan-03
 """
 
 # scapy.contrib.description = ERSPAN - Encapsulated Remote SPAN
 # scapy.contrib.status = loads
 
 # This file inspired by scapy-vxlan
 
@@ -15,36 +17,44 @@
 from scapy.fields import BitField, BitEnumField, XIntField, \
     XShortField
 from scapy.layers.l2 import Ether, GRE
 
 
 class ERSPAN(Packet):
     """
-    A generic ERSPAN packet, pointing by default to ERSPAN II
+    A generic ERSPAN packet
     """
     name = "ERSPAN"
     fields_desc = []
 
     @classmethod
     def dispatch_hook(cls, _pkt=None, *args, **kargs):
+        if _pkt:
+            ver = _pkt[0] >> 4
+            if ver == 1:
+                return ERSPAN_II
+            elif ver == 2:
+                return ERSPAN_III
+            else:
+                return ERSPAN_I
         if cls == ERSPAN:
             return ERSPAN_II
-        return Packet.dispatch_hook(cls, _pkt, *args, **kargs)
+        return cls
 
 
 class ERSPAN_I(ERSPAN):
     name = "ERSPAN I"
     match_subclass = True
     fields_desc = []
 
 
 class ERSPAN_II(ERSPAN):
     name = "ERSPAN II"
     match_subclass = True
-    fields_desc = [BitField("ver", 0, 4),
+    fields_desc = [BitField("ver", 1, 4),
                    BitField("vlan", 0, 12),
                    BitField("cos", 0, 3),
                    BitField("en", 0, 2),
                    BitField("t", 0, 1),
                    BitField("session_id", 0, 10),
                    BitField("reserved", 0, 12),
                    BitField("index", 0, 20),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/esmc.py` & `scapy-2.6.0rc1/scapy/contrib/esmc.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/ethercat.py` & `scapy-2.6.0rc1/scapy/contrib/ethercat.py`

 * *Files 1% similar despite different names*

```diff
@@ -40,15 +40,14 @@
 
 
 from scapy.compat import raw
 from scapy.error import log_runtime, Scapy_Exception
 from scapy.fields import BitField, ByteField, LEShortField, FieldListField, \
     LEIntField, FieldLenField, _EnumField, EnumField
 from scapy.layers.l2 import Ether, Dot1Q
-import scapy.libs.six as six
 from scapy.packet import bind_layers, Packet, Padding
 
 '''
 EtherCat uses some little endian bitfields without alignment to any common boundaries.  # noqa: E501
 See https://github.com/secdev/scapy/pull/569#issuecomment-295419176 for a short explanation  # noqa: E501
 why the following field definitions are necessary.
 '''
@@ -248,15 +247,15 @@
     def __init__(self, name, default, size, length_of=None, count_of=None, adjust=lambda pkt, x: x):  # noqa: E501
         LEBitField.__init__(self, name, default, size)
         self.length_of = length_of
         self.count_of = count_of
         self.adjust = adjust
 
     def i2m(self, pkt, x):
-        return (FieldLenField.i2m.__func__ if six.PY2 else FieldLenField.i2m)(self, pkt, x)  # noqa: E501
+        return FieldLenField.i2m(self, pkt, x)
 
 
 class LEBitEnumField(LEBitField, _EnumField):
     __slots__ = EnumField.__slots__
 
     def __init__(self, name, default, size, enum):
         _EnumField.__init__(self, name, default, enum)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/etherip.py` & `scapy-2.6.0rc1/scapy/contrib/etherip.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/exposure_notification.py` & `scapy-2.6.0rc1/scapy/contrib/exposure_notification.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/geneve.py` & `scapy-2.6.0rc1/scapy/contrib/geneve.py`

 * *Files 7% similar despite different names*

```diff
@@ -5,25 +5,24 @@
 
 # scapy.contrib.description = Generic Network Virtualization Encapsulation (GENEVE)
 # scapy.contrib.status = loads
 
 """
 Geneve: Generic Network Virtualization Encapsulation
 
-draft-ietf-nvo3-geneve-16
+https://datatracker.ietf.org/doc/html/rfc8926
 """
 
 import struct
 
 from scapy.fields import BitField, XByteField, XShortEnumField, X3BytesField, StrLenField, PacketListField
 from scapy.packet import Packet, bind_layers
 from scapy.layers.inet import IP, UDP
 from scapy.layers.inet6 import IPv6
 from scapy.layers.l2 import Ether, ETHER_TYPES
-from scapy.compat import chb, orb
 
 CLASS_IDS = {0x0100: "Linux",
              0x0101: "Open vSwitch",
              0x0102: "Open Virtual Networking (OVN)",
              0x0103: "In-band Network Telemetry (INT)",
              0x0104: "VMware",
              0x0105: "Amazon.com, Inc.",
@@ -38,39 +37,43 @@
 
 class GeneveOptions(Packet):
     name = "Geneve Options"
     fields_desc = [XShortEnumField("classid", 0x0000, CLASS_IDS),
                    XByteField("type", 0x00),
                    BitField("reserved", 0, 3),
                    BitField("length", None, 5),
-                   StrLenField('data', '', length_from=lambda x:x.length * 4)]
+                   StrLenField('data', '', length_from=lambda x: x.length * 4)]
+
+    def extract_padding(self, s):
+        return "", s
 
     def post_build(self, p, pay):
         if self.length is None:
             tmp_len = len(self.data) // 4
-            p = p[:3] + struct.pack("!B", tmp_len) + p[4:]
+            p = p[:3] + struct.pack("!B", (p[3] & 0x3) | (tmp_len & 0x1f)) + p[4:]
         return p + pay
 
 
 class GENEVE(Packet):
     name = "GENEVE"
     fields_desc = [BitField("version", 0, 2),
                    BitField("optionlen", None, 6),
                    BitField("oam", 0, 1),
                    BitField("critical", 0, 1),
                    BitField("reserved", 0, 6),
                    XShortEnumField("proto", 0x0000, ETHER_TYPES),
                    X3BytesField("vni", 0),
                    XByteField("reserved2", 0x00),
-                   PacketListField("options", [], GeneveOptions, length_from=lambda pkt:pkt.optionlen * 4)]
+                   PacketListField("options", [], GeneveOptions,
+                                   length_from=lambda pkt: pkt.optionlen * 4)]
 
     def post_build(self, p, pay):
         if self.optionlen is None:
             tmp_len = (len(p) - 8) // 4
-            p = chb(tmp_len & 0x2f | orb(p[0]) & 0xc0) + p[1:]
+            p = struct.pack("!B", (p[0] & 0xc0) | (tmp_len & 0x3f)) + p[1:]
         return p + pay
 
     def answers(self, other):
         if isinstance(other, GENEVE):
             if ((self.proto == other.proto) and (self.vni == other.vni)):
                 return self.payload.answers(other.payload)
         else:
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/gtp.py` & `scapy-2.6.0rc1/scapy/contrib/gtp.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 """
 GPRS Tunneling Protocol (GTP)
 
 Spec: 3GPP TS 29.060 and 3GPP TS 29.274
 Some IEs: 3GPP TS 24.008
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.compat import chb, orb, bytes_encode
 from scapy.config import conf
 from scapy.error import warning
 from scapy.fields import (
     BitEnumField,
@@ -254,15 +253,18 @@
                        ByteEnumField("next_ex", 0, ExtensionHeadersTypes),
                        lambda pkt:pkt.E == 1 or pkt.S == 1 or pkt.PN == 1),
                    ]
 
     def post_build(self, p, pay):
         p += pay
         if self.length is None:
-            tmp_len = len(p) - 8
+            # The message length field is calculated different in GTPv1 and GTPv2.  # noqa: E501
+            # For GTPv1 it is defined as the rest of the packet following the mandatory 8-byte GTP header  # noqa: E501
+            # For GTPv2 it is defined as the length of the message in bytes excluding the mandatory part of the GTP-C header (the first 4 bytes)  # noqa: E501
+            tmp_len = len(p) - 4 if self.version == 2 else len(p) - 8
             p = p[:2] + struct.pack("!H", tmp_len) + p[4:]
         return p
 
     def hashret(self):
         hsh = struct.pack("B", self.version)
         if self.seq:
             hsh += struct.pack("H", self.seq)
@@ -445,15 +447,15 @@
 
     def post_build(self, p, pay):
         if self.fields_desc[1].name == "length":
             if self.length is None:
                 tmp_len = len(p)
                 if isinstance(self.payload, conf.padding_layer):
                     tmp_len += len(self.payload.load)
-                p = p[:1] + struct.pack("!H", tmp_len - 2) + p[3:]
+                p = p[:1] + struct.pack("!H", tmp_len - 4) + p[3:]
         return p + pay
 
 
 class IE_Cause(IE_Base):
     name = "Cause"
     fields_desc = [ByteEnumField("ietype", 1, IEType),
                    ByteEnumField("CauseValue", None, CauseValues)]
@@ -1019,14 +1021,17 @@
 
 
 class GTPDeletePDPContextResponse(Packet):
     # 3GPP TS 29.060 V9.1.0 (2009-12)
     name = "GTP Delete PDP Context Response"
     fields_desc = [PacketListField("IE_list", [], IE_Dispatcher)]
 
+    def answers(self, other):
+        return isinstance(other, GTPDeletePDPContextRequest)
+
 
 class GTPPDUNotificationRequest(Packet):
     # 3GPP TS 29.060 V9.1.0 (2009-12)
     name = "GTP PDU Notification Request"
     fields_desc = [PacketListField("IE_list", [IE_IMSI(),
                                                IE_TEICP(TEICI=RandInt()),
                                                IE_EndUserAddress(PDPTypeNumber=0x21),  # noqa: E501
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/gtp_v2.py` & `scapy-2.6.0rc1/scapy/contrib/gtp_v2.py`

 * *Files 0% similar despite different names*

```diff
@@ -1356,19 +1356,22 @@
                    BitField("CR_flag", 0, 4),
                    BitField("instance", 0, 4),
                    IntField("ChargingID", 0)]
 
 
 class IE_ChargingCharacteristics(gtp.IE_Base):
     name = "IE Charging Characteristics"
+    deprecated_fields = {
+        "ChargingCharacteristric": ("ChargingCharacteristic", "2.6.0")
+    }
     fields_desc = [ByteEnumField("ietype", 95, IEType),
                    ShortField("length", None),
                    BitField("CR_flag", 0, 4),
                    BitField("instance", 0, 4),
-                   XShortField("ChargingCharacteristric", 0)]
+                   XShortField("ChargingCharacteristic", 0)]
 
 
 class IE_PDN_type(gtp.IE_Base):
     name = "IE PDN Type"
     fields_desc = [ByteEnumField("ietype", 99, IEType),
                    ShortField("length", None),
                    BitField("CR_flag", 0, 4),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/gxrp.py` & `scapy-2.6.0rc1/scapy/contrib/gxrp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/homeplugav.py` & `scapy-2.6.0rc1/scapy/contrib/homeplugav.py`

 * *Files 0% similar despite different names*

```diff
@@ -10,15 +10,14 @@
 
 Copyright (C) FlUxIuS (Sebastien Dudek)
 
 HomePlugAV Management Message Type
 Key (type value) : Description
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.packet import Packet, bind_layers
 from scapy.fields import (
     BitField,
     ByteEnumField,
     ByteField,
@@ -95,15 +94,15 @@
 
 DefaultVendor = "Qualcomm"
 
 #########################################################################
 # Qualcomm Vendor Specific Management Message Types;                    #
 # from https://github.com/qca/open-plc-utils/blob/master/mme/qualcomm.h #
 #########################################################################
-# Commented commands are already in HPAVTypeList, the other have to be implemted  # noqa: E501
+# Commented commands are already in HPAVTypeList, the other have to be implemented  # noqa: E501
 QualcommTypeList = {  # 0xA000 : "VS_SW_VER",
     0xA004: "VS_WR_MEM",
     # 0xA008 : "VS_RD_MEM",
     # 0xA00C : "VS_ST_MAC",
     # 0xA010 : "VS_GET_NVM",
     0xA014: "VS_RSVD_1",
     0xA018: "VS_RSVD_2",
@@ -638,18 +637,18 @@
                    LEIntField("checksum", None),
                    StrLenField("ModuleData", b"\x00", length_from=lambda pkt: pkt.DataLen),  # noqa: E501
                    ]
 
     def post_build(self, p, pay):
         if self.DataLen is None:
             _len = len(self.ModuleData)
-            p = p[:2] + struct.pack('h', _len) + p[4:]
+            p = p[:2] + struct.pack('<H', _len) + p[4:]
         if self.checksum is None and p:
             ck = chksum32(self.ModuleData)
-            p = p[:8] + struct.pack('I', ck) + p[12:]
+            p = p[:8] + struct.pack('<I', ck) + p[12:]
         return p + pay
 
 ######################################
 # Parse PIB                          #
 ######################################
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/homepluggp.py` & `scapy-2.6.0rc1/scapy/contrib/homepluggp.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 
 # scapy.contrib.description = HomePlugGP Layer
 # scapy.contrib.status = loads
 
-from __future__ import absolute_import
 
 from scapy.packet import Packet, bind_layers
 from scapy.fields import ByteEnumField, ByteField, FieldLenField, \
     MACField, PacketListField, ShortField, \
     StrFixedLenField, XIntField, PacketField \
 
 # This layer extends HomePlug AV one
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/homeplugsg.py` & `scapy-2.6.0rc1/scapy/contrib/homeplugsg.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 
 # scapy.contrib.description = HomePlugSG Layer
 # scapy.contrib.status = loads
 
-from __future__ import absolute_import
 
 from scapy.packet import Packet, bind_layers
 from scapy.fields import FieldLenField, StrFixedLenField, StrLenField
 
 # Extends HomePlug AV and GP layer
 from scapy.contrib.homeplugav import HomePlugAV, QualcommTypeList
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/http2.py` & `scapy-2.6.0rc1/scapy/contrib/http2.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,28 +14,33 @@
 """
 
 # scapy.contrib.status=loads
 # scapy.contrib.description=HTTP/2 (RFC 7540, RFC 7541)
 
 # base_classes triggers an unwanted import warning
 
-from __future__ import absolute_import
-from __future__ import print_function
 import abc
 import re
 from io import BytesIO
 import struct
-import scapy.libs.six as six
 from scapy.compat import raw, plain_str, hex_bytes, orb, chb, bytes_encode
 
 # Only required if using mypy-lang for static typing
 # Most symbols are used in mypy-interpreted "comments".
 # Sized must be one of the superclasses of a class implementing __len__
-from scapy.compat import Optional, List, Union, Callable, Any, \
-    Tuple, Sized, Pattern  # noqa: F401
+from typing import (
+    Optional,
+    List,
+    Union,
+    Callable,
+    Any,
+    Tuple,
+    Sized,
+    Pattern,
+)
 from scapy.base_classes import Packet_metaclass  # noqa: F401
 
 import scapy.fields as fields
 import scapy.packet as packet
 import scapy.config as config
 import scapy.volatile as volatile
 import scapy.error as error
@@ -92,15 +97,15 @@
           are remaining bits to parse in the first byte. Returned value is equal to default value  # noqa: E501
         :raises: AssertionError
         """
         r = super(HPackMagicBitField, self).getfield(pkt, s)
         assert (
             isinstance(r, tuple) and
             len(r) == 2 and
-            isinstance(r[1], six.integer_types)
+            isinstance(r[1], int)
         ), 'Second element of BitField.getfield return value expected to be an int or a long; API change detected'  # noqa: E501
         assert r[1] == self._magic, 'Invalid value parsed from s; error in class guessing detected!'  # noqa: E501
         return r
 
     def h2i(self, pkt, x):
         # type: (Optional[packet.Packet], int) -> int
         """
@@ -184,33 +189,33 @@
         """
         :param str name: the name of this field instance
         :param int|None default: positive, null or None default value for this field instance.  # noqa: E501
         :param int size: the number of bits to consider in the first byte. Valid range is ]0;8]  # noqa: E501
         :return: None
         :raises: AssertionError
         """
-        assert default is None or (isinstance(default, six.integer_types) and default >= 0)  # noqa: E501
+        assert default is None or (isinstance(default, int) and default >= 0)
         assert 0 < size <= 8
         super(AbstractUVarIntField, self).__init__(name, default)
         self.size = size
         self._max_value = (1 << self.size) - 1
 
-        # Configuring the fake property that is useless for this class but that is  # noqa: E501
-        # expected from BitFields
+        # Configuring the fake property that is useless for this class
+        # but that is expected from BitFields
         self.rev = False
 
     def h2i(self, pkt, x):
         # type: (Optional[packet.Packet], Optional[int]) -> Optional[int]
         """
         :param packet.Packet|None pkt: unused.
         :param int|None x: the value to convert.
         :return: int|None: the converted value.
         :raises: AssertionError
         """
-        assert not isinstance(x, six.integer_types) or x >= 0
+        assert not isinstance(x, int) or x >= 0
         return x
 
     def i2h(self, pkt, x):
         # type: (Optional[packet.Packet], Optional[int]) -> Optional[int]
         """
         :param packet.Packet|None pkt: unused.
         :param int|None x: the value to convert.
@@ -328,22 +333,22 @@
         :param packet.Packet|None pkt: the packet containing this field; probably unused.  # noqa: E501
         :param str|int|None x: the value to convert.
         :return: int|None: the converted value.
         :raises: AssertionError
         """
         if isinstance(x, type(None)):
             return x
-        if isinstance(x, six.integer_types):
+        if isinstance(x, int):
             assert x >= 0
             ret = self.h2i(pkt, x)
-            assert isinstance(ret, six.integer_types) and ret >= 0
+            assert isinstance(ret, int) and ret >= 0
             return ret
         elif isinstance(x, bytes):
             ret = self.m2i(pkt, x)
-            assert (isinstance(ret, six.integer_types) and ret >= 0)
+            assert (isinstance(ret, int) and ret >= 0)
             return ret
         assert False, 'EINVAL: x: No idea what the parameter format is'
 
     def i2repr(self, pkt, x):
         # type: (Optional[packet.Packet], Optional[int]) -> str
         """
         :param packet.Packet|None pkt: probably unused.
@@ -628,16 +633,15 @@
         return ret
 
 ###############################################################################
 #                                                HPACK String Fields          #
 ###############################################################################
 
 
-@six.add_metaclass(abc.ABCMeta)
-class HPackStringsInterface(Sized):  # type: ignore
+class HPackStringsInterface(Sized, metaclass=abc.ABCMeta):  # type: ignore
     @abc.abstractmethod
     def __str__(self):
         pass
 
     def __bytes__(self):
         r = self.__str__()
         return bytes_encode(r)
@@ -2045,15 +2049,15 @@
     def extract_padding(self, s):
         # type: (str) -> Tuple[str, str]
         """
         :param str s: the string from which to tell the padding and the payload data apart  # noqa: E501
         :return: (str, str): the padding and the payload data strings
         :raises: AssertionError
         """
-        assert isinstance(self.len, six.integer_types) and self.len >= 0, 'Invalid length: negative len?'  # noqa: E501
+        assert isinstance(self.len, int) and self.len >= 0, 'Invalid length: negative len?'  # noqa: E501
         assert len(s) >= self.len, 'Invalid length: string too short for this length'  # noqa: E501
         return s[:self.len], s[self.len:]
 
     def post_build(self, p, pay):
         # type: (str, str) -> str
         """
         :param str p: the stringified packet
@@ -2403,15 +2407,15 @@
         This implementation will prefer returning a static entry index whenever
         possible. If multiple matching header name are found in the static
         table, there is insurance that the first entry (lowest index number)
         will be returned.
         If no matching header is found, this method returns None.
         """
         name = name.lower()
-        for key, val in six.iteritems(type(self)._static_entries):
+        for key, val in type(self)._static_entries.items():
             if val.name() == name:
                 return key
         for idx, val in enumerate(self._dynamic_table):
             if val.name() == name:
                 return type(self)._static_entries_last_idx + idx + 1
         return None
 
@@ -2422,15 +2426,15 @@
 
         This implementation will prefer returning a static entry index whenever
         possible. If multiple matching headers are found in the dynamic table,
         the lowest index is returned
         If no matching header is found, this method returns None.
         """
         name = name.lower()
-        for key, val in six.iteritems(type(self)._static_entries):
+        for key, val in type(self)._static_entries.items():
             if val.name() == name and val.value() == value:
                 return key
         for idx, val in enumerate(self._dynamic_table):
             if val.name() == name and val.value() == value:
                 return type(self)._static_entries_last_idx + idx + 1
         return None
 
@@ -2610,15 +2614,15 @@
         if grp.group(1) is not None:
             hdr_name = b':' + grp.group(1)
         else:
             hdr_name = grp.group(2)
         return plain_str(hdr_name.lower()), plain_str(grp.group(3))
 
     def parse_txt_hdrs(self,
-                       s,  # type: str
+                       s,  # type: Union[bytes, str]
                        stream_id=1,  # type: int
                        body=None,  # type: Optional[str]
                        max_frm_sz=4096,  # type: int
                        max_hdr_lst_sz=0,  # type: int
                        is_sensitive=lambda n, v: False,  # type: Callable[[str, str], bool]  # noqa: E501
                        should_index=lambda x: False,  # type: Callable[[str], bool]  # noqa: E501
                        register=True,  # type: bool
@@ -2656,15 +2660,15 @@
           provided header should be stored in a header packet requesting
           indexation in the dynamic header table.
         :param bool register: whether to register new headers with incremental
           indexing as we parse them
         :raises: Exception
         """
 
-        sio = BytesIO(s)
+        sio = BytesIO(s.encode() if isinstance(s, str) else s)
 
         base_frm_len = len(raw(H2Frame()))
 
         ret = H2Seq()
         cur_frm = H2HeadersFrame()  # type: Union[H2HeadersFrame, H2ContinuationFrame]  # noqa: E501
         cur_hdr_sz = 0
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/ibeacon.py` & `scapy-2.6.0rc1/scapy/contrib/ibeacon.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/ife.py` & `scapy-2.6.0rc1/scapy/contrib/ife.py`

 * *Files 4% similar despite different names*

```diff
@@ -55,15 +55,15 @@
     IFE_META_SKBMARK,
     IFE_META_PRIO,
 ]
 
 
 class IFETlv(Packet):
     """
-    Parent Class interhit by all ForCES TLV strucutures
+    Parent Class interhit by all ForCES TLV structures
     """
     name = "IFETlv"
 
     fields_desc = [
         ShortEnumField("type", 0, IFE_META_TYPES),
         FieldLenField("length", None, length_of="value",
                       adjust=lambda pkt, x: x + 4),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/igmp.py` & `scapy-2.6.0rc1/scapy/contrib/igmp.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 
 # scapy.contrib.description = Internet Group Management Protocol v1/v2 (IGMP/IGMPv2)
 # scapy.contrib.status = loads
 
-from __future__ import print_function
 from scapy.compat import chb, orb
 from scapy.error import warning
 from scapy.fields import ByteEnumField, ByteField, IPField, XShortField
 from scapy.layers.inet import IP, IPOption_Router_Alert
 from scapy.layers.l2 import Ether, getmacbyip
 from scapy.packet import bind_layers, Packet
 from scapy.utils import atol, checksum
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/igmpv3.py` & `scapy-2.6.0rc1/scapy/contrib/igmpv3.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 
 # scapy.contrib.description = Internet Group Management Protocol v3 (IGMPv3)
 # scapy.contrib.status = loads
 
-from __future__ import print_function
 from scapy.packet import Packet, bind_layers
 from scapy.fields import BitField, ByteEnumField, ByteField, FieldLenField, \
     FieldListField, IPField, PacketListField, ShortField, XShortField
 from scapy.compat import orb
 from scapy.layers.inet import IP
 from scapy.contrib.igmp import IGMP
 from scapy.config import conf
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/ikev2.py` & `scapy-2.6.0rc1/scapy/contrib/ikev2.py`

 * *Files 15% similar despite different names*

```diff
@@ -5,115 +5,174 @@
 """
 Internet Key Exchange Protocol Version 2 (IKEv2), RFC 7296
 """
 
 # scapy.contrib.description = Internet Key Exchange Protocol Version 2 (IKEv2), RFC 7296
 # scapy.contrib.status = loads
 
-import logging
 import struct
 
 
 # Modified from the original ISAKMP code by Yaron Sheffer <yaronf.ietf@gmail.com>, June 2010.  # noqa: E501
 
-from scapy.packet import Packet, bind_top_down, bind_bottom_up, \
-    split_bottom_up, split_layers, Raw
-from scapy.fields import ByteEnumField, ByteField, ConditionalField, \
-    FieldLenField, FlagsField, IP6Field, IPField, IntField, MultiEnumField, \
-    MultipleTypeField, \
-    PacketField, PacketLenField, PacketListField, ShortEnumField, ShortField, \
-    StrFixedLenField, StrLenField, X3BytesField, XByteField, XIntField
+from scapy.packet import (
+    Packet,
+    Raw,
+    bind_bottom_up,
+    bind_layers,
+    bind_top_down,
+    split_bottom_up,
+)
+from scapy.fields import (
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    FieldLenField,
+    FieldListField,
+    FlagsField,
+    IP6Field,
+    IPField,
+    IntField,
+    MultiEnumField,
+    MultipleTypeField,
+    PacketField,
+    PacketLenField,
+    PacketListField,
+    ShortEnumField,
+    ShortField,
+    StrLenField,
+    X3BytesField,
+    XByteField,
+    XStrFixedLenField,
+    XStrLenField,
+)
 from scapy.layers.x509 import X509_Cert, X509_CRL
 from scapy.layers.inet import IP, UDP
-from scapy.layers.ipsec import ESP
+from scapy.layers.ipsec import NON_ESP
 from scapy.layers.isakmp import ISAKMP
 from scapy.sendrecv import sr
 from scapy.config import conf
 from scapy.volatile import RandString
 
 # see https://www.iana.org/assignments/ikev2-parameters for details
-IKEv2AttributeTypes = {"Encryption": (1, {"DES-IV64": 1,
-                                          "DES": 2,
-                                          "3DES": 3,
-                                          "RC5": 4,
-                                          "IDEA": 5,
-                                          "CAST": 6,
-                                          "Blowfish": 7,
-                                          "3IDEA": 8,
-                                          "DES-IV32": 9,
-                                          "AES-CBC": 12,
-                                          "AES-CTR": 13,
-                                          "AES-CCM-8": 14,
-                                          "AES-CCM-12": 15,
-                                          "AES-CCM-16": 16,
-                                          "AES-GCM-8ICV": 18,
-                                          "AES-GCM-12ICV": 19,
-                                          "AES-GCM-16ICV": 20,
-                                          "Camellia-CBC": 23,
-                                          "Camellia-CTR": 24,
-                                          "Camellia-CCM-8ICV": 25,
-                                          "Camellia-CCM-12ICV": 26,
-                                          "Camellia-CCM-16ICV": 27,
-                                          "ChaCha20-Poly1305": 28,
-                                          "Kuzneychik-MGM-KTREE": 32,
-                                          "MAGMA-MGM-KTREE": 33,
-                                          }, 0),
-                       "PRF": (2, {"PRF_HMAC_MD5": 1,
-                                   "PRF_HMAC_SHA1": 2,
-                                   "PRF_HMAC_TIGER": 3,
-                                   "PRF_AES128_XCBC": 4,
-                                   "PRF_HMAC_SHA2_256": 5,
-                                   "PRF_HMAC_SHA2_384": 6,
-                                   "PRF_HMAC_SHA2_512": 7,
-                                   "PRF_AES128_CMAC": 8,
-                                   "PRF_HMAC_STREEBOG_512": 9,
-                                   }, 0),
-                       "Integrity": (3, {"HMAC-MD5-96": 1,
-                                         "HMAC-SHA1-96": 2,
-                                         "DES-MAC": 3,
-                                         "KPDK-MD5": 4,
-                                         "AES-XCBC-96": 5,
-                                         "HMAC-MD5-128": 6,
-                                         "HMAC-SHA1-160": 7,
-                                         "AES-CMAC-96": 8,
-                                         "AES-128-GMAC": 9,
-                                         "AES-192-GMAC": 10,
-                                         "AES-256-GMAC": 11,
-                                         "SHA2-256-128": 12,
-                                         "SHA2-384-192": 13,
-                                         "SHA2-512-256": 14,
-                                         }, 0),
-                       "GroupDesc": (4, {"768MODPgr": 1,
-                                         "1024MODPgr": 2,
-                                         "1536MODPgr": 5,
-                                         "2048MODPgr": 14,
-                                         "3072MODPgr": 15,
-                                         "4096MODPgr": 16,
-                                         "6144MODPgr": 17,
-                                         "8192MODPgr": 18,
-                                         "256randECPgr": 19,
-                                         "384randECPgr": 20,
-                                         "521randECPgr": 21,
-                                         "1024MODP160POSgr": 22,
-                                         "2048MODP224POSgr": 23,
-                                         "2048MODP256POSgr": 24,
-                                         "192randECPgr": 25,
-                                         "224randECPgr": 26,
-                                         "brainpoolP224r1gr": 27,
-                                         "brainpoolP256r1gr": 28,
-                                         "brainpoolP384r1gr": 29,
-                                         "brainpoolP512r1gr": 30,
-                                         "curve25519gr": 31,
-                                         "curve448gr": 32,
-                                         "GOST3410_2012_256": 33,
-                                         "GOST3410_2012_512": 34,
-                                         }, 0),
-                       "Extended Sequence Number": (5, {"No ESN": 0,
-                                                        "ESN": 1}, 0),
-                       }
+IKEv2AttributeTypes = {
+    1: (
+        "Encryption",
+        {
+            1: "DES-IV64",
+            2: "DES",
+            3: "3DES",
+            4: "RC5",
+            5: "IDEA",
+            6: "CAST",
+            7: "Blowfish",
+            8: "3IDEA",
+            9: "DES-IV32",
+            12: "AES-CBC",
+            13: "AES-CTR",
+            14: "AES-CCM-8",
+            15: "AES-CCM-12",
+            16: "AES-CCM-16",
+            18: "AES-GCM-8ICV",
+            19: "AES-GCM-12ICV",
+            20: "AES-GCM-16ICV",
+            23: "Camellia-CBC",
+            24: "Camellia-CTR",
+            25: "Camellia-CCM-8ICV",
+            26: "Camellia-CCM-12ICV",
+            27: "Camellia-CCM-16ICV",
+            28: "ChaCha20-Poly1305",
+            32: "Kuzneychik-MGM-KTREE",
+            33: "MAGMA-MGM-KTREE",
+        }
+    ),
+    2: (
+        "PRF",
+        {
+            1: "PRF_HMAC_MD5",
+            2: "PRF_HMAC_SHA1",
+            3: "PRF_HMAC_TIGER",
+            4: "PRF_AES128_XCBC",
+            5: "PRF_HMAC_SHA2_256",
+            6: "PRF_HMAC_SHA2_384",
+            7: "PRF_HMAC_SHA2_512",
+            8: "PRF_AES128_CMAC",
+            9: "PRF_HMAC_STREEBOG_512",
+        }
+    ),
+    3: (
+        "Integrity",
+        {
+            1: "HMAC-MD5-96",
+            2: "HMAC-SHA1-96",
+            3: "DES-MAC",
+            4: "KPDK-MD5",
+            5: "AES-XCBC-96",
+            6: "HMAC-MD5-128",
+            7: "HMAC-SHA1-160",
+            8: "AES-CMAC-96",
+            9: "AES-128-GMAC",
+            10: "AES-192-GMAC",
+            11: "AES-256-GMAC",
+            12: "SHA2-256-128",
+            13: "SHA2-384-192",
+            14: "SHA2-512-256",
+        }
+    ),
+    4: (
+        "GroupDesc",
+        {
+            1: "768MODPgr",
+            2: "1024MODPgr",
+            5: "1536MODPgr",
+            14: "2048MODPgr",
+            15: "3072MODPgr",
+            16: "4096MODPgr",
+            17: "6144MODPgr",
+            18: "8192MODPgr",
+            19: "256randECPgr",
+            20: "384randECPgr",
+            21: "521randECPgr",
+            22: "1024MODP160POSgr",
+            23: "2048MODP224POSgr",
+            24: "2048MODP256POSgr",
+            25: "192randECPgr",
+            26: "224randECPgr",
+            27: "brainpoolP224r1gr",
+            28: "brainpoolP256r1gr",
+            29: "brainpoolP384r1gr",
+            30: "brainpoolP512r1gr",
+            31: "curve25519gr",
+            32: "curve448gr",
+            33: "GOST3410_2012_256",
+            34: "GOST3410_2012_512",
+        }
+    ),
+    5: (
+        "Extended Sequence Number",
+        {
+            0: "No ESN",
+            1: "ESN"
+        }
+    ),
+}
+
+IKEv2TransformTypes = {
+    tf_num: tf_name for tf_name, (tf_num, _) in IKEv2AttributeTypes.items()
+}
+
+IKEv2TransformAlgorithms = {
+    tf_num: tf_dict for tf_num, (_, tf_dict) in IKEv2AttributeTypes.items()
+}
+
+IKEv2ProtocolTypes = {
+    1: "IKE",
+    2: "AH",
+    3: "ESP"
+}
 
 IKEv2AuthenticationTypes = {
     0: "Reserved",
     1: "RSA Digital Signature",
     2: "Shared Key Message Integrity Code",
     3: "DSS Digital Signature",
     9: "ECDSA with SHA-256 on the P-256 curve",
@@ -143,14 +202,15 @@
     40: "UNACCEPTABLE_ADDRESSES",
     41: "UNEXPECTED_NAT_DETECTED",
     42: "USE_ASSIGNED_HoA",
     43: "TEMPORARY_FAILURE",
     44: "CHILD_SA_NOT_FOUND",
     45: "INVALID_GROUP_ID",
     46: "AUTHORIZATION_FAILED",
+    47: "NOTIFY_STATE_NOT_FOUND",
     16384: "INITIAL_CONTACT",
     16385: "SET_WINDOW_SIZE",
     16386: "ADDITIONAL_TS_POSSIBLE",
     16387: "IPCOMP_SUPPORTED",
     16388: "NAT_DETECTION_SOURCE_IP",
     16389: "NAT_DETECTION_DESTINATION_IP",
     16390: "COOKIE",
@@ -192,15 +252,30 @@
     16426: "PSK_CONFIRM",
     16427: "ERX_SUPPORTED",
     16428: "IFOM_CAPABILITY",
     16429: "SENDER_REQUEST_ID",
     16430: "IKEV2_FRAGMENTATION_SUPPORTED",
     16431: "SIGNATURE_HASH_ALGORITHMS",
     16432: "CLONE_IKE_SA_SUPPORTED",
-    16433: "CLONE_IKE_SA"
+    16433: "CLONE_IKE_SA",
+    16434: "IV2_NOTIFY_PUZZLE",
+    16435: "IV2_NOTIFY_USE_PPK",
+    16436: "IV2_NOTIFY_PPK_IDENTITY",
+    16437: "IV2_NOTIFY_NO_PPK_AUTH",
+    16438: "IV2_NOTIFY_INTERMEDIATE_EXCHANGE_SUPPORTED",
+    16439: "IV2_NOTIFY_IP4_ALLOWED",
+    16440: "IV2_NOTIFY_IP6_ALLOWED",
+    16441: "IV2_NOTIFY_ADDITIONAL_KEY_EXCHANGE",
+    16442: "IV2_NOTIFY_USE_AGGFRAG",
+}
+
+IKEv2GatewayIDTypes = {
+    1: "IPv4_addr",
+    2: "IPv6_addr",
+    3: "FQDN"
 }
 
 IKEv2CertificateEncodings = {
     1: "PKCS #7 wrapped X.509 certificate",
     2: "PGP Certificate",
     3: "DNS Signed Key",
     4: "X.509 Certificate - Signature",
@@ -395,88 +470,79 @@
     138: "MANET Protocols",
     139: "Host Identity Protocol",
     140: "Site Multihoming by IPv6 Intermediation",
     141: "Wrapped Encapsulating Security Payload",
     142: "Robust Header Compression",
 }
 
-# the name 'IKEv2TransformTypes' is actually a misnomer (since the table
-# holds info for all IKEv2 Attribute types, not just transforms, but we'll
-# keep it for backwards compatibility... for now at least
-IKEv2TransformTypes = IKEv2AttributeTypes
-
-IKEv2TransformNum = {}
-for n in IKEv2TransformTypes:
-    val = IKEv2TransformTypes[n]
-    tmp = {}
-    for e in val[1]:
-        tmp[val[1][e]] = e
-    IKEv2TransformNum[val[0]] = tmp
-
-IKEv2Transforms = {}
-for n in IKEv2TransformTypes:
-    IKEv2Transforms[IKEv2TransformTypes[n][0]] = n
-
-del n
-del e
-del tmp
-del val
-
-# Note: Transform and Proposal can only be used inside the SA payload
-IKEv2_payload_type = ["None", "", "Proposal", "Transform"]
-
-IKEv2_payload_type.extend([""] * 29)
-IKEv2_payload_type.extend(["SA", "KE", "IDi", "IDr", "CERT", "CERTREQ", "AUTH", "Nonce", "Notify", "Delete",  # noqa: E501
-                           "VendorID", "TSi", "TSr", "Encrypted", "CP", "EAP", "", "", "", "", "Encrypted_Fragment"])  # noqa: E501
-
-IKEv2_exchange_type = [""] * 34
-IKEv2_exchange_type.extend(["IKE_SA_INIT", "IKE_AUTH", "CREATE_CHILD_SA",
-                            "INFORMATIONAL", "IKE_SESSION_RESUME"])
-
-
-class IKEv2_class(Packet):
-    def guess_payload_class(self, payload):
-        np = self.next_payload
-        logging.debug("For IKEv2_class np=%d", np)
-        if np == 0:
-            return conf.raw_layer
-        elif np < len(IKEv2_payload_type):
-            pt = IKEv2_payload_type[np]
-            logging.debug(globals().get("IKEv2_payload_%s" % pt, IKEv2_payload))  # noqa: E501
-            return globals().get("IKEv2_payload_%s" % pt, IKEv2_payload)
-        else:
-            return IKEv2_payload
+IKEv2PayloadTypes = {
+    0: "None",
+    2: "Proposal",   # used only inside the SA payload
+    3: "Transform",  # used only inside the SA payload
+    33: "SA",
+    34: "KE",
+    35: "IDi",
+    36: "IDr",
+    37: "CERT",
+    38: "CERTREQ",
+    39: "AUTH",
+    40: "Nonce",
+    41: "Notify",
+    42: "Delete",
+    43: "VendorID",
+    44: "TSi",
+    45: "TSr",
+    46: "Encrypted",
+    47: "CP",
+    48: "EAP",
+    49: "GSPM",
+    50: "IDg",
+    51: "GSA",
+    52: "KD",
+    53: "Encrypted_Fragment",
+    54: "PS"
+}
+
+
+IKEv2ExchangeTypes = {
+    34: "IKE_SA_INIT",
+    35: "IKE_AUTH",
+    36: "CREATE_CHILD_SA",
+    37: "INFORMATIONAL",
+    38: "IKE_SESSION_RESUME",
+    43: "IKE_INTERMEDIATE"
+}
+
+
+class _IKEv2_Packet(Packet):
+    def default_payload_class(self, payload):
+        return IKEv2_Payload if self.next_payload else conf.raw_layer
 
 
-class IKEv2(IKEv2_class):  # rfc4306
+class IKEv2(_IKEv2_Packet):  # rfc4306
     name = "IKEv2"
     fields_desc = [
-        StrFixedLenField("init_SPI", "", 8),
-        StrFixedLenField("resp_SPI", "", 8),
-        ByteEnumField("next_payload", 0, IKEv2_payload_type),
+        XStrFixedLenField("init_SPI", "", 8),
+        XStrFixedLenField("resp_SPI", "", 8),
+        ByteEnumField("next_payload", 0, IKEv2PayloadTypes),
         XByteField("version", 0x20),
-        ByteEnumField("exch_type", 0, IKEv2_exchange_type),
+        ByteEnumField("exch_type", 0, IKEv2ExchangeTypes),
         FlagsField("flags", 0, 8, ["res0", "res1", "res2", "Initiator", "Version", "Response", "res6", "res7"]),  # noqa: E501
         IntField("id", 0),
         IntField("length", None)  # Length of total message: packets + all payloads  # noqa: E501
     ]
 
     @classmethod
     def dispatch_hook(cls, _pkt=None, *args, **kargs):
         if _pkt and len(_pkt) >= 18:
             version = struct.unpack("!B", _pkt[17:18])[0]
             if version < 0x20:
                 return ISAKMP
         return cls
 
-    def guess_payload_class(self, payload):
-        if self.flags & 1:
-            return conf.raw_layer
-        return IKEv2_class.guess_payload_class(self, payload)
-
     def answers(self, other):
         if isinstance(other, IKEv2):
             if other.init_SPI == self.init_SPI:
                 return 1
         return 0
 
     def post_build(self, p, pay):
@@ -494,73 +560,65 @@
     def i2h(self, pkt, x):
         return IntField.i2h(self, pkt, x & 0xFFFF)
 
     def h2i(self, pkt, x):
         return IntField.h2i(self, pkt, (x if x is not None else 0) | 0x800E0000)  # noqa: E501
 
 
-class IKEv2_payload_Transform(IKEv2_class):
-    name = "IKE Transform"
+class IKEv2_Payload(_IKEv2_Packet):
+    name = "IKEv2 Payload"
     fields_desc = [
-        ByteEnumField("next_payload", None, {0: "last", 3: "Transform"}),
-        ByteField("res", 0),
-        ShortField("length", 8),
-        ByteEnumField("transform_type", None, IKEv2Transforms),
+        ByteEnumField("next_payload", None, IKEv2PayloadTypes),
+        FlagsField("flags", 0, 8, ["critical"]),
+        ShortField("length", None),
+        XStrLenField("load", "", length_from=lambda pkt: pkt.length - 4),
+    ]
+
+    def post_build(self, pkt, pay):
+        if self.length is None:
+            pkt = pkt[:2] + struct.pack("!H", len(pkt)) + pkt[4:]
+        return pkt + pay
+
+
+class IKEv2_Transform(IKEv2_Payload):
+    name = "IKEv2 Transform"
+    fields_desc = IKEv2_Payload.fields_desc[:2] + [
+        ShortField("length", 8),  # can't be None, because 'key_length' depends on it
+        ByteEnumField("transform_type", None, IKEv2TransformTypes),
         ByteField("res2", 0),
-        MultiEnumField("transform_id", None, IKEv2TransformNum, depends_on=lambda pkt: pkt.transform_type, fmt="H"),  # noqa: E501
+        MultiEnumField("transform_id", None, IKEv2TransformAlgorithms, depends_on=lambda pkt: pkt.transform_type, fmt="H"),  # noqa: E501
         ConditionalField(IKEv2_Key_Length_Attribute("key_length"), lambda pkt: pkt.length > 8),  # noqa: E501
     ]
 
 
-class IKEv2_payload_Proposal(IKEv2_class):
+class IKEv2_Proposal(IKEv2_Payload):
     name = "IKEv2 Proposal"
-    fields_desc = [
-        ByteEnumField("next_payload", None, {0: "last", 2: "Proposal"}),
-        ByteField("res", 0),
-        FieldLenField("length", None, "trans", "H", adjust=lambda pkt, x: x + 8 + (pkt.SPIsize if pkt.SPIsize else 0)),  # noqa: E501
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         ByteField("proposal", 1),
-        ByteEnumField("proto", 1, {1: "IKEv2", 2: "AH", 3: "ESP"}),
+        ByteEnumField("proto", 1, IKEv2ProtocolTypes),
         FieldLenField("SPIsize", None, "SPI", "B"),
         ByteField("trans_nb", None),
-        StrLenField("SPI", "", length_from=lambda pkt: pkt.SPIsize),
-        PacketLenField("trans", conf.raw_layer(), IKEv2_payload_Transform, length_from=lambda pkt: pkt.length - 8 - pkt.SPIsize),  # noqa: E501
+        XStrLenField("SPI", "", length_from=lambda pkt: pkt.SPIsize),
+        PacketLenField("trans", conf.raw_layer(), IKEv2_Transform, length_from=lambda pkt: pkt.length - 8 - pkt.SPIsize),  # noqa: E501
     ]
 
 
-class IKEv2_payload(IKEv2_class):
-    name = "IKEv2 Payload"
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        FlagsField("flags", 0, 8, ["critical", "res1", "res2", "res3", "res4", "res5", "res6", "res7"]),  # noqa: E501
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 4),
-        StrLenField("load", "", length_from=lambda x:x.length - 4),
-    ]
-
-
-class IKEv2_payload_AUTH(IKEv2_class):
+class IKEv2_AUTH(IKEv2_Payload):
     name = "IKEv2 Authentication"
-    overload_fields = {IKEv2: {"next_payload": 39}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 8),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         ByteEnumField("auth_type", None, IKEv2AuthenticationTypes),
         X3BytesField("res2", 0),
-        StrLenField("load", "", length_from=lambda x:x.length - 8),
+        XStrLenField("load", "", length_from=lambda pkt: pkt.length - 8),
     ]
 
 
-class IKEv2_payload_VendorID(IKEv2_class):
+class IKEv2_VendorID(IKEv2_Payload):
     name = "IKEv2 Vendor ID"
-    overload_fields = {IKEv2: {"next_payload": 43}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "vendorID", "H", adjust=lambda pkt, x:x + 4),  # noqa: E501
-        StrLenField("vendorID", "", length_from=lambda x:x.length - 4),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        XStrLenField("vendorID", "", length_from=lambda pkt: pkt.length - 4),
     ]
 
 
 class TrafficSelector(Packet):
     @classmethod
     def dispatch_hook(cls, _pkt=None, *args, **kargs):
         if _pkt and len(_pkt) >= 16:
@@ -623,339 +681,279 @@
 
 
 class RawTrafficSelector(TrafficSelector):
     name = "IKEv2 Encrypted Traffic Selector"
     fields_desc = [
         ByteEnumField("TS_type", None, IKEv2TrafficSelectorTypes),
         ByteEnumField("IP_protocol_ID", None, IPProtocolIDs),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 4),
+        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x: x + 4),
         PacketField("load", "", Raw)
     ]
 
 
-class IKEv2_payload_TSi(IKEv2_class):
+class IKEv2_TSi(IKEv2_Payload):
     name = "IKEv2 Traffic Selector - Initiator"
-    overload_fields = {IKEv2: {"next_payload": 44}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "traffic_selector", "H", adjust=lambda pkt, x:x + 8),  # noqa: E501
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         FieldLenField("number_of_TSs", None, fmt="B",
                       count_of="traffic_selector"),
         X3BytesField("res2", 0),
         PacketListField("traffic_selector", None, TrafficSelector,
-                        length_from=lambda x:x.length - 8,
-                        count_from=lambda x:x.number_of_TSs),
+                        length_from=lambda pkt: pkt.length - 8,
+                        count_from=lambda pkt: pkt.number_of_TSs),
     ]
 
 
-class IKEv2_payload_TSr(IKEv2_class):
+class IKEv2_TSr(IKEv2_Payload):
     name = "IKEv2 Traffic Selector - Responder"
-    overload_fields = {IKEv2: {"next_payload": 45}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "traffic_selector", "H", adjust=lambda pkt, x:x + 8),  # noqa: E501
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         FieldLenField("number_of_TSs", None, fmt="B",
                       count_of="traffic_selector"),
         X3BytesField("res2", 0),
         PacketListField("traffic_selector", None, TrafficSelector,
-                        length_from=lambda x:x.length - 8,
-                        count_from=lambda x:x.number_of_TSs),
+                        length_from=lambda pkt: pkt.length - 8,
+                        count_from=lambda pkt: pkt.number_of_TSs),
     ]
 
 
-class IKEv2_payload_Delete(IKEv2_class):
-    name = "IKEv2 Vendor ID"
-    overload_fields = {IKEv2: {"next_payload": 42}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "vendorID", "H", adjust=lambda pkt, x:x + 4),  # noqa: E501
-        StrLenField("vendorID", "", length_from=lambda x:x.length - 4),
+class IKEv2_Delete(IKEv2_Payload):
+    name = "IKEv2 Delete"
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        ByteEnumField("proto", None, {0: "Reserved", 1: "IKE", 2: "AH", 3: "ESP"}),  # noqa: E501
+        FieldLenField("SPIsize", None, "SPI", "B"),
+        ShortField("SPInum", 0),
+        FieldListField("SPI", [],
+                       XStrLenField("", "", length_from=lambda pkt: pkt.SPIsize),
+                       count_from=lambda pkt: pkt.SPInum)
     ]
 
 
-class IKEv2_payload_SA(IKEv2_class):
+class IKEv2_SA(IKEv2_Payload):
     name = "IKEv2 SA"
-    overload_fields = {IKEv2: {"next_payload": 33}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "prop", "H", adjust=lambda pkt, x:x + 4),
-        PacketLenField("prop", conf.raw_layer(), IKEv2_payload_Proposal, length_from=lambda x:x.length - 4),  # noqa: E501
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        PacketLenField("prop", conf.raw_layer(), IKEv2_Proposal, length_from=lambda pkt: pkt.length - 4),  # noqa: E501
     ]
 
 
-class IKEv2_payload_Nonce(IKEv2_class):
+class IKEv2_Nonce(IKEv2_Payload):
     name = "IKEv2 Nonce"
-    overload_fields = {IKEv2: {"next_payload": 40}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 4),
-        StrLenField("load", "", length_from=lambda x:x.length - 4),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        XStrLenField("nonce", "", length_from=lambda pkt: pkt.length - 4),
     ]
 
 
-class IKEv2_payload_Notify(IKEv2_class):
+class IKEv2_Notify(IKEv2_Payload):
     name = "IKEv2 Notify"
-    overload_fields = {IKEv2: {"next_payload": 41}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 8),
-        ByteEnumField("proto", None, {0: "Reserved", 1: "IKE", 2: "AH", 3: "ESP"}),  # noqa: E501
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        ByteEnumField("proto", None, IKEv2ProtocolTypes),
         FieldLenField("SPIsize", None, "SPI", "B"),
         ShortEnumField("type", 0, IKEv2NotifyMessageTypes),
-        StrLenField("SPI", "", length_from=lambda x: x.SPIsize),
-        StrLenField("load", "", length_from=lambda x: x.length - 8),
+        XStrLenField("SPI", "", length_from=lambda pkt: pkt.SPIsize),
+        ConditionalField(
+            XStrLenField("notify", "",
+                         length_from=lambda pkt: pkt.length - 8 - pkt.SPIsize),
+            lambda pkt: pkt.type not in (16407, 16408)
+        ),
+        ConditionalField(
+            # REDIRECT, REDIRECTED_FROM  (RFC 5685)
+            ByteEnumField("gw_id_type", 1, IKEv2GatewayIDTypes),
+            lambda pkt: pkt.type in (16407, 16408)
+        ),
+        ConditionalField(
+            # REDIRECT, REDIRECTED_FROM  (RFC 5685)
+            FieldLenField("gw_id_len", None, "gw_id", "B"),
+            lambda pkt: pkt.type in (16407, 16408)
+        ),
+        ConditionalField(
+            # REDIRECT, REDIRECTED_FROM  (RFC 5685)
+            MultipleTypeField(
+                [
+                    (IPField("gw_id", "127.0.0.1"), lambda x: x.gw_id_type == 1),
+                    (IP6Field("gw_id", "::1"), lambda x: x.gw_id_type == 5),
+                ],
+                StrLenField("gw_id", "", length_from=lambda x: x.gw_id_len)
+            ),
+            lambda pkt: pkt.type in (16407, 16408)
+        ),
+        ConditionalField(
+            # REDIRECT  (RFC 5685)
+            XStrLenField("nonce", "", length_from=lambda x:x.length - 10 - x.gw_id_len),
+            lambda pkt: pkt.type == 16407
+        )
     ]
 
 
-class IKEv2_payload_KE(IKEv2_class):
+class IKEv2_KE(IKEv2_Payload):
     name = "IKEv2 Key Exchange"
-    overload_fields = {IKEv2: {"next_payload": 34}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 8),
-        ShortEnumField("group", 0, IKEv2TransformTypes['GroupDesc'][1]),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        ShortEnumField("group", 0, IKEv2TransformAlgorithms[4]),
         ShortField("res2", 0),
-        StrLenField("load", "", length_from=lambda x:x.length - 8),
+        XStrLenField("ke", "", length_from=lambda pkt: pkt.length - 8),
     ]
 
 
-class IKEv2_payload_IDi(IKEv2_class):  # RFC 7296, section 3.5
+class IKEv2_IDi(IKEv2_Payload):  # RFC 7296, section 3.5
     name = "IKEv2 Identification - Initiator"
-    overload_fields = {IKEv2: {"next_payload": 35}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 8),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         ByteEnumField("IDtype", 1, {1: "IPv4_addr", 2: "FQDN", 3: "Email_addr", 5: "IPv6_addr", 11: "Key"}),  # noqa: E501
         X3BytesField("res2", 0),
         MultipleTypeField(
             [
-                (IPField("ID", "127.0.0.1"), lambda x: x.IDtype == 1),
-                (IP6Field("ID", "::1"), lambda x: x.IDtype == 5),
+                (IPField("ID", "127.0.0.1"), lambda pkt: pkt.IDtype == 1),
+                (IP6Field("ID", "::1"), lambda pkt: pkt.IDtype == 5),
             ],
-            StrLenField("ID", "", length_from=lambda x: x.length - 8),
+            XStrLenField("ID", "", length_from=lambda pkt: pkt.length - 8),
         )
     ]
 
 
-class IKEv2_payload_IDr(IKEv2_class):  # RFC 7296, section 3.5
+class IKEv2_IDr(IKEv2_Payload):  # RFC 7296, section 3.5
     name = "IKEv2 Identification - Responder"
-    overload_fields = {IKEv2: {"next_payload": 36}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "ID", "H", adjust=lambda pkt, x:x + 8),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         ByteEnumField("IDtype", 1, {1: "IPv4_addr", 2: "FQDN", 3: "Email_addr", 5: "IPv6_addr", 11: "Key"}),  # noqa: E501
         X3BytesField("res2", 0),
         MultipleTypeField(
             [
-                (IPField("ID", "127.0.0.1"), lambda x: x.IDtype == 1),
-                (IP6Field("ID", "::1"), lambda x: x.IDtype == 5),
+                (IPField("ID", "127.0.0.1"), lambda pkt: pkt.IDtype == 1),
+                (IP6Field("ID", "::1"), lambda pkt: pkt.IDtype == 5),
             ],
-            StrLenField("ID", "", length_from=lambda x: x.length - 8),
+            XStrLenField("ID", "", length_from=lambda pkt: pkt.length - 8),
         )
     ]
 
 
-class IKEv2_payload_Encrypted(IKEv2_class):
+class IKEv2_Encrypted(IKEv2_Payload):
     name = "IKEv2 Encrypted and Authenticated"
-    overload_fields = {IKEv2: {"next_payload": 46}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 4),
-        StrLenField("load", "", length_from=lambda x:x.length - 4),
-    ]
 
 
 class ConfigurationAttribute(Packet):
     name = "IKEv2 Configuration Attribute"
     fields_desc = [
         ShortEnumField("type", 1, IKEv2ConfigurationAttributeTypes),
         FieldLenField("length", None, "value", "H"),
         MultipleTypeField(
             [
                 (IPField("value", "127.0.0.1"),
-                 lambda x: x.length == 4 and x.type in (1, 2, 3, 4, 6, 20)),
+                 lambda pkt: pkt.length == 4 and pkt.type in (1, 2, 3, 4, 6, 20)),
                 (IP6Field("value", "::1"),
-                 lambda x: x.length == 16 and x.type in (10, 12, 21)),
+                 lambda pkt: pkt.length == 16 and pkt.type in (10, 12, 21)),
             ],
-            StrLenField("value", "", length_from=lambda x: x.length),
+            XStrLenField("value", "", length_from=lambda pkt: pkt.length),
         )
     ]
 
     def extract_padding(self, s):
         return b'', s
 
 
-class IKEv2_payload_CP(IKEv2_class):  # RFC 7296, section 3.15
+class IKEv2_CP(IKEv2_Payload):  # RFC 7296, section 3.15
     name = "IKEv2 Configuration"
-    overload_fields = {IKEv2: {"next_payload": 46}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x:x + 8),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         ByteEnumField("CFGType", 1, IKEv2ConfigurationPayloadCFGTypes),
         X3BytesField("res2", 0),
         PacketListField("attributes", None, ConfigurationAttribute,
-                        length_from=lambda x: x.length - 8),
+                        length_from=lambda pkt: pkt.length - 8),
     ]
 
 
-class IKEv2_payload_Encrypted_Fragment(IKEv2_class):
-    name = "IKEv2 Encrypted Fragment"
-    overload_fields = {IKEv2: {"next_payload": 53}}
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "load", "H", adjust=lambda pkt, x: x + 8),  # noqa: E501
+class IKEv2_Encrypted_Fragment(IKEv2_Payload):
+    name = "IKEv2 Encrypted and Authenticated Fragment"
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
         ShortField("frag_number", 1),
         ShortField("frag_total", 1),
-        StrLenField("load", "", length_from=lambda x: x.length - 8),
+        XStrLenField("load", "", length_from=lambda pkt: pkt.length - 8),
     ]
 
 
-class IKEv2_payload_CERTREQ(IKEv2_class):
+class IKEv2_CERTREQ(IKEv2_Payload):
     name = "IKEv2 Certificate Request"
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "cert_data", "H", adjust=lambda pkt, x:x + 5),  # noqa: E501
-        ByteEnumField("cert_type", 0, IKEv2CertificateEncodings),
-        StrLenField("cert_data", "", length_from=lambda x:x.length - 5),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        ByteEnumField("cert_encoding", 0, IKEv2CertificateEncodings),
+        XStrLenField("cert_authority", "", length_from=lambda pkt: pkt.length - 5),
     ]
 
 
-class IKEv2_payload_CERT(IKEv2_class):
-    @classmethod
-    def dispatch_hook(cls, _pkt=None, *args, **kargs):
-        if _pkt and len(_pkt) >= 16:
-            ts_type = struct.unpack("!B", _pkt[4:5])[0]
-            if ts_type == 4:
-                return IKEv2_payload_CERT_CRT
-            elif ts_type == 7:
-                return IKEv2_payload_CERT_CRL
-            else:
-                return IKEv2_payload_CERT_STR
-        return IKEv2_payload_CERT_STR
-
-
-class IKEv2_payload_CERT_CRT(IKEv2_payload_CERT):
+class IKEv2_CERT(IKEv2_Payload):
     name = "IKEv2 Certificate"
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "x509Cert", "H", adjust=lambda pkt, x: x + 5),  # noqa: E501
-        ByteEnumField("cert_type", 4, IKEv2CertificateEncodings),
-        PacketLenField("x509Cert", X509_Cert(''), X509_Cert, length_from=lambda x:x.length - 5),  # noqa: E501
-    ]
-
-
-class IKEv2_payload_CERT_CRL(IKEv2_payload_CERT):
-    name = "IKEv2 Certificate"
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "x509CRL", "H", adjust=lambda pkt, x: x + 5),  # noqa: E501
-        ByteEnumField("cert_type", 7, IKEv2CertificateEncodings),
-        PacketLenField("x509CRL", X509_CRL(''), X509_CRL, length_from=lambda x:x.length - 5),  # noqa: E501
-    ]
-
-
-class IKEv2_payload_CERT_STR(IKEv2_payload_CERT):
-    name = "IKEv2 Certificate"
-    fields_desc = [
-        ByteEnumField("next_payload", None, IKEv2_payload_type),
-        ByteField("res", 0),
-        FieldLenField("length", None, "cert_data", "H", adjust=lambda pkt, x: x + 5),  # noqa: E501
-        ByteEnumField("cert_type", 0, IKEv2CertificateEncodings),
-        StrLenField("cert_data", "", length_from=lambda x:x.length - 5),
+    fields_desc = IKEv2_Payload.fields_desc[:3] + [
+        ByteEnumField("cert_encoding", 4, IKEv2CertificateEncodings),
+        MultipleTypeField(
+            [
+                (PacketLenField("cert_data", X509_Cert(), X509_Cert,
+                                length_from=lambda pkt: pkt.length - 5),
+                 lambda pkt: pkt.cert_encoding == 4),
+                (PacketLenField("cert_data", X509_CRL(), X509_CRL,
+                                length_from=lambda pkt: pkt.length - 5),
+                 lambda pkt: pkt.cert_encoding == 7)
+            ],
+            XStrLenField("cert_data", "", length_from=lambda pkt: pkt.length - 5),
+        )
     ]
 
 
-IKEv2_payload_type_overload = {}
-for i, payloadname in enumerate(IKEv2_payload_type):
-    name = "IKEv2_payload_%s" % payloadname
-    if name in globals():
-        IKEv2_payload_type_overload[globals()[name]] = {"next_payload": i}
-
-del i, payloadname, name
-IKEv2_class._overload_fields = IKEv2_payload_type_overload.copy()
-
-# the upper bindings for port 500 to ISAKMP are handled by IKEv2.dispatch_hook
-split_bottom_up(UDP, ISAKMP, dport=500)
-split_bottom_up(UDP, ISAKMP, sport=500)
-
-bind_bottom_up(UDP, IKEv2, dport=500)
-bind_bottom_up(UDP, IKEv2, sport=500)
-bind_top_down(UDP, IKEv2, dport=500, sport=500)
-
+# TODO: the following payloads are not fully dissected yet
 
-split_layers(UDP, ESP, dport=4500)  # NAT-Traversal encapsulation
-split_layers(UDP, ESP, sport=4500)  # NAT-Traversal encapsulation
+class IKEv2_EAP(IKEv2_Payload):
+    name = "IKEv2 Extensible Authentication"
 
 
-# TODO: the bindings for NAT-traversal (UDP encapsulation on port 4500)
-#       actually belong into the scapy.layers.ipsec module. They will
-#       be moved there as soon as the IKEv2 protocol has been promoted
-#       from scapy.contrib to scapy.layers.
-
-class UDP_ENCAP(Packet):  # RFC 3948
-    """
-    UDP Encapsulation of IPsec ESP Packets [RFC3948] (for NAT-Traversal)
-    """
-    name = 'UDP_ENCAP'
+class IKEv2_GSPM(IKEv2_Payload):
+    name = "Generic Secure Password Method"
 
-    @classmethod
-    def dispatch_hook(cls, _pkt=None, *args, **kargs):
-        if _pkt:
-            if len(_pkt) >= 4 and struct.unpack("!I", _pkt[0:4])[0] == 0x00:
-                return NON_ESP
-            elif len(_pkt) == 1 and struct.unpack("!B", _pkt)[0] == 0xff:
-                return NAT_KEEPALIVE
-            else:
-                return ESP
-        return cls
 
+class IKEv2_IDg(IKEv2_Payload):
+    name = "Group Identification"
 
-class NON_ESP(Packet):  # RFC 3948, section 2.2
 
-    fields_desc = [
-        XIntField("non_esp", 0x0)
-    ]
+class IKEv2_GSA(IKEv2_Payload):
+    name = "Group Security Association"
 
-    def guess_payload_class(self, payload):
-        return IKEv2
 
+class IKEv2_KD(IKEv2_Payload):
+    name = "Key Download"
 
-class NAT_KEEPALIVE(Packet):  # RFC 3948, section 2.2
 
-    fields_desc = [
-        XByteField("nat_keepalive", 0xFF)
-    ]
+class IKEv2_PS(IKEv2_Payload):
+    name = "Puzzle Solution"
 
-    def guess_payload_class(self, payload):
-        return conf.raw_layer
 
+# bind all IKEv2 payload classes together
+bind_layers(_IKEv2_Packet, IKEv2_Proposal, next_payload=2)
+bind_layers(_IKEv2_Packet, IKEv2_Transform, next_payload=3)
+bind_layers(_IKEv2_Packet, IKEv2_SA, next_payload=33)
+bind_layers(_IKEv2_Packet, IKEv2_KE, next_payload=34)
+bind_layers(_IKEv2_Packet, IKEv2_IDi, next_payload=35)
+bind_layers(_IKEv2_Packet, IKEv2_IDr, next_payload=36)
+bind_layers(_IKEv2_Packet, IKEv2_CERT, next_payload=37)
+bind_layers(_IKEv2_Packet, IKEv2_CERTREQ, next_payload=38)
+bind_layers(_IKEv2_Packet, IKEv2_AUTH, next_payload=39)
+bind_layers(_IKEv2_Packet, IKEv2_Nonce, next_payload=40)
+bind_layers(_IKEv2_Packet, IKEv2_Notify, next_payload=41)
+bind_layers(_IKEv2_Packet, IKEv2_Delete, next_payload=42)
+bind_layers(_IKEv2_Packet, IKEv2_VendorID, next_payload=43)
+bind_layers(_IKEv2_Packet, IKEv2_TSi, next_payload=44)
+bind_layers(_IKEv2_Packet, IKEv2_TSr, next_payload=45)
+bind_layers(_IKEv2_Packet, IKEv2_Encrypted, next_payload=46)
+bind_layers(_IKEv2_Packet, IKEv2_CP, next_payload=47)
+bind_layers(_IKEv2_Packet, IKEv2_EAP, next_payload=48)
+bind_layers(_IKEv2_Packet, IKEv2_GSPM, next_payload=49)
+bind_layers(_IKEv2_Packet, IKEv2_IDg, next_payload=50)
+bind_layers(_IKEv2_Packet, IKEv2_GSA, next_payload=51)
+bind_layers(_IKEv2_Packet, IKEv2_KD, next_payload=52)
+bind_layers(_IKEv2_Packet, IKEv2_Encrypted_Fragment, next_payload=53)
+bind_layers(_IKEv2_Packet, IKEv2_PS, next_payload=54)
 
-split_layers(UDP, ESP, dport=4500)
-split_layers(UDP, ESP, sport=4500)
+# the upper bindings for port 500 to ISAKMP are handled by IKEv2.dispatch_hook
+split_bottom_up(UDP, ISAKMP, dport=500)
+split_bottom_up(UDP, ISAKMP, sport=500)
 
-bind_bottom_up(UDP, UDP_ENCAP, dport=4500)
-bind_bottom_up(UDP, UDP_ENCAP, sport=4500)
+bind_bottom_up(UDP, IKEv2, dport=500)
+bind_bottom_up(UDP, IKEv2, sport=500)
+bind_top_down(UDP, IKEv2, dport=500, sport=500)
 
-bind_top_down(UDP, ESP, dport=4500, sport=4500)
-bind_top_down(UDP, NON_ESP, dport=4500, sport=4500)
-bind_top_down(UDP, NAT_KEEPALIVE, dport=4500, sport=4500)
+split_bottom_up(NON_ESP, ISAKMP)
+bind_bottom_up(NON_ESP, IKEv2)
 
 
 def ikev2scan(ip, **kwargs):
     """Send a IKEv2 SA to an IP and wait for answers."""
     return sr(IP(dst=ip) / UDP() / IKEv2(init_SPI=RandString(8),
-                                         exch_type=34) / IKEv2_payload_SA(prop=IKEv2_payload_Proposal()), **kwargs)  # noqa: E501
+                                         exch_type=34) / IKEv2_SA(prop=IKEv2_Proposal()), **kwargs)  # noqa: E501
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/isis.py` & `scapy-2.6.0rc1/scapy/contrib/isis.py`

 * *Files 0% similar despite different names*

```diff
@@ -38,15 +38,14 @@
           * RFC 5305 (traffic engineering)
           * RFC 5307 (support for G-MPLS)
           * RFC 5310 (generic cryptographic authentication)
           * RFC 5316 (inter-AS MPLS and G-MPLS TE)
 
 """
 
-from __future__ import absolute_import
 import struct
 import random
 
 from scapy.config import conf
 from scapy.fields import BitField, BitFieldLenField, BoundStrLenField, \
     ByteEnumField, ByteField, ConditionalField, Field, FieldLenField, \
     FieldListField, FlagsField, IEEEFloatField, IP6PrefixField, IPField, \
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/isotp/__init__.py` & `scapy-2.6.0rc1/scapy/contrib/isotp/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,36 +5,38 @@
 
 # scapy.contrib.description = ISO-TP (ISO 15765-2)
 # scapy.contrib.status = loads
 
 import logging
 
 from scapy.consts import LINUX
-import scapy.libs.six as six
 from scapy.config import conf
 from scapy.error import log_loading
 
 from scapy.contrib.isotp.isotp_packet import ISOTP, ISOTPHeader, \
-    ISOTPHeaderEA, ISOTP_SF, ISOTP_FF, ISOTP_CF, ISOTP_FC
+    ISOTPHeaderEA, ISOTP_SF, ISOTP_FF, ISOTP_CF, ISOTP_FC, \
+    ISOTP_FF_FD, ISOTP_SF_FD, ISOTPHeaderEA_FD, ISOTPHeader_FD
 from scapy.contrib.isotp.isotp_utils import ISOTPSession, \
     ISOTPMessageBuilder
 from scapy.contrib.isotp.isotp_soft_socket import ISOTPSoftSocket
 from scapy.contrib.isotp.isotp_scanner import isotp_scan
 
 __all__ = ["ISOTP", "ISOTPHeader", "ISOTPHeaderEA", "ISOTP_SF", "ISOTP_FF",
-           "ISOTP_CF", "ISOTP_FC", "ISOTPSoftSocket", "ISOTPSession",
+           "ISOTP_CF", "ISOTP_FC", "ISOTP_FF_FD", "ISOTP_SF_FD",
+           "ISOTPSoftSocket", "ISOTPSession", "ISOTPHeader_FD",
+           "ISOTPHeaderEA_FD",
            "ISOTPSocket", "ISOTPMessageBuilder", "isotp_scan",
            "USE_CAN_ISOTP_KERNEL_MODULE", "log_isotp"]
 
 USE_CAN_ISOTP_KERNEL_MODULE = False
 
 log_isotp = logging.getLogger("scapy.contrib.isotp")
 log_isotp.setLevel(logging.INFO)
 
-if six.PY3 and LINUX:
+if LINUX:
     try:
         if conf.contribs['ISOTP']['use-can-isotp-kernel-module']:
             USE_CAN_ISOTP_KERNEL_MODULE = True
     except KeyError:
         log_loading.info(
             "Specify 'conf.contribs['ISOTP'] = {'use-can-isotp-kernel-module': True}' "  # noqa: E501
             "to enable usage of can-isotp kernel module.")
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/isotp/isotp_native_socket.py` & `scapy-2.6.0rc1/scapy/contrib/isotp/isotp_native_socket.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,26 +7,34 @@
 # scapy.contrib.status = library
 
 import ctypes
 from ctypes.util import find_library
 import struct
 import socket
 
-from scapy.compat import Optional, Union, Tuple, Type, cast
 from scapy.contrib.isotp import log_isotp
 from scapy.packet import Packet
-import scapy.libs.six as six
 from scapy.error import Scapy_Exception
 from scapy.supersocket import SuperSocket
 from scapy.data import SO_TIMESTAMPNS
 from scapy.config import conf
 from scapy.arch.linux import get_last_packet_timestamp, SIOCGIFINDEX
 from scapy.contrib.isotp.isotp_packet import ISOTP
 from scapy.layers.can import CAN_MTU, CAN_FD_MTU, CAN_MAX_DLEN, CAN_FD_MAX_DLEN
 
+# Typing imports
+from typing import (
+    Any,
+    Optional,
+    Union,
+    Tuple,
+    Type,
+    cast,
+)
+
 LIBC = ctypes.cdll.LoadLibrary(find_library("c"))  # type: ignore
 
 CAN_ISOTP = 6  # ISO 15765-2 Transport Protocol
 
 SOL_CAN_BASE = 100  # from can.h
 SOL_CAN_ISOTP = SOL_CAN_BASE + CAN_ISOTP
 # /* for socket options affecting the socket (not the global system) */
@@ -293,15 +301,15 @@
                  listen_only=False,  # type: bool
                  frame_txtime=CAN_ISOTP_DEFAULT_FRAME_TXTIME,  # type: int
                  fd=False,  # type: bool
                  basecls=ISOTP  # type: Type[Packet]
                  ):
         # type: (...) -> None
 
-        if not isinstance(iface, six.string_types):
+        if not isinstance(iface, str):
             # This is for interoperability with ISOTPSoftSockets.
             # If a NativeCANSocket is provided, the interface name of this
             # socket is extracted and an ISOTPNativeSocket will be opened
             # on this interface.
             iface = cast(SuperSocket, iface)
             if hasattr(iface, "ins") and hasattr(iface.ins, "getsockname"):
                 iface = iface.ins.getsockname()
@@ -368,25 +376,31 @@
             # something bad happened (e.g. the interface went down)
             log_isotp.warning("Captured no data. %s" % e)
             if e.errno == 84:
                 log_isotp.warning("Maybe a consecutive frame was missed. "
                                   "Increasing `stmin` could solve this problem.")
             elif e.errno == 110:
                 log_isotp.warning('Captured no data, socket read timed out.')
+            elif e.errno == 70:
+                log_isotp.warning(
+                    'Communication error on send. '
+                    'TX path flowcontrol reception timeout.')
             else:
+                log_isotp.error(
+                    'Unknown error code received %d. Closing socket!', e.errno)
                 self.close()
             return None, None, None
 
-        if ts is None:
+        if pkt and ts is None:
             ts = get_last_packet_timestamp(self.ins)
         return self.basecls, pkt, ts
 
-    def recv(self, x=0xffff):
-        # type: (int) -> Optional[Packet]
-        msg = SuperSocket.recv(self, x)
+    def recv(self, x=0xffff, **kwargs):
+        # type: (int, **Any) -> Optional[Packet]
+        msg = SuperSocket.recv(self, x, **kwargs)
         if msg is None:
             return msg
 
         if hasattr(msg, "tx_id"):
             msg.tx_id = self.tx_id
         if hasattr(msg, "rx_id"):
             msg.rx_id = self.rx_id
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/isotp/isotp_scanner.py` & `scapy-2.6.0rc1/scapy/contrib/isotp/isotp_scanner.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,29 +1,39 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 # Copyright (C) Alexander Schroeder <alexander1.schroeder@st.othr.de>
-
+import itertools
+import json
 # scapy.contrib.description = ISO-TP (ISO 15765-2) Scanner Utility
 # scapy.contrib.status = library
 import logging
 import time
 
 from threading import Event
 
-from scapy.compat import Iterable, Optional, Union, List, Tuple, Dict
 from scapy.packet import Packet
 from scapy.compat import orb
 from scapy.layers.can import CAN
 from scapy.supersocket import SuperSocket
 from scapy.contrib.cansocket import PYTHON_CAN
 from scapy.contrib.isotp.isotp_packet import ISOTPHeader, ISOTPHeaderEA, \
     ISOTP_FF, ISOTP
 
+# Typing imports
+from typing import (
+    Any,
+    Dict,
+    Iterable,
+    List,
+    Optional,
+    Tuple,
+    Union,
+)
 
 log_isotp = logging.getLogger("scapy.contrib.isotp")
 
 
 def send_multiple_ext(sock, ext_id, packet, number_of_packets):
     # type: (SuperSocket, int, Packet, int) -> None
     """Send multiple packets with extended addresses at once.
@@ -52,15 +62,15 @@
     :param identifier: identifier of crafted packet
     :param extended: boolean if packet uses extended address
     :param extended_can_id: boolean if CAN should use extended Ids
     :return: Crafted Packet
     """
 
     if extended:
-        pkt = ISOTPHeaderEA() / ISOTP_FF()
+        pkt = ISOTPHeaderEA() / ISOTP_FF()  # type: Packet
         pkt.extended_address = 0
         pkt.data = b'\x00\x00\x00\x00\x00'
     else:
         pkt = ISOTPHeader() / ISOTP_FF()
         pkt.data = b'\x00\x00\x00\x00\x00\x00'
     if extended_can_id:
         pkt.flags = "extended"
@@ -190,24 +200,24 @@
                                                 noise_ids, False, pkt),
                    timeout=sniff_time, store=False)
 
     if not verify_results:
         return return_values
 
     cleaned_ret_val = dict()  # type: Dict[int, Tuple[Packet, int]]
-    for tested_id in return_values.keys():
+    retest_ids = list(set(
+        itertools.chain.from_iterable(
+            range(max(0, i - 2), i + 2) for i in return_values.keys())))
+    for value in retest_ids:
         if stop_event is not None and stop_event.is_set():
             break
-        for value in range(max(0, tested_id - 2), tested_id + 2, 1):
-            if stop_event is not None and stop_event.is_set():
-                break
-            sock.send(get_isotp_packet(value, False, extended_can_id))
-            sock.sniff(prn=lambda pkt: get_isotp_fc(value, cleaned_ret_val,
-                                                    noise_ids, False, pkt),
-                       timeout=sniff_time * 10, store=False)
+        sock.send(get_isotp_packet(value, False, extended_can_id))
+        sock.sniff(prn=lambda pkt: get_isotp_fc(value, cleaned_ret_val,
+                                                noise_ids, False, pkt),
+                   timeout=sniff_time * 10, store=False)
 
     return cleaned_ret_val
 
 
 def scan_extended(sock,  # type: SuperSocket
                   scan_range=range(0x800),  # type: Iterable[int]
                   scan_block_size=32,  # type: int
@@ -233,23 +243,23 @@
                        after sending a first frame
     :param extended_can_id: Send extended can frames
     :param stop_event: Event object to asynchronously stop the scan
     :return: Dictionary with all found packets
     """
     return_values = dict()  # type: Dict[int, Tuple[Packet, int]]
     scan_block_size = scan_block_size or 1
+    r = list(extended_scan_range)
 
     for value in scan_range:
         if noise_ids and value in noise_ids:
             continue
 
         pkt = get_isotp_packet(
             value, extended=True, extended_can_id=extended_can_id)
         id_list = []  # type: List[int]
-        r = list(extended_scan_range)
         for ext_isotp_id in range(r[0], r[-1], scan_block_size):
             if stop_event is not None and stop_event.is_set():
                 break
             send_multiple_ext(sock, ext_isotp_id, pkt, scan_block_size)
             sock.sniff(prn=lambda p: get_isotp_fc(ext_isotp_id, id_list,
                                                   noise_ids, True, p),
                        timeout=sniff_time * 3, store=False)
@@ -294,14 +304,15 @@
     """Scan for ISOTP Sockets on a bus and return findings
 
     Scan for ISOTP Sockets in the defined range and returns found sockets
     in a specified format. The format can be:
 
     - text: human readable output
     - code: python code for copy&paste
+    - json: json string
     - sockets: if output format is not specified, ISOTPSockets will be
       created and returned in a list
 
     :param sock: CANSocket object to communicate with the bus under scan
     :param scan_range: range of CAN-Identifiers to scan. Default is 0x0 - 0x7ff
     :param extended_addressing: scan with ISOTP extended addressing
     :param extended_scan_range: range for ISOTP extended addressing values
@@ -356,14 +367,18 @@
     if output_format == "text":
         return generate_text_output(found_packets, extended_addressing)
 
     if output_format == "code":
         return generate_code_output(found_packets, can_interface,
                                     extended_addressing)
 
+    if output_format == "json":
+        return generate_json_output(found_packets, can_interface,
+                                    extended_addressing)
+
     return generate_isotp_list(found_packets, can_interface or sock,
                                extended_addressing)
 
 
 def generate_text_output(found_packets, extended_addressing=False):
     # type: (Dict[int, Tuple[Packet, int]], bool) -> str
     """Generate a human readable output from the result of the `scan` or the
@@ -450,14 +465,57 @@
                       "basecls=ISOTP)\n" % \
                       (can_interface, pack,
                        int(found_packets[pack][0].identifier),
                        found_packets[pack][0].length == 8)
     return header + result
 
 
+def generate_json_output(found_packets,  # type: Dict[int, Tuple[Packet, int]]
+                         can_interface="iface",  # type: Optional[str]
+                         extended_addressing=False  # type: bool
+                         ):
+    # type: (...) -> str
+    """Generate a list of ISOTPSocket objects from the result of the `scan` or
+    the `scan_extended` function.
+
+    :param found_packets: result of the `scan` or `scan_extended` function
+    :param can_interface: description string for a CAN interface to be
+                          used for the creation of the output.
+    :param extended_addressing: print results from a scan with ISOTP
+                                extended addressing
+    :return: A list of all found ISOTPSockets
+    """
+    socket_list = []  # type: List[Dict[str, Any]]
+    for pack in found_packets:
+        pkt = found_packets[pack][0]
+
+        dest_id = pkt.identifier
+        pad = True if pkt.length == 8 else False
+
+        if extended_addressing:
+            source_id = pack >> 8
+            source_ext = int(pack - (source_id * 256))
+            dest_ext = orb(pkt.data[0])
+            socket_list.append({"iface": can_interface,
+                                "tx_id": source_id,
+                                "ext_address": source_ext,
+                                "rx_id": dest_id,
+                                "rx_ext_address": dest_ext,
+                                "padding": pad,
+                                "basecls": ISOTP.__name__})
+        else:
+            source_id = pack
+            socket_list.append({"iface": can_interface,
+                                "tx_id": source_id,
+                                "rx_id": dest_id,
+                                "padding": pad,
+                                "basecls": ISOTP.__name__})
+    return json.dumps(socket_list)
+
+
 def generate_isotp_list(found_packets,  # type: Dict[int, Tuple[Packet, int]]
                         can_interface,  # type: Union[SuperSocket, str]
                         extended_addressing=False  # type: bool
                         ):
     # type: (...) -> List[SuperSocket]
     """Generate a list of ISOTPSocket objects from the result of the `scan` or
     the `scan_extended` function.
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/isotp/isotp_soft_socket.py` & `scapy-2.6.0rc1/scapy/contrib/isotp/isotp_soft_socket.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,29 +10,39 @@
 import struct
 import time
 import traceback
 import heapq
 import socket
 
 from threading import Thread, Event, RLock
+from bisect import bisect_left
 
-from scapy.compat import Optional, Union, List, Tuple, Any, Type, cast, \
-    Callable, TYPE_CHECKING
 from scapy.packet import Packet
 from scapy.layers.can import CAN
-import scapy.libs.six as six
 from scapy.error import Scapy_Exception
 from scapy.supersocket import SuperSocket
 from scapy.config import conf
 from scapy.consts import LINUX
 from scapy.utils import EDecimal
 from scapy.automaton import ObjectPipe, select_objects
 from scapy.contrib.isotp.isotp_packet import ISOTP, CAN_MAX_DLEN, N_PCI_SF, \
-    N_PCI_CF, N_PCI_FC, N_PCI_FF, ISOTP_MAX_DLEN, ISOTP_MAX_DLEN_2015
+    N_PCI_CF, N_PCI_FC, N_PCI_FF, ISOTP_MAX_DLEN, ISOTP_MAX_DLEN_2015, CAN_FD_MAX_DLEN
 
+# Typing imports
+from typing import (
+    Optional,
+    Union,
+    List,
+    Tuple,
+    Any,
+    Type,
+    cast,
+    Callable,
+    TYPE_CHECKING,
+)
 if TYPE_CHECKING:
     from scapy.contrib.cansocket import CANSocket
 
 log_isotp = logging.getLogger("scapy.contrib.isotp")
 
 # Enum states
 ISOTP_IDLE = 0
@@ -99,53 +109,55 @@
                   Flow Control ISOTP frames
     :param padding: If True, pads sending packets with 0x00 which not
                     count to the payload.
                     Does not affect receiving packets.
     :param listen_only: Does not send Flow Control frames if a First Frame is
                         received
     :param basecls: base class of the packets emitted by this socket
+    :param fd: enables the CanFD support for this socket
     """  # noqa: E501
 
-    nonblocking_socket = True
-
     def __init__(self,
                  can_socket=None,  # type: Optional["CANSocket"]
                  tx_id=0,  # type: int
                  rx_id=0,  # type: int
                  ext_address=None,  # type: Optional[int]
                  rx_ext_address=None,  # type: Optional[int]
                  bs=0,  # type: int
                  stmin=0,  # type: int
                  padding=False,  # type: bool
                  listen_only=False,  # type: bool
-                 basecls=ISOTP  # type: Type[Packet]
+                 basecls=ISOTP,  # type: Type[Packet]
+                 fd=False  # type: bool
                  ):
         # type: (...) -> None
 
-        if six.PY3 and LINUX and isinstance(can_socket, six.string_types):
+        if LINUX and isinstance(can_socket, str):
             from scapy.contrib.cansocket_native import NativeCANSocket
-            can_socket = NativeCANSocket(can_socket)
-        elif isinstance(can_socket, six.string_types):
+            can_socket = NativeCANSocket(can_socket, fd=fd)
+        elif isinstance(can_socket, str):
             raise Scapy_Exception("Provide a CANSocket object instead")
 
         self.ext_address = ext_address
         self.rx_ext_address = rx_ext_address or ext_address
         self.tx_id = tx_id
         self.rx_id = rx_id
+        self.fd = fd
 
         impl = ISOTPSocketImplementation(
             can_socket,
             tx_id=self.tx_id,
             rx_id=self.rx_id,
             padding=padding,
             ext_address=self.ext_address,
             rx_ext_address=self.rx_ext_address,
             bs=bs,
             stmin=stmin,
-            listen_only=listen_only
+            listen_only=listen_only,
+            fd=fd
         )
 
         # Cast for compatibility to functions from SuperSocket.
         self.ins = cast(socket.socket, impl)
         self.outs = cast(socket.socket, impl)
         self.impl = impl
         self.basecls = basecls
@@ -170,17 +182,17 @@
         first frame in the receive buffer or None if there isn't any."""
         if not self.closed:
             tup = self.impl.recv()
             if tup is not None:
                 return self.basecls, tup[0], float(tup[1])
         return self.basecls, None, None
 
-    def recv(self, x=0xffff):
-        # type: (int) -> Optional[Packet]
-        msg = super(ISOTPSoftSocket, self).recv(x)
+    def recv(self, x=0xffff, **kwargs):
+        # type: (int, **Any) -> Optional[Packet]
+        msg = super(ISOTPSoftSocket, self).recv(x, **kwargs)
         if msg is None:
             return None
 
         if hasattr(msg, "tx_id"):
             msg.tx_id = self.tx_id
         if hasattr(msg, "rx_id"):
             msg.rx_id = self.rx_id
@@ -212,14 +224,16 @@
     _mutex = RLock()
     _event = Event()
     _thread = None  # type: Optional[Thread]
 
     # use heapq functions on _handles!
     _handles = []  # type: List[TimeoutScheduler.Handle]
 
+    logger = logging.getLogger("scapy.contrib.automotive.timeout_scheduler")
+
     @classmethod
     def schedule(cls, timeout, callback):
         # type: (float, Callable[[], None]) -> TimeoutScheduler.Handle
         """Schedules the execution of a timeout.
 
         The function `callback` will be called in `timeout` seconds.
 
@@ -300,34 +314,34 @@
             to_wait = cls.GRACE
         else:
             to_wait = handle._when - now
 
         # Wait until the next timeout,
         # or until event.set() gets called in another thread.
         if to_wait > 0:
-            log_isotp.debug("TimeoutScheduler Thread going to sleep @ %f " +
-                            "for %fs", now, to_wait)
+            cls.logger.debug("Thread going to sleep @ %f " +
+                             "for %fs", now, to_wait)
             interrupted = cls._event.wait(to_wait)
             new = cls._time()
-            log_isotp.debug("TimeoutScheduler Thread awake @ %f, slept for" +
-                            " %f, interrupted=%d", new, new - now,
-                            interrupted)
+            cls.logger.debug("Thread awake @ %f, slept for" +
+                             " %f, interrupted=%d", new, new - now,
+                             interrupted)
 
         # Clear the event so that we can wait on it again,
         # Must be done before doing the callbacks to avoid losing a set().
         cls._event.clear()
 
     @classmethod
     def _task(cls):
         # type: () -> None
         """Executed in a background thread, this thread will automatically
         start when the first timeout is added and stop when the last timeout
         is removed or executed."""
 
-        log_isotp.debug("TimeoutScheduler Thread spawning @ %f", cls._time())
+        cls.logger.debug("Thread spawning @ %f", cls._time())
 
         time_empty = None
 
         try:
             while 1:
                 handle = cls._peek_next()
                 if handle is None:
@@ -341,15 +355,15 @@
                     time_empty = None
                 cls._wait(handle)
                 cls._poll()
 
         finally:
             # Worst case scenario: if this thread dies, the next scheduled
             # timeout will start a new one
-            log_isotp.debug("TimeoutScheduler Thread died @ %f", cls._time())
+            cls.logger.debug("Thread died @ %f", cls._time())
             cls._thread = None
 
     @classmethod
     def _poll(cls):
         # type: () -> None
         """Execute all the callbacks that were due until now"""
 
@@ -363,26 +377,24 @@
                 # Time complexity is O(log n)
                 handle = heapq.heappop(cls._handles)
                 callback = None
                 if handle is not None:
                     callback = handle._cb
                     handle._cb = True
 
-            # Call the callback here, outside of the mutex
+            # Call the callback here, outside the mutex
             if callable(callback):
                 try:
                     callback()
                 except Exception:
                     traceback.print_exc()
 
     @staticmethod
     def _time():
         # type: () -> float
-        if six.PY2:
-            return time.time()
         return time.monotonic()
 
     class Handle:
         """Handle for a timeout, consisting of a callback and a time when it
         should be executed."""
         __slots__ = ['_when', '_cb']
 
@@ -477,24 +489,29 @@
                  tx_id,  # type: int
                  rx_id,  # type: int
                  padding=False,  # type: bool
                  ext_address=None,  # type: Optional[int]
                  rx_ext_address=None,  # type: Optional[int]
                  bs=0,  # type: int
                  stmin=0,  # type: int
-                 listen_only=False  # type: bool
+                 listen_only=False,  # type: bool
+                 fd=False  # type: bool
                  ):
         # type: (...) -> None
         self.can_socket = can_socket
         self.rx_id = rx_id
         self.tx_id = tx_id
         self.padding = padding
         self.fc_timeout = 1
         self.cf_timeout = 1
 
+        self.fd = fd
+
+        self.max_dlen = CAN_FD_MAX_DLEN if fd else CAN_MAX_DLEN
+
         self.filter_warning_emitted = False
         self.closed = False
 
         self.rx_ext_address = rx_ext_address
         self.ea_hdr = b""
         if ext_address is not None:
             self.ea_hdr = struct.pack("B", ext_address)
@@ -511,15 +528,15 @@
         self.rx_idx = 0
         self.rx_ts = 0.0  # type: Union[float, EDecimal]
         self.rx_state = ISOTP_IDLE
 
         self.tx_queue = ObjectPipe[bytes]()
         self.txfc_bs = 0
         self.txfc_stmin = 0
-        self.tx_gap = 0
+        self.tx_gap = 0.
 
         self.tx_buf = None  # type: Optional[bytes]
         self.tx_sn = 0
         self.tx_bs = 0
         self.tx_idx = 0
         self.rx_ll_dl = 0
         self.tx_state = ISOTP_IDLE
@@ -544,16 +561,29 @@
 
     def __del__(self):
         # type: () -> None
         self.close()
 
     def can_send(self, load):
         # type: (bytes) -> None
+        def _get_padding_size(pl_size):
+            # type: (int) -> int
+            if not self.fd:
+                return CAN_MAX_DLEN
+            else:
+                fd_accepted_sizes = [0, 8, 12, 16, 20, 24, 32, 48, 64]
+                pos = bisect_left(fd_accepted_sizes, pl_size)
+                if pos == 0:
+                    return fd_accepted_sizes[0]
+                if pos == len(fd_accepted_sizes):
+                    return fd_accepted_sizes[-1]
+                return fd_accepted_sizes[pos]
+
         if self.padding:
-            load += b"\xCC" * (CAN_MAX_DLEN - len(load))
+            load += b"\xCC" * (_get_padding_size(len(load)) - len(load))
         if self.tx_id is None or self.tx_id <= 0x7ff:
             self.can_socket.send(CAN(identifier=self.tx_id, data=load))
         else:
             self.can_socket.send(CAN(identifier=self.tx_id, flags="extended",
                                      data=load))
 
     def can_recv(self):
@@ -635,15 +665,15 @@
             # reset tx state
             self.tx_state = ISOTP_IDLE
             log_isotp.warning("TX state was reset due to timeout")
             return
         elif self.tx_state == ISOTP_SENDING:
             # push out the next segmented pdu
             src_off = len(self.ea_hdr)
-            max_bytes = 7 - src_off
+            max_bytes = (self.max_dlen - 1) - src_off
             if self.tx_buf is None:
                 self.tx_state = ISOTP_IDLE
                 log_isotp.warning("TX buffer is not filled")
                 return
             while 1:
                 load = self.ea_hdr
                 load += struct.pack("B", N_PCI_CF + self.tx_sn)
@@ -685,18 +715,18 @@
             return
 
         ae = 0
         if self.rx_ext_address is not None:
             ae = 1
             if len(data) < 3:
                 return
-            if six.indexbytes(data, 0) != self.rx_ext_address:
+            if data[0] != self.rx_ext_address:
                 return
 
-        n_pci = six.indexbytes(data, ae) & 0xf0
+        n_pci = data[ae] & 0xf0
 
         if n_pci == N_PCI_FC:
             self._recv_fc(data[ae:])
         elif n_pci == N_PCI_SF:
             self._recv_sf(data[ae:], cf.time)
         elif n_pci == N_PCI_FF:
             self._recv_ff(data[ae:], cf.time)
@@ -719,32 +749,31 @@
         if len(data) < 3:
             self.tx_state = ISOTP_IDLE
             log_isotp.warning("CF frame discarded because it was too short")
             return
 
         # get communication parameters only from the first FC frame
         if self.tx_state == ISOTP_WAIT_FIRST_FC:
-            self.txfc_bs = six.indexbytes(data, 1)
-            self.txfc_stmin = six.indexbytes(data, 2)
+            self.txfc_bs = data[1]
+            self.txfc_stmin = data[2]
 
         if ((self.txfc_stmin > 0x7F) and
                 ((self.txfc_stmin < 0xF1) or (self.txfc_stmin > 0xF9))):
             self.txfc_stmin = 0x7F
 
-        if six.indexbytes(data, 2) <= 127:
-            tx_gap = six.indexbytes(data, 2) / 1000.0
-        elif 0xf1 <= six.indexbytes(data, 2) <= 0xf9:
-            tx_gap = (six.indexbytes(data, 2) & 0x0f) / 10000.0
+        if data[2] <= 127:
+            self.tx_gap = data[2] / 1000
+        elif 0xf1 <= data[2] <= 0xf9:
+            self.tx_gap = (data[2] & 0x0f) / 10000
         else:
-            tx_gap = 0
-        self.tx_gap = tx_gap
+            self.tx_gap = 0.
 
         self.tx_state = ISOTP_WAIT_FC
 
-        isotp_fc = six.indexbytes(data, 0) & 0x0f
+        isotp_fc = data[0] & 0x0f
 
         if isotp_fc == ISOTP_FC_CTS:
             self.tx_bs = 0
             self.tx_state = ISOTP_SENDING
             # start cyclic timer for sending CF frame
             self.tx_timeout_handle = TimeoutScheduler.schedule(
                 self.tx_gap, self._tx_timer_handler)
@@ -774,19 +803,28 @@
 
         if self.rx_state != ISOTP_IDLE:
             if conf.verb > 2:
                 log_isotp.warning("RX state was reset because "
                                   "single frame was received")
             self.rx_state = ISOTP_IDLE
 
-        length = six.indexbytes(data, 0) & 0xf
+        length = data[0] & 0xf
+        is_fd_frame = self.fd and length == 0 and len(data) >= 2
+
+        if is_fd_frame:
+            length = data[1]
+
         if len(data) - 1 < length:
             return
 
-        msg = data[1:1 + length]
+        msg = None
+        if is_fd_frame:
+            msg = data[2:2 + length]
+        else:
+            msg = data[1:1 + length]
         self.rx_queue.send((msg, ts))
 
     def _recv_ff(self, data, ts):
         # type: (bytes, Union[float, EDecimal]) -> None
         """Process a received 'First Frame' frame"""
         log_isotp.debug("Processing FF")
 
@@ -800,25 +838,24 @@
             self.rx_state = ISOTP_IDLE
 
         if len(data) < 7:
             return
         self.rx_ll_dl = len(data)
 
         # get the FF_DL
-        self.rx_len = (six.indexbytes(data, 0) & 0x0f) * 256 + six.indexbytes(
-            data, 1)
+        self.rx_len = (data[0] & 0x0f) * 256 + data[1]
         ff_pci_sz = 2
 
         # Check for FF_DL escape sequence supporting 32 bit PDU length
         if self.rx_len == 0:
             # FF_DL = 0 => get real length from next 4 bytes
-            self.rx_len = six.indexbytes(data, 2) << 24
-            self.rx_len += six.indexbytes(data, 3) << 16
-            self.rx_len += six.indexbytes(data, 4) << 8
-            self.rx_len += six.indexbytes(data, 5)
+            self.rx_len = data[2] << 24
+            self.rx_len += data[3] << 16
+            self.rx_len += data[4] << 8
+            self.rx_len += data[5]
             ff_pci_sz = 6
 
         # copy the first received data bytes
         data_bytes = data[ff_pci_sz:]
         self.rx_idx = len(data_bytes)
         self.rx_buf = data_bytes
         self.rx_ts = ts
@@ -859,15 +896,15 @@
         if len(data) < self.rx_ll_dl:
             # this is only allowed for the last CF
             if self.rx_len - self.rx_idx > self.rx_ll_dl:
                 if conf.verb > 2:
                     log_isotp.warning("Received a CF with insufficient length")
                 return
 
-        if six.indexbytes(data, 0) & 0x0f != self.rx_sn:
+        if data[0] & 0x0f != self.rx_sn:
             # Wrong sequence number
             if conf.verb > 2:
                 log_isotp.warning("RX state was reset because wrong sequence "
                                   "number was received")
             self.rx_state = ISOTP_IDLE
             return
 
@@ -915,30 +952,35 @@
             return
 
         self.tx_state = ISOTP_SENDING
         length = len(x)
         if length > ISOTP_MAX_DLEN_2015:
             log_isotp.warning("Too much data for ISOTP message")
 
-        if len(self.ea_hdr) + length <= 7:
+        sf_size_check = self.max_dlen - 1
+
+        if len(self.ea_hdr) + length + int(self.fd) <= sf_size_check:
             # send a single frame
             data = self.ea_hdr
-            data += struct.pack("B", length)
+            if not self.fd or length <= 7:
+                data += struct.pack("B", length)
+            else:
+                data += struct.pack("BB", 0, length)
             data += x
             self.tx_state = ISOTP_IDLE
             self.can_send(data)
             return
 
         # send the first frame
         data = self.ea_hdr
         if length > ISOTP_MAX_DLEN:
             data += struct.pack(">HI", 0x1000, length)
         else:
             data += struct.pack(">H", 0x1000 | length)
-        load = x[0:8 - len(data)]
+        load = x[0:self.max_dlen - len(data)]
         data += load
         self.can_send(data)
 
         self.tx_buf = x
         self.tx_sn = 1
         self.tx_bs = 0
         self.tx_idx = len(load)
@@ -968,13 +1010,9 @@
         # type: (bytes) -> None
         """Send an ISOTP frame and block until the message is sent or an error
         happens."""
         self.tx_queue.send(p)
 
     def recv(self, timeout=None):
         # type: (Optional[int]) -> Optional[Tuple[bytes, Union[float, EDecimal]]]  # noqa: E501
-        """Receive an ISOTP frame, blocking if none is available in the buffer
-        for at most 'timeout' seconds."""
-        try:
-            return self.rx_queue.recv()
-        except IndexError:
-            return None
+        """Receive an ISOTP frame, blocking if none is available in the buffer."""
+        return self.rx_queue.recv()
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/isotp/isotp_utils.py` & `scapy-2.6.0rc1/scapy/sessions.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,342 +1,394 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
-# Copyright (C) Nils Weiss <nils@we155.de>
-# Copyright (C) Enrico Pozzobon <enricopozzobon@gmail.com>
-# Copyright (C) Alexander Schroeder <alexander1.schroeder@st.othr.de>
 
-# scapy.contrib.description = ISO-TP (ISO 15765-2) Utilities
-# scapy.contrib.status = library
+"""
+Sessions: decode flow of packets when sniffing
+"""
 
+from collections import defaultdict
+import socket
 import struct
 
-from scapy.compat import Iterable, Optional, Union, List, Tuple, Dict, Any, \
-    Type
-from scapy.utils import EDecimal
-from scapy.packet import Packet
-from scapy.sessions import DefaultSession
-from scapy.contrib.isotp.isotp_packet import ISOTP, N_PCI_CF, N_PCI_SF, \
-    N_PCI_FF, N_PCI_FC
-import scapy.libs.six as six
+from scapy.compat import orb
+from scapy.config import conf
+from scapy.packet import NoPayload, Packet
+from scapy.pton_ntop import inet_pton
+
+# Typing imports
+from typing import (
+    Any,
+    Callable,
+    DefaultDict,
+    Dict,
+    Iterator,
+    List,
+    Optional,
+    Tuple,
+    Type,
+    cast,
+    TYPE_CHECKING,
+)
+from scapy.compat import Self
+if TYPE_CHECKING:
+    from scapy.supersocket import SuperSocket
+
+
+class DefaultSession(object):
+    """Default session: no stream decoding"""
+
+    def __init__(self, supersession: Optional[Self] = None):
+        if supersession and not isinstance(supersession, DefaultSession):
+            supersession = supersession()
+        self.supersession = supersession
 
+    def process(self, pkt: Packet) -> Optional[Packet]:
+        """
+        Called to pre-process the packet
+        """
+        # Optionally handle supersession
+        if self.supersession:
+            return self.supersession.process(pkt)
+        return pkt
 
-class ISOTPMessageBuilderIter(object):
-    """
-    Iterator class for ISOTPMessageBuilder
-    """
-    slots = ["builder"]
-
-    def __init__(self, builder):
-        # type: (ISOTPMessageBuilder) -> None
-        self.builder = builder
-
-    def __iter__(self):
-        # type: () -> ISOTPMessageBuilderIter
-        return self
-
-    def __next__(self):
-        # type: () -> ISOTP
-        while self.builder.count:
-            p = self.builder.pop()
-            if p is None:
-                break
-            else:
-                return p
-        raise StopIteration
-
-    next = __next__
-
-
-class ISOTPMessageBuilder(object):
-    """
-    Initialize a ISOTPMessageBuilder object
-
-    Utility class to build ISOTP messages out of CAN frames, used by both
-    ISOTP.defragment() and ISOTPSession.
-
-    This class attempts to interpret some CAN frames as ISOTP frames, both with
-    and without extended addressing at the same time. For example, if an
-    extended address of 07 is being used, all frames will also be interpreted
-    as ISOTP single-frame messages.
-
-    CAN frames are fed to an ISOTPMessageBuilder object with the feed() method
-    and the resulting ISOTP frames can be extracted using the pop() method.
-
-    :param use_ext_address: True for only attempting to defragment with
-                         extended addressing, False for only attempting
-                         to defragment without extended addressing,
-                         or None for both
-    :param rx_id: Destination Identifier
-    :param basecls: The class of packets that will be returned,
-                    defaults to ISOTP
-    """
-
-    class Bucket(object):
+    def recv(self, sock: 'SuperSocket') -> Iterator[Packet]:
         """
-        Helper class to store not finished ISOTP messages while building.
+        Will be called by sniff() to ask for a packet
         """
+        pkt = sock.recv()
+        if not pkt:
+            return
+        pkt = self.process(pkt)
+        if pkt:
+            yield pkt
 
-        def __init__(self, total_len, first_piece, ts):
-            # type: (int, bytes, Union[EDecimal, float]) -> None
-            self.pieces = list()  # type: List[bytes]
-            self.total_len = total_len
-            self.current_len = 0
-            self.ready = None  # type: Optional[bytes]
-            self.tx_id = None  # type: Optional[int]
-            self.ext_address = None  # type: Optional[int]
-            self.time = ts  # type: Union[float, EDecimal]
-            self.push(first_piece)
-
-        def push(self, piece):
-            # type: (bytes) -> None
-            self.pieces.append(piece)
-            self.current_len += len(piece)
-            if self.current_len >= self.total_len:
-                if six.PY3:
-                    isotp_data = b"".join(self.pieces)
-                else:
-                    isotp_data = "".join(map(str, self.pieces))
-                self.ready = isotp_data[:self.total_len]
 
-    def __init__(
-            self,
-            use_ext_address=None,  # type: Optional[bool]
-            rx_id=None,  # type: Optional[Union[int, List[int], Iterable[int]]]
-            basecls=ISOTP  # type: Type[Packet]
-    ):
-        # type: (...) -> None
-        self.ready = []  # type: List[Tuple[int, Optional[int], ISOTPMessageBuilder.Bucket]]  # noqa: E501
-        self.buckets = {}  # type: Dict[Tuple[Optional[int], int, int], ISOTPMessageBuilder.Bucket]  # noqa: E501
-        self.use_ext_addr = use_ext_address
-        self.basecls = basecls
-        self.rx_ids = None  # type: Optional[Iterable[int]]
-        self.last_ff = None  # type: Optional[Tuple[Optional[int], int, int]]
-        self.last_ff_ex = None  # type: Optional[Tuple[Optional[int], int, int]]  # noqa: E501
-        if rx_id is not None:
-            if isinstance(rx_id, list):
-                self.rx_ids = rx_id
-            elif isinstance(rx_id, int):
-                self.rx_ids = [rx_id]
-            elif hasattr(rx_id, "__iter__"):
-                self.rx_ids = rx_id
-            else:
-                raise TypeError("Invalid type for argument rx_id!")
+class IPSession(DefaultSession):
+    """Defragment IP packets 'on-the-flow'.
 
-    def feed(self, can):
-        # type: (Union[Iterable[Packet], Packet]) -> None
-        """Attempt to feed an incoming CAN frame into the state machine"""
-        if not isinstance(can, Packet) and hasattr(can, "__iter__"):
-            for p in can:
-                self.feed(p)
-            return
+    Usage:
+    >>> sniff(session=IPSession)
+    """
 
-        if not isinstance(can, Packet):
-            return
+    def __init__(self, *args, **kwargs):
+        # type: (*Any, **Any) -> None
+        DefaultSession.__init__(self, *args, **kwargs)
+        self.fragments = defaultdict(list)  # type: DefaultDict[Tuple[Any, ...], List[Packet]]  # noqa: E501
+
+    def process(self, packet: Packet) -> Optional[Packet]:
+        from scapy.layers.inet import IP, _defrag_ip_pkt
+        if not packet:
+            return None
+        if IP not in packet:
+            return packet
+        return _defrag_ip_pkt(packet, self.fragments)[1]  # type: ignore
 
-        if self.rx_ids is not None and can.identifier not in self.rx_ids:
-            return
 
-        data = bytes(can.data)
+class StringBuffer(object):
+    """StringBuffer is an object used to re-order data received during
+    a TCP transmission.
 
-        if len(data) > 1 and self.use_ext_addr is not True:
-            self._try_feed(can.identifier, None, data, can.time)
-        if len(data) > 2 and self.use_ext_addr is not False:
-            ea = six.indexbytes(data, 0)
-            self._try_feed(can.identifier, ea, data[1:], can.time)
+    Each TCP fragment contains a sequence number, which marks
+    (relatively to the first sequence number) the index of the data contained
+    in the fragment.
 
-    @property
-    def count(self):
-        # type: () -> int
-        """Returns the number of ready ISOTP messages built from the provided
-        can frames
+    If a TCP fragment is missed, this class will fill the missing space with
+    zeros.
+    """
 
-        :return: Number of ready ISOTP messages
-        """
-        return len(self.ready)
+    def __init__(self):
+        # type: () -> None
+        self.content = bytearray(b"")
+        self.content_len = 0
+        self.noff = 0  # negative offset
+        self.incomplete = []  # type: List[Tuple[int, int]]
+
+    def append(self, data: bytes, seq: Optional[int] = None) -> None:
+        data_len = len(data)
+        if seq is None:
+            seq = self.content_len
+        seq = seq - 1 - self.noff
+        if seq < 0:
+            # Data is located before the start of the current buffer
+            # (e.g. the first fragment was missing)
+            self.content = bytearray(b"\x00" * (-seq)) + self.content
+            self.content_len += (-seq)
+            self.noff += seq
+            seq = 0
+        if seq + data_len > self.content_len:
+            # Data is located after the end of the current buffer
+            self.content += b"\x00" * (seq - self.content_len + data_len)
+            # As data was missing, mark it.
+            # self.incomplete.append((self.content_len, seq))
+            self.content_len = seq + data_len
+            assert len(self.content) == self.content_len
+        # XXX removes empty space marker.
+        # for ifrag in self.incomplete:
+        #     if [???]:
+        #         self.incomplete.remove([???])
+        memoryview(self.content)[seq:seq + data_len] = data
+
+    def shiftleft(self, i: int) -> None:
+        self.content = self.content[i:]
+        self.content_len -= i
+
+    def full(self):
+        # type: () -> bool
+        # Should only be true when all missing data was filled up,
+        # (or there never was missing data)
+        return True  # XXX
+
+    def clear(self):
+        # type: () -> None
+        self.__init__()  # type: ignore
+
+    def __bool__(self):
+        # type: () -> bool
+        return bool(self.content_len)
+    __nonzero__ = __bool__
 
     def __len__(self):
         # type: () -> int
-        return self.count
+        return self.content_len
 
-    def pop(self, identifier=None, ext_addr=None):
-        # type: (Optional[int], Optional[int]) -> Optional[Packet]
-        """Returns a built ISOTP message
-
-        :param identifier: if not None, only return isotp messages with this
-                           destination
-        :param ext_addr: if identifier is not None, only return isotp messages
-                         with this extended address for destination
-        :returns: an ISOTP packet, or None if no message is ready
-        """
+    def __bytes__(self):
+        # type: () -> bytes
+        return bytes(self.content)
 
-        if identifier is not None:
-            for i in range(len(self.ready)):
-                b = self.ready[i]
-                iden = b[0]
-                ea = b[1]
-                if iden == identifier and ext_addr == ea:
-                    return ISOTPMessageBuilder._build(self.ready.pop(i),
-                                                      self.basecls)
-            return None
+    def __str__(self):
+        # type: () -> str
+        return cast(str, self.__bytes__())
 
-        if len(self.ready) > 0:
-            return ISOTPMessageBuilder._build(self.ready.pop(0), self.basecls)
-        return None
 
-    def __iter__(self):
-        # type: () -> ISOTPMessageBuilderIter
-        return ISOTPMessageBuilderIter(self)
-
-    @staticmethod
-    def _build(
-            t,  # type: Tuple[int, Optional[int], ISOTPMessageBuilder.Bucket]
-            basecls=ISOTP  # type: Type[Packet]
-    ):
-        # type: (...) -> Packet
-        bucket = t[2]
-        data = bucket.ready or b""
-        p = basecls(data)
-        if hasattr(p, "rx_id"):
-            p.rx_id = t[0]
-        if hasattr(p, "rx_ext_address"):
-            p.rx_ext_address = t[1]
-        if hasattr(p, "tx_id"):
-            p.tx_id = bucket.tx_id
-        if hasattr(p, "ext_address"):
-            p.ext_address = bucket.ext_address
-        if hasattr(p, "time"):
-            p.time = bucket.time
-        return p
-
-    def _feed_first_frame(self, identifier, ea, data, ts):
-        # type: (int, Optional[int], bytes, Union[EDecimal, float]) -> bool
-        if len(data) < 3:
-            # At least 3 bytes are necessary: 2 for length and 1 for data
-            return False
-
-        header = struct.unpack('>H', bytes(data[:2]))[0]
-        expected_length = header & 0x0fff
-        isotp_data = data[2:]
-        if expected_length == 0 and len(data) >= 6:
-            expected_length = struct.unpack('>I', bytes(data[2:6]))[0]
-            isotp_data = data[6:]
-
-        key = (ea, identifier, 1)
-        if ea is None:
-            self.last_ff = key
-        else:
-            self.last_ff_ex = key
-        self.buckets[key] = self.Bucket(expected_length, isotp_data, ts)
-        return True
-
-    def _feed_single_frame(self, identifier, ea, data, ts):
-        # type: (int, Optional[int], bytes, Union[EDecimal, float]) -> bool
-        if len(data) < 2:
-            # At least 2 bytes are necessary: 1 for length and 1 for data
-            return False
-
-        length = six.indexbytes(data, 0) & 0x0f
-        isotp_data = data[1:length + 1]
-
-        if length > len(isotp_data):
-            # CAN frame has less data than expected
-            return False
-
-        self.ready.append((identifier, ea,
-                           self.Bucket(length, isotp_data, ts)))
-        return True
-
-    def _feed_consecutive_frame(self, identifier, ea, data):
-        # type: (int, Optional[int], bytes) -> bool
-        if len(data) < 2:
-            # At least 2 bytes are necessary: 1 for sequence number and
-            # 1 for data
-            return False
-
-        first_byte = six.indexbytes(data, 0)
-        seq_no = first_byte & 0x0f
-        isotp_data = data[1:]
-
-        key = (ea, identifier, seq_no)
-        bucket = self.buckets.pop(key, None)
-
-        if bucket is None:
-            # There is no message constructor waiting for this frame
-            return False
-
-        bucket.push(isotp_data)
-        if bucket.ready is None:
-            # full ISOTP message is not ready yet, put it back in
-            # buckets list
-            next_seq = (seq_no + 1) % 16
-            key = (ea, identifier, next_seq)
-            self.buckets[key] = bucket
-        else:
-            self.ready.append((identifier, ea, bucket))
+def streamcls(cls: Type[Packet]) -> Callable[
+    [bytes, Dict[str, Any], Dict[str, Any]],
+    Optional[Packet],
+]:
+    """
+    Wraps a class for use when dissecting streams.
+    """
+    if hasattr(cls, "tcp_reassemble"):
+        return cls.tcp_reassemble  # type: ignore
+    else:
+        # There is no tcp_reassemble. Just dissect the packet
+        return lambda data, *_: data and cls(data)
+
+
+class TCPSession(IPSession):
+    """A Session that reconstructs TCP streams.
+
+    NOTE: this has the same effect as wrapping a real socket.socket into StreamSocket,
+    but for all concurrent TCP streams (can be used on pcaps or sniffed sessions).
+
+    NOTE: only protocols that implement a ``tcp_reassemble`` function will be processed
+    by this session. Other protocols will not be reconstructed.
+
+    DEV: implement a class-function `tcp_reassemble` in your Packet class::
+
+        @classmethod
+        def tcp_reassemble(cls, data, metadata, session):
+            # data = the reassembled data from the same request/flow
+            # metadata = empty dictionary, that can be used to store data
+            #            during TCP reassembly
+            # session = a dictionary proper to the bidirectional TCP session,
+            #           that can be used to store anything
+            [...]
+            # If the packet is available, return it. Otherwise don't.
+            # Whenever you return a packet, the buffer will be discarded.
+            return pkt
+            # Otherwise, maybe store stuff in metadata, and return None,
+            # as you need additional data.
+            return None
 
-        return True
+    For more details and a real example, see:
+    https://scapy.readthedocs.io/en/latest/usage.html#how-to-use-tcpsession-to-defragment-tcp-packets
 
-    def _feed_flow_control_frame(self, identifier, ea, data):
-        # type: (int, Optional[int], bytes) -> bool
-        if len(data) < 3:
-            # At least 2 bytes are necessary: 1 for sequence number and
-            # 1 for data
-            return False
-
-        keys = [x for x in (self.last_ff, self.last_ff_ex) if x is not None]
-        buckets = [self.buckets.pop(k, None) for k in keys]
-
-        self.last_ff = None
-        self.last_ff_ex = None
-
-        if not any(buckets) or not any(keys):
-            # There is no message constructor waiting for this frame
-            return False
-
-        for key, bucket in zip(keys, buckets):
-            if bucket is None:
-                continue
-            bucket.tx_id = identifier
-            bucket.ext_address = ea
-            self.buckets[key] = bucket
-        return True
-
-    def _try_feed(self, identifier, ea, data, ts):
-        # type: (int, Optional[int], bytes, Union[EDecimal, float]) -> None
-        first_byte = six.indexbytes(data, 0)
-        if len(data) > 1 and first_byte & 0xf0 == N_PCI_SF:
-            self._feed_single_frame(identifier, ea, data, ts)
-        if len(data) > 2 and first_byte & 0xf0 == N_PCI_FF:
-            self._feed_first_frame(identifier, ea, data, ts)
-        if len(data) > 1 and first_byte & 0xf0 == N_PCI_CF:
-            self._feed_consecutive_frame(identifier, ea, data)
-        if len(data) > 1 and first_byte & 0xf0 == N_PCI_FC:
-            self._feed_flow_control_frame(identifier, ea, data)
+    :param app: Whether the socket is on application layer = has no TCP
+                layer. This is identical to StreamSocket so only use this if your
+                underlying source of data isn't a socket.socket.
+    """
 
+    def __init__(self, app=False, *args, **kwargs):
+        # type: (bool, *Any, **Any) -> None
+        super(TCPSession, self).__init__(*args, **kwargs)
+        self.app = app
+        if app:
+            self.data = StringBuffer()
+            self.metadata = {}  # type: Dict[str, Any]
+            self.session = {}  # type: Dict[str, Any]
+        else:
+            # The StringBuffer() is used to build a global
+            # string from fragments and their seq nulber
+            self.tcp_frags = defaultdict(
+                lambda: (StringBuffer(), {})
+            )  # type: DefaultDict[bytes, Tuple[StringBuffer, Dict[str, Any]]]
+            self.tcp_sessions = defaultdict(
+                dict
+            )  # type: DefaultDict[bytes, Dict[str, Any]]
+        # Setup stopping dissection condition
+        from scapy.layers.inet import TCP
+        self.stop_dissection_after = TCP
+
+    def _get_ident(self, pkt, session=False):
+        # type: (Packet, bool) -> bytes
+        underlayer = pkt["TCP"].underlayer
+        af = socket.AF_INET6 if "IPv6" in pkt else socket.AF_INET
+        src = underlayer and inet_pton(af, underlayer.src) or b""
+        dst = underlayer and inet_pton(af, underlayer.dst) or b""
+        if session:
+            # Bidirectional
+            def xor(x, y):
+                # type: (bytes, bytes) -> bytes
+                return bytes(orb(a) ^ orb(b) for a, b in zip(x, y))
+            return struct.pack("!4sH", xor(src, dst), pkt.dport ^ pkt.sport)
+        else:
+            # Uni-directional
+            return src + dst + struct.pack("!HH", pkt.dport, pkt.sport)
 
-class ISOTPSession(DefaultSession):
-    """Defragment ISOTP packets 'on-the-flow'.
+    def _strip_padding(self, pkt: Packet) -> Optional[bytes]:
+        """Strip the packet of any padding, and return the padding.
+        """
+        pad = pkt.getlayer(conf.padding_layer)
+        if pad is not None and pad.underlayer is not None:
+            # strip padding
+            del pad.underlayer.payload
+            return cast(bytes, pad.load)
+        return None
 
-    Usage:
-        >>> sniff(session=ISOTPSession)
-    """
+    def process(self,
+                pkt: Packet,
+                cls: Optional[Type[Packet]] = None) -> Optional[Packet]:
+        """Process each packet: matches the TCP seq/ack numbers
+        to follow the TCP streams, and orders the fragments.
+        """
+        packet = None  # type: Optional[Packet]
+        if self.app:
+            # Special mode: Application layer. Use on top of TCP
+            self.data.append(bytes(pkt))
+            if cls is None and not isinstance(pkt, bytes):
+                cls = pkt.__class__
+            if "tcp_reassemble" in self.metadata:
+                tcp_reassemble = self.metadata["tcp_reassemble"]
+            elif cls is not None:
+                self.metadata["tcp_reassemble"] = tcp_reassemble = streamcls(cls)
+            else:
+                return None
+            packet = tcp_reassemble(
+                bytes(self.data),
+                self.metadata,
+                self.session,
+            )
+            if packet:
+                padding = self._strip_padding(packet)
+                if padding:
+                    # There is remaining data for the next payload.
+                    self.data.shiftleft(len(self.data) - len(padding))
+                else:
+                    # No padding (data) left. Clear
+                    self.data.clear()
+                self.metadata.clear()
+                return packet
+            return None
 
-    def __init__(self, *args, **kwargs):
-        # type: (Any, Any) -> None
-        super(ISOTPSession, self).__init__(*args, **kwargs)
-        self.m = ISOTPMessageBuilder(
-            use_ext_address=kwargs.pop("use_ext_address", None),
-            rx_id=kwargs.pop("rx_id", None),
-            basecls=kwargs.pop("basecls", ISOTP))
+        _pkt = super(TCPSession, self).process(pkt)
+        if _pkt is None:
+            return None
+        else:  # Python 3.8 := would be nice
+            pkt = _pkt
 
-    def on_packet_received(self, pkt):
-        # type: (Optional[Packet]) -> None
+        from scapy.layers.inet import IP, TCP
         if not pkt:
-            return
-        self.m.feed(pkt)
-        while len(self.m) > 0:
-            rcvd = self.m.pop()
-            if self._supersession:
-                self._supersession.on_packet_received(rcvd)
+            return None
+        if TCP not in pkt:
+            return pkt
+        pay = pkt[TCP].payload
+        if isinstance(pay, (NoPayload, conf.padding_layer)):
+            return pkt
+        new_data = pay.original
+        # Match packets by a unique TCP identifier
+        ident = self._get_ident(pkt)
+        data, metadata = self.tcp_frags[ident]
+        tcp_session = self.tcp_sessions[self._get_ident(pkt, True)]
+        # Handle TCP sequence numbers
+        seq = pkt[TCP].seq
+        if "seq" not in metadata:
+            metadata["seq"] = seq
+        if "next_seq" in metadata and seq < metadata["next_seq"]:
+            # Retransmitted data (that we already returned)
+            new_data = new_data[metadata["next_seq"] - seq:]
+            if not new_data:
+                return None
+            seq = metadata["next_seq"]
+        # Let's guess which class is going to be used
+        if "pay_class" not in metadata:
+            metadata["pay_class"] = pay_class = pkt[TCP].guess_payload_class(new_data)
+            metadata["tcp_reassemble"] = tcp_reassemble = streamcls(pay_class)
+        else:
+            tcp_reassemble = metadata["tcp_reassemble"]
+        # Get a relative sequence number for a storage purpose
+        relative_seq = metadata.get("relative_seq", None)
+        if relative_seq is None:
+            relative_seq = metadata["relative_seq"] = seq - 1
+        seq = seq - relative_seq
+        # Add the data to the buffer
+        data.append(new_data, seq)
+        # Check TCP FIN or TCP RESET
+        if pkt[TCP].flags.F or pkt[TCP].flags.R:
+            metadata["tcp_end"] = True
+
+        # In case any app layer protocol requires it,
+        # allow the parser to inspect TCP PSH flag
+        if pkt[TCP].flags.P:
+            metadata["tcp_psh"] = True
+        # XXX TODO: check that no empty space is missing in the buffer.
+        # XXX Currently, if a TCP fragment was missing, we won't notice it.
+        if data.full():
+            # Reassemble using all previous packets
+            metadata["original"] = pkt
+            packet = tcp_reassemble(
+                bytes(data),
+                metadata,
+                tcp_session
+            )
+        # Stack the result on top of the previous frames
+        if packet:
+            if "seq" in metadata:
+                pkt[TCP].seq = metadata["seq"]
+            # Clear TCP reassembly metadata
+            metadata.clear()
+            # Check for padding
+            padding = self._strip_padding(packet)
+            if padding:
+                # There is remaining data for the next payload.
+                full_length = data.content_len - len(padding)
+                metadata["relative_seq"] = relative_seq + full_length
+                data.shiftleft(full_length)
             else:
-                super(ISOTPSession, self).on_packet_received(rcvd)
+                # No padding (data) left. Clear
+                data.clear()
+                del self.tcp_frags[ident]
+            # Minimum next seq
+            metadata["next_seq"] = pkt[TCP].seq + len(new_data)
+            # Rebuild resulting packet
+            pay.underlayer.remove_payload()
+            if IP in pkt:
+                pkt[IP].len = None
+                pkt[IP].chksum = None
+            pkt = pkt / packet
+            pkt.wirelen = None
+            return pkt
+        return None
+
+    def recv(self, sock: 'SuperSocket') -> Iterator[Packet]:
+        """
+        Will be called by sniff() to ask for a packet
+        """
+        pkt = sock.recv(stop_dissection_after=self.stop_dissection_after)
+        # Now handle TCP reassembly
+        while pkt is not None:
+            pkt = self.process(pkt)
+            if pkt:
+                yield pkt
+                # keep calling process as there might be more
+                pkt = b""  # type: ignore
+        return None
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/knx.py` & `scapy-2.6.0rc1/scapy/contrib/knx.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/lacp.py` & `scapy-2.6.0rc1/scapy/contrib/lacp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/ldp.py` & `scapy-2.6.0rc1/scapy/contrib/ldp.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,21 +9,27 @@
 """
 Label Distribution Protocol (LDP)
 
 http://git.savannah.gnu.org/cgit/ldpscapy.git/snapshot/ldpscapy-5285b81d6e628043df2a83301b292f24a95f0ba1.tar.gz
 
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.compat import orb
 from scapy.packet import Packet, bind_layers, bind_bottom_up
-from scapy.fields import BitField, IPField, IntField, ShortField, StrField, \
-    XBitField
+from scapy.fields import (
+    BitField,
+    MayEnd,
+    IPField,
+    IntField,
+    ShortField,
+    StrField,
+    XBitField,
+)
 from scapy.layers.inet import UDP
 from scapy.layers.inet import TCP
 from scapy.config import conf
 from scapy.utils import inet_aton, inet_ntoa
 
 
 class _LDP_Packet(Packet):
@@ -165,14 +171,16 @@
 
     def size(self, s):
         """Get the size of this field"""
         tmp_len = 4 + struct.unpack("!H", s[2:4])[0]
         return tmp_len
 
     def getfield(self, pkt, s):
+        if not s:
+            return s, []
         tmp_len = self.size(s)
         return s[tmp_len:], self.m2i(pkt, s[:tmp_len])
 
 
 # 3.4.6. Status TLV
 
 class StatusTLVField(StrField):
@@ -355,15 +363,15 @@
 
 class LDPLabelMM(_LDP_Packet):
     name = "LDPLabelMM"
     fields_desc = [BitField("u", 0, 1),
                    XBitField("type", 0x0400, 15),
                    ShortField("len", None),
                    IntField("id", 0),
-                   FecTLVField("fec", None),
+                   MayEnd(FecTLVField("fec", None)),
                    LabelTLVField("label", 0)]
 
 # 3.5.8. Label Request Message
 
 
 class LDPLabelReqM(_LDP_Packet):
     name = "LDPLabelReqM"
@@ -390,15 +398,15 @@
 
 class LDPLabelWM(_LDP_Packet):
     name = "LDPLabelWM"
     fields_desc = [BitField("u", 0, 1),
                    XBitField("type", 0x0402, 15),
                    ShortField("len", None),
                    IntField("id", 0),
-                   FecTLVField("fec", None),
+                   MayEnd(FecTLVField("fec", None)),
                    LabelTLVField("label", 0)]
 
 # 3.5.11. Label Release Message
 
 
 class LDPLabelRelM(_LDP_Packet):
     name = "LDPLabelRelM"
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/lldp.py` & `scapy-2.6.0rc1/scapy/contrib/lldp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/loraphy2wan.py` & `scapy-2.6.0rc1/scapy/contrib/loraphy2wan.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,20 +12,37 @@
 Initially developed @PentHertz
 and improved at @Trend Micro
 
 Spec: lorawantm_specification v1.1
 """
 
 from scapy.packet import Packet
-from scapy.fields import BitField, ByteEnumField, ByteField, \
-    ConditionalField, IntField, LEShortField, PacketListField, \
-    StrFixedLenField, X3BytesField, XByteField, XIntField, \
-    XShortField, BitFieldLenField, LEX3BytesField, XBitField, \
-    BitEnumField, XLEIntField, StrField, PacketField, \
-    MultipleTypeField
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    BitFieldLenField,
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    IntField,
+    LEShortField,
+    MayEnd,
+    MultipleTypeField,
+    PacketField,
+    PacketListField,
+    StrField,
+    StrFixedLenField,
+    X3BytesField,
+    XBitField,
+    XByteField,
+    XIntField,
+    XLE3BytesField,
+    XLEIntField,
+    XShortField,
+)
 
 
 class FCtrl_DownLink(Packet):
     name = "FCtrl_DownLink"
     fields_desc = [BitField("ADR", 0, 1),
                    BitField("ADRACKReq", 0, 1),
                    BitField("ACK", 0, 1),
@@ -59,15 +76,15 @@
     def extract_padding(self, p):
         return "", p
 
 
 class DevAddrElem(Packet):
     name = "DevAddrElem"
     fields_desc = [XByteField("NwkID", 0x0),
-                   LEX3BytesField("NwkAddr", b"\x00" * 3)]
+                   XLE3BytesField("NwkAddr", b"\x00" * 3)]
 
 
 CIDs_up = {0x01: "ResetInd",
            0x02: "LinkCheckReq",
            0x03: "LinkADRReq",
            0x04: "DutyCycleReq",
            0x05: "RXParamSetupReq",
@@ -588,16 +605,16 @@
                    StrFixedLenField("DevEUI", b"\00" * 8, 8),
                    LEShortField("DevNonce", 0x0000)]
 
 
 class Join_Accept(Packet):
     name = "Join_Accept"
     dcflist = False
-    fields_desc = [LEX3BytesField("JoinAppNonce", 0),
-                   LEX3BytesField("NetID", 0),
+    fields_desc = [XLE3BytesField("JoinAppNonce", 0),
+                   XLE3BytesField("NetID", 0),
                    XLEIntField("DevAddr", 0),
                    DLsettings,
                    XByteField("RxDelay", 0),
                    ConditionalField(StrFixedLenField("CFList", b"\x00" * 16, 16),  # noqa: E501
                                     lambda pkt:(Join_Accept.dcflist is True))]
 
     def extract_padding(self, p):
@@ -688,17 +705,17 @@
                    BitField("Major", 0b00, 2)]
 
 
 class PHYPayload(Packet):
     name = "PHYPayload"
     fields_desc = [MHDR,
                    MACPayload,
-                   ConditionalField(XIntField("MIC", 0),
-                                    lambda pkt:(pkt.MType != 0b001 or
-                                                LoRa.encrypted is False))]
+                   MayEnd(ConditionalField(XIntField("MIC", 0),
+                                           lambda pkt: (pkt.MType != 0b001 or
+                                                        LoRa.encrypted is False)))]
 
 
 class LoRa(Packet):  # default frame (unclear specs => taken from https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5677147/)  # noqa: E501
     name = "LoRa"
     version = "1.1"  # default version to parse
     encrypted = True
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/ltp.py` & `scapy-2.6.0rc1/scapy/contrib/ltp.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,14 @@
     and Article GP-51, Rights in Data  General, respectively.
     This software is publicly released under MITRE case #12-3054
 """
 
 # scapy.contrib.description = Licklider Transmission Protocol (LTP)
 # scapy.contrib.status = loads
 
-import scapy.libs.six as six
 from scapy.packet import Packet, bind_layers, bind_top_down
 from scapy.fields import BitEnumField, BitField, BitFieldLenField, \
     ByteEnumField, ConditionalField, PacketListField, StrLenField
 from scapy.layers.inet import UDP
 from scapy.config import conf
 from scapy.contrib.sdnv import SDNV2, SDNV2FieldLenField
 
@@ -96,15 +95,15 @@
                    SDNV2("ReceptionClaimLength", 0)]
 
     def default_payload_class(self, pay):
         return conf.padding_layer
 
 
 def _ltp_guess_payload(pkt, *args):
-    for k, v in six.iteritems(_ltp_payload_conditions):
+    for k, v in _ltp_payload_conditions.items():
         if v(pkt):
             return k
     return conf.raw_layer
 
 
 class LTP(Packet):
     name = "LTP"
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/mac_control.py` & `scapy-2.6.0rc1/scapy/contrib/mac_control.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/macsec.py` & `scapy-2.6.0rc1/scapy/contrib/macsec.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,31 +6,28 @@
 # scapy.contrib.description = 802.1AE - IEEE MAC Security standard (MACsec)
 # scapy.contrib.status = loads
 
 """
 Classes and functions for MACsec.
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 import struct
 import copy
 
 from scapy.config import conf
 from scapy.fields import BitField, ConditionalField, IntField, PacketField, \
     XShortEnumField
 from scapy.packet import Packet, Raw, bind_layers
 from scapy.layers.l2 import Ether, Dot1AD, Dot1Q
 from scapy.layers.eap import MACsecSCI
 from scapy.layers.inet import IP
 from scapy.layers.inet6 import IPv6
 from scapy.compat import raw
 from scapy.data import ETH_P_MACSEC, ETHER_TYPES, ETH_P_IP, ETH_P_IPV6
 from scapy.error import log_loading
-import scapy.libs.six as six
 
 if conf.crypto_valid:
     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives.ciphers import (
         Cipher,
         algorithms,
         modes,
@@ -48,49 +45,49 @@
 class MACsecSA(object):
     """Representation of a MACsec Secure Association
 
     Provides encapsulation, decapsulation, encryption, and decryption
     of MACsec frames
     """
     def __init__(self, sci, an, pn, key, icvlen, encrypt, send_sci, xpn_en=False, ssci=None, salt=None):  # noqa: E501
-        if isinstance(sci, six.integer_types):
+        if isinstance(sci, int):
             self.sci = struct.pack('!Q', sci)
         elif isinstance(sci, bytes):
             self.sci = sci
         else:
             raise TypeError("SCI must be either bytes or int")
         self.an = an
         self.pn = pn
         self.key = key
         self.icvlen = icvlen
         self.do_encrypt = encrypt
         self.send_sci = send_sci
         self.xpn_en = xpn_en
         if self.xpn_en:
             # Get SSCI (32 bits)
-            if isinstance(ssci, six.integer_types):
+            if isinstance(ssci, int):
                 self.ssci = struct.pack('!L', ssci)
             elif isinstance(ssci, bytes):
                 self.ssci = ssci
             else:
                 raise TypeError("SSCI must be either bytes or int")
             # Get Salt (96 bits, only bytes allowed)
             if isinstance(salt, bytes):
                 self.salt = salt
             else:
                 raise TypeError("Salt must be bytes")
 
     def make_iv(self, pkt):
         """generate an IV for the packet"""
         if self.xpn_en:
-            tmp_pn = (self.pn & 0xFFFFFFFF00000000) | (pkt[MACsec].pn & 0xFFFFFFFF)  # noqa: E501
+            tmp_pn = (self.pn & 0xFFFFFFFF00000000) | (pkt[MACsec].PN & 0xFFFFFFFF)  # noqa: E501
             tmp_iv = self.ssci + struct.pack('!Q', tmp_pn)
             return bytes(bytearray([a ^ b for a, b in zip(bytearray(tmp_iv), bytearray(self.salt))]))  # noqa: E501
         else:
-            return self.sci + struct.pack('!I', pkt[MACsec].pn)
+            return self.sci + struct.pack('!I', pkt[MACsec].PN)
 
     @staticmethod
     def split_pkt(pkt, assoclen, icvlen=0):
         """
         split the packet into associated data, plaintext or ciphertext, and
         optional ICV
         """
@@ -123,19 +120,19 @@
     def encap(self, pkt):
         """encapsulate a frame using this Secure Association"""
         if pkt.name != Ether().name:
             raise TypeError('cannot encapsulate packet in MACsec, must be Ethernet')  # noqa: E501
         hdr = copy.deepcopy(pkt)
         payload = hdr.payload
         del hdr.payload
-        tag = MACsec(sci=self.sci, an=self.an,
+        tag = MACsec(SCI=self.sci, AN=self.an,
                      SC=self.send_sci,
                      E=self.e_bit(), C=self.c_bit(),
-                     shortlen=MACsecSA.shortlen(pkt),
-                     pn=(self.pn & 0xFFFFFFFF), type=pkt.type)
+                     SL=MACsecSA.shortlen(pkt),
+                     PN=(self.pn & 0xFFFFFFFF), type=pkt.type)
         hdr.type = ETH_P_MACSEC
         return hdr / tag / payload
 
     # this doesn't really need to be a method, but for symmetry with
     # encap(), it is
     def decap(self, orig_pkt):
         """decapsulate a MACsec frame"""
@@ -240,17 +237,17 @@
             lambda pkt: pkt.SC
         ),
         # Off-spec. Used for conveniency (only present if passed manually)
         ConditionalField(XShortEnumField("type", None, ETHER_TYPES),
                          lambda pkt: "type" in pkt.fields)]
 
     def mysummary(self):
-        summary = self.sprintf("an=%MACsec.an%, pn=%MACsec.pn%")
+        summary = self.sprintf("AN=%MACsec.AN%, PN=%MACsec.PN%")
         if self.SC:
-            summary += self.sprintf(", sci=%MACsec.sci%")
+            summary += self.sprintf(", SCI=%MACsec.SCI%")
         if self.type is not None:
             summary += self.sprintf(", %MACsec.type%")
         return summary
 
 
 bind_layers(MACsec, IP, type=ETH_P_IP)
 bind_layers(MACsec, IPv6, type=ETH_P_IPV6)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/metawatch.py` & `scapy-2.6.0rc1/scapy/contrib/metawatch.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/modbus.py` & `scapy-2.6.0rc1/scapy/contrib/modbus.py`

 * *Files 1% similar despite different names*

```diff
@@ -680,35 +680,35 @@
 }
 
 
 class ModbusPDUReservedFunctionCodeRequest(_ModbusPDUNoPayload):
     name = "Reserved Function Code Request"
     fields_desc = [
         ByteEnumField("funcCode", 0x00, _reserved_funccode_request),
-        StrFixedLenField('payload', '', 255), ]
+        StrFixedLenField('mb_payload', '', 255), ]
 
     def mysummary(self):
         return self.sprintf("Modbus Reserved Request %funcCode%")
 
 
 class ModbusPDUReservedFunctionCodeResponse(_ModbusPDUNoPayload):
     name = "Reserved Function Code Response"
     fields_desc = [
         ByteEnumField("funcCode", 0x00, _reserved_funccode_response),
-        StrFixedLenField('payload', '', 255), ]
+        StrFixedLenField('mb_payload', '', 255), ]
 
     def mysummary(self):
         return self.sprintf("Modbus Reserved Response %funcCode%")
 
 
 class ModbusPDUReservedFunctionCodeError(_ModbusPDUNoPayload):
     name = "Reserved Function Code Error"
     fields_desc = [
         ByteEnumField("funcCode", 0x00, _reserved_funccode_error),
-        StrFixedLenField('payload', '', 255), ]
+        StrFixedLenField('mb_payload', '', 255), ]
 
     def mysummary(self):
         return self.sprintf("Modbus Reserved Error %funcCode%")
 
 
 _userdefined_funccode_request = {
 }
@@ -736,39 +736,39 @@
 
 class ModbusPDUUserDefinedFunctionCodeRequest(_ModbusPDUNoPayload):
     name = "User-Defined Function Code Request"
     fields_desc = [
         ModbusByteEnumField(
             "funcCode", 0x00, _userdefined_funccode_request,
             "Unknown user-defined request function Code"),
-        StrFixedLenField('payload', '', 255), ]
+        StrFixedLenField('mb_payload', '', 255), ]
 
     def mysummary(self):
         return self.sprintf("Modbus User-Defined Request %funcCode%")
 
 
 class ModbusPDUUserDefinedFunctionCodeResponse(_ModbusPDUNoPayload):
     name = "User-Defined Function Code Response"
     fields_desc = [
         ModbusByteEnumField(
             "funcCode", 0x00, _userdefined_funccode_response,
             "Unknown user-defined response function Code"),
-        StrFixedLenField('payload', '', 255), ]
+        StrFixedLenField('mb_payload', '', 255), ]
 
     def mysummary(self):
         return self.sprintf("Modbus User-Defined Response %funcCode%")
 
 
 class ModbusPDUUserDefinedFunctionCodeError(_ModbusPDUNoPayload):
     name = "User-Defined Function Code Error"
     fields_desc = [
         ModbusByteEnumField(
             "funcCode", 0x00, _userdefined_funccode_error,
             "Unknown user-defined error function Code"),
-        StrFixedLenField('payload', '', 255), ]
+        StrFixedLenField('mb_payload', '', 255), ]
 
     def mysummary(self):
         return self.sprintf("Modbus User-Defined Error %funcCode%")
 
 
 class ModbusObjectId(Packet):
     name = "Object"
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/mount.py` & `scapy-2.6.0rc1/scapy/contrib/mount.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/mpls.py` & `scapy-2.6.0rc1/scapy/contrib/mpls.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,20 +2,32 @@
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 
 # scapy.contrib.description = Multiprotocol Label Switching (MPLS)
 # scapy.contrib.status = loads
 
 from scapy.packet import Packet, bind_layers, Padding
-from scapy.fields import BitField, ByteField, ShortField
-from scapy.layers.inet import IP, UDP
-from scapy.contrib.bier import BIER
+from scapy.fields import (
+    BitField,
+    ByteField,
+    ByteEnumField,
+    PacketListField,
+    ShortField,
+)
+
+from scapy.layers.inet import (
+    _ICMP_classnums,
+    ICMPExtension_Object,
+    IP,
+    UDP,
+)
 from scapy.layers.inet6 import IPv6
 from scapy.layers.l2 import Ether, GRE
-from scapy.compat import orb
+
+from scapy.contrib.bier import BIER
 
 
 class EoMCW(Packet):
     name = "EoMCW"
     fields_desc = [BitField("zero", 0, 4),
                    BitField("reserved", 0, 12),
                    ShortField("seq", 0)]
@@ -33,29 +45,44 @@
                    BitField("s", 1, 1),
                    ByteField("ttl", 0)]
 
     def guess_payload_class(self, payload):
         if len(payload) >= 1:
             if not self.s:
                 return MPLS
-            ip_version = (orb(payload[0]) >> 4) & 0xF
+            ip_version = (payload[0] >> 4) & 0xF
             if ip_version == 4:
                 return IP
             elif ip_version == 5:
                 return BIER
             elif ip_version == 6:
                 return IPv6
             else:
-                if orb(payload[0]) == 0 and orb(payload[1]) == 0:
+                if payload[0] == 0 and payload[1] == 0:
                     return EoMCW
                 else:
                     return Ether
         return Padding
 
 
+# ICMP Extension
+
+class ICMPExtension_MPLS(ICMPExtension_Object):
+    name = "ICMP Extension Object - MPLS (RFC4950)"
+
+    fields_desc = [
+        ShortField("len", None),
+        ByteEnumField("classnum", 1, _ICMP_classnums),
+        ByteField("classtype", 1),
+        PacketListField("stack", [], MPLS, length_from=lambda pkt: pkt.len - 4),
+    ]
+
+
+# Bindings
+
 bind_layers(Ether, MPLS, type=0x8847)
 bind_layers(IP, MPLS, proto=137)
 bind_layers(IPv6, MPLS, nh=137)
 bind_layers(UDP, MPLS, dport=6635)
 bind_layers(GRE, MPLS, proto=0x8847)
 bind_layers(MPLS, MPLS, s=0)
 bind_layers(MPLS, IP, label=0)  # IPv4 Explicit NULL
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/mqtt.py` & `scapy-2.6.0rc1/scapy/contrib/mqtt.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,16 +3,25 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Santiago Hernandez Ramos <shramos@protonmail.com>
 
 # scapy.contrib.description = Message Queuing Telemetry Transport (MQTT)
 # scapy.contrib.status = loads
 
 from scapy.packet import Packet, bind_layers
-from scapy.fields import FieldLenField, BitEnumField, StrLenField, \
-    ShortField, ConditionalField, ByteEnumField, ByteField, PacketListField
+from scapy.fields import (
+    BitEnumField,
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    FieldLenField,
+    FieldListField,
+    PacketListField,
+    ShortField,
+    StrLenField,
+)
 from scapy.layers.inet import TCP
 from scapy.error import Scapy_Exception
 from scapy.compat import orb, chb
 from scapy.volatile import RandNum
 from scapy.config import conf
 
 
@@ -246,26 +255,34 @@
     fields_desc = [
         ShortField("msgid", None),
         PacketListField("topics", [], pkt_cls=MQTTTopicQOS)
     ]
 
 
 ALLOWED_RETURN_CODE = {
-    0: 'Success',
-    1: 'Success',
-    2: 'Success',
-    128: 'Failure'
+    0x00: 'Granted QoS 0',
+    0x01: 'Granted QoS 1',
+    0x02: 'Granted QoS 2',
+    0x80: 'Unspecified error',
+    0x83: 'Implementation specific error',
+    0x87: 'Not authorized',
+    0x8F: 'Topic Filter invalid',
+    0x91: 'Packet Identifier in use',
+    0x97: 'Quota exceeded',
+    0x9E: 'Shared Subscriptions not supported',
+    0xA1: 'Subscription Identifiers not supported',
+    0xA2: 'Wildcard Subscriptions not supported',
 }
 
 
 class MQTTSuback(Packet):
     name = "MQTT suback"
     fields_desc = [
         ShortField("msgid", None),
-        ByteEnumField("retcode", None, ALLOWED_RETURN_CODE)
+        FieldListField("retcodes", None, ByteEnumField("", None, ALLOWED_RETURN_CODE))
     ]
 
 
 class MQTTUnsubscribe(Packet):
     name = "MQTT unsubscribe"
     fields_desc = [
         ShortField("msgid", None),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/mqttsn.py` & `scapy-2.6.0rc1/scapy/contrib/mqttsn.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/nfs.py` & `scapy-2.6.0rc1/scapy/contrib/nfs.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 
 from scapy.contrib.oncrpc import RPC, RPC_Call, Object_Name
 from binascii import unhexlify
 from scapy.packet import Packet, bind_layers
 from scapy.fields import IntField, IntEnumField, FieldListField, LongField, \
     XIntField, XLongField, ConditionalField, PacketListField, StrLenField, \
     PacketField
-from scapy.libs.six import integer_types
 
 nfsstat3 = {
     0: 'NFS3_OK',
     1: 'NFS3ERR_PERM',
     2: 'NFS3ERR_NOENT',
     5: 'NFS3ERR_IO',
     6: 'NFS3ERR_NXIO',
@@ -54,15 +53,15 @@
     5: 'NF3LNK',
     6: 'NF3SOCK',
     7: 'NF3FIFO'
 }
 
 
 def loct(x):
-    if isinstance(x, integer_types):
+    if isinstance(x, int):
         return oct(x)
     if isinstance(x, tuple):
         return "(%s)" % ", ".join(map(loct, x))
     if isinstance(x, list):
         return "[%s]" % ", ".join(map(loct, x))
     return x
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/nlm.py` & `scapy-2.6.0rc1/scapy/contrib/nlm.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/nsh.py` & `scapy-2.6.0rc1/scapy/contrib/nsh.py`

 * *Files 10% similar despite different names*

```diff
@@ -71,15 +71,15 @@
     ]
 
     def mysummary(self):
         return self.sprintf("SPI: %spi% - SI: %si%")
 
 
 bind_layers(Ether, NSH, {'type': 0x894F}, type=0x894F)
-bind_layers(VXLAN, NSH, {'flags': 0xC, 'nextproto': 4}, nextproto=4)
+bind_layers(VXLAN, NSH, {'flags': 0xC, 'NextProtocol': 4}, NextProtocol=4)
 bind_layers(GRE, NSH, {'proto': 0x894F}, proto=0x894F)
 
 bind_layers(NSH, IP, nextproto=1)
 bind_layers(NSH, IPv6, nextproto=2)
 bind_layers(NSH, Ether, nextproto=3)
 bind_layers(NSH, NSH, nextproto=4)
 bind_layers(NSH, MPLS, nextproto=5)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/oncrpc.py` & `scapy-2.6.0rc1/scapy/contrib/oncrpc.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/opc_da.py` & `scapy-2.6.0rc1/scapy/contrib/opc_da.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/openflow.py` & `scapy-2.6.0rc1/scapy/contrib/openflow.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,27 +10,25 @@
 OpenFlow is an open standard used in SDN deployments.
 Specifications can be retrieved from https://www.opennetworking.org/
 """
 
 # scapy.contrib.description = Openflow v1.0
 # scapy.contrib.status = loads
 
-from __future__ import absolute_import
 import struct
 
 
 from scapy.compat import chb, orb, raw
 from scapy.config import conf
 from scapy.error import warning
 from scapy.fields import BitEnumField, BitField, ByteEnumField, ByteField, FieldLenField, FlagsField, IntEnumField, IntField, IPField, LongField, MACField, PacketField, PacketListField, ShortEnumField, ShortField, StrFixedLenField, X3BytesField, XBitField, XByteField, XIntField, XShortField  # noqa: E501
 from scapy.layers.l2 import Ether
 from scapy.layers.inet import TCP
 from scapy.packet import Packet, Raw, bind_bottom_up, bind_top_down
 from scapy.utils import binrepr
-import scapy.libs.six as six
 
 
 # If prereq_autocomplete is True then match prerequisites will be
 # automatically handled. See OFPMatch class.
 conf.contribs['OPENFLOW'] = {'prereq_autocomplete': True}
 
 #####################################################
@@ -713,15 +711,15 @@
     name = "OFPT_FEATURES_REQUEST"
     fields_desc = [ByteEnumField("version", 0x01, ofp_version),
                    ByteEnumField("type", 5, ofp_type),
                    ShortField("len", None),
                    IntField("xid", 0)]
 
 
-ofp_action_types_flags = [v for v in six.itervalues(ofp_action_types)
+ofp_action_types_flags = [v for v in ofp_action_types.values()
                           if v != 'OFPAT_VENDOR']
 
 
 class OFPTFeaturesReply(_ofp_header):
     name = "OFPT_FEATURES_REPLY"
     fields_desc = [ByteEnumField("version", 0x01, ofp_version),
                    ByteEnumField("type", 6, ofp_type),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/openflow3.py` & `scapy-2.6.0rc1/scapy/contrib/openflow3.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,29 +11,27 @@
 Specifications can be retrieved from https://www.opennetworking.org/
 """
 
 
 # scapy.contrib.description = OpenFlow v1.3
 # scapy.contrib.status = loads
 
-from __future__ import absolute_import
 import copy
 import struct
 
 
 from scapy.compat import orb, raw
 from scapy.config import conf
 from scapy.fields import BitEnumField, BitField, ByteEnumField, ByteField, \
     FieldLenField, FlagsField, IntEnumField, IntField, IPField, \
     LongField, MACField, PacketField, PacketListField, ShortEnumField, \
     ShortField, StrFixedLenField, X3BytesField, XBitField, XByteField, \
     XIntField, XShortField, PacketLenField
 from scapy.layers.l2 import Ether
 from scapy.packet import Packet, Padding, Raw
-import scapy.libs.six as six
 
 from scapy.contrib.openflow import _ofp_header, _ofp_header_item, \
     OFPacketField, OpenFlow, _UnknownOpenFlow
 
 #####################################################
 #                 Predefined values                 #
 #####################################################
@@ -2246,15 +2244,15 @@
                                                "NO_BYT_COUNTS"]),
                    IntField("pad2", 0),
                    LongField("cookie", 0),
                    LongField("packet_count", 0),
                    LongField("byte_count", 0),
                    MatchField("match"),
                    PacketListField("instructions", [], OFPIT,
-                                   length_from=lambda pkt:pkt.len - 56 - pkt.match.len)]  # noqa: E501
+                                   length_from=lambda pkt:pkt.len - 52 - pkt.match.len)]  # noqa: E501
 
     def extract_padding(self, s):
         return b"", s
 
 
 class OFPMPReplyFlow(_ofp_header):
     name = "OFPMP_REPLY_FLOW"
@@ -2513,15 +2511,15 @@
                    ShortField("len", None),
                    IntField("xid", 0),
                    ShortEnumField("mp_type", 8, ofp_multipart_types),
                    FlagsField("flags", 0, 16, ofpmp_request_flags),
                    XIntField("pad1", 0)]
 
 
-ofp_action_types_flags = [v for v in six.itervalues(ofp_action_types)
+ofp_action_types_flags = [v for v in ofp_action_types.values()
                           if v != 'OFPAT_EXPERIMENTER']
 
 
 class OFPMPReplyGroupFeatures(_ofp_header):
     name = "OFPMP_REPLY_GROUP_FEATURES"
     fields_desc = [ByteEnumField("version", 0x04, ofp_version),
                    ByteEnumField("type", 19, ofp_type),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/ospf.py` & `scapy-2.6.0rc1/scapy/contrib/ospf.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/pfcp.py` & `scapy-2.6.0rc1/scapy/contrib/pfcp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/pim.py` & `scapy-2.6.0rc1/scapy/contrib/pim.py`

 * *Files 14% similar despite different names*

```diff
@@ -8,17 +8,18 @@
 References:
   - https://tools.ietf.org/html/rfc4601
   - https://www.iana.org/assignments/pim-parameters/pim-parameters.xhtml
 """
 import struct
 from scapy.packet import Packet, bind_layers
 from scapy.fields import BitFieldLenField, BitField, BitEnumField, ByteField, \
-    ShortField, XShortField, IPField, PacketListField, \
-    IntField, FieldLenField, BoundStrLenField, FlagsField
+    ShortField, XShortField, IPField, IP6Field, PacketListField, \
+    IntField, FieldLenField, BoundStrLenField, MultipleTypeField
 from scapy.layers.inet import IP
+from scapy.layers.inet6 import IPv6, in6_chksum, _IPv6ExtHdr
 from scapy.utils import checksum
 from scapy.compat import orb
 from scapy.config import conf
 from scapy.volatile import RandInt
 
 
 PIM_TYPE = {
@@ -49,16 +50,29 @@
         Parameters:
           self    The instantiation of an PIMv2Hdr class
           p       The PIMv2Hdr message in hex in network byte order
           pay     Additional payload for the PIMv2Hdr message
         """
         p += pay
         if self.chksum is None:
-            ck = checksum(p)
-            p = p[:2] + struct.pack("!H", ck) + p[4:]
+            if isinstance(self.underlayer, IP):
+                ck = checksum(p)
+                # ck = in4_chksum(103, self.underlayer, p)
+                # According to RFC768 if the result checksum is 0, it should be set to 0xFFFF  # noqa: E501
+                if ck == 0:
+                    ck = 0xFFFF
+                p = p[:2] + struct.pack("!H", ck) + p[4:]
+
+            elif isinstance(self.underlayer, IPv6) or isinstance(self.underlayer, _IPv6ExtHdr):  # noqa: E501
+                ck = in6_chksum(103, self.underlayer, p)  # noqa: E501
+                # According to RFC2460 if the result checksum is 0, it should be set to 0xFFFF  # noqa: E501
+                if ck == 0:
+                    ck = 0xFFFF
+                p = p[:2] + struct.pack("!H", ck) + p[4:]
+
         return p
 
 
 def _guess_pim_tlv_class(h_classes, default_key, pkt, **kargs):
     cls = conf.raw_layer
     if len(pkt) >= 2:
         tlvtype = orb(pkt[1])
@@ -110,15 +124,15 @@
         ShortField("holdtime", 105)
     ]
 
 
 class PIMv2HelloLANPruneDelayValue(_PIMv2GenericHello):
     name = "PIMv2 Hello Options : LAN Prune Delay Value"
     fields_desc = [
-        FlagsField("t", 0, 1, [0, 1]),
+        BitField("t", 0, 1),
         BitField("propagation_delay", 500, 15),
         ShortField("override_interval", 2500),
     ]
 
 
 class PIMv2HelloLANPruneDelay(_PIMv2GenericHello):
     name = "PIMv2 Hello Options : LAN Prune Delay"
@@ -166,20 +180,42 @@
             "length", None, length_of="value", fmt="!H"
         ),
         PacketListField("value", PIMv2HelloStateRefreshValue(),
                         PIMv2HelloStateRefreshValue)
     ]
 
 
+class PIMv2HelloAddrListValue(_PIMv2GenericHello):
+    name = "PIMv2 Hello Options : Address List Value"
+    fields_desc = [
+        ByteField("addr_family", 1),
+        ByteField("encoding_type", 0),
+        IP6Field("prefix", "::"),
+    ]
+
+
+class PIMv2HelloAddrList(_PIMv2GenericHello):
+    name = "PIMv2 Hello Options : Address List"
+    fields_desc = [
+        ShortField("type", 24),
+        FieldLenField(
+            "length", None, length_of="value" , fmt="!H"
+        ),
+        PacketListField("value", PIMv2HelloAddrListValue(),
+                        PIMv2HelloAddrListValue)
+    ]
+
+
 PIMv2_HELLO_CLASSES = {
     1: PIMv2HelloHoldtime,
     2: PIMv2HelloLANPruneDelay,
     19: PIMv2HelloDRPriority,
     20: PIMv2HelloGenerationID,
     21: PIMv2HelloStateRefresh,
+    24: PIMv2HelloAddrList,
     None: _PIMv2GenericHello,
 }
 
 
 ##################################
 # PIMv2 Join/Prune
 ##################################
@@ -188,15 +224,19 @@
         ByteField("addr_family", 1),
         ByteField("encoding_type", 0),
         BitField("rsrvd", 0, 5),
         BitField("sparse", 0, 1),
         BitField("wildcard", 0, 1),
         BitField("rpt", 1, 1),
         ByteField("mask_len", 32),
-        IPField("src_ip", "0.0.0.0")
+        MultipleTypeField(
+            [(IP6Field("src_ip", "::"),
+              lambda pkt: pkt.addr_family == 2)],
+            IPField("src_ip", "0.0.0.0")
+        ),
 
     ]
 
 
 class PIMv2JoinAddrs(PIMv2JoinPruneAddrsBase):
     name = "PIMv2 Join: Source Address"
 
@@ -210,34 +250,43 @@
     fields_desc = [
         ByteField("addr_family", 1),
         ByteField("encoding_type", 0),
         BitField("bidirection", 0, 1),
         BitField("reserved", 0, 6),
         BitField("admin_scope_zone", 0, 1),
         ByteField("mask_len", 32),
-        IPField("gaddr", "0.0.0.0"),
+        MultipleTypeField(
+            [(IP6Field("gaddr", "::"),
+              lambda pkt: pkt.addr_family == 2)],
+            IPField("gaddr", "0.0.0.0")
+        ),
         BitFieldLenField("num_joins", None, size=16, count_of="join_ips"),
         BitFieldLenField("num_prunes", None, size=16, count_of="prune_ips"),
         PacketListField("join_ips", [], PIMv2JoinAddrs,
                         count_from=lambda x: x.num_joins),
         PacketListField("prune_ips", [], PIMv2PruneAddrs,
                         count_from=lambda x: x.num_prunes),
     ]
 
 
 class PIMv2JoinPrune(_PIMGenericTlvBase):
     name = "PIMv2 Join/Prune Options"
     fields_desc = [
         ByteField("up_addr_family", 1),
         ByteField("up_encoding_type", 0),
-        IPField("up_neighbor_ip", "0.0.0.0"),
+        MultipleTypeField(
+            [(IP6Field("up_neighbor_ip", "::"),
+              lambda pkt: pkt.up_addr_family == 2)],
+            IPField("up_neighbor_ip", "0.0.0.0")
+        ),
         ByteField("reserved", 0),
         FieldLenField("num_group", None, count_of="jp_ips", fmt="B"),
         ShortField("holdtime", 210),
         PacketListField("jp_ips", [], PIMv2GroupAddrs,
                         count_from=lambda pkt: pkt.num_group)
     ]
 
 
 bind_layers(IP, PIMv2Hdr, proto=103)
+bind_layers(IPv6, PIMv2Hdr, nh=103)
 bind_layers(PIMv2Hdr, PIMv2Hello, type=0)
 bind_layers(PIMv2Hdr, PIMv2JoinPrune, type=3)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/pnio.py` & `scapy-2.6.0rc1/scapy/contrib/pnio.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 from scapy.layers.inet import UDP
 from scapy.fields import (
     XShortEnumField, BitEnumField, XBitField,
     BitField, StrField, PacketListField,
     StrFixedLenField, ShortField,
     FlagsField, ByteField, XIntField, X3BytesField
 )
-import scapy.libs.six as six
 
 PNIO_FRAME_IDS = {
     0x0020: "PTCP-RTSyncPDU-followup",
     0x0080: "PTCP-RTSyncPDU",
     0xFC01: "Alarm High",
     0xFE01: "Alarm Low",
     0xFEFC: "DCP-Hello-Req",
@@ -73,15 +72,15 @@
             "RT_CLASS_1": 0x8000,
             "RT_CLASS_UDP": 0xC000,
             "FragmentationFrameID": 0xFF80,
         }[x]
     except KeyError:
         pass
     try:
-        return next(key for key, value in six.iteritems(PNIO_FRAME_IDS)
+        return next(key for key, value in PNIO_FRAME_IDS.items()
                     if value == x)
     except StopIteration:
         pass
     return x
 
 
 #################
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/pnio_dcp.py` & `scapy-2.6.0rc1/scapy/contrib/pnio_dcp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/pnio_rpc.py` & `scapy-2.6.0rc1/scapy/contrib/pnio_rpc.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/portmap.py` & `scapy-2.6.0rc1/scapy/contrib/portmap.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/postgres.py` & `scapy-2.6.0rc1/scapy/contrib/postgres.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,20 @@
 # See https://scapy.net/ for more information
 
 # scapy.contrib.description = Postgres PSQL Binary Protocol
 # scapy.contrib.status = loads
 
 import struct
 
-from scapy.compat import Optional, Callable, Any, Tuple  # noqa: F401
+from typing import (
+    Optional,
+    Callable,
+    Any,
+    Tuple,
+)
 from scapy.fields import (
     ByteField,
     CharEnumField,
     Field,
     FieldLenField,
     FieldListField,
     IntEnumField,
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/ppi_cace.py` & `scapy-2.6.0rc1/scapy/contrib/ppi_cace.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/ppi_geotag.py` & `scapy-2.6.0rc1/scapy/contrib/ppi_geotag.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,27 +7,25 @@
 # scapy.contrib.status = loads
 
 
 """
 PPI-GEOLOCATION tags
 """
 
-from __future__ import absolute_import
 import functools
 import struct
 
 from scapy.base_classes import Packet_metaclass
 from scapy.data import PPI_GPS, PPI_VECTOR, PPI_SENSOR, PPI_ANTENNA
 from scapy.packet import bind_layers
 from scapy.fields import ByteField, ConditionalField, Field, FlagsField, \
     LEIntField, LEShortEnumField, LEShortField, StrFixedLenField, \
     UTCTimeField, XLEIntField, SignedByteField, XLEShortField
 from scapy.layers.ppi import PPI_Hdr, PPI_Element
 from scapy.error import warning
-import scapy.libs.six as six
 
 CURR_GEOTAG_VER = 2  # Major revision of specification
 
 
 # The FixedX_Y Fields are used to store fixed point numbers in a variety of
 # fields in the GEOLOCATION-TAGS specification
 
@@ -249,15 +247,15 @@
 class HCSIAppField(StrFixedLenField):
     def __init__(self, name, default):
         StrFixedLenField.__init__(self, name, default, length=60)
 
 
 def _FlagsList(myfields):
     flags = ["Reserved%02d" % i for i in range(32)]
-    for i, value in six.iteritems(myfields):
+    for i, value in myfields.items():
         flags[i] = value
     return flags
 
 
 # Define all geolocation-tag flags lists
 _hcsi_gps_flags = _FlagsList({
     0: "No Fix Available",
@@ -276,15 +274,15 @@
     1: "Direction of Travel",
     2: "Front of Vehicle",
     3: "Angle of Arrival",
     4: "Transmitter Position",
     8: "GPS Derived",
     9: "INS Derived",
     10: "Compass Derived",
-    11: "Acclerometer Derived",
+    11: "Accelerometer Derived",
     12: "Human Derived",
 })
 
 _hcsi_antenna_flags = _FlagsList({
     1: "Horizontal Polarization",
     2: "Vertical Polarization",
     3: "Circular Polarization Left",
@@ -356,15 +354,15 @@
 
             dct['fields_desc'] = fields_desc
 
         x = super(_Geotag_metaclass, cls).__new__(cls, name, bases, dct)
         return x
 
 
-class HCSIPacket(six.with_metaclass(_Geotag_metaclass, PPI_Element)):
+class HCSIPacket(PPI_Element, metaclass=_Geotag_metaclass):
     def post_build(self, p, pay):
         if self.geotag_len is None:
             sl_g = struct.pack('<H', len(p))
             p = p[:2] + sl_g + p[4:]
         p += pay
         return p
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/ripng.py` & `scapy-2.6.0rc1/scapy/contrib/ripng.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/roce.py` & `scapy-2.6.0rc1/scapy/contrib/roce.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,20 +10,24 @@
 RoCE: RDMA over Converged Ethernet
 """
 
 from scapy.packet import Packet, bind_layers, Raw
 from scapy.fields import ByteEnumField, ByteField, XByteField, \
     ShortField, XShortField, XLongField, BitField, XBitField, FCSField
 from scapy.layers.inet import IP, UDP
+from scapy.layers.inet6 import IPv6
 from scapy.layers.l2 import Ether
 from scapy.compat import raw
 from scapy.error import warning
 from zlib import crc32
 import struct
-from scapy.compat import Tuple
+
+from typing import (
+    Tuple
+)
 
 _transports = {
     'RC': 0x00,
     'UC': 0x20,
     'RD': 0x40,
     'UD': 0x60,
 }
@@ -172,16 +176,33 @@
             payload = raw(pshdr[BTH].payload)
             # add ICRC placeholder just to get the right IP.totlen and
             # UDP.length
             icrc_placeholder = b'\xff\xff\xff\xff'
             pshdr[UDP].payload = Raw(bth + payload + icrc_placeholder)
             icrc = crc32(raw(pshdr)[:-4]) & 0xffffffff
             return self.pack_icrc(icrc)
+        elif isinstance(ip, IPv6):
+            # pseudo-LRH / IPv6 / UDP / BTH / payload
+            pshdr = Raw(b'\xff' * 8) / ip.copy()
+            pshdr.hlim = 0xff
+            pshdr.fl = 0xfffff
+            pshdr.tc = 0xff
+            pshdr[UDP].chksum = 0xffff
+            pshdr[BTH].fecn = 1
+            pshdr[BTH].becn = 1
+            pshdr[BTH].resv6 = 0xff
+            bth = pshdr[BTH].self_build()
+            payload = raw(pshdr[BTH].payload)
+            # add ICRC placeholder just to get the right IPv6.plen and
+            # UDP.length
+            icrc_placeholder = b'\xff\xff\xff\xff'
+            pshdr[UDP].payload = Raw(bth + payload + icrc_placeholder)
+            icrc = crc32(raw(pshdr)[:-4]) & 0xffffffff
+            return self.pack_icrc(icrc)
         else:
-            # TODO support IPv6
             warning("The underlayer protocol %s is not supported.",
                     ip and ip.name)
             return self.pack_icrc(0)
 
     # RoCE packets end with ICRC - a 32-bit CRC of the packet payload and
     # pseudo-header. Add the ICRC header if it is missing and calculate its
     # value.
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/rpl.py` & `scapy-2.6.0rc1/scapy/contrib/rpl.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/rpl_metrics.py` & `scapy-2.6.0rc1/scapy/contrib/rpl_metrics.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/rsvp.py` & `scapy-2.6.0rc1/scapy/contrib/rsvp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/rtcp.py` & `scapy-2.6.0rc1/scapy/contrib/rtcp.py`

 * *Files 9% similar despite different names*

```diff
@@ -47,27 +47,33 @@
     fields_desc = [
         LongField('ntp_timestamp', None),
         IntField('rtp_timestamp', None),
         IntField('sender_packet_count', None),
         IntField('sender_octet_count', None)
     ]
 
+    def extract_padding(self, p):
+        return "", p
+
 
 class ReceptionReport(Packet):
     name = "Reception report"
     fields_desc = [
         IntField('sourcesync', None),
         ByteField('fraction_lost', None),
         X3BytesField('cumulative_lost', None),
         IntField('highest_seqnum_recv', None),
         IntField('interarrival_jitter', None),
         IntField('last_SR_timestamp', None),
         IntField('delay_since_last_SR', None)
     ]
 
+    def extract_padding(self, p):
+        return "", p
+
 
 _sdes_chunk_types = {
     0: "END",
     1: "CNAME",
     2: "NAME",
     3: "EMAIL",
     4: "PHONE",
@@ -90,15 +96,20 @@
         return "", p
 
 
 class SDESChunk(Packet):
     name = "SDES chunk"
     fields_desc = [
         IntField('sourcesync', None),
-        PacketListField('items', None, pkt_cls=SDESItem)
+        PacketListField(
+            'items', None,
+            next_cls_cb=(
+                lambda x, y, p, z: None if (p and p.chunk_type == 0) else SDESItem
+            )
+        )
     ]
 
 
 class RTCP(Packet):
     name = "RTCP"
 
     fields_desc = [
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/rtps/common_types.py` & `scapy-2.6.0rc1/scapy/contrib/rtps/common_types.py`

 * *Files 6% similar despite different names*

```diff
@@ -275,31 +275,35 @@
 
     def extract_padding(self, p):
         return b"", p
 
 
 _rtps_vendor_ids = {
     0x0000: "VENDOR_ID_UNKNOWN (0x0000)",
-    0x0101: "Real-Time Innovations, Inc. - Connext DDS",
-    0x0102: "PrismTech Inc. - OpenSplice DDS",
-    0x0103: "Object Computing Incorporated, Inc. (OCI) - OpenDDS",
-    0x0104: "MilSoft",
-    0x0105: "Gallium Visual Systems Inc. - InterCOM DDS",
-    0x0106: "TwinOaks Computing, Inc. - CoreDX DDS",
+    0x0101: "Real-Time Innovations, Inc. (RTI) - Connext DDS",
+    0x0102: "ADLink Ltd. - OpenSplice DDS",
+    0x0103: "Object Computing Inc. (OCI) - OpenDDS",
+    0x0104: "MilSoft - Mil-DDS",
+    0x0105: "Kongsberg - InterCOM DDS",
+    0x0106: "Twin Oaks Computing, Inc. - CoreDX DDS",
     0x0107: "Lakota Technical Solutions, Inc.",
     0x0108: "ICOUP Consulting",
-    0x0109: "ETRI Electronics and Telecommunication Research Institute",
+    0x0109: "Electronics and Telecommunication Research Institute (ETRI) - Diamond DDS",
     0x010A: "Real-Time Innovations, Inc. (RTI) - Connext DDS Micro",
-    0x010B: "PrismTech - OpenSplice Mobile",
-    0x010C: "PrismTech - OpenSplice Gateway",
-    0x010D: "PrismTech - OpenSplice Lite",
-    0x010E: "Technicolor Inc. - Qeo",
-    0x010F: "eProsima - Fast-RTPS",
-    0x0110: "ADLINK - Cyclone DDS",
-    0x0111: "GurumNetworks - GurumDDS",
+    0x010B: "ADLink Ltd. - VortexCafe",
+    0x010C: "PrismTech Ltd",
+    0x010D: "ADLink Ltd. - Vortex Lite",
+    0x010E: "Technicolor - Qeo",
+    0x010F: "eProsima - FastRTPS, FastDDS",
+    0x0110: "Eclipse Foundation - Cyclone DDS",
+    0x0111: "Gurum Networks, Inc. - GurumDDS",
+    0x0112: "Atostek - RustDDS",
+    0x0113: "Nanjing Zhenrong Software Technology Co. \
+        - Zhenrong Data Distribution Service (ZRDDS)",
+    0x0114: "S2E Software Systems B.V. - Dust DDS",
 }
 
 
 class VendorIdPacket(Packet):
     name = "RTPS Vendor ID"
     fields_desc = [
         # ByteField("major", 0),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/rtps/pid_types.py` & `scapy-2.6.0rc1/scapy/contrib/rtps/pid_types.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/rtps/rtps.py` & `scapy-2.6.0rc1/scapy/contrib/rtps/rtps.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,15 +21,14 @@
     ShortField,
     StrField,
     StrFixedLenField,
     StrLenField,
     X3BytesField,
     XByteField,
     XIntField,
-    XLongField,
     XNBytesField,
     XShortField,
     XStrLenField,
     FlagsField,
     Field,
     EnumField,
 )
@@ -348,15 +347,16 @@
             fmt="4s",
             enum=_rtps_reserved_entity_ids,
         ),
         XStrLenField(
             "readerSNState",
             0, length_from=lambda pkt: pkt.octetsToNextHeader - 8 - 4
         ),
-        XNBytesField("count", 0, 4),
+        EField(IntField("count", 0),
+               endianness_from=e_flags),
     ]
 
 
 class RTPSSubMessage_HEARTBEAT(EPacket):
     """
     0...2...........7...............15.............23...............31
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
@@ -392,16 +392,22 @@
         ),
         EnumField(
             "writer_id",
             default=b"\x00\x00\x00\x00",
             fmt="4s",
             enum=_rtps_reserved_entity_ids,
         ),
-        XLongField("firstAvailableSeqNum", 0),
-        XLongField("lastSeqNum", 0),
+        EField(IntField("firstAvailableSeqNumHi", 0),
+               endianness_from=e_flags),
+        EField(IntField("firstAvailableSeqNumLow", 0),
+               endianness_from=e_flags),
+        EField(IntField("lastSeqNumHi", 0),
+               endianness_from=e_flags),
+        EField(IntField("lastSeqNumLow", 0),
+               endianness_from=e_flags),
         EField(IntField("count", 0),
                endianness_from=e_flags),
     ]
 
 
 class RTPSSubMessage_INFO_DST(EPacket):
     """
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/rtr.py` & `scapy-2.6.0rc1/scapy/contrib/rtr.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/scada/iec104/__init__.py` & `scapy-2.6.0rc1/scapy/contrib/scada/iec104/__init__.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/scada/iec104/iec104_fields.py` & `scapy-2.6.0rc1/scapy/contrib/scada/iec104/iec104_fields.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/scada/iec104/iec104_information_elements.py` & `scapy-2.6.0rc1/scapy/contrib/scada/iec104/iec104_information_elements.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,17 +25,24 @@
         - some definitions should use signed types as outlined in the standard
         - normed value element should use a float type
 
 """
 from scapy.contrib.scada.iec104.iec104_fields import \
     IEC60870_5_4_NormalizedFixPoint, IEC104SignedSevenBitValue, \
     LESignedShortField, LEIEEEFloatField
-from scapy.fields import BitEnumField, ByteEnumField, ByteField, \
-    ThreeBytesField, \
-    BitField, LEShortField, LESignedIntField
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    ByteEnumField,
+    ByteField,
+    LEShortField,
+    LESignedIntField,
+    MayEnd,
+    ThreeBytesField,
+)
 
 
 def _generate_attributes_and_dicts(cls):
     """
     create class attributes and dict entries for range-based attributes
 
     class attributes will take the form: cls.<attribute_name_prefix>_<index>
@@ -609,15 +616,15 @@
         BitEnumField('gen', 0, 1, GEN_FLAGS),
         # only valid in monitor direction ToDo: special treatment needed?
         BitField('minutes', 0, 6),
         BitEnumField('su', 0, 1, SU_FLAGS),
         BitField('reserved_2', 0, 2),
         BitField('hours', 0, 5),
         BitEnumField('weekday', 0, 3, WEEK_DAY_FLAGS),
-        BitField('day_of_month', 0, 5),
+        MayEnd(BitField('day_of_month', 0, 5)),
         BitField('reserved_3', 0, 4),
         BitField('month', 0, 4),
         BitField('reserved_4', 0, 1),
         BitField('year', 0, 7),
     ]
 
 
@@ -626,15 +633,15 @@
     derived IE, used for ASDU that requires two CP56TIME2A timestamps for
     defining a range
     """
     _DERIVED_IE = True
     informantion_element_fields = [
         LEShortField('start_sec_milli', 0),
         BitEnumField('start_iv', 0, 1, IEC104_IE_CommonQualityFlags.IV_FLAGS),
-        BitEnumField('start_gen', 0, 1, IEC104_IE_CP56TIME2A.GEN_FLAGS),
+        MayEnd(BitEnumField('start_gen', 0, 1, IEC104_IE_CP56TIME2A.GEN_FLAGS)),
         # only valid in monitor direction ToDo: special treatment needed?
         BitField('start_minutes', 0, 6),
         BitEnumField('start_su', 0, 1, IEC104_IE_CP56TIME2A.SU_FLAGS),
         BitField('start_reserved_2', 0, 2),
         BitField('start_hours', 0, 5),
         BitEnumField('start_weekday', 0, 3,
                      IEC104_IE_CP56TIME2A.WEEK_DAY_FLAGS),
@@ -651,15 +658,15 @@
     derived IE, used for ASDU that requires two CP56TIME2A timestamps for
     defining a range
     """
     _DERIVED_IE = True
     informantion_element_fields = [
         LEShortField('stop_sec_milli', 0),
         BitEnumField('stop_iv', 0, 1, IEC104_IE_CommonQualityFlags.IV_FLAGS),
-        BitEnumField('stop_gen', 0, 1, IEC104_IE_CP56TIME2A.GEN_FLAGS),
+        MayEnd(BitEnumField('stop_gen', 0, 1, IEC104_IE_CP56TIME2A.GEN_FLAGS)),
         # only valid in monitor direction ToDo: special treatment needed?
         BitField('stop_minutes', 0, 6),
         BitEnumField('stop_su', 0, 1, IEC104_IE_CP56TIME2A.SU_FLAGS),
         BitField('stop_reserved_2', 0, 2),
         BitField('stop_hours', 0, 5),
         BitEnumField('stop_weekday', 0, 3,
                      IEC104_IE_CP56TIME2A.WEEK_DAY_FLAGS),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/scada/iec104/iec104_information_objects.py` & `scapy-2.6.0rc1/scapy/contrib/scada/iec104/iec104_information_objects.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/scada/pcom.py` & `scapy-2.6.0rc1/scapy/contrib/scada/pcom.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
 import struct
 
 from scapy.packet import Packet, bind_layers
 from scapy.layers.inet import TCP
 from scapy.fields import XShortField, ByteEnumField, XByteField, \
     StrFixedLenField, StrLenField, LEShortField, \
-    LEFieldLenField, LEX3BytesField, XLEShortField
+    LEFieldLenField, XLE3BytesField, XLEShortField
 from scapy.volatile import RandShort
 from scapy.compat import bytes_encode, orb
 
 _protocol_modes = {0x65: "ascii", 0x66: "binary"}
 
 _ascii_command_codes = {
     "ID": "Send Identification Command",
@@ -79,15 +79,15 @@
         ByteEnumField("mode", 0x65, _protocol_modes),
         XByteField("reserved", 0x00),
         LEShortField("len", None)
     ]
 
     def post_build(self, pkt, pay):
         if self.len is None and pay:
-            pkt = pkt[:4] + struct.pack("H", len(pay))
+            pkt = pkt[:4] + struct.pack("<H", len(pay))
         return pkt + pay
 
 
 class PCOMRequest(PCOM):
     name = "PCOM/TCP Request"
 
 
@@ -189,15 +189,15 @@
 class PCOMBinaryRequest(PCOMBinary):
     name = "PCOM/Binary Request"
     fields_desc = [
         StrFixedLenField("stx", "/_OPLC", 6),
         XByteField("id", 0x0),
         XByteField("reserved1", 0xfe),
         XByteField("reserved2", 0x1),
-        LEX3BytesField("reserved3", 0x0),
+        XLE3BytesField("reserved3", 0x0),
         PCOMBinaryCommandField("command", None),
         XByteField("reserved4", 0x0),
         StrFixedLenField("commandSpecific", '', 6),
         LEFieldLenField("len", 0, length_of="data"),
         XLEShortField("headerChksum", None),
         StrLenField("data", '', length_from=lambda pkt: pkt.len),
         XLEShortField("footerChksum", None),
@@ -208,15 +208,15 @@
 class PCOMBinaryResponse(PCOMBinary):
     name = "PCOM/Binary Response"
     fields_desc = [
         StrFixedLenField("stx", "/_OPLC", 6),
         XByteField("reserved1", 0xfe),
         XByteField("id", 0x0),
         XByteField("reserved2", 0x1),
-        LEX3BytesField("reserved3", 0x0),
+        XLE3BytesField("reserved3", 0x0),
         PCOMBinaryCommandField("command", None),
         XByteField("reserved4", 0x0),
         StrFixedLenField("commandSpecific", '', 6),
         LEFieldLenField("len", 0, length_of="data"),
         XLEShortField("headerChksum", None),
         StrLenField("data", '', length_from=lambda pkt: pkt.len),
         XLEShortField("footerChksum", None),
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/sdnv.py` & `scapy-2.6.0rc1/scapy/contrib/sdnv.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/sebek.py` & `scapy-2.6.0rc1/scapy/contrib/sebek.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/send.py` & `scapy-2.6.0rc1/scapy/contrib/send.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 """
 Secure Neighbor Discovery (SEND) - RFC3971
 """
 
 # scapy.contrib.description = Secure Neighbor Discovery (SEND) (ICMPv6)
 # scapy.contrib.status = loads
 
-from __future__ import absolute_import
 
 from scapy.packet import Packet
 from scapy.fields import BitField, ByteField, FieldLenField, PacketField, \
     PacketLenField, ShortField, StrFixedLenField, StrLenField, UTCTimeField
 from scapy.layers.x509 import X509_SubjectPublicKeyInfo
 from scapy.layers.inet6 import icmp6ndoptscls, _ICMPv6NDGuessPayload
 from scapy.compat import chb
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/skinny.py` & `scapy-2.6.0rc1/scapy/contrib/skinny.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 # scapy.contrib.description = Skinny Call Control Protocol (SCCP)
 # scapy.contrib.status = loads
 
 """
 Skinny Call Control Protocol (SCCP) extension
 """
 
-from __future__ import absolute_import
 import time
 import struct
 
 from scapy.packet import Packet, bind_layers
 from scapy.fields import FlagsField, IPField, LEIntEnumField, LEIntField, \
     StrFixedLenField
 from scapy.layers.inet import TCP
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/slowprot.py` & `scapy-2.6.0rc1/scapy/contrib/slowprot.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/socks.py` & `scapy-2.6.0rc1/scapy/contrib/socks.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,16 +12,23 @@
 """
 
 from scapy.config import conf
 from scapy.error import warning
 from scapy.layers.dns import DNSStrField
 from scapy.layers.inet import TCP, UDP
 from scapy.layers.inet6 import IP6Field
-from scapy.fields import ByteField, ByteEnumField, ShortField, IPField, \
-    StrField, MultipleTypeField
+from scapy.fields import (
+    ByteEnumField,
+    ByteField,
+    IPField,
+    MultipleTypeField,
+    ShortField,
+    StrField,
+    StrNullField,
+)
 from scapy.packet import Packet, bind_layers, bind_bottom_up
 
 # TODO: support the 3 different authentication exchange procedures for SOCKS5  # noqa: E501
 # 1 - Plain (https://tools.ietf.org/html/rfc1928 - 3.Procedure for TCP-based clients)  # noqa: E501
 # 2 - Username/password (https://tools.ietf.org/html/rfc1929)
 # 3 - GSS-API (https://tools.ietf.org/html/rfc1961)
 
@@ -82,16 +89,15 @@
 class SOCKS4Request(Packet):
     name = "SOCKS 4 - Request"
     overload_fields = {SOCKS: {"vn": 0x4}}
     fields_desc = [
         ByteEnumField("cd", 1, _socks4_cd_request),
         ShortField("dstport", 80),
         IPField("dst", "0.0.0.0"),
-        StrField("userid", ""),
-        ByteField("null", 0),
+        StrNullField("userid", ""),
     ]
 
 
 _socks4_cd_reply = {
     90: "Request granted",
     91: "Request rejected",
     92: "Request rejected - SOCKS server cannot connect to identd",
@@ -100,15 +106,15 @@
 
 
 class SOCKS4Reply(Packet):
     name = "SOCKS 4 - Reply"
     overload_fields = {SOCKS: {"vn": 0x0}}
     fields_desc = [
         ByteEnumField("cd", 90, _socks4_cd_reply),
-    ] + SOCKS4Request.fields_desc[1:-2]  # Re-use dstport, dst and userid
+    ] + SOCKS4Request.fields_desc[1:-2]  # Reuse dstport, dst and userid
 
 # SOCKS v5 - TCP
 
 
 _socks5_cdtypes = {
     1: "Connect",
     2: "Bind",
@@ -164,15 +170,15 @@
 # SOCKS v5 - UDP
 
 class SOCKS5UDP(Packet):
     name = "SOCKS 5 - UDP Header"
     fields_desc = [
         ShortField("res", 0),
         ByteField("frag", 0),
-    ] + SOCKS5Request.fields_desc[2:]  # Re-use the atyp, addr and port fields
+    ] + SOCKS5Request.fields_desc[2:]  # Reuse the atyp, addr and port fields
 
     def guess_payload_class(self, s):
         if self.port == 0:
             return conf.raw_layer
         return UDP(sport=self.port, dport=self.port).guess_payload_class(None)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/stamp.py` & `scapy-2.6.0rc1/scapy/contrib/stamp.py`

 * *Files 3% similar despite different names*

```diff
@@ -221,16 +221,15 @@
                     lambda pkt:pkt.err_estimate.Z == 0)
             ],
             UTCTimeField('ts', 0, fmt='Q')
         ),
         PacketField('err_estimate', ErrorEstimate(), ErrorEstimate),
         ShortField('ssid', 1),
         NBytesField('mbz', 0, 28),  # 28 bytes MBZ
-        PacketListField('tlv_objects', [], STAMPTestTLV,
-                        length_from=lambda pkt: pkt.parent.len - 8 - 44),
+        PacketListField('tlv_objects', [], STAMPTestTLV),
     ]
 
 
 class STAMPSessionReflectorTestUnauthenticated(Packet):
     """
     Extended STAMP Session-Reflector Test Packet in Unauthenticated Mode.
 
@@ -293,14 +292,13 @@
             ],
             UTCTimeField('ts_sender', 0, fmt='Q')
         ),
         PacketField('err_estimate_sender', ErrorEstimate(), ErrorEstimate),
         ShortField('mbz1', 0),
         ByteField('ttl_sender', 255),
         NBytesField('mbz2', 0, 3),  # 3 bytes MBZ
-        PacketListField('tlv_objects', [], STAMPTestTLV,
-                        length_from=lambda pkt: pkt.parent.len - 8 - 44),
+        PacketListField('tlv_objects', [], STAMPTestTLV),
     ]
 
 
 bind_layers(UDP, STAMPSessionSenderTestUnauthenticated, dport=862)
 bind_layers(UDP, STAMPSessionReflectorTestUnauthenticated, sport=862)
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/stun.py` & `scapy-2.6.0rc1/scapy/contrib/stun.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/tacacs.py` & `scapy-2.6.0rc1/scapy/contrib/tacacs.py`

 * *Files 1% similar despite different names*

```diff
@@ -358,15 +358,16 @@
 
     '''
 
     def post_dissect(self, pay):
 
         if self.flags == 0:
             pay = obfuscate(pay, SECRET, self.session_id, self.version, self.seq)  # noqa: E501
-            return pay
+
+        return pay
 
 
 class TacacsHeader(TacacsClientPacket):
 
     '''
 
     Tacacs Header packet from section 3.8
@@ -416,19 +417,17 @@
 
         # Setting length of packet to obfuscate if not filled by user
 
         if self.length is None and pay:
             p = p[:-4] + struct.pack('!I', len(pay))
 
         if self.flags == 0:
-
             pay = obfuscate(pay, SECRET, self.session_id, self.version, self.seq)  # noqa: E501
-            return p + pay
 
-        return p
+        return p + pay
 
     def hashret(self):
         return struct.pack('I', self.session_id)
 
     def answers(self, other):
         return (isinstance(other, TacacsHeader) and
                 self.seq == other.seq + 1 and
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/tcpao.py` & `scapy-2.6.0rc1/scapy/contrib/tcpao.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,23 +5,27 @@
 
 # scapy.contrib.description = TCP-AO Signature Calculation
 # scapy.contrib.status = loads
 
 """Packet-processing utilities implementing RFC5925 and RFC5926"""
 
 import logging
-from scapy.compat import orb, Union
+from scapy.compat import orb
 from scapy.layers.inet import IP, TCP
 from scapy.layers.inet import tcp_pseudoheader
 from scapy.layers.inet6 import IPv6
 from scapy.packet import Packet
 from scapy.pton_ntop import inet_pton
 import socket
 import struct
 
+from typing import (
+    Union,
+)
+
 logger = logging.getLogger(__name__)
 
 
 def _hmac_sha1_digest(key, msg):
     # type: (bytes, bytes) -> bytes
     import hmac
     import hashlib
```

### Comparing `scapy-2.5.0rc3/scapy/contrib/tzsp.py` & `scapy-2.6.0rc1/scapy/contrib/tzsp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/vqp.py` & `scapy-2.6.0rc1/scapy/contrib/vqp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/vtp.py` & `scapy-2.6.0rc1/scapy/contrib/vtp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/contrib/wireguard.py` & `scapy-2.6.0rc1/scapy/contrib/wireguard.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/dadict.py` & `scapy-2.6.0rc1/scapy/dadict.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,30 +3,31 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Direct Access dictionary.
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 from scapy.error import Scapy_Exception
-import scapy.libs.six as six
 from scapy.compat import plain_str
 
-from scapy.compat import (
+# Typing
+from typing import (
     Any,
     Dict,
     Generic,
     Iterator,
     List,
+    Tuple,
+    Type,
     TypeVar,
     Union,
-    cast,
 )
+from scapy.compat import Self
+
 
 ###############################
 #  Direct Access dictionary   #
 ###############################
 
 
 def fixname(x):
@@ -66,51 +67,53 @@
 
         ETHER_TYPES[2048] -> IPv4
 
     Whereas humans can access::
 
         ETHER_TYPES.IPv4 -> 2048
     """
+    __slots__ = ["_name", "d"]
+
     def __init__(self, _name="DADict", **kargs):
         # type: (str, **Any) -> None
         self._name = _name
         self.d = {}  # type: Dict[_K, _V]
-        self.update(kargs)
+        self.update(kargs)  # type: ignore
 
     def ident(self, v):
         # type: (_V) -> str
         """
         Return value that is used as key for the direct access
         """
         if isinstance(v, (str, bytes)):
             return fixname(v)
         return "unknown"
 
     def update(self, *args, **kwargs):
-        # type: (*Dict[str, _V], **Dict[str, _V]) -> None
-        for k, v in six.iteritems(dict(*args, **kwargs)):
-            self[k] = v
+        # type: (*Dict[_K, _V], **Dict[_K, _V]) -> None
+        for k, v in dict(*args, **kwargs).items():
+            self[k] = v  # type: ignore
 
     def iterkeys(self):
         # type: () -> Iterator[_K]
-        for x in six.iterkeys(self.d):
+        for x in self.d:
             if not isinstance(x, str) or x[0] != "_":
                 yield x
 
     def keys(self):
         # type: () -> List[_K]
         return list(self.iterkeys())
 
     def __iter__(self):
         # type: () -> Iterator[_K]
         return self.iterkeys()
 
     def itervalues(self):
         # type: () -> Iterator[_V]
-        return six.itervalues(self.d)  # type: ignore
+        return self.d.values()  # type: ignore
 
     def values(self):
         # type: () -> List[_V]
         return list(self.itervalues())
 
     def _show(self):
         # type: () -> None
@@ -140,15 +143,24 @@
     __bool__ = __nonzero__
 
     def __getattr__(self, attr):
         # type: (str) -> _K
         try:
             return object.__getattribute__(self, attr)  # type: ignore
         except AttributeError:
-            for k, v in six.iteritems(self.d):
+            for k, v in self.d.items():
                 if self.ident(v) == attr:
-                    return cast(_K, k)
+                    return k
         raise AttributeError
 
     def __dir__(self):
         # type: () -> List[str]
         return [self.ident(x) for x in self.itervalues()]
+
+    def __reduce__(self):
+        # type: () -> Tuple[Type[Self], Tuple[str], Tuple[Dict[_K, _V]]]
+        return (self.__class__, (self._name,), (self.d,))
+
+    def __setstate__(self, state):
+        # type: (Tuple[Dict[_K, _V]]) -> Self
+        self.d.update(state[0])
+        return self
```

### Comparing `scapy-2.5.0rc3/scapy/data.py` & `scapy-2.6.0rc1/scapy/data.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,34 +5,34 @@
 
 """
 Global variables and functions for handling external data sets.
 """
 
 import calendar
 import os
+import pickle
 import warnings
 
-
 from scapy.dadict import DADict, fixname
 from scapy.consts import FREEBSD, NETBSD, OPENBSD, WINDOWS
 from scapy.error import log_loading
-from scapy.compat import plain_str
-import scapy.libs.six as six
 
-from scapy.compat import (
+# Typing imports
+from typing import (
     Any,
     Callable,
     Dict,
     Iterator,
     List,
     Optional,
     Tuple,
     Union,
     cast,
 )
+from scapy.compat import DecoratorCallable
 
 
 ############
 #  Consts  #
 ############
 
 ETHER_ANY = b"\x00" * 6
@@ -125,16 +125,18 @@
     DLT_IPV4 = 228
     DLT_IPV6 = 229
 DLT_IEEE802_15_4_NOFCS = 230
 DLT_USBPCAP = 249
 DLT_NETLINK = 253
 DLT_USB_DARWIN = 266
 DLT_BLUETOOTH_LE_LL = 251
+DLT_BLUETOOTH_LINUX_MONITOR = 254
 DLT_BLUETOOTH_LE_LL_WITH_PHDR = 256
 DLT_VSOCK = 271
+DLT_NORDIC_BLE = 272
 DLT_ETHERNET_MPACKET = 274
 DLT_LINUX_SLL2 = 276
 
 # From net/ipv6.h on Linux (+ Additions)
 IPV6_ADDR_UNICAST = 0x01
 IPV6_ADDR_MULTICAST = 0x02
 IPV6_ADDR_CAST_MASK = 0x0F
@@ -285,25 +287,77 @@
     5771: "Cisco Systems, Inc.",
     5842: "Cisco Systems",
     11129: "Google, Inc",
     16885: "Nortel Networks",
 }
 
 
+def scapy_data_cache(name):
+    # type: (str) -> Callable[[DecoratorCallable], DecoratorCallable]
+    """
+    This decorator caches the loading of 'data' dictionaries, in order to reduce
+    loading times.
+    """
+    from scapy.main import SCAPY_CACHE_FOLDER
+    if SCAPY_CACHE_FOLDER is None:
+        # Cannot cache.
+        return lambda x: x
+    cachepath = SCAPY_CACHE_FOLDER / name
+
+    def _cached_loader(func, name=name):
+        # type: (DecoratorCallable, str) -> DecoratorCallable
+        def load(filename=None):
+            # type: (Optional[str]) -> Any
+            cache_id = hash(filename)
+            if cachepath.exists():
+                try:
+                    with cachepath.open("rb") as fd:
+                        data = pickle.load(fd)
+                    if data["id"] == cache_id:
+                        return data["content"]
+                except Exception:
+                    log_loading.warning(
+                        "Couldn't load cache from %s" % str(cachepath),
+                        exc_info=True,
+                    )
+                    cachepath.unlink()
+            # Cache does not exist or is invalid.
+            content = func(filename)
+            data = {
+                "content": content,
+                "id": cache_id,
+            }
+            try:
+                cachepath.parent.mkdir(parents=True, exist_ok=True)
+                with cachepath.open("wb") as fd:
+                    pickle.dump(data, fd)
+                return content
+            except Exception:
+                log_loading.warning(
+                    "Couldn't cache %s into %s" % (repr(func), str(cachepath)),
+                    exc_info=True,
+                )
+                return content
+        return load  # type: ignore
+    return _cached_loader
+
+
 def load_protocols(filename, _fallback=None, _integer_base=10,
                    _cls=DADict[int, str]):
-    # type: (str, Optional[bytes], int, type) -> DADict[int, str]
-    """"Parse /etc/protocols and return values as a dictionary."""
+    # type: (str, Optional[Callable[[], Iterator[str]]], int, type) -> DADict[int, str]
+    """"
+    Parse /etc/protocols and return values as a dictionary.
+    """
     dct = _cls(_name=filename)  # type: DADict[int, str]
 
     def _process_data(fdesc):
-        # type: (Iterator[bytes]) -> None
+        # type: (Iterator[str]) -> None
         for line in fdesc:
             try:
-                shrp = line.find(b"#")
+                shrp = line.find("#")
                 if shrp >= 0:
                     line = line[:shrp]
                 line = line.strip()
                 if not line:
                     continue
                 lt = tuple(line.split())
                 if len(lt) < 2 or not lt[0]:
@@ -315,19 +369,19 @@
                     filename,
                     line,
                     e,
                 )
     try:
         if not filename:
             raise IOError
-        with open(filename, "rb") as fdesc:
+        with open(filename, "r", errors="backslashreplace") as fdesc:
             _process_data(fdesc)
     except IOError:
         if _fallback:
-            _process_data(iter(_fallback.split(b"\n")))
+            _process_data(_fallback())
         else:
             log_loading.info("Can't open %s file", filename)
     return dct
 
 
 class EtherDA(DADict[int, str]):
     # Backward compatibility: accept
@@ -349,26 +403,31 @@
                 "Please use 'ETHER_TYPES.%s'" % attr,
                 DeprecationWarning
             )
             return super(EtherDA, self).__getattr__(attr)
         return super(EtherDA, self).__getitem__(attr)
 
 
-def load_ethertypes(filename):
+@scapy_data_cache("ethertypes")
+def load_ethertypes(filename=None):
     # type: (Optional[str]) -> EtherDA
     """"Parse /etc/ethertypes and return values as a dictionary.
     If unavailable, use the copy bundled with Scapy."""
-    from scapy.libs.ethertypes import DATA
-    prot = load_protocols(filename or "Scapy's backup ETHER_TYPES",
-                          _fallback=DATA,
+    def _fallback() -> Iterator[str]:
+        # Fallback. Lazy loaded as the file is big.
+        from scapy.libs.ethertypes import DATA
+        return iter(DATA.split("\n"))
+    prot = load_protocols(filename or "scapy/ethertypes",
+                          _fallback=_fallback,
                           _integer_base=16,
                           _cls=EtherDA)
     return cast(EtherDA, prot)
 
 
+@scapy_data_cache("services")
 def load_services(filename):
     # type: (str) -> Tuple[DADict[int, str], DADict[int, str], DADict[int, str]]  # noqa: E501
     tdct = DADict(_name="%s-tcp" % filename)  # type: DADict[int, str]
     udct = DADict(_name="%s-udp" % filename)  # type: DADict[int, str]
     sdct = DADict(_name="%s-sctp" % filename)  # type: DADict[int, str]
     dcts = {
         b"tcp": tdct,
@@ -454,52 +513,63 @@
         :returns: a dict of mac:tuples (Name, Extended Name)
         """
         if case_sensitive:
             filtr = lambda x, l: any(x in z for z in l)  # type: Callable[[str, Tuple[str, str]], bool]  # noqa: E501
         else:
             name = name.lower()
             filtr = lambda x, l: any(x in z.lower() for z in l)
-        return {k: v for k, v in six.iteritems(self.d)
-                if filtr(name, v)}
+        return {k: v for k, v in self.d.items() if filtr(name, v)}  # type: ignore
 
     def __dir__(self):
         # type: () -> List[str]
         return [
             "_get_manuf",
             "_get_short_manuf",
             "_resolve_MAC",
             "loopkup",
             "reverse_lookup",
         ] + super(ManufDA, self).__dir__()
 
 
-def load_manuf(filename):
-    # type: (str) -> ManufDA
+@scapy_data_cache("manufdb")
+def load_manuf(filename=None):
+    # type: (Optional[str]) -> ManufDA
     """
     Loads manuf file from Wireshark.
 
     :param filename: the file to load the manuf file from
     :returns: a ManufDA filled object
     """
-    manufdb = ManufDA(_name=filename)
-    with open(filename, "rb") as fdesc:
+    manufdb = ManufDA(_name=filename or "scapy/manufdb")
+
+    def _process_data(fdesc):
+        # type: (Iterator[str]) -> None
         for line in fdesc:
             try:
                 line = line.strip()
-                if not line or line.startswith(b"#"):
+                if not line or line.startswith("#"):
                     continue
                 parts = line.split(None, 2)
-                ouib, shrt = parts[:2]
-                lng = parts[2].lstrip(b"#").strip() if len(parts) > 2 else b""
+                oui, shrt = parts[:2]
+                lng = parts[2].lstrip("#").strip() if len(parts) > 2 else ""
                 lng = lng or shrt
-                oui = plain_str(ouib)
-                manufdb[oui] = plain_str(shrt), plain_str(lng)
+                manufdb[oui] = shrt, lng
             except Exception:
                 log_loading.warning("Couldn't parse one line from [%s] [%r]",
                                     filename, line, exc_info=True)
+
+    try:
+        if not filename:
+            raise IOError
+        with open(filename, "r", errors="backslashreplace") as fdesc:
+            _process_data(fdesc)
+    except IOError:
+        # Fallback. Lazy loaded as the file is big.
+        from scapy.libs.manuf import DATA
+        _process_data(iter(DATA.split("\n")))
     return manufdb
 
 
 def select_path(directories, filename):
     # type: (List[str], str) -> Optional[str]
     """Find filename among several directories"""
     for directory in directories:
@@ -520,32 +590,27 @@
     TCP_SERVICES, UDP_SERVICES, SCTP_SERVICES = load_services(os.path.join(
         os.environ["SystemRoot"],
         "system32",
         "drivers",
         "etc",
         "services",
     ))
-    # Default values, will be updated by arch.windows
-    ETHER_TYPES = load_ethertypes(None)
-    MANUFDB = ManufDA()
+    ETHER_TYPES = load_ethertypes()
+    MANUFDB = load_manuf()
 else:
     IP_PROTOS = load_protocols("/etc/protocols")
-    ETHER_TYPES = load_ethertypes("/etc/ethertypes")
     TCP_SERVICES, UDP_SERVICES, SCTP_SERVICES = load_services("/etc/services")
-    MANUFDB = ManufDA()
-    manuf_path = select_path(
-        ['/usr', '/usr/local', '/opt', '/opt/wireshark',
-         '/Applications/Wireshark.app/Contents/Resources'],
-        "share/wireshark/manuf"
+    ETHER_TYPES = load_ethertypes("/etc/ethertypes")
+    MANUFDB = load_manuf(
+        select_path(
+            ['/usr', '/usr/local', '/opt', '/opt/wireshark',
+             '/Applications/Wireshark.app/Contents/Resources'],
+            "share/wireshark/manuf"
+        )
     )
-    if manuf_path:
-        try:
-            MANUFDB = load_manuf(manuf_path)
-        except (IOError, OSError):
-            log_loading.warning("Cannot read wireshark manuf database")
 
 
 #####################
 #  knowledge bases  #
 #####################
 KBBaseType = Optional[Union[str, List[Tuple[str, Dict[str, Dict[str, str]]]]]]
```

### Comparing `scapy-2.5.0rc3/scapy/error.py` & `scapy-2.6.0rc1/scapy/error.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,22 +11,20 @@
 #     Logging subsystem     #
 #############################
 
 
 import logging
 import traceback
 import time
-import warnings
 
 from scapy.consts import WINDOWS
-import scapy.libs.six as six
 
 # Typing imports
 from logging import LogRecord
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     Tuple,
 )
 
 
 class Scapy_Exception(Exception):
@@ -66,15 +64,15 @@
             if ltm - tm > wt:
                 tm = ltm
                 nb = 0
             else:
                 if nb < 2:
                     nb += 1
                     if nb == 2:
-                        record.msg = "more " + record.msg
+                        record.msg = "more " + str(record.msg)
                 else:
                     return False
             self.warning_table[caller] = (tm, nb)
         return True
 
 
 class ScapyColoredFormatter(logging.Formatter):
@@ -106,14 +104,15 @@
         import colorama
         colorama.init()
     except ImportError:
         pass
 
 # get Scapy's master logger
 log_scapy = logging.getLogger("scapy")
+log_scapy.propagate = False
 # override the level if not already set
 if log_scapy.level == logging.NOTSET:
     log_scapy.setLevel(logging.WARNING)
 # add a custom handler controlled by Scapy's config
 _handler = logging.StreamHandler()
 _handler.setFormatter(
     ScapyColoredFormatter(
@@ -126,25 +125,14 @@
 log_runtime.addFilter(ScapyFreqFilter())
 # logs in interactive functions
 log_interactive = logging.getLogger("scapy.interactive")
 log_interactive.setLevel(logging.DEBUG)
 # logs when loading Scapy
 log_loading = logging.getLogger("scapy.loading")
 
-# Apply warnings filters for python 2
-if six.PY2:
-    try:
-        with warnings.catch_warnings():
-            warnings.simplefilter("ignore")
-            from cryptography.utils import CryptographyDeprecationWarning
-        warnings.filterwarnings("ignore",
-                                category=CryptographyDeprecationWarning)
-    except ImportError:
-        pass
-
 
 def warning(x, *args, **kargs):
     # type: (str, *Any, **Any) -> None
     """
     Prints a warning during runtime.
     """
     log_runtime.warning(x, *args, **kargs)
```

### Comparing `scapy-2.5.0rc3/scapy/fields.py` & `scapy-2.6.0rc1/scapy/fields.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,27 +5,28 @@
 # Copyright (C) Michael Farrell <micolous+git@gmail.com>
 
 
 """
 Fields: basic data structures that make up parts of packets.
 """
 
-from __future__ import absolute_import
 import calendar
 import collections
 import copy
+import datetime
 import inspect
 import math
 import socket
 import struct
 import time
 import warnings
 
 from types import MethodType
 from uuid import UUID
+from enum import Enum
 
 from scapy.config import conf
 from scapy.dadict import DADict
 from scapy.volatile import RandBin, RandByte, RandEnumKeys, RandInt, \
     RandIP, RandIP6, RandLong, RandMAC, RandNum, RandShort, RandSInt, \
     RandSByte, RandTermString, RandUUID, VolatileValue, RandSShort, \
     RandSLong, RandFloat
@@ -35,24 +36,16 @@
 from scapy.pton_ntop import inet_ntop, inet_pton
 from scapy.utils import inet_aton, inet_ntoa, lhex, mac2str, str2mac, EDecimal
 from scapy.utils6 import in6_6to4ExtractAddr, in6_isaddr6to4, \
     in6_isaddrTeredo, in6_ptop, Net6, teredoAddrExtractInfo
 from scapy.base_classes import Gen, Net, BasePacket, Field_metaclass
 from scapy.error import warning
 
-import scapy.libs.six as six
-from scapy.libs.six import integer_types
-
-try:
-    from enum import Enum
-except ImportError:
-    Enum = None  # type: ignore
-
 # Typing imports
-from scapy.compat import (
+from typing import (
     Any,
     AnyStr,
     Callable,
     Dict,
     List,
     Generic,
     Optional,
@@ -140,16 +133,15 @@
 #  Fields  #
 ############
 
 I = TypeVar('I')  # Internal storage  # noqa: E741
 M = TypeVar('M')  # Machine storage
 
 
-@six.add_metaclass(Field_metaclass)
-class Field(Generic[I, M]):
+class Field(Generic[I, M], metaclass=Field_metaclass):
     """
     For more information on how this works, please refer to the
     'Adding new protocols' chapter in the online documentation:
 
     https://scapy.readthedocs.io/en/stable/build_dissect.html
     """
     __slots__ = [
@@ -309,14 +301,15 @@
             )
 
 
 class _FieldContainer(object):
     """
     A field that acts as a container for another field
     """
+    __slots__ = ["fld"]
 
     def __getattr__(self, attr):
         # type: (str) -> Any
         return getattr(self.fld, attr)
 
 
 AnyField = Union[Field[Any, Any], _FieldContainer]
@@ -330,21 +323,43 @@
         # type: (Any) -> None
         self.fld = fld
 
     def __eq__(self, other):
         # type: (Any) -> bool
         return bool(self.fld == other)
 
-    def __ne__(self, other):
+    def __hash__(self):
+        # type: () -> int
+        return hash(self.fld)
+
+
+class MayEnd(_FieldContainer):
+    """
+    Allow packet dissection to end after the dissection of this field
+    if no bytes are left.
+
+    A good example would be a length field that can be 0 or a set value,
+    and where it would be too annoying to use multiple ConditionalFields
+
+    Important note: any field below this one MUST default
+    to an empty value, else the behavior will be unexpected.
+    """
+    __slots__ = ["fld"]
+
+    def __init__(self, fld):
+        # type: (Any) -> None
+        self.fld = fld
+
+    def __eq__(self, other):
         # type: (Any) -> bool
-        # Python 2.7 compat
-        return not self == other
+        return bool(self.fld == other)
 
-    # mypy doesn't support __hash__ = None
-    __hash__ = None  # type: ignore
+    def __hash__(self):
+        # type: () -> int
+        return hash(self.fld)
 
 
 class ActionField(_FieldContainer):
     __slots__ = ["fld", "_action_method", "_privdata"]
 
     def __init__(self, fld, action_method, **kargs):
         # type: (Field[Any, Any], str, **Any) -> None
@@ -358,15 +373,15 @@
         return getattr(self.fld, "any2i")(pkt, val)
 
 
 class ConditionalField(_FieldContainer):
     __slots__ = ["fld", "cond"]
 
     def __init__(self,
-                 fld,  # type: Field[Any, Any]
+                 fld,  # type: AnyField
                  cond  # type: Callable[[Packet], bool]
                  ):
         # type: (...) -> None
         self.fld = fld
         self.cond = cond
 
     def _evalcond(self, pkt):
@@ -410,56 +425,64 @@
 
     def __getattr__(self, attr):
         # type: (str) -> Any
         return getattr(self.fld, attr)
 
 
 class MultipleTypeField(_FieldContainer):
-    """MultipleTypeField are used for fields that can be implemented by
-various Field subclasses, depending on conditions on the packet.
-
-It is initialized with `flds` and `dflt`.
-
-`dflt` is the default field type, to be used when none of the
-conditions matched the current packet.
-
-`flds` is a list of tuples (`fld`, `cond`), where `fld` if a field
-type, and `cond` a "condition" to determine if `fld` is the field type
-that should be used.
+    """
+    MultipleTypeField are used for fields that can be implemented by
+    various Field subclasses, depending on conditions on the packet.
 
-`cond` is either:
+    It is initialized with `flds` and `dflt`.
 
-  - a callable `cond_pkt` that accepts one argument (the packet) and
-    returns True if `fld` should be used, False otherwise.
+    :param dflt: is the default field type, to be used when none of the
+                 conditions matched the current packet.
+    :param flds: is a list of tuples (`fld`, `cond`) or (`fld`, `cond`, `hint`)
+                 where `fld` if a field type, and `cond` a "condition" to
+                 determine if `fld` is the field type that should be used.
 
-  - a tuple (`cond_pkt`, `cond_pkt_val`), where `cond_pkt` is the same
-    as in the previous case and `cond_pkt_val` is a callable that
-    accepts two arguments (the packet, and the value to be set) and
-    returns True if `fld` should be used, False otherwise.
+    ``cond`` is either:
 
-See scapy.layers.l2.ARP (type "help(ARP)" in Scapy) for an example of
-use.
+    - a callable `cond_pkt` that accepts one argument (the packet) and
+      returns True if `fld` should be used, False otherwise.
+    - a tuple (`cond_pkt`, `cond_pkt_val`), where `cond_pkt` is the same
+      as in the previous case and `cond_pkt_val` is a callable that
+      accepts two arguments (the packet, and the value to be set) and
+      returns True if `fld` should be used, False otherwise.
 
+    See scapy.layers.l2.ARP (type "help(ARP)" in Scapy) for an example of
+    use.
     """
 
-    __slots__ = ["flds", "dflt", "name", "default"]
+    __slots__ = ["flds", "dflt", "hints", "name", "default"]
 
-    def __init__(self,
-                 flds,  # type: List[Tuple[Field[Any, Any], Any]]
-                 dflt  # type: Field[Any, Any]
-                 ):
-        # type: (...) -> None
-        self.flds = flds
+    def __init__(
+        self,
+        flds: List[Union[
+            Tuple[Field[Any, Any], Any, str],
+            Tuple[Field[Any, Any], Any]
+        ]],
+        dflt: Field[Any, Any]
+    ) -> None:
+        self.hints = {
+            x[0]: x[2]
+            for x in flds
+            if len(x) == 3
+        }
+        self.flds = [
+            (x[0], x[1]) for x in flds
+        ]
         self.dflt = dflt
         self.default = None  # So that we can detect changes in defaults
         self.name = self.dflt.name
         if any(x[0].name != self.name for x in self.flds):
             warnings.warn(
                 ("All fields should have the same name in a "
-                 "MultipleTypeField (%s)") % self.name,
+                 "MultipleTypeField (%s). Use hints.") % self.name,
                 SyntaxWarning
             )
 
     def _iterate_fields_cond(self, pkt, val, use_val):
         # type: (Optional[Packet], Any, bool) -> Field[Any, Any]
         """Internal function used by _find_fld_pkt & _find_fld_pkt_val"""
         # Iterate through the fields
@@ -569,35 +592,42 @@
         # type: (Packet, Any) -> int
         fld, val = self._find_fld_pkt_val(pkt, val)
         return fld.i2len(pkt, val)
 
     def i2repr(self, pkt, val):
         # type: (Optional[Packet], Any) -> str
         fld, val = self._find_fld_pkt_val(pkt, val)
-        return fld.i2repr(pkt, val)
+        hint = ""
+        if fld in self.hints:
+            hint = " (%s)" % self.hints[fld]
+        return fld.i2repr(pkt, val) + hint
 
     def register_owner(self, cls):
         # type: (Type[Packet]) -> None
         for fld, _ in self.flds:
             fld.owners.append(cls)
         self.dflt.owners.append(cls)
 
+    def get_fields_list(self):
+        # type: () -> List[Any]
+        return [self]
+
     @property
     def fld(self):
         # type: () -> Field[Any, Any]
         return self._find_fld()
 
 
 class PadField(_FieldContainer):
     """Add bytes after the proxified field so that it ends at the specified
        alignment from its beginning"""
     __slots__ = ["fld", "_align", "_padwith"]
 
     def __init__(self, fld, align, padwith=None):
-        # type: (Field[Any, Any], int, Optional[bytes]) -> None
+        # type: (AnyField, int, Optional[bytes]) -> None
         self.fld = fld
         self._align = align
         self._padwith = padwith or b"\x00"
 
     def padlen(self, flen, pkt):
         # type: (int, Packet) -> int
         return -flen % self._align
@@ -614,19 +644,16 @@
     def addfield(self,
                  pkt,  # type: Packet
                  s,  # type: bytes
                  val,  # type: Any
                  ):
         # type: (...) -> bytes
         sval = self.fld.addfield(pkt, b"", val)
-        return s + sval + struct.pack(
-            "%is" % (
-                self.padlen(len(sval), pkt)
-            ),
-            self._padwith
+        return s + sval + (
+            self.padlen(len(sval), pkt) * self._padwith
         )
 
 
 class ReversePadField(PadField):
     """Add bytes BEFORE the proxified field so that it starts at the specified
        alignment from its beginning"""
 
@@ -671,19 +698,14 @@
         elif isinstance(item, slice):
             start, stop, step = item.start, item.stop, item.step
             new_start = -stop if stop else None
             new_stop = -start if start else None
             item = slice(new_start, new_stop, step)
         return super(self.__class__, self).__getitem__(item)
 
-    if six.PY2:
-        def __getslice__(self, i, j):
-            # Python 2 compat
-            return self.__getitem__(slice(i, j))
-
 
 class TrailerField(_FieldContainer):
     """Special Field that gets its value from the end of the *packet*
     (Note: not layer, but packet).
 
     Mostly used for FCS
     """
@@ -750,15 +772,15 @@
         self.defaultdst = default
 
     def dst_from_pkt(self, pkt):
         # type: (Packet) -> str
         for addr, condition in self.bindings.get(pkt.payload.__class__, []):
             try:
                 if all(pkt.payload.getfieldval(field) == value
-                       for field, value in six.iteritems(condition)):
+                       for field, value in condition.items()):
                     return addr  # type: ignore
             except AttributeError:
                 pass
         return self.defaultdst
 
     @classmethod
     def bind_addr(cls, layer, addr, **condition):
@@ -771,15 +793,15 @@
 class MACField(Field[Optional[str], bytes]):
     def __init__(self, name, default):
         # type: (str, Optional[Any]) -> None
         Field.__init__(self, name, default, "6s")
 
     def i2m(self, pkt, x):
         # type: (Optional[Packet], Optional[str]) -> bytes
-        if x is None:
+        if not x:
             return b"\0\0\0\0\0\0"
         try:
             y = mac2str(x)
         except (struct.error, OverflowError):
             y = bytes_encode(x)
         return y
 
@@ -803,28 +825,42 @@
         return x
 
     def randval(self):
         # type: () -> RandMAC
         return RandMAC()
 
 
+class LEMACField(MACField):
+    def i2m(self, pkt, x):
+        # type: (Optional[Packet], Optional[str]) -> bytes
+        return MACField.i2m(self, pkt, x)[::-1]
+
+    def m2i(self, pkt, x):
+        # type: (Optional[Packet], bytes) -> str
+        return MACField.m2i(self, pkt, x[::-1])
+
+
 class IPField(Field[Union[str, Net], bytes]):
     def __init__(self, name, default):
         # type: (str, Optional[str]) -> None
         Field.__init__(self, name, default, "4s")
 
     def h2i(self, pkt, x):
         # type: (Optional[Packet], Union[AnyStr, List[AnyStr]]) -> Any
         if isinstance(x, bytes):
             x = plain_str(x)  # type: ignore
         if isinstance(x, str):
             try:
                 inet_aton(x)
             except socket.error:
                 return Net(x)
+        elif isinstance(x, tuple):
+            if len(x) != 2:
+                raise ValueError("Invalid IP format")
+            return Net(*x)
         elif isinstance(x, list):
             return [self.h2i(pkt, n) for n in x]
         return x
 
     def i2h(self, pkt, x):
         # type: (Optional[Packet], Optional[Union[str, Net]]) -> str
         return cast(str, x)
@@ -913,14 +949,18 @@
         if isinstance(x, bytes):
             x = plain_str(x)
         if isinstance(x, str):
             try:
                 x = in6_ptop(x)
             except socket.error:
                 return Net6(x)  # type: ignore
+        elif isinstance(x, tuple):
+            if len(x) != 2:
+                raise ValueError("Invalid IPv6 format")
+            return Net6(*x)
         elif isinstance(x, list):
             x = [self.h2i(pkt, n) for n in x]
         return x  # type: ignore
 
     def i2h(self, pkt, x):
         # type: (Optional[Packet], Optional[Union[str, Net6]]) -> str
         return cast(str, x)
@@ -1062,20 +1102,29 @@
         return s + struct.pack(self.fmt, self.i2m(pkt, val))[:3]
 
     def getfield(self, pkt, s):
         # type: (Optional[Packet], bytes) -> Tuple[bytes, int]
         return s[3:], self.m2i(pkt, struct.unpack(self.fmt, s[:3] + b"\x00")[0])  # noqa: E501
 
 
-class LEX3BytesField(LEThreeBytesField, XByteField):
+class XLE3BytesField(LEThreeBytesField, XByteField):
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], int) -> str
         return XByteField.i2repr(self, pkt, x)
 
 
+def LEX3BytesField(*args, **kwargs):
+    # type: (*Any, **Any) -> Any
+    warnings.warn(
+        "LEX3BytesField is deprecated. Use XLE3BytesField",
+        DeprecationWarning
+    )
+    return XLE3BytesField(*args, **kwargs)
+
+
 class NBytesField(Field[int, List[int]]):
     def __init__(self, name, default, sz):
         # type: (str, Optional[int], int) -> None
         Field.__init__(self, name, default, "<" + "B" * sz)
 
     def i2m(self, pkt, x):
         # type: (Optional[Packet], Optional[int]) -> List[int]
@@ -1089,37 +1138,41 @@
 
     def m2i(self, pkt, x):
         # type: (Optional[Packet], Union[List[int], int]) -> int
         if isinstance(x, int):
             return x
         # x can be a tuple when coming from struct.unpack  (from getfield)
         if isinstance(x, (list, tuple)):
-            return sum(d * (256 ** i) for i, d in enumerate(x))
+            return sum(d * (256 ** i) for i, d in enumerate(reversed(x)))
         return 0
 
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], int) -> str
-        if isinstance(x, integer_types):
+        if isinstance(x, int):
             return '%i' % x
         return super(NBytesField, self).i2repr(pkt, x)
 
     def addfield(self, pkt, s, val):
         # type: (Optional[Packet], bytes, Optional[int]) -> bytes
         return s + self.struct.pack(*self.i2m(pkt, val))
 
     def getfield(self, pkt, s):
         # type: (Optional[Packet], bytes) -> Tuple[bytes, int]
         return (s[self.sz:],
                 self.m2i(pkt, self.struct.unpack(s[:self.sz])))  # type: ignore
 
+    def randval(self):
+        # type: () -> RandNum
+        return RandNum(0, 2 ** (self.sz * 8) - 1)
+
 
 class XNBytesField(NBytesField):
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], int) -> str
-        if isinstance(x, integer_types):
+        if isinstance(x, int):
             return '0x%x' % x
         # x can be a tuple when coming from struct.unpack (from getfield)
         if isinstance(x, (list, tuple)):
             return "0x" + "".join("%02x" % b for b in x)
         return super(XNBytesField, self).i2repr(pkt, x)
 
 
@@ -1129,14 +1182,18 @@
         Field.__init__(self, name, default, "b")
 
 
 class FieldValueRangeException(Scapy_Exception):
     pass
 
 
+class MaximumItemsCount(Scapy_Exception):
+    pass
+
+
 class FieldAttributeException(Scapy_Exception):
     pass
 
 
 class YesNoByteField(ByteField):
     """
     A byte based flag field that shows representation of its number
@@ -1383,22 +1440,22 @@
         # type: (Optional[Packet], Any) -> int
         if x is None:
             return 0
         return len(x)
 
     def any2i(self, pkt, x):
         # type: (Optional[Packet], Any) -> I
-        if isinstance(x, six.text_type):
+        if isinstance(x, str):
             x = bytes_encode(x)
         return super(_StrField, self).any2i(pkt, x)  # type: ignore
 
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], I) -> str
-        if isinstance(x, bytes):
-            return repr(plain_str(x))
+        if x and isinstance(x, bytes):
+            return repr(x)
         return super(_StrField, self).i2repr(pkt, x)
 
     def i2m(self, pkt, x):
         # type: (Optional[Packet], Optional[I]) -> bytes
         if x is None:
             return b""
         if not isinstance(x, bytes):
@@ -1422,31 +1479,31 @@
 
 
 class StrField(_StrField[bytes]):
     pass
 
 
 class StrFieldUtf16(StrField):
-    def h2i(self, pkt, x):
-        # type: (Optional[Packet], Optional[str]) -> bytes
-        return plain_str(x).encode('utf-16')[2:]
-
     def any2i(self, pkt, x):
         # type: (Optional[Packet], Optional[str]) -> bytes
-        if isinstance(x, six.text_type):
+        if isinstance(x, str):
             return self.h2i(pkt, x)
         return super(StrFieldUtf16, self).any2i(pkt, x)
 
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], bytes) -> str
         return plain_str(self.i2h(pkt, x))
 
+    def h2i(self, pkt, x):
+        # type: (Optional[Packet], Optional[str]) -> bytes
+        return plain_str(x).encode('utf-16-le', errors="replace")
+
     def i2h(self, pkt, x):
         # type: (Optional[Packet], bytes) -> str
-        return bytes_encode(x).decode('utf-16', errors="replace")
+        return bytes_encode(x).decode('utf-16-le', errors="replace")
 
 
 class _StrEnumField:
     def __init__(self, **kwargs):
         # type: (**Any) -> None
         self.enum = kwargs.pop("enum", {})
 
@@ -1498,50 +1555,52 @@
             i,  # type: Any
             ):
         # type: (...) -> bytes
         if i is None:
             return b""
         return raw(i)
 
-    def m2i(self, pkt, m):
+    def m2i(self, pkt, m):  # type: ignore
         # type: (Optional[Packet], bytes) -> Packet
         try:
             # we want to set parent wherever possible
             return self.cls(m, _parent=pkt)  # type: ignore
         except TypeError:
             return self.cls(m)
 
+
+class _PacketFieldSingle(_PacketField[K]):
+    def any2i(self, pkt, x):
+        # type: (Optional[Packet], Any) -> K
+        if x and pkt and hasattr(x, "add_parent"):
+            cast("Packet", x).add_parent(pkt)
+        return super(_PacketFieldSingle, self).any2i(pkt, x)
+
     def getfield(self,
                  pkt,  # type: Packet
                  s,  # type: bytes
                  ):
         # type: (...) -> Tuple[bytes, K]
         i = self.m2i(pkt, s)
         remain = b""
         if conf.padding_layer in i:
             r = i[conf.padding_layer]
             del r.underlayer.payload
             remain = r.load
-        return remain, i
+        return remain, i  # type: ignore
 
-    def randval(self):
+
+class PacketField(_PacketFieldSingle[BasePacket]):
+    def randval(self):  # type: ignore
         # type: () -> Packet
         from scapy.packet import fuzz
         return fuzz(self.cls())  # type: ignore
 
 
-class PacketField(_PacketField[BasePacket]):
-    def any2i(self, pkt, x):
-        # type: (Optional[Packet], BasePacket) -> BasePacket
-        if x and pkt and hasattr(x, "add_parent"):
-            cast("Packet", x).add_parent(pkt)
-        return super(PacketField, self).any2i(pkt, x)
-
-
-class PacketLenField(_PacketField[Optional[BasePacket]]):
+class PacketLenField(_PacketFieldSingle[Optional[BasePacket]]):
     __slots__ = ["length_from"]
 
     def __init__(self,
                  name,  # type: str
                  default,  # type: Packet
                  cls,  # type: Union[Callable[[bytes], Packet], Type[Packet]]  # noqa: E501
                  length_from=None  # type: Optional[Callable[[Packet], int]]  # noqa: E501
@@ -1550,15 +1609,15 @@
         super(PacketLenField, self).__init__(name, default, cls)
         self.length_from = length_from or (lambda x: 0)
 
     def getfield(self,
                  pkt,  # type: Packet
                  s,  # type: bytes
                  ):
-        # type: (...) -> Tuple[bytes, Optional[Packet]]
+        # type: (...) -> Tuple[bytes, Optional[BasePacket]]
         len_pkt = self.length_from(pkt)
         i = None
         if len_pkt:
             try:
                 i = self.m2i(pkt, s[:len_pkt])
             except Exception:
                 if conf.debug_dissector:
@@ -1571,25 +1630,26 @@
     """PacketListField represents a list containing a series of Packet instances
     that might occur right in the middle of another Packet field.
     This field type may also be used to indicate that a series of Packet
     instances have a sibling semantic instead of a parent/child relationship
     (i.e. a stack of layers). All elements in PacketListField have current
     packet referenced in parent field.
     """
-    __slots__ = ["count_from", "length_from", "next_cls_cb"]
+    __slots__ = ["count_from", "length_from", "next_cls_cb", "max_count"]
     islist = 1
 
     def __init__(
             self,
             name,  # type: str
             default,  # type: Optional[List[BasePacket]]
             pkt_cls=None,  # type: Optional[Union[Callable[[bytes], Packet], Type[Packet]]]  # noqa: E501
             count_from=None,  # type: Optional[Callable[[Packet], int]]
             length_from=None,  # type: Optional[Callable[[Packet], int]]
             next_cls_cb=None,  # type: Optional[Callable[[Packet, List[BasePacket], Optional[Packet], bytes], Type[Packet]]]  # noqa: E501
+            max_count=None,  # type: Optional[int]
     ):
         # type: (...) -> None
         """
         The number of Packet instances that are dissected by this field can
         be parametrized using one of three different mechanisms/parameters:
 
             * count_from: a callback that returns the number of Packet
@@ -1681,25 +1741,28 @@
         :param pkt_cls: either a callable returning a Packet instance or a
             class object defining a ``dispatch_hook`` class method
         :param count_from: a callback returning the number of Packet
             instances to dissect.
         :param length_from: a callback returning the number of bytes to dissect
         :param next_cls_cb: a callback returning either None or the type of
             the next Packet to dissect.
+        :param max_count: an int containing the max amount of results. This is
+            a safety mechanism, exceeding this value will raise a Scapy_Exception.
         """
         if default is None:
             default = []  # Create a new list for each instance
         super(PacketListField, self).__init__(
             name,
             default,
             pkt_cls  # type: ignore
         )
         self.count_from = count_from
         self.length_from = length_from
         self.next_cls_cb = next_cls_cb
+        self.max_count = max_count
 
     def any2i(self, pkt, x):
         # type: (Optional[Packet], Any) -> List[BasePacket]
         if not isinstance(x, list):
             if x and pkt and hasattr(x, "add_parent"):
                 x.add_parent(pkt)
             return [x]
@@ -1772,15 +1835,26 @@
                         cls = self.next_cls_cb(pkt, lst, p, remain)
                         if cls is not None:
                             c = 0 if c is None else c
                             c += 1
                 else:
                     remain = b""
             lst.append(p)
-        return remain + ret, lst
+            if len(lst) > (self.max_count or conf.max_list_count):
+                raise MaximumItemsCount(
+                    "Maximum amount of items reached in PacketListField: %s "
+                    "(defaults to conf.max_list_count)"
+                    % (self.max_count or conf.max_list_count)
+                )
+
+        if isinstance(remain, tuple):
+            remain, nb = remain
+            return (remain + ret, nb), lst
+        else:
+            return remain + ret, lst
 
     def i2m(self,
             pkt,  # type: Optional[Packet]
             i,  # type: Any
             ):
         # type: (...) -> bytes
         return bytes_encode(i)
@@ -1815,14 +1889,16 @@
         if isinstance(v, bytes):
             v = v.rstrip(b"\0")
         return super(StrFixedLenField, self).i2repr(pkt, v)
 
     def getfield(self, pkt, s):
         # type: (Packet, bytes) -> Tuple[bytes, bytes]
         len_pkt = self.length_from(pkt)
+        if len_pkt == 0:
+            return s, b""
         return s[len_pkt:], self.m2i(pkt, s[:len_pkt])
 
     def addfield(self, pkt, s, val):
         # type: (Packet, bytes, Optional[bytes]) -> bytes
         len_pkt = self.length_from(pkt)
         if len_pkt is None:
             return s + self.i2m(pkt, val)
@@ -1875,15 +1951,15 @@
             chb(0x41 + (orb(b) & 0xf))
             for b in x
         )  # noqa: E501
         return b" " + x
 
     def m2i(self, pkt, x):
         # type: (Optional[Packet], bytes) -> bytes
-        x = x.strip(b"\x00").strip(b" ")
+        x = x[1:].strip(b"\x00").strip(b" ")
         return b"".join(map(
             lambda x, y: chb(
                 (((orb(x) - 1) & 0xf) << 4) + ((orb(y) - 1) & 0xf)
             ),
             x[::2], x[1::2]
         ))
 
@@ -1911,14 +1987,16 @@
         self.max_length = max_length
 
     def getfield(self, pkt, s):
         # type: (Any, bytes) -> Tuple[bytes, bytes]
         len_pkt = (self.length_from or (lambda x: 0))(pkt)
         if not self.ON_WIRE_SIZE_UTF16:
             len_pkt *= 2
+        if len_pkt == 0:
+            return s, b""
         return s[len_pkt:], self.m2i(pkt, s[:len_pkt])
 
     def randval(self):
         # type: () -> RandBin
         return RandBin(RandNum(0, self.max_length or 1200))
 
 
@@ -1960,14 +2038,29 @@
         return x[:: -1]
 
 
 class StrLenFieldUtf16(StrLenField, StrFieldUtf16):
     pass
 
 
+class StrLenEnumField(_StrEnumField, StrLenField):
+    __slots__ = ["enum"]
+
+    def __init__(
+            self,
+            name,  # type: str
+            default,  # type: bytes
+            enum=None,  # type: Optional[Dict[str, str]]
+            **kwargs  # type: Any
+    ):
+        # type: (...) -> None
+        StrLenField.__init__(self, name, default, **kwargs)
+        self.enum = enum
+
+
 class BoundStrLenField(StrLenField):
     __slots__ = ["minlen", "maxlen"]
 
     def __init__(
             self,
             name,  # type: str
             default,  # type: bytes
@@ -1982,32 +2075,34 @@
 
     def randval(self):
         # type: () -> RandBin
         return RandBin(RandNum(self.minlen, self.maxlen))
 
 
 class FieldListField(Field[List[Any], List[Any]]):
-    __slots__ = ["field", "count_from", "length_from"]
+    __slots__ = ["field", "count_from", "length_from", "max_count"]
     islist = 1
 
     def __init__(
             self,
             name,  # type: str
             default,  # type: Optional[List[AnyField]]
             field,  # type: AnyField
             length_from=None,  # type: Optional[Callable[[Packet], int]]
             count_from=None,  # type: Optional[Callable[[Packet], int]]
+            max_count=None,  # type: Optional[int]
     ):
         # type: (...) -> None
         if default is None:
             default = []  # Create a new list for each instance
         self.field = field
         Field.__init__(self, name, default)
         self.count_from = count_from
         self.length_from = length_from
+        self.max_count = max_count
 
     def i2count(self, pkt, val):
         # type: (Optional[Packet], List[Any]) -> int
         if isinstance(val, list):
             return len(val)
         return 1
 
@@ -2059,15 +2154,26 @@
         while s:
             if c is not None:
                 if c <= 0:
                     break
                 c -= 1
             s, v = self.field.getfield(pkt, s)
             val.append(v)
-        return s + ret, val
+            if len(val) > (self.max_count or conf.max_list_count):
+                raise MaximumItemsCount(
+                    "Maximum amount of items reached in FieldListField: %s "
+                    "(defaults to conf.max_list_count)"
+                    % (self.max_count or conf.max_list_count)
+                )
+
+        if isinstance(s, tuple):
+            s, bn = s
+            return (s + ret, bn), val
+        else:
+            return s + ret, val
 
 
 class FieldLenField(Field[int, int]):
     __slots__ = ["length_of", "count_of", "adjust"]
 
     def __init__(
             self,
@@ -2101,15 +2207,14 @@
         elif x is None:
             x = 0
         return x
 
 
 class StrNullField(StrField):
     DELIMITER = b"\x00"
-    ALIGNMENT = 1
 
     def addfield(self, pkt, s, val):
         # type: (Packet, bytes, Optional[bytes]) -> bytes
         return s + self.i2m(pkt, val) + self.DELIMITER
 
     def getfield(self,
                  pkt,  # type: Packet
@@ -2118,15 +2223,15 @@
         # type: (...) -> Tuple[bytes, bytes]
         len_str = 0
         while True:
             len_str = s.find(self.DELIMITER, len_str)
             if len_str < 0:
                 # DELIMITER not found: return empty
                 return b"", s
-            if len_str % self.ALIGNMENT:
+            if len_str % len(self.DELIMITER):
                 len_str += 1
             else:
                 break
         return s[len_str + len(self.DELIMITER):], self.m2i(pkt, s[:len_str])
 
     def randval(self):
         # type: () -> RandTermString
@@ -2135,15 +2240,14 @@
     def i2len(self, pkt, x):
         # type: (Optional[Packet], Any) -> int
         return super(StrNullField, self).i2len(pkt, x) + 1
 
 
 class StrNullFieldUtf16(StrNullField, StrFieldUtf16):
     DELIMITER = b"\x00\x00"
-    ALIGNMENT = 2
 
 
 class StrStopField(StrField):
     __slots__ = ["stop", "additional"]
 
     def __init__(self, name, default, stop, additional=0):
         # type: (str, str, bytes, int) -> None
@@ -2342,42 +2446,42 @@
         return float(self.size) / 8
 
 
 class BitField(_BitField[int]):
     __doc__ = _BitField.__doc__
 
 
-class BitFixedLenField(BitField):
+class BitLenField(BitField):
     __slots__ = ["length_from"]
 
     def __init__(self,
                  name,  # type: str
                  default,  # type: Optional[int]
                  length_from  # type: Callable[[Packet], int]
                  ):
         # type: (...) -> None
         self.length_from = length_from
-        super(BitFixedLenField, self).__init__(name, default, 0)
+        super(BitLenField, self).__init__(name, default, 0)
 
     def getfield(self,  # type: ignore
                  pkt,  # type: Packet
                  s,  # type: Union[Tuple[bytes, int], bytes]
                  ):
         # type: (...) -> Union[Tuple[Tuple[bytes, int], int], Tuple[bytes, int]]  # noqa: E501
         self.size = self.length_from(pkt)
-        return super(BitFixedLenField, self).getfield(pkt, s)
+        return super(BitLenField, self).getfield(pkt, s)
 
     def addfield(self,  # type: ignore
                  pkt,  # type: Packet
                  s,  # type: Union[Tuple[bytes, int, int], bytes]
                  val  # type: int
                  ):
         # type: (...) -> Union[Tuple[bytes, int, int], bytes]
         self.size = self.length_from(pkt)
-        return super(BitFixedLenField, self).addfield(pkt, s, val)
+        return super(BitLenField, self).addfield(pkt, s, val)
 
 
 class BitFieldLenField(BitField):
     __slots__ = ["length_of", "count_of", "adjust", "tot_size", "end_tot_size"]
 
     def __init__(self,
                  name,  # type: str
@@ -2394,19 +2498,15 @@
                                                tot_size, end_tot_size)
         self.length_of = length_of
         self.count_of = count_of
         self.adjust = adjust
 
     def i2m(self, pkt, x):
         # type: (Optional[Packet], Optional[Any]) -> int
-        if six.PY2:
-            func = FieldLenField.i2m.__func__
-        else:
-            func = FieldLenField.i2m
-        return func(self, pkt, x)  # type: ignore
+        return FieldLenField.i2m(self, pkt, x)  # type: ignore
 
 
 class XBitField(BitField):
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], int) -> str
         return lhex(self.i2h(pkt, x))
 
@@ -2438,15 +2538,15 @@
             cast(ObservableDict, enum).observe(self)
 
         if isinstance(enum, tuple):
             self.i2s_cb = enum[0]  # type: Optional[Callable[[I], str]]
             self.s2i_cb = enum[1]  # type: Optional[Callable[[str], I]]
             self.i2s = None  # type: Optional[Dict[I, str]]
             self.s2i = None  # type: Optional[Dict[str, I]]
-        elif Enum and isinstance(enum, type) and issubclass(enum, Enum):
+        elif isinstance(enum, type) and issubclass(enum, Enum):
             # Python's Enum
             i2s = self.i2s = {}
             s2i = self.s2i = {}
             self.i2s_cb = None
             self.s2i_cb = None
             names = [x.name for x in enum]
             for n in names:
@@ -2471,36 +2571,40 @@
                 value = cast(str, enum[k])  # type: ignore
                 i2s[k] = value
                 s2i[value] = k
         Field.__init__(self, name, default, fmt)
 
     def any2i_one(self, pkt, x):
         # type: (Optional[Packet], Any) -> I
-        if Enum and isinstance(x, Enum):
+        if isinstance(x, Enum):
             return cast(I, x.value)
         elif isinstance(x, str):
             if self.s2i:
                 x = self.s2i[x]
             elif self.s2i_cb:
                 x = self.s2i_cb(x)
         return cast(I, x)
 
+    def _i2repr(self, pkt, x):
+        # type: (Optional[Packet], I) -> str
+        return repr(x)
+
     def i2repr_one(self, pkt, x):
         # type: (Optional[Packet], I) -> str
         if self not in conf.noenum and not isinstance(x, VolatileValue):
             if self.i2s:
                 try:
                     return self.i2s[x]
                 except KeyError:
                     pass
             elif self.i2s_cb:
                 ret = self.i2s_cb(x)
                 if ret is not None:
                     return ret
-        return repr(x)
+        return self._i2repr(pkt, x)
 
     def any2i(self, pkt, x):
         # type: (Optional[Packet], Any) -> Union[I, List[I]]
         if isinstance(x, list):
             return [self.any2i_one(pkt, z) for z in x]
         else:
             return self.any2i_one(pkt, x)
@@ -2540,15 +2644,15 @@
     def __init__(self,
                  name,  # type: str
                  default,  # type: str
                  enum,  # type: Union[Dict[str, str], Tuple[Callable[[str], str], Callable[[str], str]]]  # noqa: E501
                  fmt="1s",  # type: str
                  ):
         # type: (...) -> None
-        EnumField.__init__(self, name, default, enum, fmt)
+        super(CharEnumField, self).__init__(name, default, enum, fmt)
         if self.i2s is not None:
             k = list(self.i2s)
             if k and len(k[0]) != 1:
                 self.i2s, self.s2i = self.s2i, self.i2s
 
     def any2i_one(self, pkt, x):
         # type: (Optional[Packet], str) -> str
@@ -2576,42 +2680,68 @@
                pkt,  # type: Optional[Packet]
                x,  # type: Union[List[int], int]
                ):
         # type: (...) -> Any
         return _EnumField.i2repr(self, pkt, x)
 
 
+class BitLenEnumField(BitLenField, _EnumField[int]):
+    __slots__ = EnumField.__slots__
+
+    def __init__(self,
+                 name,  # type: str
+                 default,  # type: Optional[int]
+                 length_from,  # type: Callable[[Packet], int]
+                 enum,  # type: Dict[int, str]
+                 **kwargs,  # type: Any
+                 ):
+        # type: (...) -> None
+        _EnumField.__init__(self, name, default, enum)
+        BitLenField.__init__(self, name, default, length_from, **kwargs)
+
+    def any2i(self, pkt, x):
+        # type: (Optional[Packet], Any) -> int
+        return _EnumField.any2i(self, pkt, x)  # type: ignore
+
+    def i2repr(self,
+               pkt,  # type: Optional[Packet]
+               x,  # type: Union[List[int], int]
+               ):
+        # type: (...) -> Any
+        return _EnumField.i2repr(self, pkt, x)
+
+
 class ShortEnumField(EnumField[int]):
     __slots__ = EnumField.__slots__
 
     def __init__(self,
                  name,  # type: str
                  default,  # type: int
                  enum,  # type: Union[Dict[int, str], Dict[str, int], Tuple[Callable[[int], str], Callable[[str], int]], DADict[int, str]]  # noqa: E501
                  ):
         # type: (...) -> None
-        EnumField.__init__(self, name, default, enum, "H")
+        super(ShortEnumField, self).__init__(name, default, enum, "H")
 
 
 class LEShortEnumField(EnumField[int]):
     def __init__(self, name, default, enum):
         # type: (str, int, Union[Dict[int, str], List[str]]) -> None
-        EnumField.__init__(self, name, default, enum, "<H")
+        super(LEShortEnumField, self).__init__(name, default, enum, "<H")
 
 
 class LELongEnumField(EnumField[int]):
     def __init__(self, name, default, enum):
         # type: (str, int, Union[Dict[int, str], List[str]]) -> None
-        EnumField.__init__(self, name, default, enum, "<Q")
+        super(LELongEnumField, self).__init__(name, default, enum, "<Q")
 
 
 class ByteEnumField(EnumField[int]):
     def __init__(self, name, default, enum):
         # type: (str, Optional[int], Dict[int, str]) -> None
-        EnumField.__init__(self, name, default, enum, "B")
+        super(ByteEnumField, self).__init__(name, default, enum, "B")
 
 
 class XByteEnumField(ByteEnumField):
     def i2repr_one(self, pkt, x):
         # type: (Optional[Packet], int) -> str
         if self not in conf.noenum and not isinstance(x, VolatileValue):
             if self.i2s:
@@ -2625,42 +2755,55 @@
                     return ret
         return lhex(x)
 
 
 class IntEnumField(EnumField[int]):
     def __init__(self, name, default, enum):
         # type: (str, Optional[int], Dict[int, str]) -> None
-        EnumField.__init__(self, name, default, enum, "I")
+        super(IntEnumField, self).__init__(name, default, enum, "I")
 
 
 class SignedIntEnumField(EnumField[int]):
     def __init__(self, name, default, enum):
         # type: (str, Optional[int], Dict[int, str]) -> None
-        EnumField.__init__(self, name, default, enum, "i")
+        super(SignedIntEnumField, self).__init__(name, default, enum, "i")
 
 
 class LEIntEnumField(EnumField[int]):
     def __init__(self, name, default, enum):
         # type: (str, int, Dict[int, str]) -> None
-        EnumField.__init__(self, name, default, enum, "<I")
+        super(LEIntEnumField, self).__init__(name, default, enum, "<I")
 
 
 class XShortEnumField(ShortEnumField):
-    def i2repr_one(self, pkt, x):
-        # type: (Optional[Packet], int) -> str
-        if self not in conf.noenum and not isinstance(x, VolatileValue):
-            if self.i2s is not None:
-                try:
-                    return self.i2s[x]
-                except KeyError:
-                    pass
-            elif self.i2s_cb:
-                ret = self.i2s_cb(x)
-                if ret is not None:
-                    return ret
+    def _i2repr(self, pkt, x):
+        # type: (Optional[Packet], Any) -> str
+        return lhex(x)
+
+
+class LE3BytesEnumField(LEThreeBytesField, _EnumField[int]):
+    __slots__ = EnumField.__slots__
+
+    def __init__(self, name, default, enum):
+        # type: (str, Optional[int], Dict[int, str]) -> None
+        _EnumField.__init__(self, name, default, enum)
+        LEThreeBytesField.__init__(self, name, default)
+
+    def any2i(self, pkt, x):
+        # type: (Optional[Packet], Any) -> int
+        return _EnumField.any2i(self, pkt, x)  # type: ignore
+
+    def i2repr(self, pkt, x):  # type: ignore
+        # type: (Optional[Packet], Any) -> Union[List[str], str]
+        return _EnumField.i2repr(self, pkt, x)
+
+
+class XLE3BytesEnumField(LE3BytesEnumField):
+    def _i2repr(self, pkt, x):
+        # type: (Optional[Packet], Any) -> str
         return lhex(x)
 
 
 class _MultiEnumField(_EnumField[I]):
     def __init__(self,
                  name,  # type: str
                  default,  # type: int
@@ -2673,15 +2816,15 @@
         self.depends_on = depends_on
         self.i2s_multi = enum
         self.s2i_multi = {}  # type: Dict[I, Dict[str, I]]
         self.s2i_all = {}  # type: Dict[str, I]
         for m in enum:
             s2i = {}  # type: Dict[str, I]
             self.s2i_multi[m] = s2i
-            for k, v in six.iteritems(enum[m]):
+            for k, v in enum[m].items():
                 s2i[v] = k
                 self.s2i_all[v] = k
         Field.__init__(self, name, default, fmt)
 
     def any2i_one(self, pkt, x):
         # type: (Optional[Packet], Any) -> I
         if isinstance(x, str):
@@ -2723,23 +2866,31 @@
         _MultiEnumField.__init__(self, name, default, enum, depends_on)
         self.rev = size < 0
         self.size = abs(size)
         self.sz = self.size / 8.  # type: ignore
 
     def any2i(self, pkt, x):
         # type: (Optional[Packet], Any) -> Union[List[int], int]
-        return _MultiEnumField.any2i(self, pkt, x)
+        return _MultiEnumField[int].any2i(
+            self,  # type: ignore
+            pkt,
+            x
+        )
 
     def i2repr(  # type: ignore
             self,
             pkt,  # type: Optional[Packet]
             x  # type: Union[List[int], int]
     ):
         # type: (...) -> Union[str, List[str]]
-        return _MultiEnumField.i2repr(self, pkt, x)
+        return _MultiEnumField[int].i2repr(
+            self,  # type: ignore
+            pkt,
+            x
+        )
 
 
 class ByteEnumKeysField(ByteEnumField):
     """ByteEnumField that picks valid values when fuzzed. """
 
     def randval(self):
         # type: () -> RandEnumKeys
@@ -2765,15 +2916,15 @@
 # Little endian fixed length field
 
 
 class LEFieldLenField(FieldLenField):
     def __init__(
             self,
             name,  # type: str
-            default,  # type: int
+            default,  # type: Optional[Any]
             length_of=None,  # type: Optional[str]
             fmt="<H",  # type: str
             count_of=None,  # type: Optional[str]
             adjust=lambda pkt, x: x,  # type: Callable[[Packet, int], int]
     ):
         # type: (...) -> None
         FieldLenField.__init__(
@@ -2815,15 +2966,15 @@
 class FlagValue(object):
     __slots__ = ["value", "names", "multi"]
 
     def _fixvalue(self, value):
         # type: (Any) -> int
         if not value:
             return 0
-        if isinstance(value, six.string_types):
+        if isinstance(value, str):
             value = value.split('+') if self.multi else list(value)
         if isinstance(value, list):
             y = 0
             for i in value:
                 y |= 1 << self.names.index(i)
             value = y
         return int(value)
@@ -2952,15 +3103,15 @@
                     return self.__getattr__(attr.replace('_', '-'))
                 except AttributeError:
                     pass
             return super(FlagValue, self).__getattribute__(attr)
 
     def __setattr__(self, attr, value):
         # type: (str, Union[List[str], int, str]) -> None
-        if attr == "value" and not isinstance(value, six.integer_types):
+        if attr == "value" and not isinstance(value, int):
             raise ValueError(value)
         if attr in self.__slots__:
             return super(FlagValue, self).__setattr__(attr, value)
         if attr in self.names:
             if value:
                 self.value |= (2 ** self.names.index(attr))
             else:
@@ -3024,15 +3175,15 @@
                  size,  # type: int
                  names  # type: Union[List[str], str, Dict[int, str]]
                  ):
         # type: (...) -> None
         # Convert the dict to a list
         if isinstance(names, dict):
             tmp = ["bit_%d" % i for i in range(abs(size))]
-            for i, v in six.viewitems(names):
+            for i, v in names.items():
                 tmp[int(math.floor(math.log(i, 2)))] = v
             names = tmp
         # Store the names as str or list
         self.names = names
         super(FlagsField, self).__init__(name, default, size)
 
     def _fixup_val(self, x):
@@ -3100,15 +3251,15 @@
             else:
                 v = self.depends_on(pkt)
                 if v is not None:
                     assert v in self.names, 'invalid dependency'
                     these_names = self.names[v]
                     s = set()
                     for i in x:
-                        for val in six.itervalues(these_names):
+                        for val in these_names.values():
                             if val.short == i:
                                 s.add(i)
                                 break
                         else:
                             assert False, 'Unknown flag "{}" with this dependency'.format(i)  # noqa: E501
                             continue
                     return s
@@ -3121,15 +3272,15 @@
         v = self.depends_on(pkt)
         these_names = self.names.get(v, {})
 
         r = 0
         if x is None:
             return r
         for flag_set in x:
-            for i, val in six.iteritems(these_names):
+            for i, val in these_names.items():
                 if val.short == flag_set:
                     r |= 1 << i
                     break
             else:
                 r |= 1 << int(flag_set[len('bit '):])
         return r
 
@@ -3153,15 +3304,15 @@
     def i2repr(self, pkt, x):
         # type: (Optional[Packet], Set[str]) -> str
         v = self.depends_on(pkt)
         these_names = self.names.get(v, {})
 
         r = set()
         for flag_set in x:
-            for i in six.itervalues(these_names):
+            for i in these_names.values():
                 if i.short == flag_set:
                     r.add("{} ({})".format(i.long, i.short))
                     break
             else:
                 r.add(flag_set)
         return repr(r)
 
@@ -3179,16 +3330,18 @@
         if val is None:
             return val
         ival = int(val)
         fract = int((val - ival) * 2**self.frac_bits)
         return (ival << self.frac_bits) | fract
 
     def i2h(self, pkt, val):
-        # type: (Optional[Packet], int) -> EDecimal
+        # type: (Optional[Packet], Optional[int]) -> Optional[EDecimal]
         # A bit of trickery to get precise floats
+        if val is None:
+            return val
         int_part = val >> self.frac_bits
         pw = 2.0**self.frac_bits
         frac_part = EDecimal(val & (1 << self.frac_bits) - 1)
         frac_part /= pw  # type: ignore
         return int_part + frac_part.normalize(int(math.log10(pw)))
 
     def i2repr(self, pkt, val):
@@ -3328,16 +3481,14 @@
         )
 
 
 class UTCTimeField(Field[float, int]):
     __slots__ = ["epoch", "delta", "strf",
                  "use_msec", "use_micro", "use_nano", "custom_scaling"]
 
-    # Do not change the order of the keywords in here
-    # Netflow heavily rely on this
     def __init__(self,
                  name,  # type: str
                  default,  # type: int
                  use_msec=False,  # type: bool
                  use_micro=False,  # type: bool
                  use_nano=False,  # type: bool
                  epoch=None,  # type: Optional[Tuple[int, int, int, int, int, int, int, int, int]]  # noqa: E501
@@ -3364,17 +3515,22 @@
             x = x / 1e3
         elif self.use_micro:
             x = x / 1e6
         elif self.use_nano:
             x = x / 1e9
         elif self.custom_scaling:
             x = x / self.custom_scaling
-        x = int(x) + self.delta
-        t = time.strftime(self.strf, time.gmtime(x))
-        return "%s (%d)" % (t, x)
+        x += self.delta
+        # To make negative timestamps work on all plateforms (e.g. Windows),
+        # we need a trick.
+        t = (
+            datetime.datetime(1970, 1, 1) +
+            datetime.timedelta(seconds=x)
+        ).strftime(self.strf)
+        return "%s (%d)" % (t, int(x))
 
     def i2m(self, pkt, x):
         # type: (Optional[Packet], Optional[float]) -> int
         if x is None:
             x = time.time() - self.delta
             if self.use_msec:
                 x = x * 1e3
@@ -3387,16 +3543,14 @@
             return int(x)
         return int(x)
 
 
 class SecondsIntField(Field[float, int]):
     __slots__ = ["use_msec", "use_micro", "use_nano"]
 
-    # Do not change the order of the keywords in here
-    # Netflow heavily rely on this
     def __init__(self, name, default,
                  use_msec=False,
                  use_micro=False,
                  use_nano=False):
         # type: (str, int, bool, bool, bool) -> None
         Field.__init__(self, name, default, "I")
         self.use_msec = use_msec
```

### Comparing `scapy-2.5.0rc3/scapy/interfaces.py` & `scapy-2.6.0rc1/scapy/interfaces.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,92 +8,105 @@
 """
 
 import itertools
 import uuid
 from collections import defaultdict
 
 from scapy.config import conf
-from scapy.consts import WINDOWS
+from scapy.consts import WINDOWS, LINUX
 from scapy.utils import pretty_list
 from scapy.utils6 import in6_isvalid
 
-from scapy.libs.six.moves import UserDict
-import scapy.libs.six as six
-
 # Typing imports
 import scapy
-from scapy.compat import (
+from scapy.compat import UserDict
+from typing import (
+    cast,
     Any,
     DefaultDict,
     Dict,
     List,
     NoReturn,
     Optional,
     Tuple,
     Type,
     Union,
 )
 
 
 class InterfaceProvider(object):
     name = "Unknown"
-    headers = ("Index", "Name", "MAC", "IPv4", "IPv6")
+    headers: Tuple[str, ...] = ("Index", "Name", "MAC", "IPv4", "IPv6")
     header_sort = 1
     libpcap = False
 
     def load(self):
         # type: () -> Dict[str, NetworkInterface]
         """Returns a dictionary of the loaded interfaces, by their
         name."""
         raise NotImplementedError
 
     def reload(self):
         # type: () -> Dict[str, NetworkInterface]
         """Same than load() but for reloads. By default calls load"""
         return self.load()
 
-    def l2socket(self):
-        # type: () -> Type[scapy.supersocket.SuperSocket]
+    def _l2socket(self, dev):
+        # type: (NetworkInterface) -> Type[scapy.supersocket.SuperSocket]
         """Return L2 socket used by interfaces of this provider"""
         return conf.L2socket
 
-    def l2listen(self):
-        # type: () -> Type[scapy.supersocket.SuperSocket]
+    def _l2listen(self, dev):
+        # type: (NetworkInterface) -> Type[scapy.supersocket.SuperSocket]
         """Return L2listen socket used by interfaces of this provider"""
         return conf.L2listen
 
-    def l3socket(self):
-        # type: () -> Type[scapy.supersocket.SuperSocket]
+    def _l3socket(self, dev, ipv6):
+        # type: (NetworkInterface, bool) -> Type[scapy.supersocket.SuperSocket]
         """Return L3 socket used by interfaces of this provider"""
+        if LINUX and not self.libpcap and dev.name == conf.loopback_name:
+            # handle the loopback case. see troubleshooting.rst
+            if ipv6:
+                from scapy.supersocket import L3RawSocket6
+                return cast(Type['scapy.supersocket.SuperSocket'], L3RawSocket6)
+            else:
+                from scapy.supersocket import L3RawSocket
+                return L3RawSocket
         return conf.L3socket
 
     def _is_valid(self, dev):
         # type: (NetworkInterface) -> bool
         """Returns whether an interface is valid or not"""
         return bool((dev.ips[4] or dev.ips[6]) and dev.mac)
 
     def _format(self,
                 dev,  # type: NetworkInterface
                 **kwargs  # type: Any
                 ):
-        # type: (...) -> Tuple[str, str, str, List[str], List[str]]
+        # type: (...) -> Tuple[Union[str, List[str]], ...]
         """Returns the elements used by show()
 
         If a tuple is returned, this consist of the strings that will be
         inlined along with the interface.
         If a list of tuples is returned, they will be appended one above the
         other and should all be part of a single interface.
         """
         mac = dev.mac
         resolve_mac = kwargs.get("resolve_mac", True)
         if resolve_mac and conf.manufdb and mac:
             mac = conf.manufdb._resolve_MAC(mac)
         index = str(dev.index)
         return (index, dev.description, mac or "", dev.ips[4], dev.ips[6])
 
+    def __repr__(self) -> str:
+        """
+        repr
+        """
+        return "<InterfaceProvider: %s>" % self.name
+
 
 class NetworkInterface(object):
     def __init__(self,
                  provider,  # type: InterfaceProvider
                  data=None,  # type: Optional[Dict[str, Any]]
                  ):
         # type: (...) -> None
@@ -154,23 +167,23 @@
         # type: () -> bool
         if self.dummy:
             return False
         return self.provider._is_valid(self)
 
     def l2socket(self):
         # type: () -> Type[scapy.supersocket.SuperSocket]
-        return self.provider.l2socket()
+        return self.provider._l2socket(self)
 
     def l2listen(self):
         # type: () -> Type[scapy.supersocket.SuperSocket]
-        return self.provider.l2listen()
+        return self.provider._l2listen(self)
 
-    def l3socket(self):
-        # type: () -> Type[scapy.supersocket.SuperSocket]
-        return self.provider.l3socket()
+    def l3socket(self, ipv6=False):
+        # type: (bool) -> Type[scapy.supersocket.SuperSocket]
+        return self.provider._l3socket(self, ipv6)
 
     def __repr__(self):
         # type: () -> str
         return "<%s %s [%s]>" % (self.__class__.__name__,
                                  self.description,
                                  self.dummy and "dummy" or (self.flags or ""))
 
@@ -186,39 +199,42 @@
         # type: (str) -> str
         return other + self.network_name
 
 
 _GlobInterfaceType = Union[NetworkInterface, str]
 
 
-class NetworkInterfaceDict(UserDict):
+class NetworkInterfaceDict(UserDict[str, NetworkInterface]):
     """Store information about network interfaces and convert between names"""
 
     def __init__(self):
         # type: () -> None
         self.providers = {}  # type: Dict[Type[InterfaceProvider], InterfaceProvider]  # noqa: E501
-        UserDict.__init__(self)
+        super(NetworkInterfaceDict, self).__init__()
 
     def _load(self,
               dat,  # type: Dict[str, NetworkInterface]
               prov,  # type: InterfaceProvider
               ):
         # type: (...) -> None
-        for ifname, iface in six.iteritems(dat):
+        for ifname, iface in dat.items():
             if ifname in self.data:
                 # Handle priorities: keep except if libpcap
                 if prov.libpcap:
                     self.data[ifname] = iface
             else:
                 self.data[ifname] = iface
 
     def register_provider(self, provider):
         # type: (type) -> None
         prov = provider()
         self.providers[provider] = prov
+        if self.data:
+            # late registration
+            self._load(prov.reload(), prov)
 
     def load_confiface(self):
         # type: () -> None
         """
         Reload conf.iface
         """
         # Can only be called after conf.route is populated
@@ -231,68 +247,71 @@
         self.clear()
         for prov in self.providers.values():
             self._load(prov.reload(), prov)
 
     def reload(self):
         # type: () -> None
         self._reload_provs()
-        if conf.route:
-            self.load_confiface()
+        if not conf.route:
+            # routes are not loaded yet.
+            return
+        self.load_confiface()
 
     def dev_from_name(self, name):
         # type: (str) -> NetworkInterface
         """Return the first network device name for a given
         device name.
         """
         try:
-            return next(iface for iface in six.itervalues(self)  # type: ignore
+            return next(iface for iface in self.values()
                         if (iface.name == name or iface.description == name))
         except (StopIteration, RuntimeError):
             raise ValueError("Unknown network interface %r" % name)
 
     def dev_from_networkname(self, network_name):
         # type: (str) -> NoReturn
         """Return interface for a given network device name."""
         try:
-            return next(iface for iface in six.itervalues(self)  # type: ignore
+            return next(iface for iface in self.values()  # type: ignore
                         if iface.network_name == network_name)
         except (StopIteration, RuntimeError):
             raise ValueError(
                 "Unknown network interface %r" %
                 network_name)
 
     def dev_from_index(self, if_index):
         # type: (int) -> NetworkInterface
         """Return interface name from interface index"""
         try:
             if_index = int(if_index)  # Backward compatibility
-            return next(iface for iface in six.itervalues(self)  # type: ignore
+            return next(iface for iface in self.values()
                         if iface.index == if_index)
         except (StopIteration, RuntimeError):
             if str(if_index) == "1":
                 # Test if the loopback interface is set up
                 return self.dev_from_networkname(conf.loopback_name)
             raise ValueError("Unknown network interface index %r" % if_index)
 
-    def _add_fake_iface(self, ifname):
-        # type: (str) -> None
+    def _add_fake_iface(self, ifname, mac="00:00:00:00:00:00"):
+        # type: (str, str) -> None
         """Internal function used for a testing purpose"""
         data = {
             'name': ifname,
             'description': ifname,
             'network_name': ifname,
             'index': -1000,
             'dummy': True,
-            'mac': '00:00:00:00:00:00',
+            'mac': mac,
             'flags': 0,
             'ips': ["127.0.0.1", "::"],
             # Windows only
             'guid': "{%s}" % uuid.uuid1(),
             'ipv4_metric': 0,
             'ipv6_metric': 0,
+            'nameservers': [],
         }
         if WINDOWS:
             from scapy.arch.windows import NetworkInterface_Win, \
                 WindowsInterfacesProvider
 
             class FakeProv(WindowsInterfacesProvider):
                 name = "fake"
@@ -314,23 +333,24 @@
         """
         res = defaultdict(list)
         for iface_name in sorted(self.data):
             dev = self.data[iface_name]
             if not hidden and not dev.is_valid():
                 continue
             prov = dev.provider
-            res[prov].append(
+            res[(prov.headers, prov.header_sort)].append(
                 (prov.name,) + prov._format(dev, **kwargs)
             )
         output = ""
-        for provider in res:
+        for key in res:
+            hdrs, sortBy = key
             output += pretty_list(
-                res[provider],
-                [("Source",) + provider.headers],
-                sortBy=provider.header_sort
+                res[key],
+                [("Source",) + hdrs],
+                sortBy=sortBy
             ) + "\n"
         output = output[:-1]
         if print_result:
             print(output)
             return None
         else:
             return output
@@ -356,15 +376,15 @@
     # mask (route by default if it exists)
     routes = conf.route.routes[:]
     routes.sort(key=lambda x: x[1])
     ifaces = (x[3] for x in routes)
     # First check the routing ifaces from best to worse,
     # then check all the available ifaces as backup.
     for ifname in itertools.chain(ifaces, conf.ifaces.values()):
-        iface = resolve_iface(ifname)
+        iface = resolve_iface(ifname)  # type: ignore
         if iface.is_valid():
             return iface
     # There is no hope left
     return resolve_iface(conf.loopback_name)
 
 
 def get_working_ifaces():
```

### Comparing `scapy-2.5.0rc3/scapy/layers/all.py` & `scapy-2.6.0rc1/scapy/layers/all.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,25 +3,24 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 All layers. Configurable with conf.load_layers.
 """
 
-from __future__ import absolute_import
+
+import builtins
+import logging
 
 # We import conf from arch to make sure arch specific layers are populated
 from scapy.arch import conf
 from scapy.error import log_loading
 from scapy.main import load_layer
 
-import logging
-import scapy.libs.six as six
-
-ignored = list(six.moves.builtins.__dict__) + ["sys"]
+ignored = list(builtins.__dict__) + ["sys"]
 log = logging.getLogger("scapy.loading")
 
 __all__ = []
 
 for _l in conf.load_layers:
     log_loading.debug("Loading layer %s", _l)
     try:
```

### Comparing `scapy-2.5.0rc3/scapy/layers/bluetooth4LE.py` & `scapy-2.6.0rc1/scapy/layers/bluetooth4LE.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,16 +7,19 @@
 
 """Bluetooth 4LE layer"""
 
 import struct
 
 from scapy.compat import orb, chb
 from scapy.config import conf
-from scapy.data import DLT_BLUETOOTH_LE_LL, DLT_BLUETOOTH_LE_LL_WITH_PHDR, \
-    PPI_BTLE
+from scapy.data import (
+    DLT_BLUETOOTH_LE_LL,
+    DLT_BLUETOOTH_LE_LL_WITH_PHDR,
+    PPI_BTLE,
+)
 from scapy.packet import Packet, bind_layers
 from scapy.fields import (
     BitEnumField,
     BitField,
     ByteEnumField,
     ByteField,
     Field,
@@ -160,15 +163,39 @@
              'le_2m_phy',
              'tx_mod_idx',
              'rx_mod_idx',
              'le_coded_phy',
              'le_ext_adv',
              'le_periodic_adv',
              'ch_sel_alg',
-             'le_pwr_class']
+             'le_pwr_class'
+             'min_used_channels',
+             'conn_cte_req',
+             'conn_cte_rsp',
+             'connless_cte_tx',
+             'connless_cte_rx',
+             'antenna_switching_cte_aod_tx',
+             'antenna_switching_cte_aoa_rx',
+             'cte_rx',
+             'periodic_adv_sync_transfer_tx',
+             'periodic_adv_sync_transfer_rx',
+             'sleep_clock_accuracy_updates',
+             'remote_public_key_validation',
+             'cis_central',
+             'cis_peripheral',
+             'iso_broadcaster',
+             'synchronized_receiver',
+             'connected_iso_host_support',
+             'le_power_control_request',
+             'le_power_control_request',
+             'le_path_loss_monitoring',
+             'periodic_adv_adi_support',
+             'connection_subrating',
+             'connection_subrating_host_support',
+             'channel_classification']
         )
 
 
 class BTLEPhysField(FlagsField):
     def __init__(self, name, default):
         super(BTLEPhysField, self).__init__(
             name, default, -8,
@@ -391,14 +418,31 @@
     0x0F: 'LL_CONNECTION_PARAM_REQ',
     0x10: 'LL_CONNECTION_PARAM_RSP',
     0x14: 'LL_LENGTH_REQ',
     0x15: 'LL_LENGTH_RSP',
     0x16: 'LL_PHY_REQ',
     0x17: 'LL_PHY_RSP',
     0x18: 'LL_PHY_UPDATE_IND',
+    0x19: 'LL_MIN_USED_CHANNELS',
+    0x1A: 'LL_CTE_REQ',
+    0x1B: 'LL_CTE_RSP',
+    0x1C: 'LL_PERIODIC_SYNC_IND',
+    0x1D: 'LL_CLOCK_ACCURACY_REQ',
+    0x1E: 'LL_CLOCK_ACCURACY_RSP',
+    0x1F: 'LL_CIS_REQ',
+    0x20: 'LL_CIS_RSP',
+    0x21: 'LL_CIS_IND',
+    0x22: 'LL_CIS_TERMINATE_IND',
+    0x23: 'LL_POWER_CONTROL_REQ',
+    0x24: 'LL_POWER_CONTROL_RSP',
+    0x25: 'LL_POWER_CHANGE_IND',
+    0x26: 'LL_SUBRATE_REQ',
+    0x27: 'LL_SUBRATE_IND',
+    0x28: 'LL_CHANNEL_REPORTING_IND',
+    0x29: 'LL_CHANNEL_STATUS_IND',
 }
 
 
 class BTLE_EMPTY_PDU(Packet):
     name = "Empty data PDU"
 
 
@@ -616,14 +660,189 @@
     name = "LL_MIN_USED_CHANNELS_IND"
     fields_desc = [
         BTLEPhysField('phys', 0),
         ByteField("min_used_channels", 2),
     ]
 
 
+class LL_CTE_REQ(Packet):
+    name = "LL_CTE_REQ"
+    fields_desc = [
+        LEBitField('min_cte_len_req', 0, 5),
+        LEBitField('rfu', 0, 1),
+        LEBitField("cte_type_req", 0, 2)
+    ]
+
+
+class LL_CTE_RSP(Packet):
+    name = "LL_CTE_RSP"
+    fields_desc = []
+
+
+class LL_PERIODIC_SYNC_IND(Packet):
+    name = "LL_PERIODIC_SYNC_IND"
+    fields_desc = [
+        XLEShortField("id", 251),
+        LEBitField("sync_info", 0, 18 * 8),
+        XLEShortField("conn_event_count", 0),
+        XLEShortField("last_pa_event_counter", 0),
+        LEBitField('sid', 0, 4),
+        LEBitField('a_type', 0, 1),
+        LEBitField('sca', 0, 3),
+        BTLEPhysField('phy', 0),
+        BDAddrField("AdvA", None),
+        XLEShortField("sync_conn_event_count", 0),
+    ]
+
+
+class LL_CLOCK_ACCURACY_REQ(Packet):
+    name = "LL_CLOCK_ACCURACY_REQ"
+    fields_desc = [
+        XByteField("sca", 0),
+    ]
+
+
+class LL_CLOCK_ACCURACY_RSP(Packet):
+    name = "LL_CLOCK_ACCURACY_RSP"
+    fields_desc = [
+        XByteField("sca", 0),
+    ]
+
+
+class LL_CIS_REQ(Packet):
+    name = 'LL_CIS_REQ'
+    fields_desc = [
+        XByteField("cig_id", 0),
+        XByteField("cis_id", 0),
+        BTLEPhysField('phy_c_to_p', 0),
+        BTLEPhysField('phy_p_to_c', 0),
+        LEBitField('max_sdu_c_to_p', 0, 12),
+        LEBitField('rfu1', 0, 3),
+        LEBitField('framed', 0, 1),
+        LEBitField('max_sdu_p_to_c', 0, 12),
+        LEBitField('rfu2', 0, 4),
+        LEBitField('sdu_interval_c_to_p', 0, 20),
+        LEBitField('rfu3', 0, 4),
+        LEBitField('sdu_interval_p_to_c', 0, 20),
+        LEBitField('rfu4', 0, 4),
+        XLEShortField("max_pdu_c_to_p", 0),
+        XLEShortField("max_pdu_p_to_c", 0),
+        XByteField("nse", 0),
+        X3BytesField("subinterval", 0x0),
+        LEBitField('bn_c_to_p', 0, 4),
+        LEBitField('bn_p_to_c', 0, 4),
+        ByteField("ft_c_to_p", 0),
+        ByteField("ft_p_to_c", 0),
+        XLEShortField("iso_interval", 0),
+        X3BytesField("cis_offset_min", 0x0),
+        X3BytesField("cis_offset_max", 0x0),
+        XLEShortField("conn_event_count", 0),
+    ]
+
+
+class LL_CIS_RSP(Packet):
+    name = 'LL_CIS_RSP'
+    fields_desc = [
+        X3BytesField("cis_offset_min", 0x0),
+        X3BytesField("cis_offset_max", 0x0),
+        XLEShortField("conn_event_count", 0),
+    ]
+
+
+class LL_CIS_IND(Packet):
+    name = 'LL_CIS_IND'
+    fields_desc = [
+        XIntField("AA", 0x00),
+        X3BytesField("cis_offset", 0x0),
+        X3BytesField("cig_sync_delay", 0x0),
+        X3BytesField("cis_sync_delay", 0x0),
+        XLEShortField("conn_event_count", 0),
+    ]
+
+
+class LL_CIS_TERMINATE_IND(Packet):
+    name = 'LL_CIS_TERMINATE_IND'
+    fields_desc = [
+        ByteField("cig_id", 0x0),
+        ByteField("cis_id", 0x0),
+        ByteField("error_code", 0x0),
+    ]
+
+
+class LL_POWER_CONTROL_REQ(Packet):
+    name = 'LL_POWER_CONTROL_REQ'
+    fields_desc = [
+        ByteField("phy", 0x0),
+        SignedByteField("delta", 0x0),
+        SignedByteField("tx_power", 0x0),
+    ]
+
+
+class LL_POWER_CONTROL_RSP(Packet):
+    name = 'LL_POWER_CONTROL_RSP'
+    fields_desc = [
+        LEBitField("min", 0, 1),
+        LEBitField("max", 0, 1),
+        LEBitField("rfu", 0, 6),
+        SignedByteField("delta", 0),
+        SignedByteField("tx_power", 0x0),
+        ByteField("apr", 0x0),
+    ]
+
+
+class LL_POWER_CHANGE_IND(Packet):
+    name = 'LL_POWER_CHANGE_IND'
+    fields_desc = [
+        ByteField("phy", 0x0),
+        LEBitField("min", 0, 1),
+        LEBitField("max", 0, 1),
+        LEBitField("rfu", 0, 6),
+        SignedByteField("delta", 0),
+        ByteField("tx_power", 0x0),
+    ]
+
+
+class LL_SUBRATE_REQ(Packet):
+    name = 'LL_SUBRATE_REQ'
+    fields_desc = [
+        LEShortField("subrate_factor_min", 0x0),
+        LEShortField("subrate_factor_max", 0x0),
+        LEShortField("max_latency", 0x0),
+        LEShortField("continuation_number", 0x0),
+        LEShortField("timeout", 0x0),
+    ]
+
+
+class LL_SUBRATE_IND(Packet):
+    name = 'LL_SUBRATE_IND'
+    fields_desc = [
+        LEShortField("subrate_factor", 0x0),
+        LEShortField("subrate_base_event", 0x0),
+        LEShortField("latency", 0x0),
+        LEShortField("continuation_number", 0x0),
+        LEShortField("timeout", 0x0),
+    ]
+
+
+class LL_CHANNEL_REPORTING_IND(Packet):
+    name = 'LL_SUBRATE_IND'
+    fields_desc = [
+        ByteField("enable", 0x0),
+        ByteField("min_spacing", 0x0),
+        ByteField("max_delay", 0x0),
+    ]
+
+
+class LL_CHANNEL_STATUS_IND(Packet):
+    name = 'LL_CHANNEL_STATUS_IND'
+    fields_desc = [
+        LEBitField("channel_classification", 0, 10 * 8),
+    ]
+
+
 # Advertisement (37-39) channel PDUs
 bind_layers(BTLE, BTLE_ADV, access_addr=0x8E89BED6)
 bind_layers(BTLE, BTLE_DATA)
 bind_layers(BTLE_ADV, BTLE_ADV_IND, PDU_type=0)
 bind_layers(BTLE_ADV, BTLE_ADV_DIRECT_IND, PDU_type=1)
 bind_layers(BTLE_ADV, BTLE_ADV_NONCONN_IND, PDU_type=2)
 bind_layers(BTLE_ADV, BTLE_SCAN_REQ, PDU_type=3)
@@ -658,14 +877,30 @@
 bind_layers(BTLE_CTRL, LL_PING_RSP, opcode=0x13)
 bind_layers(BTLE_CTRL, LL_LENGTH_REQ, opcode=0x14)
 bind_layers(BTLE_CTRL, LL_LENGTH_RSP, opcode=0x15)
 bind_layers(BTLE_CTRL, LL_PHY_REQ, opcode=0x16)
 bind_layers(BTLE_CTRL, LL_PHY_RSP, opcode=0x17)
 bind_layers(BTLE_CTRL, LL_PHY_UPDATE_IND, opcode=0x18)
 bind_layers(BTLE_CTRL, LL_MIN_USED_CHANNELS_IND, opcode=0x19)
+bind_layers(BTLE_CTRL, LL_CTE_REQ, opcode=0x1A)
+bind_layers(BTLE_CTRL, LL_CTE_RSP, opcode=0x1B)
+bind_layers(BTLE_CTRL, LL_PERIODIC_SYNC_IND, opcode=0x1C)
+bind_layers(BTLE_CTRL, LL_CLOCK_ACCURACY_REQ, opcode=0x1D)
+bind_layers(BTLE_CTRL, LL_CLOCK_ACCURACY_RSP, opcode=0x1E)
+bind_layers(BTLE_CTRL, LL_CIS_REQ, opcode=0x1F)
+bind_layers(BTLE_CTRL, LL_CIS_RSP, opcode=0x20)
+bind_layers(BTLE_CTRL, LL_CIS_IND, opcode=0x21)
+bind_layers(BTLE_CTRL, LL_CIS_TERMINATE_IND, opcode=0x22)
+bind_layers(BTLE_CTRL, LL_POWER_CONTROL_REQ, opcode=0x23)
+bind_layers(BTLE_CTRL, LL_POWER_CONTROL_RSP, opcode=0x24)
+bind_layers(BTLE_CTRL, LL_POWER_CHANGE_IND, opcode=0x25)
+bind_layers(BTLE_CTRL, LL_SUBRATE_REQ, opcode=0x26)
+bind_layers(BTLE_CTRL, LL_SUBRATE_IND, opcode=0x27)
+bind_layers(BTLE_CTRL, LL_CHANNEL_REPORTING_IND, opcode=0x28)
+bind_layers(BTLE_CTRL, LL_CHANNEL_STATUS_IND, opcode=0x29)
 
 
 conf.l2types.register(DLT_BLUETOOTH_LE_LL, BTLE)
 conf.l2types.register(DLT_BLUETOOTH_LE_LL_WITH_PHDR, BTLE_RF)
 
 bind_layers(BTLE_RF, BTLE)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/can.py` & `scapy-2.6.0rc1/scapy/layers/can.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,31 +9,40 @@
 
 """
 
 import os
 import gzip
 import struct
 
-from scapy.compat import Tuple, Optional, Type, List, Union, Callable, IO, \
-    Any, cast, hex_bytes
-
-import scapy.libs.six as six
 from scapy.config import conf
-from scapy.compat import orb
+from scapy.compat import chb, hex_bytes
 from scapy.data import DLT_CAN_SOCKETCAN
 from scapy.fields import FieldLenField, FlagsField, StrLenField, \
     ThreeBytesField, XBitField, ScalingField, ConditionalField, LenField, ShortField
 from scapy.volatile import RandFloat, RandBinFloat
 from scapy.packet import Packet, bind_layers
 from scapy.layers.l2 import CookedLinux
 from scapy.error import Scapy_Exception
 from scapy.plist import PacketList
 from scapy.supersocket import SuperSocket
 from scapy.utils import _ByteStream
 
+# Typing imports
+from typing import (
+    Tuple,
+    Optional,
+    Type,
+    List,
+    Union,
+    Callable,
+    IO,
+    Any,
+    cast,
+)
+
 __all__ = ["CAN", "SignalPacket", "SignalField", "LESignedSignalField",
            "LEUnsignedSignalField", "LEFloatSignalField", "BEFloatSignalField",
            "BESignedSignalField", "BEUnsignedSignalField", "rdcandump",
            "CandumpReader", "SignalHeader", "CAN_MTU", "CAN_MAX_IDENTIFIER",
            "CAN_MAX_DLEN", "CAN_INV_FILTER", "CANFD", "CAN_FD_MTU",
            "CAN_FD_MAX_DLEN"]
 
@@ -98,19 +107,19 @@
     @classmethod
     def dispatch_hook(cls,
                       _pkt=None,  # type: Optional[bytes]
                       *args,  # type: Any
                       **kargs  # type: Any
                       ):  # type: (...) -> Type[Packet]
         if _pkt:
-            fdf_set = len(_pkt) > 5 and orb(_pkt[5]) & 0x04 and \
-                not orb(_pkt[5]) & 0xf8
+            fdf_set = len(_pkt) > 5 and _pkt[5] & 0x04 and \
+                not _pkt[5] & 0xf8
             if fdf_set:
                 return CANFD
-            elif len(_pkt) > 16:
+            elif len(_pkt) > 4 and _pkt[4] > 8:
                 return CANFD
         return CAN
 
     @staticmethod
     def inv_endianness(pkt):
         # type: (bytes) -> bytes
         """Invert the order of the first four bytes of a CAN packet
@@ -176,14 +185,34 @@
         FlagsField('fd_flags', 4, 8, ['bit_rate_switch',
                                       'error_state_indicator',
                                       'fd_frame']),
         ShortField('reserved', 0),
         StrLenField('data', b'', length_from=lambda pkt: int(pkt.length)),
     ]
 
+    def post_build(self, pkt, pay):
+        # type: (bytes, bytes) -> bytes
+
+        data = super(CANFD, self).post_build(pkt, pay)
+
+        length = data[4]
+
+        if 8 < length <= 24:
+            wire_length = length + (-length) % 4
+        elif 24 < length <= 64:
+            wire_length = length + (-length) % 8
+        elif length > 64:
+            raise NotImplementedError
+        else:
+            wire_length = length
+
+        pad = b"\x00" * (wire_length - length)
+
+        return data[0:4] + chb(wire_length) + data[5:] + pad
+
 
 bind_layers(CookedLinux, CANFD, proto=13)
 
 
 class SignalField(ScalingField):
     """SignalField is a base class for signal data, usually transmitted from
     CAN messages in automotive applications. Most vehicle manufacturers
@@ -513,18 +542,18 @@
     nonblocking_socket = True
 
     def __init__(self, filename, interface=None):
         # type: (str, Optional[Union[List[str], str]]) -> None
         self.filename, self.f = self.open(filename)
         self.ifilter = None  # type: Optional[List[str]]
         if interface is not None:
-            if isinstance(interface, six.string_types):
+            if isinstance(interface, str):
                 self.ifilter = [interface]
             else:
-                self.ifilter = cast(List[str], interface)
+                self.ifilter = interface
 
     def __iter__(self):
         # type: () -> CandumpReader
         return self
 
     @staticmethod
     def open(filename):
@@ -585,21 +614,21 @@
         :return: A single packet read from the file or None if filters apply
         """
         line = self.f.readline()
         line = line.lstrip()
         if len(line) < 16:
             raise EOFError
 
-        is_log_file_format = orb(line[0]) == orb(b"(")
+        is_log_file_format = line[0] == ord(b"(")
         fd_flags = None
         if is_log_file_format:
             t_b, intf, f = line.split()
             if b'##' in f:
                 idn, data = f.split(b'##')
-                fd_flags = orb(data[0])
+                fd_flags = data[0]
                 data = data[1:]
             else:
                 idn, data = f.split(b'#')
             le = None
             t = float(t_b[1:-1])  # type: Optional[float]
         else:
             h, data = line.split(b']')
```

### Comparing `scapy-2.5.0rc3/scapy/layers/clns.py` & `scapy-2.6.0rc1/scapy/layers/clns.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/dcerpc.py` & `scapy-2.6.0rc1/scapy/layers/ntlm.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,1947 +1,1816 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
+# SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
-# Copyright (C) 2016 Gauthier Sebaux
-#               2022 Gabriel Potter
-
-# scapy.contrib.description = DCE/RPC
-# scapy.contrib.status = loads
+# Copyright (C) Gabriel Potter
 
 """
-DCE/RPC
-Distributed Computing Environment / Remote Procedure Calls
+NTLM
 
-Based on [C706] - aka DCE/RPC 1.1
-https://pubs.opengroup.org/onlinepubs/9629399/toc.pdf
+This is documented in [MS-NLMP]
 
-And on [MS-RPCE]
-https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/290c38b1-92fe-4229-91e6-4fc376610c15
+.. note::
+    You will find more complete documentation for this layer over at
+    `GSSAPI <https://scapy.readthedocs.io/en/latest/layers/gssapi.html#ntlm>`_
 """
 
-from functools import partial
-from collections import namedtuple, deque
-
+import copy
+import time
+import os
 import struct
-from uuid import UUID
-from scapy.base_classes import Packet_metaclass
 
-from scapy.config import conf
+from enum import IntEnum
+
+from scapy.asn1.asn1 import ASN1_Codecs
+from scapy.asn1.mib import conf  # loads conf.mib
+from scapy.asn1fields import (
+    ASN1F_OID,
+    ASN1F_PRINTABLE_STRING,
+    ASN1F_SEQUENCE,
+    ASN1F_SEQUENCE_OF,
+)
+from scapy.asn1packet import ASN1_Packet
+from scapy.compat import bytes_base64
 from scapy.error import log_runtime
-from scapy.layers.dns import DNSStrField
-from scapy.layers.ntlm import NTLM_Header
-from scapy.packet import Packet, Raw, bind_bottom_up, bind_layers, bind_top_down
 from scapy.fields import (
-    _FieldContainer,
-    BitEnumField,
     ByteEnumField,
     ByteField,
     ConditionalField,
-    EnumField,
     Field,
     FieldLenField,
-    FieldListField,
     FlagsField,
-    IEEEDoubleField,
-    IEEEFloatField,
-    IntField,
     LEIntEnumField,
     LEIntField,
-    LELongField,
     LEShortEnumField,
     LEShortField,
-    LESignedIntField,
-    LESignedLongField,
-    LESignedShortField,
-    LenField,
+    LEThreeBytesField,
     MultipleTypeField,
     PacketField,
-    PacketLenField,
     PacketListField,
-    PadField,
-    ReversePadField,
-    ShortEnumField,
-    ShortField,
-    SignedByteField,
     StrField,
+    StrFieldUtf16,
     StrFixedLenField,
-    StrLenField,
     StrLenFieldUtf16,
-    StrNullField,
-    StrNullFieldUtf16,
-    TrailerField,
-    UUIDEnumField,
-    UUIDField,
-    XByteField,
-    XLEIntField,
-    XLELongField,
-    XLEShortField,
-    XShortField,
+    UTCTimeField,
+    XStrField,
     XStrFixedLenField,
+    XStrLenField,
+    _StrField,
 )
-from scapy.sessions import DefaultSession
+from scapy.packet import Packet
+from scapy.sessions import StringBuffer
 
-from scapy.layers.kerberos import KRB5_GSS_Wrap_RFC1964, KRB5_GSS_Wrap, Kerberos
-from scapy.layers.gssapi import GSSAPI_BLOB
-from scapy.layers.inet import TCP
-
-from scapy.contrib.rtps.common_types import (
-    EField,
-    EPacket,
-    EPacketField,
-    EPacketListField,
+from scapy.layers.gssapi import (
+    GSS_C_FLAGS,
+    GSS_S_COMPLETE,
+    GSS_S_CONTINUE_NEEDED,
+    GSS_S_DEFECTIVE_CREDENTIAL,
+    GSS_S_DEFECTIVE_TOKEN,
+    SSP,
+    _GSSAPI_OIDS,
+    _GSSAPI_SIGNATURE_OIDS,
 )
 
-import scapy.libs.six as six
-
+# Typing imports
+from typing import (
+    Any,
+    Callable,
+    List,
+    Optional,
+    Tuple,
+    Union,
+)
 
-# DCE/RPC Packet
-DCE_RPC_TYPE = {
-    0: "request",
-    1: "ping",
-    2: "response",
-    3: "fault",
-    4: "working",
-    5: "no_call",
-    6: "reject",
-    7: "acknowledge",
-    8: "connectionless_cancel",
-    9: "frag_ack",
-    10: "cancel_ack",
-    11: "bind",
-    12: "bind_ack",
-    13: "bind_nak",
-    14: "alter_context",
-    15: "alter_context_resp",
-    16: "auth3",
-    17: "shutdown",
-    18: "co_cancel",
-    19: "orphaned",
-}
-_DCE_RPC_4_FLAGS1 = [
-    "reserved_01",
-    "last_frag",
-    "frag",
-    "no_frag_ack",
-    "maybe",
-    "idempotent",
-    "broadcast",
-    "reserved_7",
-]
-_DCE_RPC_4_FLAGS2 = [
-    "reserved_0",
-    "cancel_pending",
-    "reserved_2",
-    "reserved_3",
-    "reserved_4",
-    "reserved_5",
-    "reserved_6",
-    "reserved_7",
-]
+# Crypto imports
 
+from scapy.layers.tls.crypto.hash import Hash_MD4, Hash_MD5
+from scapy.layers.tls.crypto.h_mac import Hmac_MD5
 
-def _dce_rpc_endianess(pkt):
-    """
-    Determine the right endianness sign for a given DCE/RPC packet
-    """
-    if pkt.endian == 0:  # big endian
-        return ">"
-    elif pkt.endian == 1:  # little endian
-        return "<"
-    else:
-        return "!"
-
-
-class _EField(EField):
-    def __init__(self, fld):
-        super(_EField, self).__init__(fld, endianness_from=_dce_rpc_endianess)
+##########
+# Fields #
+##########
+
+
+class _NTLMPayloadField(_StrField[List[Tuple[str, Any]]]):
+    """Special field used to dissect NTLM payloads.
+    This isn't trivial because the offsets are variable."""
+
+    __slots__ = [
+        "fields",
+        "fields_map",
+        "offset",
+        "length_from",
+        "force_order",
+        "offset_name",
+    ]
+    islist = True
+
+    def __init__(
+        self,
+        name,  # type: str
+        offset,  # type: Union[int, Callable[[Packet], int]]
+        fields,  # type: List[Field[Any, Any]]
+        length_from=None,  # type: Optional[Callable[[Packet], int]]
+        force_order=None,  # type: Optional[List[str]]
+        offset_name="BufferOffset",  # type: str
+    ):
+        # type: (...) -> None
+        self.offset = offset
+        self.fields = fields
+        self.fields_map = {field.name: field for field in fields}
+        self.length_from = length_from
+        self.force_order = force_order  # whether the order of fields is fixed
+        self.offset_name = offset_name
+        super(_NTLMPayloadField, self).__init__(
+            name,
+            [
+                (field.name, field.default)
+                for field in fields
+                if field.default is not None
+            ],
+        )
 
+    def _on_payload(self, pkt, x, func):
+        # type: (Optional[Packet], bytes, str) -> List[Tuple[str, Any]]
+        if not pkt or not x:
+            return []
+        results = []
+        for field_name, value in x:
+            if field_name not in self.fields_map:
+                continue
+            if not isinstance(
+                self.fields_map[field_name], PacketListField
+            ) and not isinstance(value, Packet):
+                value = getattr(self.fields_map[field_name], func)(pkt, value)
+            results.append((field_name, value))
+        return results
 
-class DceRpc(Packet):
-    """DCE/RPC packet"""
+    def i2h(self, pkt, x):
+        # type: (Optional[Packet], bytes) -> List[Tuple[str, str]]
+        return self._on_payload(pkt, x, "i2h")
 
-    @classmethod
-    def dispatch_hook(cls, _pkt=None, *args, **kargs):
-        if _pkt and len(_pkt) >= 1:
-            ver = ord(_pkt[0:1])
-            if ver == 4:
-                return DceRpc4
-            elif ver == 5:
-                return DceRpc5
-        return DceRpc5
-
-
-bind_bottom_up(TCP, DceRpc, sport=135)
-bind_layers(TCP, DceRpc, dport=135)
-
-
-class _DceRpcPayload(Packet):
-    @property
-    def endianness(self):
-        if not self.underlayer:
-            return "!"
-        return _dce_rpc_endianess(self.underlayer)
-
-
-# sect 12.5
-
-_drep = [
-    BitEnumField("endian", 1, 4, ["big", "little"]),
-    BitEnumField("encoding", 0, 4, ["ASCII", "EBCDIC"]),
-    ByteEnumField("float", 0, ["IEEE", "VAX", "CRAY", "IBM"]),
-    ByteField("reserved1", 0),
-]
+    def h2i(self, pkt, x):
+        # type: (Optional[Packet], bytes) -> List[Tuple[str, str]]
+        return self._on_payload(pkt, x, "h2i")
 
+    def i2repr(self, pkt, x):
+        # type: (Optional[Packet], bytes) -> str
+        return repr(self._on_payload(pkt, x, "i2repr"))
+
+    def _o_pkt(self, pkt):
+        # type: (Optional[Packet]) -> int
+        if callable(self.offset):
+            return self.offset(pkt)
+        return self.offset
 
-class DceRpc4(Packet):
-    """
-    DCE/RPC v4 'connection-less' packet
-    """
+    def addfield(self, pkt, s, val):
+        # type: (Optional[Packet], bytes, Optional[List[Tuple[str, str]]]) -> bytes
+        # Create string buffer
+        buf = StringBuffer()
+        buf.append(s, 1)
+        # Calc relative offset
+        r_off = self._o_pkt(pkt) - len(s)
+        if self.force_order:
+            val.sort(key=lambda x: self.force_order.index(x[0]))
+        for field_name, value in val:
+            if field_name not in self.fields_map:
+                continue
+            field = self.fields_map[field_name]
+            offset = pkt.getfieldval(field_name + self.offset_name)
+            if offset is None:
+                # No offset specified: calc
+                offset = len(buf)
+            else:
+                # Calc relative offset
+                offset -= r_off
+                pad = offset + 1 - len(buf)
+                # Add padding if necessary
+                if pad > 0:
+                    buf.append(pad * b"\x00", len(buf))
+            buf.append(field.addfield(pkt, bytes(buf), value)[len(buf) :], offset + 1)
+        return bytes(buf)
 
-    name = "DCE/RPC v4"
-    fields_desc = (
-        [
-            ByteEnumField(
-                "rpc_vers", 4, {4: "4 (connection-less)", 5: "5 (connection-oriented)"}
-            ),
-            ByteEnumField("ptype", 0, DCE_RPC_TYPE),
-            FlagsField("flags1", 0, 8, _DCE_RPC_4_FLAGS1),
-            FlagsField("flags2", 0, 8, _DCE_RPC_4_FLAGS2),
-        ] +
-        _drep +
-        [
-            XByteField("serial_hi", 0),
-            _EField(UUIDField("object", None)),
-            _EField(UUIDField("if_id", None)),
-            _EField(UUIDField("act_id", None)),
-            _EField(IntField("server_boot", 0)),
-            _EField(IntField("if_vers", 1)),
-            _EField(IntField("seqnum", 0)),
-            _EField(ShortField("opnum", 0)),
-            _EField(XShortField("ihint", 0xFFFF)),
-            _EField(XShortField("ahint", 0xFFFF)),
-            _EField(LenField("len", None, fmt="H")),
-            _EField(ShortField("fragnum", 0)),
-            ByteEnumField("auth_proto", 0, ["none", "OSF DCE Private Key"]),
-            XByteField("serial_lo", 0),
+    def getfield(self, pkt, s):
+        # type: (Packet, bytes) -> Tuple[bytes, List[Tuple[str, str]]]
+        if self.length_from is None:
+            ret, remain = b"", s
+        else:
+            len_pkt = self.length_from(pkt)
+            ret, remain = s[len_pkt:], s[:len_pkt]
+        if not pkt or not remain:
+            return s, []
+        results = []
+        max_offset = 0
+        o_pkt = self._o_pkt(pkt)
+        offsets = [
+            pkt.getfieldval(x.name + self.offset_name) - o_pkt for x in self.fields
         ]
-    )
+        for i, field in enumerate(self.fields):
+            offset = offsets[i]
+            try:
+                length = pkt.getfieldval(field.name + "Len")
+            except AttributeError:
+                length = len(remain) - offset
+                # length can't be greater than the difference with the next offset
+                try:
+                    length = min(length, min(x - offset for x in offsets if x > offset))
+                except ValueError:
+                    pass
+            if offset < 0:
+                continue
+            max_offset = max(offset + length, max_offset)
+            if remain[offset : offset + length]:
+                results.append(
+                    (
+                        offset,
+                        field.name,
+                        field.getfield(pkt, remain[offset : offset + length])[1],
+                    )
+                )
+        ret += remain[max_offset:]
+        results.sort(key=lambda x: x[0])
+        return ret, [x[1:] for x in results]
+
+
+class _NTLMPayloadPacket(Packet):
+    _NTLM_PAYLOAD_FIELD_NAME = "Payload"
+
+    def __init__(
+        self,
+        _pkt=b"",  # type: Union[bytes, bytearray]
+        post_transform=None,  # type: Any
+        _internal=0,  # type: int
+        _underlayer=None,  # type: Optional[Packet]
+        _parent=None,  # type: Optional[Packet]
+        **fields,  # type: Any
+    ):
+        # pop unknown fields. We can't process them until the packet is initialized
+        unknown = {
+            k: fields.pop(k)
+            for k in list(fields)
+            if not any(k == f.name for f in self.fields_desc)
+        }
+        super(_NTLMPayloadPacket, self).__init__(
+            _pkt=_pkt,
+            post_transform=post_transform,
+            _internal=_internal,
+            _underlayer=_underlayer,
+            _parent=_parent,
+            **fields,
+        )
+        # check unknown fields for implicit ones
+        local_fields = next(
+            [y.name for y in x.fields]
+            for x in self.fields_desc
+            if x.name == self._NTLM_PAYLOAD_FIELD_NAME
+        )
+        implicit_fields = {k: v for k, v in unknown.items() if k in local_fields}
+        for k, value in implicit_fields.items():
+            self.setfieldval(k, value)
 
+    def getfieldval(self, attr):
+        # Ease compatibility with _NTLMPayloadField
+        try:
+            return super(_NTLMPayloadPacket, self).getfieldval(attr)
+        except AttributeError:
+            try:
+                return next(
+                    x[1]
+                    for x in super(_NTLMPayloadPacket, self).getfieldval(
+                        self._NTLM_PAYLOAD_FIELD_NAME
+                    )
+                    if x[0] == attr
+                )
+            except StopIteration:
+                raise AttributeError(attr)
 
-# Exceptionally, we define those 2 here.
+    def getfield_and_val(self, attr):
+        # Ease compatibility with _NTLMPayloadField
+        try:
+            return super(_NTLMPayloadPacket, self).getfield_and_val(attr)
+        except ValueError:
+            PayFields = self.get_field(self._NTLM_PAYLOAD_FIELD_NAME).fields_map
+            try:
+                return (
+                    PayFields[attr],
+                    PayFields[attr].h2i(  # cancel out the i2h.. it's dumb i know
+                        self,
+                        next(
+                            x[1]
+                            for x in super(_NTLMPayloadPacket, self).__getattr__(
+                                self._NTLM_PAYLOAD_FIELD_NAME
+                            )
+                            if x[0] == attr
+                        ),
+                    ),
+                )
+            except (StopIteration, KeyError):
+                raise ValueError(attr)
 
+    def setfieldval(self, attr, val):
+        # Ease compatibility with _NTLMPayloadField
+        try:
+            return super(_NTLMPayloadPacket, self).setfieldval(attr, val)
+        except AttributeError:
+            Payload = super(_NTLMPayloadPacket, self).__getattr__(
+                self._NTLM_PAYLOAD_FIELD_NAME
+            )
+            if attr not in self.get_field(self._NTLM_PAYLOAD_FIELD_NAME).fields_map:
+                raise AttributeError(attr)
+            try:
+                Payload.pop(
+                    next(
+                        i
+                        for i, x in enumerate(
+                            super(_NTLMPayloadPacket, self).__getattr__(
+                                self._NTLM_PAYLOAD_FIELD_NAME
+                            )
+                        )
+                        if x[0] == attr
+                    )
+                )
+            except StopIteration:
+                pass
+            Payload.append([attr, val])
+            super(_NTLMPayloadPacket, self).setfieldval(
+                self._NTLM_PAYLOAD_FIELD_NAME, Payload
+            )
 
-class NL_AUTH_MESSAGE(Packet):
-    # [MS-NRPC] sect 2.2.1.3.1
-    name = "NL_AUTH_MESSAGE"
-    fields_desc = [
-        LEIntEnumField(
-            "MessageType",
-            0x00000000,
-            {
-                0x00000000: "Request",
-                0x00000001: "Response",
-            },
-        ),
-        FlagsField(
-            "Flags",
-            0,
-            -32,
-            [
-                "NETBIOS_DOMAIN_NAME",
-                "NETBIOS_COMPUTER_NAME",
-                "DNS_DOMAIN_NAME",
-                "DNS_HOST_NAME",
-                "NETBIOS_COMPUTER_NAME_UTF8",
-            ],
-        ),
-        ConditionalField(
-            StrNullField("NetbiosDomainName", ""),
-            lambda pkt: pkt.Flags.NETBIOS_DOMAIN_NAME,
-        ),
-        ConditionalField(
-            StrNullField("NetbiosComputerName", ""),
-            lambda pkt: pkt.Flags.NETBIOS_COMPUTER_NAME,
-        ),
-        ConditionalField(
-            DNSStrField("DnsDomainName", ""),
-            lambda pkt: pkt.Flags.DNS_DOMAIN_NAME,
-        ),
-        ConditionalField(
-            DNSStrField("DnsHostName", ""),
-            lambda pkt: pkt.Flags.DNS_HOST_NAME,
-        ),
-        ConditionalField(
-            # What the fuck? Why are they doing this
-            # The spec is just wrong
-            DNSStrField("NetbiosComputerNameUtf8", ""),
-            lambda pkt: pkt.Flags.NETBIOS_COMPUTER_NAME_UTF8,
-        ),
-    ]
+
+class _NTLM_ENUM(IntEnum):
+    LEN = 0x0001
+    MAXLEN = 0x0002
+    OFFSET = 0x0004
+    COUNT = 0x0008
+    PAD8 = 0x1000
+
+
+_NTLM_CONFIG = [
+    ("Len", _NTLM_ENUM.LEN),
+    ("MaxLen", _NTLM_ENUM.MAXLEN),
+    ("BufferOffset", _NTLM_ENUM.OFFSET),
+]
 
 
-class NL_AUTH_SIGNATURE(Packet):
-    # [MS-NRPC] sect 2.2.1.3.2/2.2.1.3.3
-    name = "NL_AUTH_(SHA2_)SIGNATURE"
-    fields_desc = [
-        LEShortEnumField(
-            "SignatureAlgorithm",
-            0x0077,
-            {
-                0x0077: "HMAC-MD5",
-                0x0013: "HMAC-SHA256",
-            },
-        ),
-        LEShortEnumField(
-            "SealAlgorithm",
-            0xFFFF,
-            {
-                0xFFFF: "Unencrypted",
-                0x007A: "RC4",
-                0x00A1: "AES-128",
-            },
-        ),
-        XLEShortField("Pad", 0xFFFF),
-        ShortField("Flags", 0),
-        XStrFixedLenField("SequenceNumber", b"", length=8),
-        XStrFixedLenField("Checksum", b"", length=8),
-        ConditionalField(
-            XStrFixedLenField("Confounder", b"", length=8),
-            lambda pkt: pkt.SealAlgorithm != 0xFFFF,
-        ),
-        MultipleTypeField([
-            (StrFixedLenField("Reserved2", b"", length=24),
-             lambda pkt: pkt.SignatureAlgorithm == 0x0013),
-        ], StrField("Reserved2", b"")
-        ),
-    ]
+def _NTLM_post_build(self, p, pay_offset, fields, config=_NTLM_CONFIG):
+    """Util function to build the offset and populate the lengths"""
+    for field_name, value in self.fields[self._NTLM_PAYLOAD_FIELD_NAME]:
+        fld = self.get_field(self._NTLM_PAYLOAD_FIELD_NAME).fields_map[field_name]
+        length = fld.i2len(self, value)
+        count = fld.i2count(self, value)
+        offset = fields[field_name]
+        i = 0
+        r = lambda y: {2: "H", 4: "I", 8: "Q"}[y]
+        for fname, ftype in config:
+            if isinstance(ftype, dict):
+                ftype = ftype[field_name]
+            if ftype & _NTLM_ENUM.LEN:
+                fval = length
+            elif ftype & _NTLM_ENUM.OFFSET:
+                fval = pay_offset
+            elif ftype & _NTLM_ENUM.MAXLEN:
+                fval = length
+            elif ftype & _NTLM_ENUM.COUNT:
+                fval = count
+            else:
+                raise ValueError
+            if ftype & _NTLM_ENUM.PAD8:
+                fval += (-fval) % 8
+            sz = self.get_field(field_name + fname).sz
+            if self.getfieldval(field_name + fname) is None:
+                p = (
+                    p[: offset + i]
+                    + struct.pack("<%s" % r(sz), fval)
+                    + p[offset + i + sz :]
+                )
+            i += sz
+        pay_offset += length
+    return p
 
 
-# sect 13.2.6.1
+##############
+# Structures #
+##############
 
 
-_MSRPCE_SECURITY_PROVIDERS = {
-    # [MS-RPCE] sect 2.2.1.1.7
-    0x00: "None",
-    0x09: "SPNEGO",
-    0x0A: "NTLM",
-    0x0E: "TLS",
-    0x10: "Kerberos",
-    0x44: "Netlogon",
-    0xFF: "NTLM",
-}
-
-_MSRPCE_SECURITY_AUTHLEVELS = {
-    # [MS-RPCE] sect 2.2.1.1.7
-    0x00: "RPC_C_AUTHN_LEVEL_DEFAULT",
-    0x01: "RPC_C_AUTHN_LEVEL_NONE",
-    0x02: "RPC_C_AUTHN_LEVEL_CONNECT",
-    0x03: "RPC_C_AUTHN_LEVEL_CALL",
-    0x04: "RPC_C_AUTHN_LEVEL_PKT",
-    0x05: "RPC_C_AUTHN_LEVEL_PKT_INTEGRITY",
-    0x06: "RPC_C_AUTHN_LEVEL_PKT_PRIVACY",
-}
+# Sect 2.2
 
 
-class CommonAuthVerifier(Packet):
-    name = "Common Authentication Verifier (sec_trailer)"
+class NTLM_Header(Packet):
+    name = "NTLM Header"
     fields_desc = [
-        ByteEnumField(
-            "auth_type",
-            0,
-            _MSRPCE_SECURITY_PROVIDERS,
-        ),
-        ByteEnumField("auth_level", 0, _MSRPCE_SECURITY_AUTHLEVELS),
-        ByteField("auth_pad_length", None),
-        ByteField("auth_reserved", 0),
-        XLEIntField("auth_context_id", 0),
-        MultipleTypeField(
-            [
-                (
-                    PacketLenField(
-                        "auth_value",
-                        GSSAPI_BLOB(),
-                        GSSAPI_BLOB,
-                        length_from=lambda pkt: pkt.parent.auth_len,
-                    ),
-                    lambda pkt: pkt.auth_type == 0x09,
-                ),
-                (
-                    PacketLenField(
-                        "auth_value",
-                        NTLM_Header(),
-                        NTLM_Header,
-                        length_from=lambda pkt: pkt.parent.auth_len,
-                    ),
-                    lambda pkt: pkt.auth_type in [0x0A, 0xFF],
-                ),
-                (
-                    PacketLenField(
-                        "auth_value",
-                        Kerberos(),
-                        Kerberos,
-                        length_from=lambda pkt: pkt.parent.auth_len,
-                    ),
-                    lambda pkt: pkt.auth_type == 0x10,
-                ),
-                # NetLogon
-                (
-                    PacketLenField(
-                        "auth_value",
-                        NL_AUTH_MESSAGE(),
-                        NL_AUTH_MESSAGE,
-                        length_from=lambda pkt: pkt.parent.auth_len,
-                    ),
-                    lambda pkt: pkt.auth_type == 0x44 and
-                    pkt.parent and
-                    pkt.parent.ptype in [11, 12, 13, 14, 15],
-                ),
-                (
-                    PacketLenField(
-                        "auth_value",
-                        NL_AUTH_SIGNATURE(),
-                        NL_AUTH_SIGNATURE,
-                        length_from=lambda pkt: pkt.parent.auth_len,
-                    ),
-                    lambda pkt: pkt.auth_type == 0x44 and
-                    (not pkt.parent or pkt.parent.ptype not in [11, 12, 13, 14, 15]),
-                ),
-            ],
-            PacketLenField(
-                "auth_value",
-                None,
-                conf.raw_layer,
-                length_from=lambda pkt: pkt.parent and pkt.parent.auth_len or 0,
-            ),
+        StrFixedLenField("Signature", b"NTLMSSP\0", length=8),
+        LEIntEnumField(
+            "MessageType",
+            3,
+            {1: "NEGOTIATE_MESSAGE", 2: "CHALLENGE_MESSAGE", 3: "AUTHENTICATE_MESSAGE"},
         ),
     ]
 
-    def is_encrypted(self):
-        if self.auth_type == 9 and isinstance(self.auth_value, GSSAPI_BLOB):
-            return isinstance(
-                self.auth_value.innerContextToken,
-                (KRB5_GSS_Wrap_RFC1964, KRB5_GSS_Wrap),
+    @classmethod
+    def dispatch_hook(cls, _pkt=None, *args, **kargs):
+        if _pkt and len(_pkt) >= 10:
+            MessageType = struct.unpack("<H", _pkt[8:10])[0]
+            if MessageType == 1:
+                return NTLM_NEGOTIATE
+            elif MessageType == 2:
+                return NTLM_CHALLENGE
+            elif MessageType == 3:
+                return NTLM_AUTHENTICATE_V2
+        return cls
+
+
+# Sect 2.2.2.5
+_negotiateFlags = [
+    "NEGOTIATE_UNICODE",  # A
+    "NEGOTIATE_OEM",  # B
+    "REQUEST_TARGET",  # C
+    "r10",
+    "NEGOTIATE_SIGN",  # D
+    "NEGOTIATE_SEAL",  # E
+    "NEGOTIATE_DATAGRAM",  # F
+    "NEGOTIATE_LM_KEY",  # G
+    "r9",
+    "NEGOTIATE_NTLM",  # H
+    "r8",
+    "J",
+    "NEGOTIATE_OEM_DOMAIN_SUPPLIED",  # K
+    "NEGOTIATE_OEM_WORKSTATION_SUPPLIED",  # L
+    "r7",
+    "NEGOTIATE_ALWAYS_SIGN",  # M
+    "TARGET_TYPE_DOMAIN",  # N
+    "TARGET_TYPE_SERVER",  # O
+    "r6",
+    "NEGOTIATE_EXTENDED_SESSIONSECURITY",  # P
+    "NEGOTIATE_IDENTIFY",  # Q
+    "r5",
+    "REQUEST_NON_NT_SESSION_KEY",  # R
+    "NEGOTIATE_TARGET_INFO",  # S
+    "r4",
+    "NEGOTIATE_VERSION",  # T
+    "r3",
+    "r2",
+    "r1",
+    "NEGOTIATE_128",  # U
+    "NEGOTIATE_KEY_EXCH",  # V
+    "NEGOTIATE_56",  # W
+]
+
+
+def _NTLMStrField(name, default):
+    return MultipleTypeField(
+        [
+            (
+                StrFieldUtf16(name, default),
+                lambda pkt: pkt.NegotiateFlags.NEGOTIATE_UNICODE,
             )
-        elif self.auth_type == 0x44:
-            return (not self.parent or self.parent.ptype not in [11, 12, 13, 14, 15])
-        return False
+        ],
+        StrField(name, default),
+    )
 
-    def default_payload_class(self, pkt):
-        return conf.padding_layer
 
+# Sect 2.2.2.10
 
-# sect 12.6
 
+class _NTLM_Version(Packet):
+    fields_desc = [
+        ByteField("ProductMajorVersion", 0),
+        ByteField("ProductMinorVersion", 0),
+        LEShortField("ProductBuild", 0),
+        LEThreeBytesField("res_ver", 0),
+        ByteEnumField("NTLMRevisionCurrent", 0x0F, {0x0F: "v15"}),
+    ]
 
-_DCE_RPC_5_FLAGS = {
-    0x01: "FIRST_FRAG",
-    0x02: "LAST_FRAG",
-    0x04: "PENDING_CANCEL",
-    0x10: "CONC_MPX",
-    0x20: "DID_NOT_EXECUTE",
-    0x40: "MAYBE",
-    0x80: "OBJECT_UUID",
-}
-
-_DCE_RPC_ERROR_CODES = {
-    # Appendix E
-    0x1C000008: "nca_rpc_version_mismatch",
-    0x1C000009: "nca_unspec_reject",
-    0x1C00000A: "nca_s_bad_actid",
-    0x1C00000B: "nca_who_are_you_failed",
-    0x1C00000C: "nca_manager_not_entered",
-    0x1C010002: "nca_op_rng_error",
-    0x1C010003: "nca_unk_if",
-    0x1C010006: "nca_wrong_boot_time",
-    0x1C010009: "nca_s_you_crashed",
-    0x1C01000B: "nca_proto_error",
-    0x1C010013: "nca_out_args_too_big",
-    0x1C010014: "nca_server_too_busy",
-    0x1C010017: "nca_unsupported_type",
-    0x1C00001C: "nca_invalid_pres_context_id",
-    0x1C00001D: "nca_unsupported_authn_level",
-    0x1C00001F: "nca_invalid_checksum",
-    0x1C000020: "nca_invalid_crc",
-    # [MS-ERREF]
-    0x000006F7: "RPC_X_BAD_STUB_DATA",
-}
 
+# Sect 2.2.1.1
 
-class DceRpc5(Packet):
-    """
-    DCE/RPC v5 'connection-oriented' packet
-    """
 
-    name = "DCE/RPC v5"
+class NTLM_NEGOTIATE(_NTLMPayloadPacket):
+    name = "NTLM Negotiate"
+    MessageType = 1
+    OFFSET = lambda pkt: (((pkt.DomainNameBufferOffset or 40) > 32) and 40 or 32)
     fields_desc = (
         [
-            ByteEnumField(
-                "rpc_vers", 5, {4: "4 (connection-less)", 5: "5 (connection-oriented)"}
-            ),
-            ByteField("rpc_vers_minor", 0),
-            ByteEnumField("ptype", 0, DCE_RPC_TYPE),
-            FlagsField("pfc_flags", 0, 8, _DCE_RPC_5_FLAGS),
-        ] +
-        _drep +
-        [
-            ByteField("reserved2", 0),
-            _EField(ShortField("frag_len", None)),
-            _EField(
-                FieldLenField(
-                    "auth_len",
-                    None,
-                    fmt="H",
-                    length_of="auth_verifier",
-                    adjust=lambda pkt, x: 0 if not x else (x - 8),
-                )
-            ),
-            _EField(IntField("call_id", None)),
+            NTLM_Header,
+            FlagsField("NegotiateFlags", 0, -32, _negotiateFlags),
+            # DomainNameFields
+            LEShortField("DomainNameLen", None),
+            LEShortField("DomainNameMaxLen", None),
+            LEIntField("DomainNameBufferOffset", None),
+            # WorkstationFields
+            LEShortField("WorkstationNameLen", None),
+            LEShortField("WorkstationNameMaxLen", None),
+            LEIntField("WorkstationNameBufferOffset", None),
+        ]
+        + [
+            # VERSION
             ConditionalField(
-                TrailerField(
-                    PacketLenField(
-                        "auth_verifier",
-                        None,
-                        CommonAuthVerifier,
-                        length_from=lambda pkt: pkt.auth_len + 8,
+                # (not present on some old Windows versions. We use a heuristic)
+                x,
+                lambda pkt: (
+                    (
+                        40
+                        if pkt.DomainNameBufferOffset is None
+                        else pkt.DomainNameBufferOffset or len(pkt.original or b"")
                     )
-                ),
-                lambda pkt: pkt.auth_len != 0,
+                    > 32
+                )
+                or pkt.fields.get(x.name, b""),
+            )
+            for x in _NTLM_Version.fields_desc
+        ]
+        + [
+            # Payload
+            _NTLMPayloadField(
+                "Payload",
+                OFFSET,
+                [
+                    _NTLMStrField("DomainName", b""),
+                    _NTLMStrField("WorkstationName", b""),
+                ],
             ),
         ]
     )
 
     def post_build(self, pkt, pay):
-        if self.auth_verifier and self.auth_verifier.auth_pad_length is None:
-            # Compute auth_len and add padding
-            auth_len = self.get_field("auth_len").getfield(self, pkt[10:12])[1] + 8
-            auth_verifier, pay = pay[-auth_len:], pay[:-auth_len]
-            # [MS-RPCE]
-            # > The sec_trailer structure MUST be 16-byte aligned
-            # > with respect to the beginning of the PDU Body<
-            padlen = (-(len(pay) - 8)) % 16
-            auth_verifier = (
-                auth_verifier[:2] + struct.pack("B", padlen) + auth_verifier[3:]
-            )
-            pay = pay + (padlen * b"\x00") + auth_verifier
-        if self.frag_len is None:
-            # Compute frag_len
-            length = len(pkt) + len(pay)
-            pkt = (
-                pkt[:8] +
-                self.get_field("frag_len").addfield(self, b"", length) +
-                pkt[10:]
+        # type: (bytes, bytes) -> bytes
+        return (
+            _NTLM_post_build(
+                self,
+                pkt,
+                self.OFFSET(),
+                {
+                    "DomainName": 16,
+                    "WorkstationName": 24,
+                },
             )
-        return pkt + pay
-
-    def answers(self, pkt):
-        return isinstance(pkt, DceRpc5) and pkt[DceRpc5].call_id == self.call_id
-
-    @classmethod
-    def tcp_reassemble(cls, data, _, session):
-        if data[0:1] != b"\x05":
-            return
-        endian = struct.unpack("!B", data[4:5])[0] >> 4
-        if endian not in [0, 1]:
-            return
-        length = struct.unpack(("<" if endian else ">") + "H", data[8:10])[0]
-        if len(data) == length:
-            # Start a DCE/RPC session for this TCP stream
-            dcerpc_session = session.get("dcerpc_session", None)
-            if not dcerpc_session:
-                dcerpc_session = session["dcerpc_session"] = DceRpcSession()
-            pkt = dcerpc_session._process_dcerpc_packet(DceRpc5(data))
-            return pkt
+            + pay
+        )
 
 
-# sec 12.6.3.1
+# Challenge
 
 
-DCE_RPC_INTERFACES_NAMES = {}
-DCE_RPC_INTERFACES_NAMES_rev = {}
+class Single_Host_Data(Packet):
+    fields_desc = [
+        LEIntField("Size", 48),
+        LEIntField("Z4", 0),
+        XStrFixedLenField("CustomData", b"", length=8),
+        XStrFixedLenField("MachineID", b"", length=32),
+    ]
 
-DCE_RPC_TRANSFER_SYNTAXES = {
-    UUID("00000000-0000-0000-0000-000000000000"): "NULL",
-    UUID("6cb71c2c-9812-4540-0300-000000000000"): "Bind Time Feature Negotiation",
-    UUID("8a885d04-1ceb-11c9-9fe8-08002b104860"): "NDR 2.0",
-    UUID("71710533-beba-4937-8319-b5dbef9ccc36"): "NDR64",
-}
+    def default_payload_class(self, payload):
+        return conf.padding_layer
 
 
-class DceRpc5AbstractSyntax(EPacket):
-    name = "Presentation Syntax (p_syntax_id_t)"
+class AV_PAIR(Packet):
+    name = "NTLM AV Pair"
     fields_desc = [
-        _EField(
-            UUIDEnumField(
-                "if_uuid",
-                None,
+        LEShortEnumField(
+            "AvId",
+            0,
+            {
+                0x0000: "MsvAvEOL",
+                0x0001: "MsvAvNbComputerName",
+                0x0002: "MsvAvNbDomainName",
+                0x0003: "MsvAvDnsComputerName",
+                0x0004: "MsvAvDnsDomainName",
+                0x0005: "MsvAvDnsTreeName",
+                0x0006: "MsvAvFlags",
+                0x0007: "MsvAvTimestamp",
+                0x0008: "MsvAvSingleHost",
+                0x0009: "MsvAvTargetName",
+                0x000A: "MsvAvChannelBindings",
+            },
+        ),
+        FieldLenField("AvLen", None, length_of="Value", fmt="<H"),
+        MultipleTypeField(
+            [
                 (
-                    # Those are dynamic
-                    DCE_RPC_INTERFACES_NAMES.get,
-                    DCE_RPC_INTERFACES_NAMES_rev.get,
+                    LEIntEnumField(
+                        "Value",
+                        1,
+                        {
+                            0x0001: "constrained",
+                            0x0002: "MIC integrity",
+                            0x0004: "SPN from untrusted source",
+                        },
+                    ),
+                    lambda pkt: pkt.AvId == 0x0006,
                 ),
-            )
-        ),
-        _EField(ShortField("if_version", 3)),
-        _EField(ShortField("if_version_minor", 0)),
-    ]
-
-
-class DceRpc5TransferSyntax(EPacket):
-    name = "Presentation Transfer Syntax (p_syntax_id_t)"
-    fields_desc = [
-        _EField(
-            UUIDEnumField(
-                "if_uuid",
-                None,
-                DCE_RPC_TRANSFER_SYNTAXES,
-            )
+                (
+                    UTCTimeField(
+                        "Value",
+                        None,
+                        epoch=[1601, 1, 1, 0, 0, 0],
+                        custom_scaling=1e7,
+                        fmt="<Q",
+                    ),
+                    lambda pkt: pkt.AvId == 0x0007,
+                ),
+                (
+                    PacketField("Value", Single_Host_Data(), Single_Host_Data),
+                    lambda pkt: pkt.AvId == 0x0008,
+                ),
+                (
+                    XStrLenField("Value", b"", length_from=lambda pkt: pkt.AvLen),
+                    lambda pkt: pkt.AvId == 0x000A,
+                ),
+            ],
+            StrLenFieldUtf16("Value", b"", length_from=lambda pkt: pkt.AvLen),
         ),
-        _EField(ShortField("if_version", 3)),
-        _EField(ShortField("reserved", 0)),
     ]
 
-
-class DceRpc5Context(EPacket):
-    name = "Presentation Context (p_cont_elem_t)"
-    fields_desc = [
-        _EField(ShortField("context_id", 0)),
-        FieldLenField("n_transfer_syn", None, count_of="transfer_syntaxes", fmt="B"),
-        ByteField("reserved", 0),
-        EPacketField("abstract_syntax", None, DceRpc5AbstractSyntax),
-        EPacketListField(
-            "transfer_syntaxes",
-            None,
-            DceRpc5TransferSyntax,
-            count_from=lambda pkt: pkt.n_transfer_syn,
-            endianness_from=_dce_rpc_endianess,
-        ),
-    ]
+    def default_payload_class(self, payload):
+        return conf.padding_layer
 
 
-class DceRpc5Result(EPacket):
-    name = "Context negotiation Result"
-    fields_desc = [
-        _EField(
-            ShortEnumField(
-                "result", 0, ["acceptance", "user_rejection", "provider_rejection"]
+class NTLM_CHALLENGE(_NTLMPayloadPacket):
+    name = "NTLM Challenge"
+    MessageType = 2
+    OFFSET = lambda pkt: (((pkt.TargetInfoBufferOffset or 56) > 48) and 56 or 48)
+    fields_desc = (
+        [
+            NTLM_Header,
+            # TargetNameFields
+            LEShortField("TargetNameLen", None),
+            LEShortField("TargetNameMaxLen", None),
+            LEIntField("TargetNameBufferOffset", None),
+            #
+            FlagsField("NegotiateFlags", 0, -32, _negotiateFlags),
+            XStrFixedLenField("ServerChallenge", None, length=8),
+            XStrFixedLenField("Reserved", None, length=8),
+            # TargetInfoFields
+            LEShortField("TargetInfoLen", None),
+            LEShortField("TargetInfoMaxLen", None),
+            LEIntField("TargetInfoBufferOffset", None),
+        ]
+        + [
+            # VERSION
+            ConditionalField(
+                # (not present on some old Windows versions. We use a heuristic)
+                x,
+                lambda pkt: ((pkt.TargetInfoBufferOffset or 56) > 40)
+                or pkt.fields.get(x.name, b""),
             )
-        ),
-        _EField(
-            ShortEnumField(
-                "reason",
-                0,
+            for x in _NTLM_Version.fields_desc
+        ]
+        + [
+            # Payload
+            _NTLMPayloadField(
+                "Payload",
+                OFFSET,
                 [
-                    "reason_not_specified",
-                    "abstract_syntax_not_supported",
-                    "proposed_transfer_syntaxes_not_supported",
-                    "local_limit_exceeded",
+                    _NTLMStrField("TargetName", b""),
+                    PacketListField("TargetInfo", [AV_PAIR()], AV_PAIR),
                 ],
-            )
-        ),
-        EPacketField("transfer_syntax", None, DceRpc5TransferSyntax),
-    ]
+            ),
+        ]
+    )
 
+    def getAv(self, AvId):
+        try:
+            return next(x for x in self.TargetInfo if x.AvId == AvId)
+        except (StopIteration, AttributeError):
+            raise IndexError
 
-class DceRpc5PortAny(EPacket):
-    name = "Port Any (port_any_t)"
-    fields_desc = [
-        _EField(FieldLenField("length", None, length_of="port_spec", fmt="H")),
-        _EField(StrLenField("port_spec", b"", length_from=lambda pkt: pkt.length)),
-    ]
+    def post_build(self, pkt, pay):
+        # type: (bytes, bytes) -> bytes
+        return (
+            _NTLM_post_build(
+                self,
+                pkt,
+                self.OFFSET(),
+                {
+                    "TargetName": 12,
+                    "TargetInfo": 40,
+                },
+            )
+            + pay
+        )
 
 
-# sec 12.6.4.3
+# Authenticate
 
 
-class DceRpc5Bind(_DceRpcPayload):
-    name = "DCE/RPC v5 - Bind"
+class LM_RESPONSE(Packet):
     fields_desc = [
-        _EField(ShortField("max_xmit_frag", 5840)),
-        _EField(ShortField("max_recv_frag", 8192)),
-        _EField(IntField("assoc_group_id", 0)),
-        # p_cont_list_t
-        _EField(
-            FieldLenField("n_context_elem", None, count_of="context_elem", fmt="B")
-        ),
-        StrFixedLenField("reserved", 0, length=3),
-        EPacketListField(
-            "context_elem",
-            [],
-            DceRpc5Context,
-            endianness_from=_dce_rpc_endianess,
-            count_from=lambda pkt: pkt.n_context_elem,
-        ),
+        StrFixedLenField("Response", b"", length=24),
     ]
 
 
-bind_layers(DceRpc5, DceRpc5Bind, ptype=11)
-
-# sec 12.6.4.4
-
-
-class DceRpc5BindAck(_DceRpcPayload):
-    name = "DCE/RPC v5 - Bind Ack"
+class LMv2_RESPONSE(Packet):
     fields_desc = [
-        _EField(ShortField("max_xmit_frag", 5840)),
-        _EField(ShortField("max_recv_frag", 8192)),
-        _EField(IntField("assoc_group_id", 0)),
-        PadField(
-            EPacketField("sec_addr", None, DceRpc5PortAny),
-            align=4,
-        ),
-        # p_result_list_t
-        _EField(FieldLenField("n_results", None, count_of="results", fmt="B")),
-        StrFixedLenField("reserved", 0, length=3),
-        EPacketListField(
-            "results",
-            [],
-            DceRpc5Result,
-            endianness_from=_dce_rpc_endianess,
-            count_from=lambda pkt: pkt.n_results,
-        ),
+        StrFixedLenField("Response", b"", length=16),
+        StrFixedLenField("ChallengeFromClient", b"", length=8),
     ]
 
 
-bind_layers(DceRpc5, DceRpc5BindAck, ptype=12)
-
-# sec 12.6.4.5
-
-
-class DceRpc5Version(EPacket):
-    name = "version_t"
+class NTLM_RESPONSE(Packet):
     fields_desc = [
-        ByteField("major", 0),
-        ByteField("minor", 0),
+        StrFixedLenField("Response", b"", length=24),
     ]
 
 
-class DceRpc5BindNak(_DceRpcPayload):
-    name = "DCE/RPC v5 - Bind Nak"
+class NTLMv2_CLIENT_CHALLENGE(Packet):
     fields_desc = [
-        _EField(ShortField("provider_reject_reason", 0)),
-        # p_rt_versions_supported_t
-        _EField(FieldLenField("n_protocols", None, length_of="protocols", fmt="B")),
-        EPacketListField(
-            "protocols",
-            [],
-            DceRpc5Version,
-            count_from=lambda pkt: pkt.n_protocols,
-            endianness_from=_dce_rpc_endianess,
+        ByteField("RespType", 1),
+        ByteField("HiRespType", 1),
+        LEShortField("Reserved1", 0),
+        LEIntField("Reserved2", 0),
+        UTCTimeField(
+            "TimeStamp", None, fmt="<Q", epoch=[1601, 1, 1, 0, 0, 0], custom_scaling=1e7
         ),
+        StrFixedLenField("ChallengeFromClient", b"12345678", length=8),
+        LEIntField("Reserved3", 0),
+        PacketListField("AvPairs", [AV_PAIR()], AV_PAIR),
     ]
 
-
-bind_layers(DceRpc5, DceRpc5BindNak, ptype=13)
-
-
-# sec 12.6.4.1
-
-
-class DceRpc5AlterContext(_DceRpcPayload):
-    name = "DCE/RPC v5 - AlterContext"
-    fields_desc = DceRpc5Bind.fields_desc
-
-
-bind_layers(DceRpc5, DceRpc5AlterContext, ptype=14)
-
-
-# sec 12.6.4.2
-
-
-class DceRpc5AlterContextResp(_DceRpcPayload):
-    name = "DCE/RPC v5 - AlterContextResp"
-    fields_desc = DceRpc5BindAck.fields_desc
-
-
-bind_layers(DceRpc5, DceRpc5AlterContextResp, ptype=15)
-
-# [MS-RPCE] sect 2.2.2.10 - rpc_auth_3
-
-
-class DceRpc5Auth3(Packet):
-    name = "DCE/RPC v5 - Auth3"
-    fields_desc = [StrFixedLenField("pad", b"", length=4)]
-
-
-bind_layers(DceRpc5, DceRpc5Auth3, ptype=16)
-
-# sec 12.6.4.7
-
-
-class DceRpc5Fault(_DceRpcPayload):
-    name = "DCE/RPC v5 - Fault"
-    fields_desc = [
-        _EField(IntField("alloc_hint", 0)),
-        _EField(ShortField("cont_id", 0)),
-        ByteField("cancel_count", 0),
-        ByteField("reserved", 0),
-        _EField(LEIntEnumField("status", 0, _DCE_RPC_ERROR_CODES)),
-        IntField("reserved2", 0),
-    ]
-
-
-bind_layers(DceRpc5, DceRpc5Fault, ptype=3)
-
-
-# sec 12.6.4.9
-
-
-class DceRpc5Request(_DceRpcPayload):
-    name = "DCE/RPC v5 - Request"
-    fields_desc = [
-        _EField(IntField("alloc_hint", 0)),
-        _EField(ShortField("cont_id", 0)),
-        _EField(ShortField("opnum", 0)),
-        ConditionalField(
-            PadField(
-                _EField(UUIDField("object", None)),
-                align=8,
-            ),
-            lambda pkt: pkt.underlayer and pkt.underlayer.pfc_flags.OBJECT_UUID,
-        ),
-    ]
-
-
-bind_layers(DceRpc5, DceRpc5Request, ptype=0)
-
-# sec 12.6.4.10
+    def getAv(self, AvId):
+        try:
+            return next(x for x in self.AvPairs if x.AvId == AvId)
+        except StopIteration:
+            raise IndexError
 
 
-class DceRpc5Response(_DceRpcPayload):
-    name = "DCE/RPC v5 - Response"
+class NTLMv2_RESPONSE(NTLMv2_CLIENT_CHALLENGE):
     fields_desc = [
-        _EField(IntField("alloc_hint", 0)),
-        _EField(ShortField("cont_id", 0)),
-        ByteField("cancel_count", 0),
-        ByteField("reserved", 0),
+        XStrFixedLenField("NTProofStr", b"", length=16),
+        NTLMv2_CLIENT_CHALLENGE,
     ]
 
+    def computeNTProofStr(self, ResponseKeyNT, ServerChallenge):
+        """
+        Set temp to ConcatenationOf(Responserversion, HiResponserversion,
+            Z(6), Time, ClientChallenge, Z(4), ServerName, Z(4))
+        Set NTProofStr to HMAC_MD5(ResponseKeyNT,
+            ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge,temp))
 
-bind_layers(DceRpc5, DceRpc5Response, ptype=2)
-
-# --- API
-
-DceRpcOp = namedtuple("DceRpcOp", ["request", "response"])
-DCE_RPC_INTERFACES = {}
-
-
-class DceRpcInterface:
-    def __init__(self, name, uuid, version, opnums):
-        self.name = name
-        self.uuid = uuid
-        self.version, self.minor_version = map(int, version.split("."))
-        self.opnums = opnums
-
-    def __repr__(self):
-        return "<DCE/RPC Interface %s v%s>" % (self.name, self.version)
-
-
-def register_dcerpc_interface(name, uuid, version, opnums):
-    """
-    Register a DCE/RPC interface
-    """
-    if uuid in DCE_RPC_INTERFACES:
-        raise ValueError("Interface is already registered !")
-    DCE_RPC_INTERFACES_NAMES[uuid] = "%s (v%s)" % (name.upper(), version)
-    DCE_RPC_INTERFACES_NAMES_rev[name.upper()] = uuid
-    DCE_RPC_INTERFACES[uuid] = DceRpcInterface(
-        name,
-        uuid,
-        version,
-        opnums,
-    )
-    # bind for build
-    for opnum, operations in opnums.items():
-        bind_top_down(DceRpc5Request, operations.request, opnum=opnum)
-
-
-def find_dcerpc_interface(name):
-    """
-    Find an interface object through the name in the IDL
-    """
-    try:
-        return next(x for x in DCE_RPC_INTERFACES.values() if x.name == name)
-    except StopIteration:
-        raise AttributeError("Unknown interface !")
-
-
-# --- NDR fields - [C706] chap 14
-
-
-def _set_ndr_on(f, ndr64):
-    if isinstance(f, _NDRPacket):
-        f.ndr64 = ndr64
-    if isinstance(f, list):
-        for x in f:
-            if isinstance(x, _NDRPacket):
-                x.ndr64 = ndr64
-
-
-class _NDRPacket(Packet):
-    __slots__ = ["ndr64", "defered_pointers", "request_packet"]
-
-    def __init__(self, *args, **kwargs):
-        self.ndr64 = kwargs.pop("ndr64", True)
-        # request_packet is used in the session, so that a response packet
-        # can resolve union arms if the case parameter is in the request.
-        self.request_packet = kwargs.pop("request_packet", None)
-        self.defered_pointers = []
-        super(_NDRPacket, self).__init__(*args, **kwargs)
-
-    def dissect(self, s):
-        _up = self.parent or self.underlayer
-        if _up and isinstance(_up, _NDRPacket):
-            self.ndr64 = _up.ndr64
-        return super(_NDRPacket, self).dissect(s)
-
-    def do_build(self):
-        for f in self.fields.values():
-            _set_ndr_on(f, self.ndr64)
-        return super(_NDRPacket, self).do_build()
-
-    def default_payload_class(self, pkt):
-        return conf.padding_layer
+        Remember ServerName = AvPairs
+        """
+        Responserversion = b"\x01"
+        HiResponserversion = b"\x01"
 
-    def clone_with(self, *args, **kwargs):
-        pkt = super(_NDRPacket, self).clone_with(*args, **kwargs)
-        # We need to copy defered_pointers to not break pointer deferral
-        # on build.
-        pkt.defered_pointers = self.defered_pointers
-        pkt.ndr64 = self.ndr64
-        return pkt
-
-    def copy(self):
-        pkt = super(_NDRPacket, self).copy()
-        pkt.defered_pointers = self.defered_pointers
-        pkt.ndr64 = self.ndr64
-        return pkt
-
-    def show2(self, dump=False, indent=3, lvl="", label_lvl=""):
-        return self.__class__(bytes(self), ndr64=self.ndr64).show(
-            dump, indent, lvl, label_lvl
+        ServerName = b"".join(bytes(x) for x in self.AvPairs)
+        temp = b"".join(
+            [
+                Responserversion,
+                HiResponserversion,
+                b"\x00" * 6,
+                struct.pack("<Q", self.TimeStamp),
+                self.ChallengeFromClient,
+                b"\x00" * 4,
+                ServerName,
+                # Final Z(4) is the EOL AvPair
+            ]
         )
-
-    def getfield_and_val(self, attr):
-        try:
-            return Packet.getfield_and_val(self, attr)
-        except ValueError:
-            if self.request_packet:
-                # Try to resolve the field from the request on failure
-                try:
-                    return self.request_packet.getfield_and_val(attr)
-                except AttributeError:
-                    pass
-            raise
-
-
-class _NDRAlign:
-    def padlen(self, flen, pkt):
-        return -flen % self._align[pkt.ndr64]
-
-    def original_length(self, pkt):
-        # Find the length of the NDR frag to be able to pad properly
-        while pkt:
-            par = pkt.parent or pkt.underlayer
-            if par and isinstance(par, _NDRPacket):
-                pkt = par
-            else:
-                break
-        return len(pkt.original)
-
-
-class NDRAlign(_NDRAlign, ReversePadField):
-    """
-    ReversePadField modified to fit NDR.
-
-    - If no align size is specified, use the one from the inner field
-    - Size is calculated from the beginning of the NDR stream
-    """
-
-    def __init__(self, fld, align, padwith=None):
-        super(NDRAlign, self).__init__(fld, align=align, padwith=padwith)
+        return HMAC_MD5(ResponseKeyNT, ServerChallenge + temp)
 
 
-class _NDRPacketMetaclass(Packet_metaclass):
-    def __new__(cls, name, bases, dct):
-        newcls = super(_NDRPacketMetaclass, cls).__new__(cls, name, bases, dct)
-        conformants = dct.get("CONFORMANT_COUNT", 0)
-        if conformants:
-            if conformants == 1:
-                newcls.fields_desc.insert(
-                    0,
+class NTLM_AUTHENTICATE(_NTLMPayloadPacket):
+    name = "NTLM Authenticate"
+    MessageType = 3
+    NTLM_VERSION = 1
+    OFFSET = lambda pkt: (
+        ((pkt.DomainNameBufferOffset or 88) <= 64)
+        and 64
+        or (((pkt.DomainNameBufferOffset or 88) > 72) and 88 or 72)
+    )
+    fields_desc = (
+        [
+            NTLM_Header,
+            # LmChallengeResponseFields
+            LEShortField("LmChallengeResponseLen", None),
+            LEShortField("LmChallengeResponseMaxLen", None),
+            LEIntField("LmChallengeResponseBufferOffset", None),
+            # NtChallengeResponseFields
+            LEShortField("NtChallengeResponseLen", None),
+            LEShortField("NtChallengeResponseMaxLen", None),
+            LEIntField("NtChallengeResponseBufferOffset", None),
+            # DomainNameFields
+            LEShortField("DomainNameLen", None),
+            LEShortField("DomainNameMaxLen", None),
+            LEIntField("DomainNameBufferOffset", None),
+            # UserNameFields
+            LEShortField("UserNameLen", None),
+            LEShortField("UserNameMaxLen", None),
+            LEIntField("UserNameBufferOffset", None),
+            # WorkstationFields
+            LEShortField("WorkstationLen", None),
+            LEShortField("WorkstationMaxLen", None),
+            LEIntField("WorkstationBufferOffset", None),
+            # EncryptedRandomSessionKeyFields
+            LEShortField("EncryptedRandomSessionKeyLen", None),
+            LEShortField("EncryptedRandomSessionKeyMaxLen", None),
+            LEIntField("EncryptedRandomSessionKeyBufferOffset", None),
+            # NegotiateFlags
+            FlagsField("NegotiateFlags", 0, -32, _negotiateFlags),
+            # VERSION
+        ]
+        + [
+            ConditionalField(
+                # (not present on some old Windows versions. We use a heuristic)
+                x,
+                lambda pkt: ((pkt.DomainNameBufferOffset or 88) > 64)
+                or pkt.fields.get(x.name, b""),
+            )
+            for x in _NTLM_Version.fields_desc
+        ]
+        + [
+            # MIC
+            ConditionalField(
+                # (not present on some old Windows versions. We use a heuristic)
+                XStrFixedLenField("MIC", b"", length=16),
+                lambda pkt: ((pkt.DomainNameBufferOffset or 88) > 72)
+                or pkt.fields.get("MIC", b""),
+            ),
+            # Payload
+            _NTLMPayloadField(
+                "Payload",
+                OFFSET,
+                [
                     MultipleTypeField(
                         [
                             (
-                                NDRLongField("max_count", 0),
-                                lambda pkt: pkt and pkt.ndr64,
+                                PacketField(
+                                    "LmChallengeResponse",
+                                    LMv2_RESPONSE(),
+                                    LMv2_RESPONSE,
+                                ),
+                                lambda pkt: pkt.NTLM_VERSION == 2,
                             )
                         ],
-                        NDRIntField("max_count", 0),
+                        PacketField("LmChallengeResponse", LM_RESPONSE(), LM_RESPONSE),
                     ),
-                )
-            else:
-                newcls.fields_desc.insert(
-                    0,
                     MultipleTypeField(
                         [
                             (
-                                NDRAlign(
-                                    FieldListField(
-                                        "max_counts",
-                                        0,
-                                        LELongField("", 0),
-                                        count_from=lambda _: conformants,
-                                    ),
-                                    align=(8, 8),
+                                PacketField(
+                                    "NtChallengeResponse",
+                                    NTLMv2_RESPONSE(),
+                                    NTLMv2_RESPONSE,
                                 ),
-                                lambda pkt: pkt and pkt.ndr64,
+                                lambda pkt: pkt.NTLM_VERSION == 2,
                             )
                         ],
-                        NDRAlign(
-                            FieldListField(
-                                "max_counts",
-                                0,
-                                LEIntField("", 0),
-                                count_from=lambda _: conformants,
-                            ),
-                            align=(4, 4),
+                        PacketField(
+                            "NtChallengeResponse", NTLM_RESPONSE(), NTLM_RESPONSE
                         ),
                     ),
-                )
-        return newcls  # type: ignore
-
-
-@six.add_metaclass(_NDRPacketMetaclass)
-class NDRPacket(_NDRPacket):
-    """
-    A NDR Packet. Handles pointer size & endianness
-    """
-
-    __slots__ = ["_align"]
-
-    # NDR64 pad structures
-    # [MS-RPCE] 2.2.5.3.4.1
-    ALIGNMENT = (1, 1)
-    # Conformants max_count can be added to the beginning
-    CONFORMANT_COUNT = 0
-
-
-# Primitive types
-NDRByteField = ByteField
-NDRSignedByteField = SignedByteField
-
-
-class NDRShortField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRShortField, self).__init__(LEShortField(*args, **kwargs), align=(2, 2))
-
-
-class NDRSignedShortField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRSignedShortField, self).__init__(
-            LESignedShortField(*args, **kwargs), align=(2, 2)
-        )
-
-
-class NDRIntField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRIntField, self).__init__(LEIntField(*args, **kwargs), align=(4, 4))
-
-
-class NDRSignedIntField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRSignedIntField, self).__init__(
-            LESignedIntField(*args, **kwargs), align=(4, 4)
-        )
-
-
-class NDRLongField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRLongField, self).__init__(LELongField(*args, **kwargs), align=(8, 8))
-
-
-class NDRSignedLongField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRSignedLongField, self).__init__(
-            LESignedLongField(*args, **kwargs), align=(8, 8)
-        )
-
+                    _NTLMStrField("DomainName", b""),
+                    _NTLMStrField("UserName", b""),
+                    _NTLMStrField("Workstation", b""),
+                    XStrField("EncryptedRandomSessionKey", b""),
+                ],
+            ),
+        ]
+    )
 
-class NDRIEEEFloatField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRIEEEFloatField, self).__init__(
-            IEEEFloatField(*args, **kwargs), align=(4, 4)
+    def post_build(self, pkt, pay):
+        # type: (bytes, bytes) -> bytes
+        return (
+            _NTLM_post_build(
+                self,
+                pkt,
+                self.OFFSET(),
+                {
+                    "LmChallengeResponse": 12,
+                    "NtChallengeResponse": 20,
+                    "DomainName": 28,
+                    "UserName": 36,
+                    "Workstation": 44,
+                    "EncryptedRandomSessionKey": 52,
+                },
+            )
+            + pay
         )
 
-
-class NDRIEEEDoubleField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRIEEEDoubleField, self).__init__(
-            IEEEDoubleField(*args, **kwargs), align=(8, 8)
+    def compute_mic(self, ExportedSessionKey, negotiate, challenge):
+        self.MIC = b"\x00" * 16
+        self.MIC = HMAC_MD5(
+            ExportedSessionKey, bytes(negotiate) + bytes(challenge) + bytes(self)
         )
 
 
-# Enum types
+class NTLM_AUTHENTICATE_V2(NTLM_AUTHENTICATE):
+    NTLM_VERSION = 2
 
 
-class _NDREnumField(EnumField):
-    # [MS-RPCE] sect 2.2.5.2 - Enums are 4 octets in NDR64
-    FMTS = ["<H", "<I"]
+def HTTP_ntlm_negotiate(ntlm_negotiate):
+    """Create an HTTP NTLM negotiate packet from an NTLM_NEGOTIATE message"""
+    assert isinstance(ntlm_negotiate, NTLM_NEGOTIATE)
+    from scapy.layers.http import HTTP, HTTPRequest
 
-    def getfield(self, pkt, s):
-        fmt = self.FMTS[pkt.ndr64]
-        return NDRAlign(Field("", 0, fmt=fmt), align=(2, 4)).getfield(pkt, s)
+    return HTTP() / HTTPRequest(
+        Authorization=b"NTLM " + bytes_base64(bytes(ntlm_negotiate))
+    )
 
-    def addfield(self, pkt, s, val):
-        fmt = self.FMTS[pkt.ndr64]
-        return NDRAlign(Field("", 0, fmt=fmt), align=(2, 4)).addfield(pkt, s, val)
 
+# Experimental - Reversed stuff
 
-class NDRInt3264EnumField(NDRAlign):
-    def __init__(self, *args, **kwargs):
-        super(NDRInt3264EnumField, self).__init__(
-            _NDREnumField(*args, **kwargs), align=(2, 4)
-        )
+# This is the GSSAPI NegoEX Exchange metadata blob. This is not documented
+# but described as an "opaque blob": this was reversed and everything is a
+# placeholder.
 
 
-class NDRIntEnumField(NDRAlign):
-    # v1_enum are always 4-octets, even in NDR32
-    def __init__(self, *args, **kwargs):
-        super(NDRIntEnumField, self).__init__(
-            LEIntEnumField(*args, **kwargs), align=(4, 4)
+class NEGOEX_EXCHANGE_NTLM_ITEM(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_SEQUENCE(
+            ASN1F_SEQUENCE(
+                ASN1F_OID("oid", ""),
+                ASN1F_PRINTABLE_STRING("token", ""),
+                explicit_tag=0x31,
+            ),
+            explicit_tag=0x80,
         )
+    )
 
 
-# Special types
-
-
-class NDRInt3264Field(Field):
-    FMTS = ["<I", "<Q"]
-
-    def getfield(self, pkt, s):
-        fmt = self.FMTS[pkt.ndr64]
-        return NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).getfield(pkt, s)
-
-    def addfield(self, pkt, s, val):
-        fmt = self.FMTS[pkt.ndr64]
-        return NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).addfield(pkt, s, val)
-
-
-class NDRSignedInt3264Field(NDRInt3264Field):
-    FMTS = ["<i", "<q"]
-
-
-# Pointer types
-
-
-class NDRPointer(_NDRPacket):
-    fields_desc = [
-        MultipleTypeField(
-            [(XLELongField("referent_id", 1), lambda pkt: pkt and pkt.ndr64)],
-            XLEIntField("referent_id", 1),
-        ),
-        PacketField("value", None, conf.raw_layer),
-    ]
-
-
-class NDRFullPointerField(_FieldContainer):
+class NEGOEX_EXCHANGE_NTLM(ASN1_Packet):
     """
-    A NDR Full/Unique pointer field encapsulation.
-
-    :param deferred: This pointer is deferred. This means that it's representation
-                     will not appear after the pointer.
-                     See [C706] 14.3.12.3 - Algorithm for Deferral of Referents
+    GSSAPI NegoEX Exchange metadata blob
+    This was reversed and may be meaningless
     """
 
-    EMBEDDED = False
-
-    def __init__(self, fld, deferred=False, fmt="I"):
-        self.fld = fld
-        self.default = None
-        self.deferred = deferred
-
-    def getfield(self, pkt, s):
-        fmt = ["<I", "<Q"][pkt.ndr64]
-        remain, referent_id = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).getfield(
-            pkt, s
-        )
-        if not self.EMBEDDED and referent_id == 0:
-            return remain, None
-        if self.deferred:
-            # deferred
-            ptr = NDRPointer(ndr64=pkt.ndr64, referent_id=referent_id)
-            pkt.defered_pointers.append((ptr, partial(self.fld.getfield, pkt)))
-            return remain, ptr
-        remain, val = self.fld.getfield(pkt, remain)
-        return remain, NDRPointer(ndr64=pkt.ndr64, referent_id=referent_id, value=val)
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_SEQUENCE(
+            ASN1F_SEQUENCE_OF("items", [], NEGOEX_EXCHANGE_NTLM_ITEM), implicit_tag=0xA0
+        ),
+    )
 
-    def addfield(self, pkt, s, val):
-        if val is not None and not isinstance(val, NDRPointer):
-            raise ValueError(
-                "Expected NDRPointer in %s. You are using it wrong!" % self.name
-            )
-        fmt = ["<I", "<Q"][pkt.ndr64]
-        fld = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8))
-        if not self.EMBEDDED and val is None:
-            return fld.addfield(pkt, s, 0)
-        else:
-            _set_ndr_on(val.value, pkt.ndr64)
-            s = fld.addfield(pkt, s, val.referent_id)
-        if self.deferred:
-            # deferred
-            pkt.defered_pointers.append(
-                ((lambda s: self.fld.addfield(pkt, s, val.value)), val)
-            )
-            return s
-        return self.fld.addfield(pkt, s, val.value)
-
-    def any2i(self, pkt, x):
-        # User-friendly helper
-        if x is not None and not isinstance(x, NDRPointer):
-            return NDRPointer(
-                referent_id=0x20000,
-                value=self.fld.any2i(pkt, x),
-            )
-        return x
-
-    # Can't use i2repr = Field.i2repr and so on on PY2 :/
-    def i2repr(self, pkt, val):
-        return repr(val)
 
-    def i2h(self, pkt, x):
-        return x
+# Crypto - [MS-NLMP]
 
-    def h2i(self, pkt, x):
-        return x
 
-    def i2count(self, pkt, x):
-        return 1
+def HMAC_MD5(key, data):
+    return Hmac_MD5(key=key).digest(data)
 
 
-class NDRRefEmbPointerField(NDRFullPointerField):
+def MD4le(x):
     """
-    A NDR Embedded Reference pointer
+    MD4 over a string encoded as utf-16le
     """
-
-    EMBEDDED = True
-
-
-# Constructed types
+    return Hash_MD4().digest(x.encode("utf-16le"))
 
 
-# Note: this is utterly complex and will drive you crazy
-
-
-class NDRConstructedType(object):
-    def __init__(self, fields):
-        self.handles_deferred = False
-        self.ndr_fields = fields
-        self.rec_check_deferral()
-
-    def rec_check_deferral(self):
-        # We iterate through the fields within this constructed type.
-        # If we have a pointer, mark this field as handling deferrance
-        # and make all sub-constructed types not.
-        for f in self.ndr_fields:
-            if isinstance(f, NDRFullPointerField) and f.deferred:
-                self.handles_deferred = True
-            if isinstance(f, NDRConstructedType):
-                f.rec_check_deferral()
-                if f.handles_deferred:
-                    self.handles_deferred = True
-                    f.handles_deferred = False
-
-    def getfield(self, pkt, s):
-        s, fval = super(NDRConstructedType, self).getfield(pkt, s)
-        if isinstance(fval, _NDRPacket):
-            # If a sub-packet we just dissected has deferred pointers,
-            # pass it to parent packet to propagate.
-            pkt.defered_pointers.extend(fval.defered_pointers)
-            del fval.defered_pointers[:]
-        if self.handles_deferred:
-            # Now read content of the pointers that were deferred
-            q = deque()
-            q.extend(pkt.defered_pointers)
-            del pkt.defered_pointers[:]
-            while q:
-                # Recursively resolve pointers that were deferred
-                ptr, getfld = q.popleft()
-                s, val = getfld(s)
-                ptr.value = val
-                if isinstance(val, _NDRPacket):
-                    # Pointer resolves to a packet.. that may have deferred pointers?
-                    q.extend(val.defered_pointers)
-                    del val.defered_pointers[:]
-        return s, fval
-
-    def addfield(self, pkt, s, val):
-        # Same logic than above, same comments.
-        s = super(NDRConstructedType, self).addfield(pkt, s, val)
-        if isinstance(val, _NDRPacket):
-            pkt.defered_pointers.extend(val.defered_pointers)
-            del val.defered_pointers[:]
-        if self.handles_deferred:
-            q = deque()
-            q.extend(pkt.defered_pointers)
-            del pkt.defered_pointers[:]
-            while q:
-                addfld, fval = q.popleft()
-                s = addfld(s)
-                if isinstance(fval, NDRPointer) and isinstance(fval.value, _NDRPacket):
-                    q.extend(fval.value.defered_pointers)
-                    del fval.value.defered_pointers[:]
-        return s
-
-
-class _NDRPacketField(PacketField):
-    def m2i(self, pkt, m):
-        return self.cls(m, ndr64=pkt.ndr64, _parent=pkt)
-
-
-# class _NDRPacketPadField(PadField):
-#     def padlen(self, flen, pkt):
-#         if pkt.ndr64:
-#             return -flen % self._align[1]
-#         else:
-#             return 0
-
-
-class NDRPacketField(NDRConstructedType, NDRAlign):
-    def __init__(self, name, default, pkt_cls, **kwargs):
-        fld = _NDRPacketField(name, default, pkt_cls=pkt_cls, **kwargs)
-        NDRAlign.__init__(
-            self,
-            # There is supposed to be padding after a struct in NDR64?
-            # _NDRPacketPadField(fld, align=pkt_cls.ALIGNMENT),
-            fld,
-            align=pkt_cls.ALIGNMENT,
+def RC4Init(key):
+    """Alleged RC4"""
+    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
+    try:
+        # cryptography > 43.0
+        from cryptography.hazmat.decrepit.ciphers import (
+            algorithms as decrepit_algorithms,
         )
-        NDRConstructedType.__init__(self, pkt_cls.fields_desc)
+    except ImportError:
+        decrepit_algorithms = algorithms
 
+    algorithm = decrepit_algorithms.ARC4(key)
+    cipher = Cipher(algorithm, mode=None)
+    encryptor = cipher.encryptor()
+    return encryptor
 
-# Array types
 
-
-class _NDRPacketListField(NDRConstructedType, PacketListField):
-    """
-    A PacketListField for NDR that can optionally pack the packets into NDRPointers
-    """
-
-    islist = 1
-    holds_packets = 1
-
-    __slots__ = ["ptr_pack", "fld"]
-
-    def __init__(self, name, default, pkt_cls, **kwargs):
-        self.ptr_pack = kwargs.pop("ptr_pack", False)
-        PacketListField.__init__(self, name, default, pkt_cls=pkt_cls, **kwargs)
-        if self.ptr_pack:
-            self.fld = NDRFullPointerField(
-                NDRPacketField("", None, pkt_cls), deferred=True
-            )
-        else:
-            self.fld = NDRPacketField("", None, pkt_cls)
-        NDRConstructedType.__init__(self, [self.fld])
-
-    def m2i(self, pkt, s):
-        remain, val = self.fld.getfield(pkt, s)
-        # A mistake here would be to use / instead of add_payload. It adds a copy
-        # which breaks pointer defferal. Same applies elsewhere
-        val.add_payload(conf.padding_layer(remain))
-        return val
-
-    def i2m(self, pkt, val):
-        return self.fld.addfield(pkt, b"", val)
-
-    def i2len(self, pkt, x):
-        return len(x)
+def RC4(handle, data):
+    """The RC4 Encryption Algorithm"""
+    return handle.update(data)
 
 
-class NDRFieldListField(NDRConstructedType, FieldListField):
+def RC4K(key, data):
+    """Indicates the encryption of data item D with the key K using the
+    RC4 algorithm.
     """
-    A FieldListField for NDR
-    """
-
-    islist = 1
-
-    def __init__(self, *args, **kwargs):
-        FieldListField.__init__(self, *args, **kwargs)
-        NDRConstructedType.__init__(self, [self.field])
-
-
-class NDRVaryingArray(_NDRPacket):
-    fields_desc = [
-        MultipleTypeField(
-            [(LELongField("offset", 0), lambda pkt: pkt and pkt.ndr64)],
-            LEIntField("offset", 0),
-        ),
-        MultipleTypeField(
-            [
-                (
-                    LELongField("actual_count", None),
-                    lambda pkt: pkt and pkt.ndr64,
-                )
-            ],
-            LEIntField("actual_count", None),
-        ),
-        PacketField("value", None, conf.raw_layer),
-    ]
-
-
-class _NDRVarField(object):
-    def getfield(self, pkt, s):
-        fmt = ["<I", "<Q"][pkt.ndr64]
-        remain, offset = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).getfield(pkt, s)
-        remain, actual_count = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).getfield(
-            pkt, remain
-        )
-        remain, val = super(_NDRVarField, self).getfield(pkt, remain)
-        return remain, NDRVaryingArray(
-            ndr64=pkt.ndr64,
-            offset=offset,
-            actual_count=actual_count,
-            value=super(_NDRVarField, self).i2h(pkt, val),
-        )
-
-    def addfield(self, pkt, s, val):
-        if not isinstance(val, NDRVaryingArray):
-            raise ValueError(
-                "Expected NDRVaryingArray in %s. You are using it wrong!" % self.name
-            )
-        fmt = ["<I", "<Q"][pkt.ndr64]
-        _set_ndr_on(val.value, pkt.ndr64)
-        s = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).addfield(pkt, s, val.offset)
-        s = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).addfield(
-            pkt,
-            s,
-            val.actual_count is None and
-            super(_NDRVarField, self).i2len(pkt, val.value) or
-            val.actual_count,
-        )
-        return super(_NDRVarField, self).addfield(
-            pkt, s, super(_NDRVarField, self).h2i(pkt, val.value)
+    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
+    try:
+        # cryptography > 43.0
+        from cryptography.hazmat.decrepit.ciphers import (
+            algorithms as decrepit_algorithms,
         )
+    except ImportError:
+        decrepit_algorithms = algorithms
 
-    def i2len(self, pkt, x):
-        return super(_NDRVarField, self).i2len(pkt, x.value)
-
-    def any2i(self, pkt, x):
-        # User-friendly helper
-        if not isinstance(x, NDRVaryingArray):
-            return NDRVaryingArray(
-                value=super(_NDRVarField, self).any2i(pkt, x),
-            )
-        return x
-
-    # Can't use i2repr = Field.i2repr and so on on PY2 :/
-    def i2repr(self, pkt, val):
-        return repr(val)
-
-    def i2h(self, pkt, x):
-        return x
-
-    def h2i(self, pkt, x):
-        return x
-
-    def i2count(self, pkt, x):
-        return 1
+    algorithm = decrepit_algorithms.ARC4(key)
+    cipher = Cipher(algorithm, mode=None)
+    encryptor = cipher.encryptor()
+    return encryptor.update(data) + encryptor.finalize()
 
 
-class NDRConformantArray(_NDRPacket):
-    fields_desc = [
-        MultipleTypeField(
-            [(LELongField("max_count", None), lambda pkt: pkt and pkt.ndr64)],
-            LEIntField("max_count", None),
-        ),
-        PacketListField(
-            "value", [], conf.raw_layer, count_from=lambda pkt: pkt.max_count
-        ),
-    ]
+# sect 2.2.2.9 - With Extended Session Security
 
 
-class NDRConformantString(_NDRPacket):
+class NTLMSSP_MESSAGE_SIGNATURE(Packet):
+    # [MS-RPCE] sect 2.2.2.9.1/2.2.2.9.2
     fields_desc = [
-        MultipleTypeField(
-            [(LELongField("max_count", None), lambda pkt: pkt and pkt.ndr64)],
-            LEIntField("max_count", None),
-        ),
-        StrField("value", ""),
+        LEIntField("Version", 0x00000001),
+        XStrFixedLenField("Checksum", b"", length=8),
+        LEIntField("SeqNum", 0x00000000),
     ]
 
 
-class _NDRConfField(object):
-    CONFORMANT_STRING = False
-
-    def __init__(self, *args, **kwargs):
-        self.conformant_in_struct = kwargs.pop("conformant_in_struct", False)
-        super(_NDRConfField, self).__init__(*args, **kwargs)
-
-    def getfield(self, pkt, s):
-        # [C706] - 14.3.7 Structures Containing Arrays
-        fmt = ["<I", "<Q"][pkt.ndr64]
-        if self.conformant_in_struct:
-            return super(_NDRConfField, self).getfield(pkt, s)
-        remain, max_count = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).getfield(
-            pkt, s
-        )
-        remain, val = super(_NDRConfField, self).getfield(pkt, remain)
-        return remain, (
-            NDRConformantString if self.CONFORMANT_STRING else NDRConformantArray
-        )(ndr64=pkt.ndr64, max_count=max_count, value=val)
-
-    def addfield(self, pkt, s, val):
-        if self.conformant_in_struct:
-            return super(_NDRConfField, self).addfield(pkt, s, val)
-        if self.CONFORMANT_STRING and not isinstance(val, NDRConformantString):
-            raise ValueError(
-                "Expected NDRConformantString in %s. You are using it wrong!"
-                % self.name
-            )
-        elif not self.CONFORMANT_STRING and not isinstance(val, NDRConformantArray):
-            raise ValueError(
-                "Expected NDRConformantArray in %s. You are using it wrong!" % self.name
-            )
-        fmt = ["<I", "<Q"][pkt.ndr64]
-        _set_ndr_on(val.value, pkt.ndr64)
-        if isinstance(val.value[0], NDRVaryingArray):
-            value = val.value[0]
-        else:
-            value = val.value
-        s = NDRAlign(Field("", 0, fmt=fmt), align=(4, 8)).addfield(
-            pkt,
-            s,
-            val.max_count is None and
-            super(_NDRConfField, self).i2len(pkt, value) or
-            val.max_count,
-        )
-        return super(_NDRConfField, self).addfield(pkt, s, value)
-
-    def i2len(self, pkt, x):
-        if not self.CONFORMANT_STRING and isinstance(x.value[0], NDRVaryingArray):
-            value = x.value[0]
-        else:
-            value = x.value
-        return super(_NDRConfField, self).i2len(pkt, value)
-
-    def any2i(self, pkt, x):
-        # User-friendly helper
-        if self.conformant_in_struct:
-            return x
-        if self.CONFORMANT_STRING and not isinstance(x, NDRConformantString):
-            return NDRConformantString(
-                value=super(_NDRConfField, self).any2i(pkt, x),
-            )
-        elif not isinstance(x, NDRConformantArray):
-            return NDRConformantArray(
-                value=super(_NDRConfField, self).any2i(pkt, x),
-            )
-        return x
-
-    # Can't use i2repr = Field.i2repr and so on on PY2 :/
-    def i2repr(self, pkt, val):
-        return repr(val)
-
-    def i2h(self, pkt, x):
-        return x
-
-    def h2i(self, pkt, x):
-        return x
-
-    def i2count(self, pkt, x):
-        return 1
-
-
-class NDRVarPacketListField(_NDRVarField, _NDRPacketListField):
-    """
-    NDR Varying PacketListField
-    """
-
-    pass
-
-
-class NDRConfPacketListField(_NDRConfField, _NDRPacketListField):
-    """
-    NDR Conformant PacketListField
-    """
-
-    pass
-
-
-class NDRConfVarPacketListField(_NDRConfField, _NDRVarField, _NDRPacketListField):
-    """
-    NDR Conformant Varying PacketListField
-    """
-
-    pass
-
-
-class NDRConfFieldListField(_NDRConfField, NDRFieldListField):
-    """
-    NDR Conformant FieldListField
-    """
-
-    pass
-
-
-class NDRConfVarFieldListField(_NDRConfField, _NDRVarField, NDRFieldListField):
-    """
-    NDR Conformant Varying FieldListField
-    """
-
-    pass
-
-
-# NDR String fields
-
-
-class NDRConfStrLenField(_NDRConfField, StrLenField):
-    """
-    NDR Conformant StrLenField.
+_GSSAPI_OIDS["1.3.6.1.4.1.311.2.2.10"] = NTLM_Header
+_GSSAPI_SIGNATURE_OIDS["1.3.6.1.4.1.311.2.2.10"] = NTLMSSP_MESSAGE_SIGNATURE
 
-    This is not a "string" per NDR, but an a conformant byte array
-    (e.g. tower_octet_string)
-    """
 
-    CONFORMANT_STRING = True
+# sect 3.3.2
 
 
-class NDRConfStrLenFieldUtf16(_NDRConfField, StrLenFieldUtf16):
+def NTOWFv2(Passwd, User, UserDom, HashNt=None):
     """
-    NDR Conformant StrLenField.
+    Computes the ResponseKeyNT (per [MS-NLMP] sect 3.3.2)
 
-    See NDRConfLenStrField for comment.
+    :param Passwd: the plain password
+    :param User: the username
+    :param UserDom: the domain name
+    :param HashNt: (out of spec) if you have the HashNt, use this and set
+                   Passwd to None
     """
+    if HashNt is None:
+        HashNt = MD4le(Passwd)
+    return HMAC_MD5(HashNt, (User.upper() + UserDom).encode("utf-16le"))
 
-    CONFORMANT_STRING = True
-    ON_WIRE_SIZE_UTF16 = False
 
+def NTLMv2_ComputeSessionBaseKey(ResponseKeyNT, NTProofStr):
+    return HMAC_MD5(ResponseKeyNT, NTProofStr)
 
-class NDRVarStrLenField(_NDRVarField, StrLenField):
-    """
-    NDR Varying StrLenField
-    """
 
-    pass
+# sect 3.4.4.2 - With Extended Session Security
 
 
-class NDRVarStrLenFieldUtf16(_NDRVarField, StrLenFieldUtf16):
-    """
-    NDR Varying StrLenField
-    """
+def MAC(Handle, SigningKey, SeqNum, Message):
+    chksum = HMAC_MD5(SigningKey, struct.pack("<i", SeqNum) + Message)[:8]
+    if Handle:
+        chksum = RC4(Handle, chksum)
+    return NTLMSSP_MESSAGE_SIGNATURE(
+        Version=0x00000001,
+        Checksum=chksum,
+        SeqNum=SeqNum,
+    )
 
-    ON_WIRE_SIZE_UTF16 = False
 
+# sect 3.4.2
 
-class NDRConfVarStrLenField(_NDRConfField, _NDRVarField, StrLenField):
-    """
-    NDR Conformant Varying StrLenField
-    """
 
-    pass
+def SIGN(Handle, SigningKey, SeqNum, Message):
+    # append? where is this used?!
+    return Message + MAC(Handle, SigningKey, SeqNum, Message)
 
 
-class NDRConfVarStrLenFieldUtf16(_NDRConfField, _NDRVarField, StrLenFieldUtf16):
-    """
-    NDR Conformant Varying StrLenField
-    """
-
-    ON_WIRE_SIZE_UTF16 = False
+# sect 3.4.3
 
 
-class NDRConfVarStrNullField(_NDRConfField, _NDRVarField, StrNullField):
+def SEAL(Handle, SigningKey, SeqNum, Message):
     """
-    NDR Conformant Varying StrNullFieldUtf16
+    SEAL() according to [MS-NLMP]
     """
-
-    pass
+    # this is unused. Use GSS_WrapEx
+    sealed_message = RC4(Handle, Message)
+    signature = MAC(Handle, SigningKey, SeqNum, Message)
+    return sealed_message, signature
 
 
-class NDRConfVarStrNullFieldUtf16(_NDRConfField, _NDRVarField, StrNullFieldUtf16):
+def UNSEAL(Handle, SigningKey, SeqNum, Message):
     """
-    NDR Conformant Varying StrNullFieldUtf16
+    UNSEAL() according to [MS-NLMP]
     """
+    # this is unused. Use GSS_UnwrapEx
+    unsealed_message = RC4(Handle, Message)
+    signature = MAC(Handle, SigningKey, SeqNum, Message)
+    return unsealed_message, signature
 
-    ON_WIRE_SIZE_UTF16 = False
-
-
-# Union type
-
-
-class NDRUnion(_NDRPacket):
-    fields_desc = [
-        IntField("tag", 0),
-        PacketField("value", None, conf.raw_layer),
-    ]
 
+# sect 3.4.5.2
 
-class _NDRUnionField(MultipleTypeField):
-    __slots__ = ["switch_fmt", "align"]
 
-    def __init__(self, flds, dflt, align, switch_fmt):
-        self.switch_fmt = switch_fmt
-        self.align = align
-        super(_NDRUnionField, self).__init__(flds, dflt)
-
-    def getfield(self, pkt, s):
-        fmt = self.switch_fmt[pkt.ndr64]
-        remain, tag = NDRAlign(Field("", 0, fmt=fmt), align=self.align).getfield(pkt, s)
-        fld, _ = super(_NDRUnionField, self)._find_fld_pkt_val(pkt, NDRUnion(tag=tag))
-        remain, val = fld.getfield(pkt, remain)
-        return remain, NDRUnion(tag=tag, value=val, ndr64=pkt.ndr64, _parent=pkt)
-
-    def addfield(self, pkt, s, val):
-        fmt = self.switch_fmt[pkt.ndr64]
-        if not isinstance(val, NDRUnion):
-            raise ValueError(
-                "Expected NDRUnion in %s. You are using it wrong!" % self.name
-            )
-        _set_ndr_on(val.value, pkt.ndr64)
-        # First, align the whole tag+union against the align param
-        s = NDRAlign(Field("", 0, fmt=fmt), align=self.align).addfield(pkt, s, val.tag)
-        # Then, compute the subfield with its own alignment
-        return super(_NDRUnionField, self).addfield(pkt, s, val)
-
-    def _find_fld_pkt_val(self, pkt, val):
-        fld, val = super(_NDRUnionField, self)._find_fld_pkt_val(pkt, val)
-        return fld, val.value
-
-    # Can't use i2repr = Field.i2repr and so on on PY2 :/
-    def i2repr(self, pkt, val):
-        return repr(val)
+def SIGNKEY(NegFlg, ExportedSessionKey, Mode):
+    if NegFlg.NEGOTIATE_EXTENDED_SESSIONSECURITY:
+        if Mode == "Client":
+            return Hash_MD5().digest(
+                ExportedSessionKey
+                + b"session key to client-to-server signing key magic constant\x00"
+            )
+        elif Mode == "Server":
+            return Hash_MD5().digest(
+                ExportedSessionKey
+                + b"session key to server-to-client signing key magic constant\x00"
+            )
+        else:
+            raise ValueError("Unknown Mode")
+    else:
+        return None
 
-    def i2h(self, pkt, x):
-        return x
 
-    def h2i(self, pkt, x):
-        return x
+# sect 3.4.5.3
 
 
-class NDRUnionField(NDRConstructedType, _NDRUnionField):
-    def __init__(self, flds, dflt, align, switch_fmt):
-        _NDRUnionField.__init__(self, flds, dflt, align=align, switch_fmt=switch_fmt)
-        NDRConstructedType.__init__(self, [x[0] for x in flds] + [dflt])
-
-    def any2i(self, pkt, x):
-        # User-friendly helper
-        if x:
-            if not isinstance(x, NDRUnion):
-                raise ValueError("Invalid value for %s; should be NDRUnion" % self.name)
-            else:
-                x.value = _NDRUnionField.any2i(self, pkt, x)
-        return x
+def SEALKEY(NegFlg, ExportedSessionKey, Mode):
+    if NegFlg.NEGOTIATE_EXTENDED_SESSIONSECURITY:
+        if NegFlg.NEGOTIATE_128:
+            SealKey = ExportedSessionKey
+        elif NegFlg.NEGOTIATE_56:
+            SealKey = ExportedSessionKey[:7]
+        else:
+            SealKey = ExportedSessionKey[:5]
+        if Mode == "Client":
+            return Hash_MD5().digest(
+                SealKey
+                + b"session key to client-to-server sealing key magic constant\x00"
+            )
+        elif Mode == "Server":
+            return Hash_MD5().digest(
+                SealKey
+                + b"session key to server-to-client sealing key magic constant\x00"
+            )
+        else:
+            raise ValueError("Unknown Mode")
+    elif NegFlg.NEGOTIATE_LM_KEY:
+        if NegFlg.NEGOTIATE_56:
+            return ExportedSessionKey[:6] + b"\xA0"
+        else:
+            return ExportedSessionKey[:4] + b"\xe5\x38\xb0"
+    else:
+        return ExportedSessionKey
 
 
-# Misc
+# --- SSP
 
 
-class NDRRecursiveField(Field):
-    """
-    A special Field that is used for pointer recursion
+class NTLMSSP(SSP):
     """
+    The NTLM SSP
+
+    Common arguments:
+
+        :param auth_level: One of DCE_C_AUTHN_LEVEL
+        :param USE_MIC: whether to use a MIC or not (default: True)
+        :param NTLM_VALUES: a dictionary used to override the following values
+
+        In case of a client::
+
+            - NegotiateFlags
+            - ProductMajorVersion
+            - ProductMinorVersion
+            - ProductBuild
+
+        In case of a server::
+
+            - NetbiosDomainName
+            - NetbiosComputerName
+            - DnsComputerName
+            - DnsDomainName (defaults to DOMAIN)
+            - DnsTreeName (defaults to DOMAIN)
+            - Flags
+            - Timestamp
+
+    Client-only arguments:
+
+        :param UPN: the UPN to use for NTLM auth. If no domain is specified, will
+                    use the one provided by the server (domain in a domain, local
+                    if without domain)
+        :param HASHNT: the password to use for NTLM auth
+        :param PASSWORD: the password to use for NTLM auth
+
+    Server-only arguments:
+
+        :param DOMAIN_NB_NAME: the domain Netbios name (default: DOMAIN)
+        :param DOMAIN_FQDN: the domain FQDN (default: <domain_nb_name>.local)
+        :param COMPUTER_NB_NAME: the server Netbios name (default: SRV)
+        :param COMPUTER_FQDN: the server FQDN
+                              (default: <computer_nb_name>.<domain_fqdn>)
+        :param IDENTITIES: a dict {"username": <HashNT>}
+                        Setting this value enables signature computation and
+                        authenticates inbound users.
+    """
+
+    oid = "1.3.6.1.4.1.311.2.2.10"
+    auth_type = 0x0A
+
+    class STATE(SSP.STATE):
+        INIT = 1
+        CLI_SENT_NEGO = 2
+        CLI_SENT_AUTH = 3
+        SRV_SENT_CHAL = 4
+
+    class CONTEXT(SSP.CONTEXT):
+        __slots__ = [
+            "SessionKey",
+            "ExportedSessionKey",
+            "IsAcceptor",
+            "SendSignKey",
+            "SendSealKey",
+            "RecvSignKey",
+            "RecvSealKey",
+            "SendSealHandle",
+            "RecvSealHandle",
+            "SendSeqNum",
+            "RecvSeqNum",
+            "neg_tok",
+            "chall_tok",
+            "ServerHostname",
+        ]
 
-    def __init__(self, name, fmt="I"):
-        super(NDRRecursiveField, self).__init__(name, None, fmt=fmt)
-
-    def getfield(self, pkt, s):
-        fmt, sz = [("<I", 4), ("<Q", 8)][pkt.ndr64]
-        if s[:sz] == b"\0" * sz:
-            return s[sz:], None
-        referent_id = struct.unpack(fmt, s[:sz])[0]
-        remain, val = NDRPacketField("", None, pkt.__class__).getfield(pkt, s[sz:])
-        return remain, NDRPointer(ndr64=pkt.ndr64, referent_id=referent_id, value=val)
-
-    def addfield(self, pkt, s, val):
-        if val is None:
-            sz = [4, 8][pkt.ndr64]
-            return s + b"\0" * sz
-        return s + bytes(val)  # FIXME
-
-
-# The very few NDR-specific structures
-
-
-class NDRContextHandle(NDRPacket):
-    ALIGNMENT = (4, 4)
-    fields_desc = [
-        LEIntField("attributes", 0),
-        StrFixedLenField("uuid", b"", length=16),
-    ]
-
-    def guess_payload_class(self, payload):
-        return conf.padding_layer
-
-
-# --- Type Serialization Version 1 - [MSRPCE] sect 2.2.6
-
-
-class NDRSerialization1Header(Packet):
-    fields_desc = [
-        ByteField("Version", 1),
-        ByteEnumField("Endianness", 0, {0x00: "Big-endian", 0x10: "Little-endian"}),
-        LEShortField("CommonHeaderLength", 8),
-        XLEIntField("Filler", 0xCCCCCCCC),
-    ]
-
-
-class NDRSerialization1PrivateHeader(Packet):
-    fields_desc = [
-        LEIntField("ObjectBufferLength", 0),
-        LEIntField("Filler", 0),
-    ]
+        def __init__(self, IsAcceptor, req_flags=None):
+            self.state = NTLMSSP.STATE.INIT
+            self.SessionKey = None
+            self.ExportedSessionKey = None
+            self.SendSignKey = None
+            self.SendSealKey = None
+            self.SendSealHandle = None
+            self.RecvSignKey = None
+            self.RecvSealKey = None
+            self.RecvSealHandle = None
+            self.SendSeqNum = 0
+            self.RecvSeqNum = 0
+            self.neg_tok = None
+            self.chall_tok = None
+            self.ServerHostname = None
+            self.IsAcceptor = IsAcceptor
+            super(NTLMSSP.CONTEXT, self).__init__(req_flags=req_flags)
+
+        def __repr__(self):
+            return "NTLMSSP"
+
+    def __init__(
+        self,
+        UPN=None,
+        HASHNT=None,
+        PASSWORD=None,
+        USE_MIC=True,
+        NTLM_VALUES={},
+        DOMAIN_NB_NAME="DOMAIN",
+        DOMAIN_FQDN=None,
+        COMPUTER_NB_NAME="SRV",
+        COMPUTER_FQDN=None,
+        IDENTITIES=None,
+        DO_NOT_CHECK_LOGIN=False,
+        SERVER_CHALLENGE=None,
+        **kwargs,
+    ):
+        self.UPN = UPN
+        if HASHNT is None and PASSWORD is not None:
+            HASHNT = MD4le(PASSWORD)
+        self.HASHNT = HASHNT
+        self.USE_MIC = USE_MIC
+        self.NTLM_VALUES = NTLM_VALUES
+        self.DOMAIN_NB_NAME = DOMAIN_NB_NAME
+        self.DOMAIN_FQDN = DOMAIN_FQDN or (self.DOMAIN_NB_NAME.lower() + ".local")
+        self.COMPUTER_NB_NAME = COMPUTER_NB_NAME
+        self.COMPUTER_FQDN = COMPUTER_FQDN or (
+            self.COMPUTER_NB_NAME.lower() + "." + self.DOMAIN_FQDN
+        )
+        self.IDENTITIES = IDENTITIES
+        self.DO_NOT_CHECK_LOGIN = DO_NOT_CHECK_LOGIN
+        self.SERVER_CHALLENGE = SERVER_CHALLENGE
+        super(NTLMSSP, self).__init__(**kwargs)
+
+    def LegsAmount(self, Context: CONTEXT):
+        return 3
+
+    def GSS_GetMICEx(self, Context, msgs, qop_req=0):
+        """
+        [MS-NLMP] sect 3.4.8
+        """
+        # Concatenate the ToSign
+        ToSign = b"".join(x.data for x in msgs if x.sign)
+        sig = MAC(
+            Context.SendSealHandle,
+            Context.SendSignKey,
+            Context.SendSeqNum,
+            ToSign,
+        )
+        Context.SendSeqNum += 1
+        return sig
 
+    def GSS_VerifyMICEx(self, Context, msgs, signature):
+        """
+        [MS-NLMP] sect 3.4.9
+        """
+        Context.RecvSeqNum = signature.SeqNum
+        # Concatenate the ToSign
+        ToSign = b"".join(x.data for x in msgs if x.sign)
+        sig = MAC(
+            Context.RecvSealHandle,
+            Context.RecvSignKey,
+            Context.RecvSeqNum,
+            ToSign,
+        )
+        if sig.Checksum != signature.Checksum:
+            raise ValueError("ERROR: Checksums don't match")
 
-def ndr_deserialize1(b, cls, ndr64=False):
-    """
-    Deserialize Type Serialization Version 1 according to [MS-RPCE] sect 2.2.6
-    """
-    if issubclass(cls, NDRPacket):
+    def GSS_WrapEx(self, Context, msgs, qop_req=0):
+        """
+        [MS-NLMP] sect 3.4.6
+        """
+        msgs_cpy = copy.deepcopy(msgs)  # Keep copy for signature
+        # Encrypt
+        for msg in msgs:
+            if msg.conf_req_flag:
+                msg.data = RC4(Context.SendSealHandle, msg.data)
+        # Sign
+        sig = self.GSS_GetMICEx(Context, msgs_cpy, qop_req=qop_req)
         return (
-            NDRSerialization1Header(b[:8]) /
-            NDRSerialization1PrivateHeader(b[8:16]) /
-            NDRPointer(
-                ndr64=ndr64,
-                referent_id=struct.unpack("<I", b[16:20])[0],
-                value=cls(b[20:], ndr64=ndr64),
-            )
+            msgs,
+            sig,
         )
-    return NDRSerialization1Header(b[:8]) / cls(b[8:])
-
 
-def ndr_serialize1(pkt, ndr64=False):
-    """
-    Serialize Type Serialization Version 1
-    """
-    pkt = pkt.copy()
-    if not isinstance(pkt, NDRSerialization1Header):
-        if isinstance(pkt, NDRPacket):
-            if not isinstance(pkt, NDRPointer):
-                pkt = NDRPointer(ndr64=ndr64, referent_id=0x20000, value=pkt)
-            pkt = (
-                NDRSerialization1Header() /
-                NDRSerialization1PrivateHeader(
-                    ObjectBufferLength=len(pkt.value),
-                ) /
-                pkt
-            )
-        else:
-            return bytes(NDRSerialization1Header() / pkt)
-    pay = struct.pack("<I", pkt.referent_id) + bytes(pkt.value)
-    pkt[NDRPointer].underlayer.remove_payload()
-    return bytes(pkt) + pay
-
-
-# --- DCE/RPC session
-
-
-class DceRpcSession(DefaultSession):
-    """
-    A DCE/RPC session within a TCP socket.
-    """
-
-    def __init__(self, *args, **kwargs):
-        self.rpc_bind_interface = None
-        self.ndr64 = False
-        self.map_callid_opnum = {}
-        super(DceRpcSession, self).__init__(*args, **kwargs)
-
-    def _parse_with_opnum(self, pkt, opnum, opts):
-        # use opnum to parse the payload
-        is_response = DceRpc5Response in pkt
+    def GSS_UnwrapEx(self, Context, msgs, signature):
+        """
+        [MS-NLMP] sect 3.4.7
+        """
+        # Decrypt
+        for msg in msgs:
+            if msg.conf_req_flag:
+                msg.data = RC4(Context.RecvSealHandle, msg.data)
+        # Check signature
+        self.GSS_VerifyMICEx(Context, msgs, signature)
+        return msgs
+
+    def canMechListMIC(self, Context):
+        if not self.USE_MIC:
+            # RFC 4178
+            # "If the mechanism selected by the negotiation does not support integrity
+            # protection, then no mechlistMIC token is used."
+            return False
+        if not Context or not Context.SessionKey:
+            # Not available yet
+            return False
+        return True
+
+    def getMechListMIC(self, Context, input):
+        # [MS-SPNG]
+        # "When NTLM is negotiated, the SPNG server MUST set OriginalHandle to
+        # ServerHandle before generating the mechListMIC, then set ServerHandle to
+        # OriginalHandle after generating the mechListMIC."
+        OriginalHandle = Context.SendSealHandle
+        Context.SendSealHandle = RC4Init(Context.SendSealKey)
+        try:
+            return super(NTLMSSP, self).getMechListMIC(Context, input)
+        finally:
+            Context.SendSealHandle = OriginalHandle
+
+    def verifyMechListMIC(self, Context, otherMIC, input):
+        # [MS-SPNG]
+        # "the SPNEGO Extension server MUST set OriginalHandle to ClientHandle before
+        # validating the mechListMIC and then set ClientHandle to OriginalHandle after
+        # validating the mechListMIC."
+        OriginalHandle = Context.RecvSealHandle
+        Context.RecvSealHandle = RC4Init(Context.RecvSealKey)
         try:
-            cls = self.rpc_bind_interface.opnums[opnum][is_response]
-        except KeyError:
-            log_runtime.warning(
-                "Unknown opnum %s for interface %s"
-                % (opnum, self.rpc_bind_interface)
+            return super(NTLMSSP, self).verifyMechListMIC(Context, otherMIC, input)
+        finally:
+            Context.RecvSealHandle = OriginalHandle
+
+    def GSS_Init_sec_context(
+        self, Context: CONTEXT, val=None, req_flags: Optional[GSS_C_FLAGS] = None
+    ):
+        if Context is None:
+            Context = self.CONTEXT(False, req_flags=req_flags)
+
+        if Context.state == self.STATE.INIT:
+            # Client: negotiate
+            # Create a default token
+            tok = NTLM_NEGOTIATE(
+                NegotiateFlags="+".join(
+                    [
+                        "NEGOTIATE_UNICODE",
+                        "REQUEST_TARGET",
+                        "NEGOTIATE_NTLM",
+                        "NEGOTIATE_ALWAYS_SIGN",
+                        "TARGET_TYPE_DOMAIN",
+                        "NEGOTIATE_EXTENDED_SESSIONSECURITY",
+                        "NEGOTIATE_TARGET_INFO",
+                        "NEGOTIATE_VERSION",
+                        "NEGOTIATE_128",
+                        "NEGOTIATE_56",
+                    ]
+                    + (
+                        [
+                            "NEGOTIATE_KEY_EXCH",
+                        ]
+                        if Context.flags
+                        & (GSS_C_FLAGS.GSS_C_INTEG_FLAG | GSS_C_FLAGS.GSS_C_CONF_FLAG)
+                        else []
+                    )
+                    + (
+                        [
+                            "NEGOTIATE_SIGN",
+                        ]
+                        if Context.flags & GSS_C_FLAGS.GSS_C_INTEG_FLAG
+                        else []
+                    )
+                    + (
+                        [
+                            "NEGOTIATE_SEAL",
+                        ]
+                        if Context.flags & GSS_C_FLAGS.GSS_C_CONF_FLAG
+                        else []
+                    )
+                ),
+                ProductMajorVersion=10,
+                ProductMinorVersion=0,
+                ProductBuild=19041,
+            )
+            if self.NTLM_VALUES:
+                # Update that token with the customs one
+                for key in [
+                    "NegotiateFlags",
+                    "ProductMajorVersion",
+                    "ProductMinorVersion",
+                    "ProductBuild",
+                ]:
+                    if key in self.NTLM_VALUES:
+                        setattr(tok, key, self.NTLM_VALUES[key])
+            Context.neg_tok = tok
+            Context.SessionKey = None  # Reset signing (if previous auth failed)
+            Context.state = self.STATE.CLI_SENT_NEGO
+            return Context, tok, GSS_S_CONTINUE_NEEDED
+        elif Context.state == self.STATE.CLI_SENT_NEGO:
+            # Client: auth (val=challenge)
+            chall_tok = val
+            if self.UPN is None or self.HASHNT is None:
+                raise ValueError(
+                    "Must provide a 'UPN' and a 'HASHNT' or 'PASSWORD' when "
+                    "running in standalone !"
+                )
+            if not chall_tok or NTLM_CHALLENGE not in chall_tok:
+                chall_tok.show()
+                raise ValueError("NTLMSSP: Unexpected token. Expected NTLM Challenge")
+            # Take a default token
+            tok = NTLM_AUTHENTICATE_V2(
+                NegotiateFlags=chall_tok.NegotiateFlags,
+                ProductMajorVersion=10,
+                ProductMinorVersion=0,
+                ProductBuild=19041,
             )
-            return
-        # Dissect payload using class
-        payload = cls(bytes(pkt[conf.raw_layer]), ndr64=self.ndr64, **opts)
-        pkt[conf.raw_layer].underlayer.remove_payload()
-        return pkt / payload
-
-    def _process_dcerpc_packet(self, pkt):
-        opnum = None
-        opts = {}
-        if DceRpc5Bind in pkt:
-            # bind => get which RPC interface
-            for ctx in pkt.context_elem:
-                if_uuid = ctx.abstract_syntax.if_uuid
+            tok.LmChallengeResponse = LMv2_RESPONSE()
+            from scapy.layers.kerberos import _parse_upn
+
+            try:
+                tok.UserName, realm = _parse_upn(self.UPN)
+            except ValueError:
+                tok.UserName, realm = self.UPN, None
+            if realm is None:
                 try:
-                    self.rpc_bind_interface = DCE_RPC_INTERFACES[if_uuid]
-                except KeyError:
+                    tok.DomainName = chall_tok.getAv(0x0002).Value
+                except IndexError:
                     log_runtime.warning(
-                        "Unknown RPC interface %s. Try loading the IDL" % if_uuid
+                        "No realm specified in UPN, nor provided by server"
                     )
-        elif DceRpc5BindAck in pkt:
-            # bind ack => is it NDR64
-            for res in pkt[DceRpc5BindAck].results:
-                if res.result == 0:  # Accepted
-                    if res.transfer_syntax.sprintf("%if_uuid%") == "NDR64":
-                        self.ndr64 = True
-        elif DceRpc5Request in pkt:
-            # request => match opnum with callID
-            opnum = pkt.opnum
-            self.map_callid_opnum[pkt.call_id] = opnum, pkt[DceRpc5Request].payload
-        elif DceRpc5Response in pkt:
-            # response => get opnum from table
+                    tok.DomainName = self.DOMAIN_NB_NAME.encode()
+            else:
+                tok.DomainName = realm
             try:
-                opnum, opts["request_packet"] = self.map_callid_opnum[pkt.call_id]
-                del self.map_callid_opnum[pkt.call_id]
-            except KeyError:
-                log_runtime.info("Unknown call_id %s in DCE/RPC session" % pkt.call_id)
-        # Check for encrypted payloads
-        if pkt.auth_verifier and pkt.auth_verifier.is_encrypted():
-            return pkt
-        # Try to parse the payload
-        if opnum is not None and self.rpc_bind_interface and conf.raw_layer in pkt:
-            # use opnum to parse the payload
-            pkt = self._parse_with_opnum(pkt, opnum, opts)
-        return pkt
-
-    def on_packet_received(self, pkt):
-        if DceRpc5 in pkt:
-            return super(DceRpcSession, self).on_packet_received(
-                self._process_dcerpc_packet(pkt)
-            )
-        return super(DceRpcSession, self).on_packet_received(pkt)
-
-
-# --- TODO cleanup below
-
-# Heuristically way to find the payload class
-#
-# To add a possible payload to a DCE/RPC packet, one must first create the
-# packet class, then instead of binding layers using bind_layers, he must
-# call DceRpcPayload.register_possible_payload() with the payload class as
-# parameter.
-#
-# To be able to decide if the payload class is capable of handling the rest of
-# the dissection, the classmethod can_handle() should be implemented in the
-# payload class. This method is given the rest of the string to dissect as
-# first argument, and the DceRpc packet instance as second argument. Based on
-# this information, the method must return True if the class is capable of
-# handling the dissection, False otherwise
-
-
-class DceRpc4Payload(Packet):
-    """Dummy class which use the dispatch_hook to find the payload class"""
-
-    _payload_class = []
+                tok.Workstation = Context.ServerHostname = chall_tok.getAv(
+                    0x0001
+                ).Value  # noqa: E501
+            except IndexError:
+                tok.Workstation = "WIN"
+            cr = tok.NtChallengeResponse = NTLMv2_RESPONSE(
+                ChallengeFromClient=os.urandom(8),
+            )
+            try:
+                # the server SHOULD set the timestamp in the CHALLENGE_MESSAGE
+                cr.TimeStamp = chall_tok.getAv(0x0007).Value
+            except IndexError:
+                cr.TimeStamp = int((time.time() + 11644473600) * 1e7)
+            cr.AvPairs = (
+                chall_tok.TargetInfo[:-1]
+                + (
+                    [
+                        AV_PAIR(AvId="MsvAvFlags", Value="MIC integrity"),
+                    ]
+                    if self.USE_MIC
+                    else []
+                )
+                + [
+                    AV_PAIR(
+                        AvId="MsvAvSingleHost",
+                        Value=Single_Host_Data(MachineID=os.urandom(32)),
+                    ),
+                    AV_PAIR(AvId="MsvAvChannelBindings", Value=b"\x00" * 16),
+                    AV_PAIR(AvId="MsvAvTargetName", Value="host/" + tok.Workstation),
+                    AV_PAIR(AvId="MsvAvEOL"),
+                ]
+            )
+            if self.NTLM_VALUES:
+                # Update that token with the customs one
+                for key in [
+                    "NegotiateFlags",
+                    "ProductMajorVersion",
+                    "ProductMinorVersion",
+                    "ProductBuild",
+                ]:
+                    if key in self.NTLM_VALUES:
+                        setattr(tok, key, self.NTLM_VALUES[key])
+            # Compute the ResponseKeyNT
+            ResponseKeyNT = NTOWFv2(
+                None,
+                tok.UserName,
+                tok.DomainName,
+                HashNt=self.HASHNT,
+            )
+            # Compute the NTProofStr
+            cr.NTProofStr = cr.computeNTProofStr(
+                ResponseKeyNT,
+                chall_tok.ServerChallenge,
+            )
+            # Compute the Session Key
+            SessionBaseKey = NTLMv2_ComputeSessionBaseKey(ResponseKeyNT, cr.NTProofStr)
+            KeyExchangeKey = SessionBaseKey  # Only true for NTLMv2
+            if chall_tok.NegotiateFlags.NEGOTIATE_KEY_EXCH:
+                ExportedSessionKey = os.urandom(16)
+                tok.EncryptedRandomSessionKey = RC4K(
+                    KeyExchangeKey,
+                    ExportedSessionKey,
+                )
+            else:
+                ExportedSessionKey = KeyExchangeKey
+            if self.USE_MIC:
+                tok.compute_mic(ExportedSessionKey, Context.neg_tok, chall_tok)
+            Context.ExportedSessionKey = ExportedSessionKey
+            # [MS-SMB] 3.2.5.3
+            Context.SessionKey = Context.ExportedSessionKey
+            # Compute NTLM keys
+            Context.SendSignKey = SIGNKEY(
+                tok.NegotiateFlags, ExportedSessionKey, "Client"
+            )
+            Context.SendSealKey = SEALKEY(
+                tok.NegotiateFlags, ExportedSessionKey, "Client"
+            )
+            Context.SendSealHandle = RC4Init(Context.SendSealKey)
+            Context.RecvSignKey = SIGNKEY(
+                tok.NegotiateFlags, ExportedSessionKey, "Server"
+            )
+            Context.RecvSealKey = SEALKEY(
+                tok.NegotiateFlags, ExportedSessionKey, "Server"
+            )
+            Context.RecvSealHandle = RC4Init(Context.RecvSealKey)
+            Context.state = self.STATE.CLI_SENT_AUTH
+            return Context, tok, GSS_S_COMPLETE
+        elif Context.state == self.STATE.CLI_SENT_AUTH:
+            if val:
+                # what is that?
+                status = GSS_S_DEFECTIVE_CREDENTIAL
+            else:
+                status = GSS_S_COMPLETE
+            return Context, None, status
+        else:
+            raise ValueError("NTLMSSP: unexpected state %s" % repr(Context.state))
 
-    @classmethod
-    def dispatch_hook(cls, _pkt, _underlayer=None, *args, **kargs):
-        """dispatch_hook to choose among different registered payloads"""
-        for klass in cls._payload_class:
-            if hasattr(klass, "can_handle") and klass.can_handle(_pkt, _underlayer):
-                return klass
-        print("DCE/RPC payload class not found or undefined (using Raw)")
-        return Raw
+    def GSS_Accept_sec_context(self, Context: CONTEXT, val=None):
+        if Context is None:
+            Context = self.CONTEXT(IsAcceptor=True, req_flags=0)
+
+        if Context.state == self.STATE.INIT:
+            # Server: challenge (val=negotiate)
+            nego_tok = val
+            if not nego_tok or NTLM_NEGOTIATE not in nego_tok:
+                nego_tok.show()
+                raise ValueError("NTLMSSP: Unexpected token. Expected NTLM Negotiate")
+            # Take a default token
+            currentTime = (time.time() + 11644473600) * 1e7
+            tok = NTLM_CHALLENGE(
+                ServerChallenge=self.SERVER_CHALLENGE or os.urandom(8),
+                NegotiateFlags="+".join(
+                    [
+                        "NEGOTIATE_UNICODE",
+                        "REQUEST_TARGET",
+                        "NEGOTIATE_NTLM",
+                        "NEGOTIATE_ALWAYS_SIGN",
+                        "NEGOTIATE_EXTENDED_SESSIONSECURITY",
+                        "NEGOTIATE_TARGET_INFO",
+                        "TARGET_TYPE_DOMAIN",
+                        "NEGOTIATE_VERSION",
+                        "NEGOTIATE_128",
+                        "NEGOTIATE_KEY_EXCH",
+                        "NEGOTIATE_56",
+                    ]
+                    + (
+                        ["NEGOTIATE_SIGN"]
+                        if nego_tok.NegotiateFlags.NEGOTIATE_SIGN
+                        else []
+                    )
+                    + (
+                        ["NEGOTIATE_SEAL"]
+                        if nego_tok.NegotiateFlags.NEGOTIATE_SEAL
+                        else []
+                    )
+                ),
+                ProductMajorVersion=10,
+                ProductMinorVersion=0,
+                Payload=[
+                    ("TargetName", ""),
+                    (
+                        "TargetInfo",
+                        [
+                            # MsvAvNbComputerName
+                            AV_PAIR(AvId=1, Value=self.COMPUTER_NB_NAME),
+                            # MsvAvNbDomainName
+                            AV_PAIR(AvId=2, Value=self.DOMAIN_NB_NAME),
+                            # MsvAvDnsComputerName
+                            AV_PAIR(AvId=3, Value=self.COMPUTER_FQDN),
+                            # MsvAvDnsDomainName
+                            AV_PAIR(AvId=4, Value=self.DOMAIN_FQDN),
+                            # MsvAvDnsTreeName
+                            AV_PAIR(AvId=5, Value=self.DOMAIN_FQDN),
+                            # MsvAvTimestamp
+                            AV_PAIR(AvId=7, Value=currentTime),
+                            # MsvAvEOL
+                            AV_PAIR(AvId=0),
+                        ],
+                    ),
+                ],
+            )
+            if self.NTLM_VALUES:
+                # Update that token with the customs one
+                for key in [
+                    "ServerChallenge",
+                    "NegotiateFlags",
+                    "ProductMajorVersion",
+                    "ProductMinorVersion",
+                    "TargetName",
+                ]:
+                    if key in self.NTLM_VALUES:
+                        setattr(tok, key, self.NTLM_VALUES[key])
+                avpairs = {x.AvId: x.Value for x in tok.TargetInfo}
+                tok.TargetInfo = [
+                    AV_PAIR(AvId=i, Value=self.NTLM_VALUES.get(x, avpairs[i]))
+                    for (i, x) in [
+                        (2, "NetbiosDomainName"),
+                        (1, "NetbiosComputerName"),
+                        (4, "DnsDomainName"),
+                        (3, "DnsComputerName"),
+                        (5, "DnsTreeName"),
+                        (6, "Flags"),
+                        (7, "Timestamp"),
+                        (0, None),
+                    ]
+                    if ((x in self.NTLM_VALUES) or (i in avpairs))
+                    and self.NTLM_VALUES.get(x, True) is not None
+                ]
+            Context.chall_tok = tok
+            Context.state = self.STATE.SRV_SENT_CHAL
+            return Context, tok, GSS_S_CONTINUE_NEEDED
+        elif Context.state == self.STATE.SRV_SENT_CHAL:
+            # server: OK or challenge again (val=auth)
+            auth_tok = val
+            if not auth_tok or NTLM_AUTHENTICATE_V2 not in auth_tok:
+                auth_tok.show()
+                raise ValueError(
+                    "NTLMSSP: Unexpected token. Expected NTLM Authenticate v2"
+                )
+            if self.DO_NOT_CHECK_LOGIN:
+                # Just trust me bro
+                return Context, None, GSS_S_COMPLETE
+            SessionBaseKey = self._getSessionBaseKey(Context, auth_tok)
+            if SessionBaseKey:
+                # [MS-NLMP] sect 3.2.5.1.2
+                KeyExchangeKey = SessionBaseKey  # Only true for NTLMv2
+                if auth_tok.NegotiateFlags.NEGOTIATE_KEY_EXCH:
+                    ExportedSessionKey = RC4K(
+                        KeyExchangeKey, auth_tok.EncryptedRandomSessionKey
+                    )
+                else:
+                    ExportedSessionKey = KeyExchangeKey
+                Context.ExportedSessionKey = ExportedSessionKey
+                # [MS-SMB] 3.2.5.3
+                Context.SessionKey = Context.ExportedSessionKey
+            # Check the NTProofStr
+            if Context.SessionKey:
+                # Compute NTLM keys
+                Context.SendSignKey = SIGNKEY(
+                    auth_tok.NegotiateFlags, ExportedSessionKey, "Server"
+                )
+                Context.SendSealKey = SEALKEY(
+                    auth_tok.NegotiateFlags, ExportedSessionKey, "Server"
+                )
+                Context.SendSealHandle = RC4Init(Context.SendSealKey)
+                Context.RecvSignKey = SIGNKEY(
+                    auth_tok.NegotiateFlags, ExportedSessionKey, "Client"
+                )
+                Context.RecvSealKey = SEALKEY(
+                    auth_tok.NegotiateFlags, ExportedSessionKey, "Client"
+                )
+                Context.RecvSealHandle = RC4Init(Context.RecvSealKey)
+                if self._checkLogin(Context, auth_tok):
+                    # Set negotiated flags
+                    if auth_tok.NegotiateFlags.NEGOTIATE_SIGN:
+                        Context.flags |= GSS_C_FLAGS.GSS_C_INTEG_FLAG
+                    if auth_tok.NegotiateFlags.NEGOTIATE_SEAL:
+                        Context.flags |= GSS_C_FLAGS.GSS_C_CONF_FLAG
+                    return Context, None, GSS_S_COMPLETE
+            # Bad NTProofStr or unknown user
+            Context.SessionKey = None
+            Context.state = self.STATE.INIT
+            return Context, None, GSS_S_DEFECTIVE_CREDENTIAL
+        else:
+            raise ValueError("NTLMSSP: unexpected state %s" % repr(Context.state))
 
-    @classmethod
-    def register_possible_payload(cls, pay):
-        """Method to call from possible DCE/RPC endpoint to register it as
-        possible payload"""
-        cls._payload_class.append(pay)
+    def MaximumSignatureLength(self, Context: CONTEXT):
+        """
+        Returns the Maximum Signature length.
+
+        This will be used in auth_len in DceRpc5, and is necessary for
+        PFC_SUPPORT_HEADER_SIGN to work properly.
+        """
+        return 16  # len(NTLMSSP_MESSAGE_SIGNATURE())
+
+    def GSS_Passive(self, Context: CONTEXT, val=None):
+        if Context is None:
+            Context = self.CONTEXT(True)
+            Context.passive = True
+
+        # We capture the Negotiate, Challenge, then call the server's auth handling
+        # and discard the output.
+
+        if Context.state == self.STATE.INIT:
+            if not val or NTLM_NEGOTIATE not in val:
+                log_runtime.warning("NTLMSSP: Expected NTLM Negotiate")
+                return None, GSS_S_DEFECTIVE_TOKEN
+            Context.neg_tok = val
+            Context.state = self.STATE.CLI_SENT_NEGO
+            return Context, GSS_S_CONTINUE_NEEDED
+        elif Context.state == self.STATE.CLI_SENT_NEGO:
+            if not val or NTLM_CHALLENGE not in val:
+                log_runtime.warning("NTLMSSP: Expected NTLM Challenge")
+                return None, GSS_S_DEFECTIVE_TOKEN
+            Context.chall_tok = val
+            Context.state = self.STATE.SRV_SENT_CHAL
+            return Context, GSS_S_CONTINUE_NEEDED
+        elif Context.state == self.STATE.SRV_SENT_CHAL:
+            if not val or NTLM_AUTHENTICATE_V2 not in val:
+                log_runtime.warning("NTLMSSP: Expected NTLM Authenticate")
+                return None, GSS_S_DEFECTIVE_TOKEN
+            Context, _, status = self.GSS_Accept_sec_context(Context, val)
+            if status != GSS_S_COMPLETE:
+                log_runtime.info("NTLMSSP: auth failed.")
+            Context.state = self.STATE.INIT
+            return Context, status
+        else:
+            raise ValueError("NTLMSSP: unexpected state %s" % repr(Context.state))
 
+    def GSS_Passive_set_Direction(self, Context: CONTEXT, IsAcceptor=False):
+        if Context.IsAcceptor is not IsAcceptor:
+            return
+        # Swap everything
+        Context.SendSignKey, Context.RecvSignKey = (
+            Context.RecvSignKey,
+            Context.SendSignKey,
+        )
+        Context.SendSealKey, Context.RecvSealKey = (
+            Context.RecvSealKey,
+            Context.SendSealKey,
+        )
+        Context.SendSealHandle, Context.RecvSealHandle = (
+            Context.RecvSealHandle,
+            Context.SendSealHandle,
+        )
+        Context.SendSeqNum, Context.RecvSeqNum = Context.RecvSeqNum, Context.SendSeqNum
+        Context.IsAcceptor = not Context.IsAcceptor
 
-bind_layers(DceRpc4, DceRpc4Payload)
+    def _getSessionBaseKey(self, Context, auth_tok):
+        """
+        Function that returns the SessionBaseKey from the ntlm Authenticate.
+        """
+        if auth_tok.UserNameLen:
+            username = auth_tok.UserName
+        else:
+            username = None
+        if auth_tok.DomainNameLen:
+            domain = auth_tok.DomainName
+        else:
+            domain = self.DOMAIN_NB_NAME
+        if self.IDENTITIES and username in self.IDENTITIES:
+            ResponseKeyNT = NTOWFv2(
+                None, username, domain, HashNt=self.IDENTITIES[username]
+            )
+            return NTLMv2_ComputeSessionBaseKey(
+                ResponseKeyNT, auth_tok.NtChallengeResponse.NTProofStr
+            )
+        return None
+
+    def _checkLogin(self, Context, auth_tok):
+        """
+        Function that checks the validity of an authentication.
+
+        Overwrite and return True to bypass.
+        """
+        # Create the NTLM AUTH
+        if auth_tok.UserNameLen:
+            username = auth_tok.UserName
+        else:
+            username = None
+        if auth_tok.DomainNameLen:
+            domain = auth_tok.DomainName
+        else:
+            domain = self.DOMAIN_NB_NAME
+        if username in self.IDENTITIES:
+            ResponseKeyNT = NTOWFv2(
+                None, username, domain, HashNt=self.IDENTITIES[username]
+            )
+            NTProofStr = auth_tok.NtChallengeResponse.computeNTProofStr(
+                ResponseKeyNT,
+                Context.chall_tok.ServerChallenge,
+            )
+            if NTProofStr == auth_tok.NtChallengeResponse.NTProofStr:
+                return True
+        return False
```

### Comparing `scapy-2.5.0rc3/scapy/layers/dhcp.py` & `scapy-2.6.0rc1/scapy/layers/dhcp.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,16 +8,14 @@
 
 Implements:
 - rfc951 - BOOTSTRAP PROTOCOL (BOOTP)
 - rfc1542 - Clarifications and Extensions for the Bootstrap Protocol
 - rfc1533 - DHCP Options and BOOTP Vendor Extensions
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 try:
     from collections.abc import Iterable
 except ImportError:
     # For backwards compatibility.  This was removed in Python 3.8
     from collections import Iterable
 import random
 import struct
@@ -53,17 +51,16 @@
     RandIP,
     RandInt,
     RandNum,
     RandNumExpo,
 )
 
 from scapy.arch import get_if_raw_hwaddr
-from scapy.sendrecv import srp1, sendp
+from scapy.sendrecv import srp1
 from scapy.error import warning
-import scapy.libs.six as six
 from scapy.config import conf
 
 dhcpmagic = b"c\x82Sc"
 
 
 class _BOOTP_chaddr(StrFixedLenField):
     def i2repr(self, pkt, v):
@@ -186,23 +183,15 @@
             return b''
         octets = (prefix + 7) // 8
         dest = socket.inet_aton(spx[0])[:octets]
         router = socket.inet_aton(spx[2])
         return struct.pack('b', prefix) + dest + router
 
     def getfield(self, pkt, s):
-        if not s:
-            return None
-
         prefix = orb(s[0])
-        # if prefix is invalid value ( 0 > prefix > 32 ) then break
-        if prefix > 32 or prefix < 0:
-            warning("Invalid prefix value: %d (0x%x)", prefix, prefix)
-            return s, []
-
         route_len = 5 + (prefix + 7) // 8
         return s[route_len:], self.m2i(pkt, s[:route_len])
 
     def addfield(self, pkt, s, val):
         return s + self.i2m(pkt, val)
 
     def randval(self):
@@ -310,14 +299,15 @@
     73: IPField("Finger_server", "0.0.0.0"),
     74: IPField("IRC_server", "0.0.0.0"),
     75: IPField("StreetTalk_server", "0.0.0.0"),
     76: IPField("StreetTalk_Dir_Assistance", "0.0.0.0"),
     77: "user_class",
     78: "slp_service_agent",
     79: "slp_service_scope",
+    80: "rapid_commit",
     81: "client_FQDN",
     82: "relay_agent_information",
     85: IPField("nds-server", "0.0.0.0"),
     86: StrField("nds-tree-name", ""),
     87: StrField("nds-context", ""),
     88: "bcms-controller-namesi",
     89: IPField("bcms-controller-address", "0.0.0.0"),
@@ -325,17 +315,18 @@
     92: IPField("associated-ip", "0.0.0.0"),
     93: "pxe_client_architecture",
     94: "pxe_client_network_interface",
     97: "pxe_client_machine_identifier",
     98: StrField("uap-servers", ""),
     100: StrField("pcode", ""),
     101: StrField("tcode", ""),
+    108: IntField("ipv6-only-preferred", 0),
     112: IPField("netinfo-server-address", "0.0.0.0"),
     113: StrField("netinfo-server-tag", ""),
-    114: StrField("default-url", ""),
+    114: StrField("captive-portal", ""),
     116: ByteField("auto-config", 0),
     117: ShortField("name-service-search", 0,),
     118: IPField("subnet-selection", "0.0.0.0"),
     121: ClasslessFieldListField(
         "classless_static_routes",
         [],
         ClasslessStaticRoutesField("route", 0)),
@@ -358,15 +349,15 @@
     212: "option-6rd",
     213: "v4-access-domain",
     255: "end"
 }
 
 DHCPRevOptions = {}
 
-for k, v in six.iteritems(DHCPOptions):
+for k, v in DHCPOptions.items():
     if isinstance(v, str):
         n = v
         v = None
     else:
         n = v.name
     DHCPRevOptions[n] = (k, v)
 del n
@@ -378,15 +369,15 @@
     def __init__(self, size=None, rndstr=None):
         if size is None:
             size = RandNumExpo(0.05)
         self.size = size
         if rndstr is None:
             rndstr = RandBin(RandNum(0, 255))
         self.rndstr = rndstr
-        self._opts = list(six.itervalues(DHCPOptions))
+        self._opts = list(DHCPOptions.values())
         self._opts.remove("pad")
         self._opts.remove("end")
 
     def _fix(self):
         op = []
         for k in range(self.size):
             o = random.choice(self._opts)
@@ -447,14 +438,24 @@
                 if isinstance(f, str):
                     olen = orb(x[1])
                     opt.append((f, x[2:olen + 2]))
                     x = x[olen + 2:]
                 else:
                     olen = orb(x[1])
                     lval = [f.name]
+
+                    if olen == 0:
+                        try:
+                            _, val = f.getfield(pkt, b'')
+                        except Exception:
+                            opt.append(x)
+                            break
+                        else:
+                            lval.append(val)
+
                     try:
                         left = x[2:olen + 2]
                         while left:
                             left, val = f.getfield(pkt, left)
                             lval.append(val)
                     except Exception:
                         opt.append(x)
@@ -582,51 +583,58 @@
         iface=iface, **kargs
     )
 
 
 class BOOTP_am(AnsweringMachine):
     function_name = "bootpd"
     filter = "udp and port 68 and port 67"
-    send_function = staticmethod(sendp)
 
     def parse_options(self,
                       pool=Net("192.168.1.128/25"),
                       network="192.168.1.0/24",
                       gw="192.168.1.1",
                       nameserver=None,
-                      domain="localnet",
+                      domain=None,
                       renewal_time=60,
-                      lease_time=1800):
+                      lease_time=1800,
+                      **kwargs):
         """
         :param pool: the range of addresses to distribute. Can be a Net,
                      a list of IPs or a string (always gives the same IP).
         :param network: the subnet range
         :param gw: the gateway IP (can be None)
         :param nameserver: the DNS server IP (by default, same than gw)
         :param domain: the domain to advertise (can be None)
+
+        Other DHCP parameters can be passed as kwargs. See DHCPOptions in dhcp.py.
+        For instance::
+
+            dhcpd(pool=Net("10.0.10.0/24"), network="10.0.0.0/8", gw="10.0.10.1",
+                  classless_static_routes=["1.2.3.4/32:9.8.7.6"])
         """
         self.domain = domain
         netw, msk = (network.split("/") + ["32"])[:2]
         msk = itom(int(msk))
         self.netmask = ltoa(msk)
         self.network = ltoa(atol(netw) & msk)
         self.broadcast = ltoa(atol(self.network) | (0xffffffff & ~msk))
         self.gw = gw
         self.nameserver = nameserver or gw
-        if isinstance(pool, six.string_types):
+        if isinstance(pool, str):
             pool = Net(pool)
         if isinstance(pool, Iterable):
             pool = [k for k in pool if k not in [gw, self.network, self.broadcast]]
             pool.reverse()
         if len(pool) == 1:
             pool, = pool
         self.pool = pool
         self.lease_time = lease_time
         self.renewal_time = renewal_time
         self.leases = {}
+        self.kwargs = kwargs
 
     def is_request(self, req):
         if not req.haslayer(BOOTP):
             return 0
         reqb = req.getlayer(BOOTP)
         if reqb.op != 1:
             return 0
@@ -675,10 +683,12 @@
                     ("broadcast_address", self.broadcast),
                     ("subnet_mask", self.netmask),
                     ("renewal_time", self.renewal_time),
                     ("lease_time", self.lease_time),
                 ]
                 if x[1] is not None
             ]
+            if self.kwargs:
+                dhcp_options += self.kwargs.items()
             dhcp_options.append("end")
             resp /= DHCP(options=dhcp_options)
         return resp
```

### Comparing `scapy-2.5.0rc3/scapy/layers/dhcp6.py` & `scapy-2.6.0rc1/scapy/layers/dhcp6.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,14 @@
 # Copyright (C) 2005  Guillaume Valadon <guedou@hongo.wide.ad.jp>
 #                     Arnaud Ebalard <arnaud.ebalard@eads.net>
 
 """
 DHCPv6: Dynamic Host Configuration Protocol for IPv6. [RFC 3315,8415]
 """
 
-from __future__ import print_function
 import socket
 import struct
 import time
 
 from scapy.ansmachine import AnsweringMachine
 from scapy.arch import get_if_raw_hwaddr, in6_getifaddr
 from scapy.config import conf
@@ -29,17 +28,17 @@
 from scapy.data import IANA_ENTERPRISE_NUMBERS
 from scapy.layers.dns import DNSStrField
 from scapy.layers.inet import UDP
 from scapy.layers.inet6 import DomainNameListField, IP6Field, IP6ListField, \
     IPv6
 from scapy.packet import Packet, bind_bottom_up
 from scapy.pton_ntop import inet_pton
+from scapy.sendrecv import send
 from scapy.themes import Color
 from scapy.utils6 import in6_addrtovendor, in6_islladdr
-import scapy.libs.six as six
 
 #############################################################################
 # Helpers                                                                  ##
 #############################################################################
 
 
 def get_cls(name, fallback_cls):
@@ -114,22 +113,24 @@
              37: "OPTION_REMOTE_ID",  # RFC4649
              38: "OPTION_SUBSCRIBER_ID",  # RFC4580
              39: "OPTION_CLIENT_FQDN",  # RFC4704
              40: "OPTION_PANA_AGENT",  # RFC5192
              41: "OPTION_NEW_POSIX_TIMEZONE",  # RFC4833
              42: "OPTION_NEW_TZDB_TIMEZONE",  # RFC4833
              48: "OPTION_LQ_CLIENT_LINK",  # RFC5007
+             56: "OPTION_NTP_SERVER",  # RFC5908
              59: "OPT_BOOTFILE_URL",  # RFC5970
              60: "OPT_BOOTFILE_PARAM",  # RFC5970
              61: "OPTION_CLIENT_ARCH_TYPE",  # RFC5970
              62: "OPTION_NII",  # RFC5970
              65: "OPTION_ERP_LOCAL_DOMAIN_NAME",  # RFC6440
              66: "OPTION_RELAY_SUPPLIED_OPTIONS",  # RFC6422
              68: "OPTION_VSS",  # RFC6607
              79: "OPTION_CLIENT_LINKLAYER_ADDR",  # RFC6939
+             103: "OPTION_CAPTIVE_PORTAL",  # RFC8910
              112: "OPTION_MUD_URL",  # RFC8520
              }
 
 dhcp6opts_by_code = {1: "DHCP6OptClientId",
                      2: "DHCP6OptServerId",
                      3: "DHCP6OptIA_NA",
                      4: "DHCP6OptIA_TA",
@@ -171,22 +172,24 @@
                      42: "DHCP6OptNewTZDBTimeZone",  # RFC4833
                      43: "DHCP6OptRelayAgentERO",  # RFC4994
                      # 44: "DHCP6OptLQQuery",            #RFC5007
                      # 45: "DHCP6OptLQClientData",       #RFC5007
                      # 46: "DHCP6OptLQClientTime",       #RFC5007
                      # 47: "DHCP6OptLQRelayData",        #RFC5007
                      48: "DHCP6OptLQClientLink",  # RFC5007
+                     56: "DHCP6OptNTPServer",  # RFC5908
                      59: "DHCP6OptBootFileUrl",  # RFC5790
                      60: "DHCP6OptBootFileParam",  # RFC5970
                      61: "DHCP6OptClientArchType",  # RFC5970
                      62: "DHCP6OptClientNetworkInterId",  # RFC5970
                      65: "DHCP6OptERPDomain",  # RFC6440
                      66: "DHCP6OptRelaySuppliedOpt",  # RFC6422
                      68: "DHCP6OptVSS",  # RFC6607
                      79: "DHCP6OptClientLinkLayerAddr",  # RFC6939
+                     103: "DHCP6OptCaptivePortal",  # RFC8910
                      112: "DHCP6OptMudUrl",  # RFC8520
                      }
 
 
 # sect 7.3 RFC 8415 : DHCP6 Messages types
 dhcp6types = {1: "SOLICIT",
                  2: "ADVERTISE",
@@ -412,15 +415,15 @@
 
 #    DHCPv6 Option Request Option                                   #
 
 class _OptReqListField(StrLenField):
     islist = 1
 
     def i2h(self, pkt, x):
-        if x is None:
+        if not x:
             return []
         return x
 
     def i2len(self, pkt, x):
         return 2 * len(x)
 
     def any2i(self, pkt, x):
@@ -957,14 +960,68 @@
     name = "DHCP6 Client Link Option"
     fields_desc = [ShortEnumField("optcode", 48, dhcp6opts),
                    FieldLenField("optlen", None, length_of="linkaddress"),
                    IP6ListField("linkaddress", [],
                                 length_from=lambda pkt: pkt.optlen)]
 
 
+class DHCP6NTPSubOptSrvAddr(Packet):  # RFC5908 sect 4.1
+    name = "DHCP6 NTP Server Address Suboption"
+    fields_desc = [ShortField("optcode", 1),
+                   ShortField("optlen", 16),
+                   IP6Field("addr", "::")]
+
+    def extract_padding(self, s):
+        return b"", s
+
+
+class DHCP6NTPSubOptMCAddr(Packet):  # RFC5908 sect 4.2
+    name = "DHCP6 NTP Multicast Address Suboption"
+    fields_desc = [ShortField("optcode", 2),
+                   ShortField("optlen", 16),
+                   IP6Field("addr", "::")]
+
+    def extract_padding(self, s):
+        return b"", s
+
+
+class DHCP6NTPSubOptSrvFQDN(Packet):  # RFC5908 sect 4.3
+    name = "DHCP6 NTP Server FQDN Suboption"
+    fields_desc = [ShortField("optcode", 3),
+                   FieldLenField("optlen", None, length_of="fqdn"),
+                   DNSStrField("fqdn", "",
+                               length_from=lambda pkt: pkt.optlen)]
+
+    def extract_padding(self, s):
+        return b"", s
+
+
+_ntp_subopts = {1: DHCP6NTPSubOptSrvAddr,
+                2: DHCP6NTPSubOptMCAddr,
+                3: DHCP6NTPSubOptSrvFQDN}
+
+
+def _ntp_subopt_dispatcher(p, **kwargs):
+    cls = conf.raw_layer
+    if len(p) >= 2:
+        o = struct.unpack("!H", p[:2])[0]
+        cls = _ntp_subopts.get(o, conf.raw_layer)
+    return cls(p, **kwargs)
+
+
+class DHCP6OptNTPServer(_DHCP6OptGuessPayload):  # RFC5908
+    name = "DHCP6 NTP Server Option"
+    fields_desc = [ShortEnumField("optcode", 56, dhcp6opts),
+                   FieldLenField("optlen", None, length_of="ntpserver",
+                                 fmt="!H"),
+                   PacketListField("ntpserver", [],
+                                   _ntp_subopt_dispatcher,
+                                   length_from=lambda pkt: pkt.optlen)]
+
+
 class DHCP6OptBootFileUrl(_DHCP6OptGuessPayload):  # RFC5970
     name = "DHCP6 Boot File URL Option"
     fields_desc = [ShortEnumField("optcode", 59, dhcp6opts),
                    FieldLenField("optlen", None, length_of="optdata"),
                    StrLenField("optdata", "",
                                length_from=lambda pkt: pkt.optlen)]
 
@@ -1024,14 +1081,22 @@
     fields_desc = [ShortEnumField("optcode", 79, dhcp6opts),
                    FieldLenField("optlen", None, length_of="clladdr",
                                  adjust=lambda pkt, x: x + 2),
                    ShortField("lltype", 1),  # ethernet
                    _LLAddrField("clladdr", ETHER_ANY)]
 
 
+class DHCP6OptCaptivePortal(_DHCP6OptGuessPayload):  # RFC8910
+    name = "DHCP6 Option - Captive-Portal"
+    fields_desc = [ShortEnumField("optcode", 103, dhcp6opts),
+                   FieldLenField("optlen", None, length_of="URI"),
+                   StrLenField("URI", "",
+                               length_from=lambda pkt: pkt.optlen)]
+
+
 class DHCP6OptMudUrl(_DHCP6OptGuessPayload):  # RFC8520
     name = "DHCP6 Option - MUD URL"
     fields_desc = [ShortEnumField("optcode", 112, dhcp6opts),
                    FieldLenField("optlen", None, length_of="mudstring"),
                    StrLenField("mudstring", "",
                                length_from=lambda pkt: pkt.optlen,
                                max_length=253,
@@ -1375,14 +1440,15 @@
 bind_bottom_up(UDP, _dhcp6_dispatcher, {"dport": 547})
 bind_bottom_up(UDP, _dhcp6_dispatcher, {"dport": 546})
 
 
 class DHCPv6_am(AnsweringMachine):
     function_name = "dhcp6d"
     filter = "udp and port 546 and port 547"
+    send_function = staticmethod(send)
 
     def usage(self):
         msg = """
 DHCPv6_am.parse_options( dns="2001:500::1035", domain="localdomain, local",
         duid=None, iface=conf.iface, advpref=255, sntpservers=None,
         sipdomains=None, sipservers=None,
         nisdomain=None, nisservers=None,
@@ -1713,22 +1779,22 @@
             Include options from the DHCPv6 query
             """
 
             # See which options should be included
             reqopts = []
             if query.haslayer(DHCP6OptOptReq):  # add only asked ones
                 reqopts = query[DHCP6OptOptReq].reqopts
-                for o, opt in six.iteritems(self.dhcpv6_options):
+                for o, opt in self.dhcpv6_options.items():
                     if o in reqopts:
                         answer /= opt
             else:
                 # advertise everything we have available
                 # Should not happen has clients MUST include
                 # and ORO in requests (sec 18.1.1)   -- arno
-                for o, opt in six.iteritems(self.dhcpv6_options):
+                for o, opt in self.dhcpv6_options.items():
                     answer /= opt
 
         if msgtype == 1:  # SOLICIT (See Sect 17.1 and 17.2 of RFC 3315)
 
             # XXX We don't support address or prefix assignment
             # XXX We also do not support relay function           --arno
 
@@ -1862,15 +1928,15 @@
             resp /= DHCP6_Reply(trid=trid)
             resp /= DHCP6OptServerId(duid=self.duid)
 
             if client_duid:
                 resp /= DHCP6OptClientId(duid=client_duid)
 
             # Stack requested options if available
-            for o, opt in six.iteritems(self.dhcpv6_options):
+            for o, opt in self.dhcpv6_options.items():
                 resp /= opt
 
             return resp
 
         else:
             # what else ?
             pass
```

### Comparing `scapy-2.5.0rc3/scapy/layers/dns.py` & `scapy-2.6.0rc1/scapy/layers/dns.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,42 +3,67 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 DNS: Domain Name System.
 """
 
-from __future__ import absolute_import
+import abc
 import operator
+import itertools
 import socket
 import struct
 import time
 import warnings
 
-from scapy.arch import get_if_addr, get_if_addr6
+from scapy.arch import (
+    get_if_addr,
+    get_if_addr6,
+    read_nameservers,
+)
 from scapy.ansmachine import AnsweringMachine
 from scapy.base_classes import Net
 from scapy.config import conf
 from scapy.compat import orb, raw, chb, bytes_encode, plain_str
 from scapy.error import log_runtime, warning, Scapy_Exception
-from scapy.packet import Packet, bind_layers, NoPayload, Raw
-from scapy.fields import BitEnumField, BitField, ByteEnumField, ByteField, \
-    ConditionalField, Field, FieldLenField, FlagsField, IntField, \
-    PacketListField, ShortEnumField, ShortField, StrField, \
-    StrLenField, MultipleTypeField, UTCTimeField, I
+from scapy.packet import Packet, bind_layers, Raw
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    Field,
+    FieldLenField,
+    FieldListField,
+    FlagsField,
+    I,
+    IP6Field,
+    IntField,
+    MultipleTypeField,
+    PacketListField,
+    ShortEnumField,
+    ShortField,
+    StrField,
+    StrLenField,
+    UTCTimeField,
+    XStrFixedLenField,
+    XStrLenField,
+)
 from scapy.sendrecv import sr1
+from scapy.supersocket import StreamSocket
 from scapy.pton_ntop import inet_ntop, inet_pton
+from scapy.volatile import RandShort
 
+from scapy.layers.l2 import Ether
 from scapy.layers.inet import IP, DestIPField, IPField, UDP, TCP
-from scapy.layers.inet6 import IPv6, DestIP6Field, IP6Field
-import scapy.libs.six as six
-
 
-from scapy.compat import (
+from typing import (
     Any,
+    List,
     Optional,
     Tuple,
     Type,
     Union,
 )
 
 
@@ -64,90 +89,106 @@
 
 
 dnsqtypes = {251: "IXFR", 252: "AXFR", 253: "MAILB", 254: "MAILA", 255: "ALL"}
 dnsqtypes.update(dnstypes)
 dnsclasses = {1: 'IN', 2: 'CS', 3: 'CH', 4: 'HS', 255: 'ANY'}
 
 
-def dns_get_str(s, pointer=0, pkt=None, _fullpacket=False):
+# 12/2023 from https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml  # noqa: E501
+dnssecalgotypes = {0: "Reserved", 1: "RSA/MD5", 2: "Diffie-Hellman", 3: "DSA/SHA-1",  # noqa: E501
+                   4: "Reserved", 5: "RSA/SHA-1", 6: "DSA-NSEC3-SHA1",
+                   7: "RSASHA1-NSEC3-SHA1", 8: "RSA/SHA-256", 9: "Reserved",
+                   10: "RSA/SHA-512", 11: "Reserved", 12: "GOST R 34.10-2001",
+                   13: "ECDSA Curve P-256 with SHA-256", 14: "ECDSA Curve P-384 with SHA-384",  # noqa: E501
+                   15: "Ed25519", 16: "Ed448",
+                   252: "Reserved for Indirect Keys", 253: "Private algorithms - domain name",  # noqa: E501
+                   254: "Private algorithms - OID", 255: "Reserved"}
+
+# 12/2023 from https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml
+dnssecdigesttypes = {0: "Reserved", 1: "SHA-1", 2: "SHA-256", 3: "GOST R 34.11-94", 4: "SHA-384"}  # noqa: E501
+
+# 12/2023 from https://www.iana.org/assignments/dnssec-nsec3-parameters/dnssec-nsec3-parameters.xhtml  # noqa: E501
+dnssecnsec3algotypes = {0: "Reserved", 1: "SHA-1"}
+
+
+def dns_get_str(s, full=None, _ignore_compression=False):
     """This function decompresses a string s, starting
     from the given pointer.
 
     :param s: the string to decompress
-    :param pointer: first pointer on the string (default: 0)
-    :param pkt: (optional) an InheritOriginDNSStrPacket packet
+    :param full: (optional) the full packet (used for decompression)
 
     :returns: (decoded_string, end_index, left_string)
     """
-    # The _fullpacket parameter is reserved for scapy. It indicates
-    # that the string provided is the full dns packet, and thus
-    # will be the same than pkt._orig_str. The "Cannot decompress"
-    # error will not be prompted if True.
+    # _ignore_compression is for internal use only
     max_length = len(s)
     # The result = the extracted name
     name = b""
     # Will contain the index after the pointer, to be returned
     after_pointer = None
     processed_pointers = []  # Used to check for decompression loops
-    # Analyse given pkt
-    if pkt and hasattr(pkt, "_orig_s") and pkt._orig_s:
-        s_full = pkt._orig_s
-    else:
-        s_full = None
     bytes_left = None
+    _fullpacket = False  # s = full packet
+    pointer = 0
     while True:
         if abs(pointer) >= max_length:
             log_runtime.info(
                 "DNS RR prematured end (ofs=%i, len=%i)", pointer, len(s)
             )
             break
-        cur = orb(s[pointer])  # get pointer value
+        cur = s[pointer]  # get pointer value
         pointer += 1  # make pointer go forward
         if cur & 0xc0:  # Label pointer
             if after_pointer is None:
                 # after_pointer points to where the remaining bytes start,
                 # as pointer will follow the jump token
                 after_pointer = pointer + 1
+            if _ignore_compression:
+                # skip
+                pointer += 1
+                continue
             if pointer >= max_length:
                 log_runtime.info(
                     "DNS incomplete jump token at (ofs=%i)", pointer
                 )
                 break
+            if not full:
+                raise Scapy_Exception("DNS message can't be compressed " +
+                                      "at this point!")
             # Follow the pointer
-            pointer = ((cur & ~0xc0) << 8) + orb(s[pointer]) - 12
+            pointer = ((cur & ~0xc0) << 8) + s[pointer]
             if pointer in processed_pointers:
                 warning("DNS decompression loop detected")
                 break
+            if len(processed_pointers) >= 20:
+                warning("More than 20 jumps in a single DNS decompression ! "
+                        "Dropping (evil packet)")
+                break
             if not _fullpacket:
-                # Do we have access to the whole packet ?
-                if s_full:
-                    # Yes -> use it to continue
-                    bytes_left = s[after_pointer:]
-                    s = s_full
-                    max_length = len(s)
-                    _fullpacket = True
-                else:
-                    # No -> abort
-                    raise Scapy_Exception("DNS message can't be compressed " +
-                                          "at this point!")
+                # We switch our s buffer to full, so we need to remember
+                # the previous context
+                bytes_left = s[after_pointer:]
+                s = full
+                max_length = len(s)
+                _fullpacket = True
             processed_pointers.append(pointer)
             continue
         elif cur > 0:  # Label
             # cur = length of the string
             name += s[pointer:pointer + cur] + b"."
             pointer += cur
-        else:
+        else:  # End
             break
     if after_pointer is not None:
         # Return the real end index (not the one we followed)
         pointer = after_pointer
     if bytes_left is None:
         bytes_left = s[pointer:]
-    # name, end_index, remaining
-    return name, pointer, bytes_left, len(processed_pointers) != 0
+    # name, remaining
+    return name or b".", bytes_left
 
 
 def _is_ptr(x):
     return b"." not in x and (
         (x and orb(x[-1]) == 0) or
         (len(x) >= 2 and (orb(x[-2]) & 0xc0) == 0xc0)
     )
@@ -192,30 +233,29 @@
     dns_pkt = pkt.getlayer(DNS)
     dns_pkt.clear_cache()
     build_pkt = raw(dns_pkt)
 
     def field_gen(dns_pkt):
         """Iterates through all DNS strings that can be compressed"""
         for lay in [dns_pkt.qd, dns_pkt.an, dns_pkt.ns, dns_pkt.ar]:
-            if lay is None:
+            if not lay:
                 continue
-            current = lay
-            while not isinstance(current, NoPayload):
-                if isinstance(current, InheritOriginDNSStrPacket):
-                    for field in current.fields_desc:
-                        if isinstance(field, DNSStrField) or \
-                           (isinstance(field, MultipleTypeField) and
-                           current.type in [2, 3, 4, 5, 12, 15]):
-                            # Get the associated data and store it accordingly  # noqa: E501
-                            dat = current.getfieldval(field.name)
-                            yield current, field.name, dat
-                current = current.payload
+            for current in lay:
+                for field in current.fields_desc:
+                    if isinstance(field, DNSStrField) or \
+                        (isinstance(field, MultipleTypeField) and
+                         current.type in [2, 3, 4, 5, 12, 15, 39]):
+                        # Get the associated data and store it accordingly  # noqa: E501
+                        dat = current.getfieldval(field.name)
+                        yield current, field.name, dat
 
     def possible_shortens(dat):
         """Iterates through all possible compression parts in a DNS string"""
+        if dat == b".":  # we'd lose by compressing it
+            return
         yield dat
         for x in range(1, dat.count(b".")):
             yield dat.split(b".", x)[x]
     data = {}
     for current, name, dat in field_gen(dns_pkt):
         for part in possible_shortens(dat):
             # Encode the data
@@ -265,159 +305,84 @@
     # Destroy the previous DNS layer if needed
     if not isinstance(pkt, DNS) and pkt.getlayer(DNS).underlayer:
         pkt.getlayer(DNS).underlayer.remove_payload()
         return pkt / dns_pkt
     return dns_pkt
 
 
-class InheritOriginDNSStrPacket(Packet):
-    __slots__ = Packet.__slots__ + ["_orig_s", "_orig_p"]
-
-    def __init__(self, _pkt=None, _orig_s=None, _orig_p=None, *args, **kwargs):
-        self._orig_s = _orig_s
-        self._orig_p = _orig_p
-        Packet.__init__(self, _pkt=_pkt, *args, **kwargs)
+class DNSCompressedPacket(Packet):
+    """
+    Class to mark that a packet contains DNSStrField and supports compression
+    """
+    @abc.abstractmethod
+    def get_full(self):
+        pass
 
 
 class DNSStrField(StrLenField):
     """
     Special StrField that handles DNS encoding/decoding.
     It will also handle DNS decompression.
     (may be StrLenField if a length_from is passed),
     """
-    __slots__ = ["compressed"]
+    def any2i(self, pkt, x):
+        if x and isinstance(x, list):
+            return [self.h2i(pkt, y) for y in x]
+        return super(DNSStrField, self).any2i(pkt, x)
 
     def h2i(self, pkt, x):
+        # Setting a DNSStrField manually (h2i) means any current compression will break
+        if (
+            pkt and
+            isinstance(pkt.parent, DNSCompressedPacket) and
+            pkt.parent.raw_packet_cache
+        ):
+            pkt.parent.clear_cache()
         if not x:
             return b"."
+        x = bytes_encode(x)
         if x[-1:] != b"." and not _is_ptr(x):
             return x + b"."
         return x
 
     def i2m(self, pkt, x):
         return dns_encode(x, check_built=True)
 
     def i2len(self, pkt, x):
         return len(self.i2m(pkt, x))
 
+    def get_full(self, pkt):
+        while pkt and not isinstance(pkt, DNSCompressedPacket):
+            pkt = pkt.parent or pkt.underlayer
+        if not pkt:
+            return None
+        return pkt.get_full()
+
     def getfield(self, pkt, s):
         remain = b""
         if self.length_from:
             remain, s = super(DNSStrField, self).getfield(pkt, s)
         # Decode the compressed DNS message
-        decoded, _, left, self.compressed = dns_get_str(s, 0, pkt)
+        decoded, left = dns_get_str(s, full=self.get_full(pkt))
         # returns (remaining, decoded)
         return left + remain, decoded
 
 
-class DNSRRCountField(ShortField):
-    __slots__ = ["rr"]
-
-    def __init__(self, name, default, rr):
-        ShortField.__init__(self, name, default)
-        self.rr = rr
-
-    def _countRR(self, pkt):
-        x = getattr(pkt, self.rr)
-        i = 0
-        while isinstance(x, (DNSRR, DNSQR)) or isdnssecRR(x):
-            x = x.payload
-            i += 1
-        return i
-
-    def i2m(self, pkt, x):
-        if x is None:
-            x = self._countRR(pkt)
-        return x
-
-    def i2h(self, pkt, x):
-        if x is None:
-            x = self._countRR(pkt)
-        return x
-
-
-class DNSRRField(StrField):
-    __slots__ = ["countfld", "passon", "rr"]
-    holds_packets = 1
-
-    def __init__(self, name, countfld, default, passon=1):
-        StrField.__init__(self, name, None)
-        self.countfld = countfld
-        # Notes:
-        # - self.rr: used by DNSRRCountField() to compute the records count
-        # - self.default: used to set the default record
-        self.rr = self.default = default
-        self.passon = passon
-
-    def i2m(self, pkt, x):
-        if x is None:
-            return b""
-        return bytes_encode(x)
-
-    def decodeRR(self, name, s, p):
-        ret = s[p:p + 10]
-        # type, cls, ttl, rdlen
-        typ, cls, _, rdlen = struct.unpack("!HHIH", ret)
-        p += 10
-        cls = DNSRR_DISPATCHER.get(typ, DNSRR)
-        rr = cls(b"\x00" + ret + s[p:p + rdlen], _orig_s=s, _orig_p=p)
-
-        # Reset rdlen if DNS compression was used
-        for fname in rr.fieldtype.keys():
-            rdata_obj = rr.fieldtype[fname]
-            if fname == "rdata" and isinstance(rdata_obj, MultipleTypeField):
-                rdata_obj = rdata_obj._find_fld_pkt_val(rr, rr.type)[0]
-            if isinstance(rdata_obj, DNSStrField) and rdata_obj.compressed:
-                del rr.rdlen
-                break
-        rr.rrname = name
-
-        p += rdlen
-        return rr, p
-
-    def getfield(self, pkt, s):
-        if isinstance(s, tuple):
-            s, p = s
-        else:
-            p = 0
-        ret = None
-        c = getattr(pkt, self.countfld)
-        if c > len(s):
-            log_runtime.info("DNS wrong value: DNS.%s=%i", self.countfld, c)
-            return s, b""
-        while c:
-            c -= 1
-            name, p, _, _ = dns_get_str(s, p, _fullpacket=True)
-            rr, p = self.decodeRR(name, s, p)
-            if ret is None:
-                ret = rr
-            else:
-                ret.add_payload(rr)
-        if self.passon:
-            return (s, p), ret
-        else:
-            return s[p:], ret
-
-
-class DNSQRField(DNSRRField):
-    def decodeRR(self, name, s, p):
-        ret = s[p:p + 4]
-        p += 4
-        rr = DNSQR(b"\x00" + ret, _orig_s=s, _orig_p=p)
-        rr.qname = name
-        return rr, p
-
-
 class DNSTextField(StrLenField):
     """
     Special StrLenField that handles DNS TEXT data (16)
     """
 
     islist = 1
 
+    def i2h(self, pkt, x):
+        if not x:
+            return []
+        return x
+
     def m2i(self, pkt, s):
         ret_s = list()
         tmp_s = s
         # RDATA contains a list of strings, each are prepended with
         # a byte containing the size of the following string.
         while tmp_s:
             tmp_len = orb(tmp_s[0]) + 1
@@ -437,158 +402,107 @@
 
     def i2len(self, pkt, x):
         return len(self.i2m(pkt, x))
 
     def i2m(self, pkt, s):
         ret_s = b""
         for text in s:
+            if not text:
+                ret_s += b"\x00"
+                continue
             text = bytes_encode(text)
             # The initial string must be split into a list of strings
             # prepended with theirs sizes.
             while len(text) >= 255:
                 ret_s += b"\xff" + text[:255]
                 text = text[255:]
             # The remaining string is less than 255 bytes long
             if len(text):
                 ret_s += struct.pack("!B", len(text)) + text
         return ret_s
 
 
-class DNSQR(InheritOriginDNSStrPacket):
-    name = "DNS Question Record"
-    show_indent = 0
-    fields_desc = [DNSStrField("qname", "www.example.com"),
-                   ShortEnumField("qtype", 1, dnsqtypes),
-                   ShortEnumField("qclass", 1, dnsclasses)]
-
-
-class DNS(Packet):
-    name = "DNS"
-    fields_desc = [
-        ConditionalField(ShortField("length", None),
-                         lambda p: isinstance(p.underlayer, TCP)),
-        ShortField("id", 0),
-        BitField("qr", 0, 1),
-        BitEnumField("opcode", 0, 4, {0: "QUERY", 1: "IQUERY", 2: "STATUS"}),
-        BitField("aa", 0, 1),
-        BitField("tc", 0, 1),
-        BitField("rd", 1, 1),
-        BitField("ra", 0, 1),
-        BitField("z", 0, 1),
-        # AD and CD bits are defined in RFC 2535
-        BitField("ad", 0, 1),  # Authentic Data
-        BitField("cd", 0, 1),  # Checking Disabled
-        BitEnumField("rcode", 0, 4, {0: "ok", 1: "format-error",
-                                     2: "server-failure", 3: "name-error",
-                                     4: "not-implemented", 5: "refused"}),
-        DNSRRCountField("qdcount", None, "qd"),
-        DNSRRCountField("ancount", None, "an"),
-        DNSRRCountField("nscount", None, "ns"),
-        DNSRRCountField("arcount", None, "ar"),
-        DNSQRField("qd", "qdcount", DNSQR()),
-        DNSRRField("an", "ancount", None),
-        DNSRRField("ns", "nscount", None),
-        DNSRRField("ar", "arcount", None, 0),
-    ]
-
-    def answers(self, other):
-        return (isinstance(other, DNS) and
-                self.id == other.id and
-                self.qr == 1 and
-                other.qr == 0)
-
-    def mysummary(self):
-        name = ""
-        if self.qr:
-            type = "Ans"
-            if self.ancount > 0 and isinstance(self.an, DNSRR):
-                name = ' "%s"' % self.an.rdata
-        else:
-            type = "Qry"
-            if self.qdcount > 0 and isinstance(self.qd, DNSQR):
-                name = ' "%s"' % self.qd.qname
-        return 'DNS %s%s ' % (type, name)
-
-    def post_build(self, pkt, pay):
-        if isinstance(self.underlayer, TCP) and self.length is None:
-            pkt = struct.pack("!H", len(pkt) - 2) + pkt[2:]
-        return pkt + pay
-
-    def compress(self):
-        """Return the compressed DNS packet (using `dns_compress()`"""
-        return dns_compress(self)
-
-    def pre_dissect(self, s):
-        """
-        Check that a valid DNS over TCP message can be decoded
-        """
-        if isinstance(self.underlayer, TCP):
-
-            # Compute the length of the DNS packet
-            if len(s) >= 2:
-                dns_len = struct.unpack("!H", s[:2])[0]
-            else:
-                message = "Malformed DNS message: too small!"
-                log_runtime.info(message)
-                raise Scapy_Exception(message)
+# RFC 2671 - Extension Mechanisms for DNS (EDNS0)
 
-            # Check if the length is valid
-            if dns_len < 14 or len(s) < dns_len:
-                message = "Malformed DNS message: invalid length!"
-                log_runtime.info(message)
-                raise Scapy_Exception(message)
+edns0types = {0: "Reserved", 1: "LLQ", 2: "UL", 3: "NSID", 4: "Reserved",
+              5: "DAU", 6: "DHU", 7: "N3U", 8: "edns-client-subnet", 10: "COOKIE",
+              15: "Extended DNS Error"}
 
-        return s
 
+class _EDNS0Dummy(Packet):
+    name = "Dummy class that implements extract_padding()"
 
-# RFC 2671 - Extension Mechanisms for DNS (EDNS0)
-
-edns0types = {0: "Reserved", 1: "LLQ", 2: "UL", 3: "NSID", 4: "Reserved",
-              5: "PING", 8: "edns-client-subnet"}
+    def extract_padding(self, p):
+        # type: (bytes) -> Tuple[bytes, Optional[bytes]]
+        return "", p
 
 
-class EDNS0TLV(Packet):
+class EDNS0TLV(_EDNS0Dummy):
     name = "DNS EDNS0 TLV"
     fields_desc = [ShortEnumField("optcode", 0, edns0types),
                    FieldLenField("optlen", None, "optdata", fmt="H"),
                    StrLenField("optdata", "",
                                length_from=lambda pkt: pkt.optlen)]
 
-    def extract_padding(self, p):
-        # type: (bytes) -> Tuple[bytes, Optional[bytes]]
-        return "", p
-
     @classmethod
     def dispatch_hook(cls, _pkt=None, *args, **kargs):
         # type: (Optional[bytes], *Any, **Any) -> Type[Packet]
         if _pkt is None:
             return EDNS0TLV
         if len(_pkt) < 2:
             return Raw
         edns0type = struct.unpack("!H", _pkt[:2])[0]
-        if edns0type == 8:
-            return EDNS0ClientSubnet
-        return EDNS0TLV
+        return EDNS0OPT_DISPATCHER.get(edns0type, EDNS0TLV)
 
 
-class DNSRROPT(InheritOriginDNSStrPacket):
+class DNSRROPT(Packet):
     name = "DNS OPT Resource Record"
     fields_desc = [DNSStrField("rrname", ""),
                    ShortEnumField("type", 41, dnstypes),
                    ShortField("rclass", 4096),
                    ByteField("extrcode", 0),
                    ByteField("version", 0),
                    # version 0 means EDNS0
                    BitEnumField("z", 32768, 16, {32768: "D0"}),
                    # D0 means DNSSEC OK from RFC 3225
                    FieldLenField("rdlen", None, length_of="rdata", fmt="H"),
                    PacketListField("rdata", [], EDNS0TLV,
                                    length_from=lambda pkt: pkt.rdlen)]
 
 
+# RFC 6975 - Signaling Cryptographic Algorithm Understanding in
+# DNS Security Extensions (DNSSEC)
+
+class EDNS0DAU(_EDNS0Dummy):
+    name = "DNSSEC Algorithm Understood (DAU)"
+    fields_desc = [ShortEnumField("optcode", 5, edns0types),
+                   FieldLenField("optlen", None, count_of="alg_code", fmt="H"),
+                   FieldListField("alg_code", None,
+                                  ByteEnumField("", 0, dnssecalgotypes),
+                                  count_from=lambda pkt:pkt.optlen)]
+
+
+class EDNS0DHU(_EDNS0Dummy):
+    name = "DS Hash Understood (DHU)"
+    fields_desc = [ShortEnumField("optcode", 6, edns0types),
+                   FieldLenField("optlen", None, count_of="alg_code", fmt="H"),
+                   FieldListField("alg_code", None,
+                                  ByteEnumField("", 0, dnssecdigesttypes),
+                                  count_from=lambda pkt:pkt.optlen)]
+
+
+class EDNS0N3U(_EDNS0Dummy):
+    name = "NSEC3 Hash Understood (N3U)"
+    fields_desc = [ShortEnumField("optcode", 7, edns0types),
+                   FieldLenField("optlen", None, count_of="alg_code", fmt="H"),
+                   FieldListField("alg_code", None,
+                                  ByteEnumField("", 0, dnssecnsec3algotypes),
+                                  count_from=lambda pkt:pkt.optlen)]
+
+
 # RFC 7871 - Client Subnet in DNS Queries
 
 class ClientSubnetv4(StrLenField):
     af_familly = socket.AF_INET
     af_length = 32
     af_default = b"\xc0"  # 192.0.0.0
 
@@ -638,15 +552,15 @@
 
 class ClientSubnetv6(ClientSubnetv4):
     af_familly = socket.AF_INET6
     af_length = 128
     af_default = b"\x20"  # 2000::
 
 
-class EDNS0ClientSubnet(Packet):
+class EDNS0ClientSubnet(_EDNS0Dummy):
     name = "DNS EDNS0 Client Subnet"
     fields_desc = [ShortEnumField("optcode", 8, edns0types),
                    FieldLenField("optlen", None, "address", fmt="H",
                                  adjust=lambda pkt, x: x + 4),
                    ShortField("family", 1),
                    FieldLenField("source_plen", None,
                                  length_of="address",
@@ -660,29 +574,83 @@
                         (ClientSubnetv6("address", "2001:db8::",
                          length_from=lambda p: p.source_plen),
                          lambda pkt: pkt.family == 2)],
                        ClientSubnetv4("address", "192.168.0.0",
                                       length_from=lambda p: p.source_plen))]
 
 
-# RFC 4034 - Resource Records for the DNS Security Extensions
+class EDNS0COOKIE(_EDNS0Dummy):
+    name = "DNS EDNS0 COOKIE"
+    fields_desc = [ShortEnumField("optcode", 10, edns0types),
+                   FieldLenField("optlen", None, length_of="server_cookie", fmt="!H",
+                                 adjust=lambda pkt, x: x + 8),
+                   XStrFixedLenField("client_cookie", b"\x00" * 8, length=8),
+                   XStrLenField("server_cookie", "",
+                                length_from=lambda pkt: max(0, pkt.optlen - 8))]
+
+
+# RFC 8914 - Extended DNS Errors
+
+# https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#extended-dns-error-codes
+extended_dns_error_codes = {
+    0: "Other",
+    1: "Unsupported DNSKEY Algorithm",
+    2: "Unsupported DS Digest Type",
+    3: "Stale Answer",
+    4: "Forged Answer",
+    5: "DNSSEC Indeterminate",
+    6: "DNSSEC Bogus",
+    7: "Signature Expired",
+    8: "Signature Not Yet Valid",
+    9: "DNSKEY Missing",
+    10: "RRSIGs Missing",
+    11: "No Zone Key Bit Set",
+    12: "NSEC Missing",
+    13: "Cached Error",
+    14: "Not Ready",
+    15: "Blocked",
+    16: "Censored",
+    17: "Filtered",
+    18: "Prohibited",
+    19: "Stale NXDOMAIN Answer",
+    20: "Not Authoritative",
+    21: "Not Supported",
+    22: "No Reachable Authority",
+    23: "Network Error",
+    24: "Invalid Data",
+    25: "Signature Expired before Valid",
+    26: "Too Early",
+    27: "Unsupported NSEC3 Iterations Value",
+    28: "Unable to conform to policy",
+    29: "Synthesized",
+}
 
 
-# 09/2013 from http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml  # noqa: E501
-dnssecalgotypes = {0: "Reserved", 1: "RSA/MD5", 2: "Diffie-Hellman", 3: "DSA/SHA-1",  # noqa: E501
-                   4: "Reserved", 5: "RSA/SHA-1", 6: "DSA-NSEC3-SHA1",
-                   7: "RSASHA1-NSEC3-SHA1", 8: "RSA/SHA-256", 9: "Reserved",
-                   10: "RSA/SHA-512", 11: "Reserved", 12: "GOST R 34.10-2001",
-                   13: "ECDSA Curve P-256 with SHA-256", 14: "ECDSA Curve P-384 with SHA-384",  # noqa: E501
-                   252: "Reserved for Indirect Keys", 253: "Private algorithms - domain name",  # noqa: E501
-                   254: "Private algorithms - OID", 255: "Reserved"}
+# https://www.rfc-editor.org/rfc/rfc8914.html
+class EDNS0ExtendedDNSError(_EDNS0Dummy):
+    name = "DNS EDNS0 Extended DNS Error"
+    fields_desc = [ShortEnumField("optcode", 15, edns0types),
+                   FieldLenField("optlen", None, length_of="extra_text", fmt="!H",
+                                 adjust=lambda pkt, x: x + 2),
+                   ShortEnumField("info_code", 0, extended_dns_error_codes),
+                   StrLenField("extra_text", "",
+                               length_from=lambda pkt: pkt.optlen - 2)]
+
+
+EDNS0OPT_DISPATCHER = {
+    5: EDNS0DAU,
+    6: EDNS0DHU,
+    7: EDNS0N3U,
+    8: EDNS0ClientSubnet,
+    10: EDNS0COOKIE,
+    15: EDNS0ExtendedDNSError,
+}
 
-# 09/2013 from http://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml
-dnssecdigesttypes = {0: "Reserved", 1: "SHA-1", 2: "SHA-256", 3: "GOST R 34.11-94", 4: "SHA-384"}  # noqa: E501
 
+# RFC 4034 - Resource Records for the DNS Security Extensions
 
 def bitmap2RRlist(bitmap):
     """
     Decode the 'Type Bit Maps' field of the NSEC Resource Record into an
     integer list.
     """
     # RFC 4034, 4.1.2. The Type Bit Maps Field
@@ -780,33 +748,49 @@
 
     def i2repr(self, pkt, x):
         x = self.i2h(pkt, x)
         rrlist = bitmap2RRlist(x)
         return [dnstypes.get(rr, rr) for rr in rrlist] if rrlist else repr(x)
 
 
-class _DNSRRdummy(InheritOriginDNSStrPacket):
+class _DNSRRdummy(Packet):
     name = "Dummy class that implements post_build() for Resource Records"
 
     def post_build(self, pkt, pay):
         if self.rdlen is not None:
             return pkt + pay
 
         lrrname = len(self.fields_desc[0].i2m("", self.getfieldval("rrname")))
         tmp_len = len(pkt) - lrrname - 10
         tmp_pkt = pkt[:lrrname + 8]
         pkt = struct.pack("!H", tmp_len) + pkt[lrrname + 8 + 2:]
 
         return tmp_pkt + pkt + pay
 
+    def default_payload_class(self, payload):
+        return conf.padding_layer
+
+
+class DNSRRHINFO(_DNSRRdummy):
+    name = "DNS HINFO Resource Record"
+    fields_desc = [DNSStrField("rrname", ""),
+                   ShortEnumField("type", 13, dnstypes),
+                   ShortEnumField("rclass", 1, dnsclasses),
+                   IntField("ttl", 0),
+                   ShortField("rdlen", None),
+                   FieldLenField("cpulen", None, fmt="!B", length_of="cpu"),
+                   StrLenField("cpu", "", length_from=lambda x: x.cpulen),
+                   FieldLenField("oslen", None, fmt="!B", length_of="os"),
+                   StrLenField("os", "", length_from=lambda x: x.oslen)]
+
 
 class DNSRRMX(_DNSRRdummy):
     name = "DNS MX Resource Record"
     fields_desc = [DNSStrField("rrname", ""),
-                   ShortEnumField("type", 6, dnstypes),
+                   ShortEnumField("type", 15, dnstypes),
                    ShortEnumField("rclass", 1, dnsclasses),
                    IntField("ttl", 0),
                    ShortField("rdlen", None),
                    ShortField("preference", 0),
                    DNSStrField("exchange", ""),
                    ]
 
@@ -929,14 +913,88 @@
                    ByteField("hashalg", 0),
                    ByteField("flags", 0),
                    ShortField("iterations", 0),
                    FieldLenField("saltlength", 0, fmt="!B", length_of="salt"),
                    StrLenField("salt", "", length_from=lambda pkt: pkt.saltlength)  # noqa: E501
                    ]
 
+
+# RFC 9460 Service Binding and Parameter Specification via the DNS
+# https://www.rfc-editor.org/rfc/rfc9460.html
+
+
+# https://www.iana.org/assignments/dns-svcb/dns-svcb.xhtml
+svc_param_keys = {
+    0: "mandatory",
+    1: "alpn",
+    2: "no-default-alpn",
+    3: "port",
+    4: "ipv4hint",
+    5: "ech",
+    6: "ipv6hint",
+    7: "dohpath",
+    8: "ohttp",
+}
+
+
+class SvcParam(Packet):
+    name = "SvcParam"
+    fields_desc = [ShortEnumField("key", 0, svc_param_keys),
+                   FieldLenField("len", None, length_of="value", fmt="H"),
+                   MultipleTypeField(
+                       [
+                           # mandatory
+                           (FieldListField("value", [],
+                                           ShortEnumField("", 0, svc_param_keys),
+                                           length_from=lambda pkt: pkt.len),
+                               lambda pkt: pkt.key == 0),
+                           # alpn, no-default-alpn
+                           (DNSTextField("value", [],
+                                         length_from=lambda pkt: pkt.len),
+                               lambda pkt: pkt.key in (1, 2)),
+                           # port
+                           (ShortField("value", 0),
+                               lambda pkt: pkt.key == 3),
+                           # ipv4hint
+                           (FieldListField("value", [],
+                                           IPField("", "0.0.0.0"),
+                                           length_from=lambda pkt: pkt.len),
+                               lambda pkt: pkt.key == 4),
+                           # ipv6hint
+                           (FieldListField("value", [],
+                                           IP6Field("", "::"),
+                                           length_from=lambda pkt: pkt.len),
+                               lambda pkt: pkt.key == 6),
+                       ],
+                       StrLenField("value", "",
+                                   length_from=lambda pkt:pkt.len))]
+
+    def extract_padding(self, p):
+        return "", p
+
+
+class DNSRRSVCB(_DNSRRdummy):
+    name = "DNS SVCB Resource Record"
+    fields_desc = [DNSStrField("rrname", ""),
+                   ShortEnumField("type", 64, dnstypes),
+                   ShortEnumField("rclass", 1, dnsclasses),
+                   IntField("ttl", 0),
+                   ShortField("rdlen", None),
+                   ShortField("svc_priority", 0),
+                   DNSStrField("target_name", ""),
+                   PacketListField("svc_params", [], SvcParam)]
+
+
+class DNSRRHTTPS(_DNSRRdummy):
+    name = "DNS HTTPS Resource Record"
+    fields_desc = [DNSStrField("rrname", ""),
+                   ShortEnumField("type", 65, dnstypes)
+                   ] + DNSRRSVCB.fields_desc[2:]
+
+
 # RFC 2782 - A DNS RR for specifying the location of services (DNS SRV)
 
 
 class DNSRRSRV(_DNSRRdummy):
     name = "DNS SRV Resource Record"
     fields_desc = [DNSStrField("rrname", ""),
                    ShortEnumField("type", 33, dnstypes),
@@ -1009,35 +1067,32 @@
                    FieldLenField("other_len", 0, fmt="!H", length_of="other_data"),  # noqa: E501
                    StrLenField("other_data", "", length_from=lambda pkt: pkt.other_len)  # noqa: E501
                    ]
 
 
 DNSRR_DISPATCHER = {
     6: DNSRRSOA,         # RFC 1035
+    13: DNSRRHINFO,      # RFC 1035
     15: DNSRRMX,         # RFC 1035
     33: DNSRRSRV,        # RFC 2782
     41: DNSRROPT,        # RFC 1671
     43: DNSRRDS,         # RFC 4034
     46: DNSRRRSIG,       # RFC 4034
     47: DNSRRNSEC,       # RFC 4034
     48: DNSRRDNSKEY,     # RFC 4034
     50: DNSRRNSEC3,      # RFC 5155
     51: DNSRRNSEC3PARAM,  # RFC 5155
+    64: DNSRRSVCB,       # RFC 9460
+    65: DNSRRHTTPS,      # RFC 9460
     250: DNSRRTSIG,      # RFC 2845
     32769: DNSRRDLV,     # RFC 4431
 }
 
-DNSSEC_CLASSES = tuple(six.itervalues(DNSRR_DISPATCHER))
-
-
-def isdnssecRR(obj):
-    return isinstance(obj, DNSSEC_CLASSES)
-
 
-class DNSRR(InheritOriginDNSStrPacket):
+class DNSRR(Packet):
     name = "DNS Resource Record"
     show_indent = 0
     fields_desc = [DNSStrField("rrname", ""),
                    ShortEnumField("type", 1, dnstypes),
                    ShortEnumField("rclass", 1, dnsclasses),
                    IntField("ttl", 0),
                    FieldLenField("rdlen", None, length_of="rdata", fmt="H"),
@@ -1045,37 +1100,284 @@
                        [
                            # A
                            (IPField("rdata", "0.0.0.0"),
                                lambda pkt: pkt.type == 1),
                            # AAAA
                            (IP6Field("rdata", "::"),
                                lambda pkt: pkt.type == 28),
-                           # NS, MD, MF, CNAME, PTR
+                           # NS, MD, MF, CNAME, PTR, DNAME
                            (DNSStrField("rdata", "",
                                         length_from=lambda pkt: pkt.rdlen),
-                               lambda pkt: pkt.type in [2, 3, 4, 5, 12]),
+                               lambda pkt: pkt.type in [2, 3, 4, 5, 12, 39]),
                            # TEXT
-                           (DNSTextField("rdata", [],
+                           (DNSTextField("rdata", [""],
                                          length_from=lambda pkt: pkt.rdlen),
                                lambda pkt: pkt.type == 16),
                        ],
                        StrLenField("rdata", "",
                                    length_from=lambda pkt:pkt.rdlen)
     )]
 
+    def default_payload_class(self, payload):
+        return conf.padding_layer
+
+
+def _DNSRR(s, **kwargs):
+    """
+    DNSRR dispatcher func
+    """
+    if s:
+        # Try to find the type of the RR using the dispatcher
+        _, remain = dns_get_str(s, _ignore_compression=True)
+        cls = DNSRR_DISPATCHER.get(
+            struct.unpack("!H", remain[:2])[0],
+            DNSRR,
+        )
+        rrlen = (
+            len(s) - len(remain) +  # rrname len
+            10 +
+            struct.unpack("!H", remain[8:10])[0]
+        )
+        pkt = cls(s[:rrlen], **kwargs) / conf.padding_layer(s[rrlen:])
+        # drop rdlen because if rdata was compressed, it will break everything
+        # when rebuilding
+        del pkt.fields["rdlen"]
+        return pkt
+    return None
+
+
+class DNSQR(Packet):
+    name = "DNS Question Record"
+    show_indent = 0
+    fields_desc = [DNSStrField("qname", "www.example.com"),
+                   ShortEnumField("qtype", 1, dnsqtypes),
+                   ShortEnumField("qclass", 1, dnsclasses)]
+
+    def default_payload_class(self, payload):
+        return conf.padding_layer
+
+
+class _DNSPacketListField(PacketListField):
+    # A normal PacketListField with backward-compatible hacks
+    def any2i(self, pkt, x):
+        # type: (Optional[Packet], List[Any]) -> List[Any]
+        if x is None:
+            warnings.warn(
+                ("The DNS fields 'qd', 'an', 'ns' and 'ar' are now "
+                 "PacketListField(s) ! "
+                 "Setting a null default should be [] instead of None"),
+                DeprecationWarning
+            )
+            x = []
+        return super(_DNSPacketListField, self).any2i(pkt, x)
+
+    def i2h(self, pkt, x):
+        # type: (Optional[Packet], List[Packet]) -> Any
+        class _list(list):
+            """
+            Fake list object to provide compatibility with older DNS fields
+            """
+            def __getattr__(self, attr):
+                try:
+                    ret = getattr(self[0], attr)
+                    warnings.warn(
+                        ("The DNS fields 'qd', 'an', 'ns' and 'ar' are now "
+                         "PacketListField(s) ! "
+                         "To access the first element, use pkt.an[0] instead of "
+                         "pkt.an"),
+                        DeprecationWarning
+                    )
+                    return ret
+                except AttributeError:
+                    raise
+        return _list(x)
+
+
+class DNS(DNSCompressedPacket):
+    name = "DNS"
+    fields_desc = [
+        ConditionalField(ShortField("length", None),
+                         lambda p: isinstance(p.underlayer, TCP)),
+        ShortField("id", 0),
+        BitField("qr", 0, 1),
+        BitEnumField("opcode", 0, 4, {0: "QUERY", 1: "IQUERY", 2: "STATUS"}),
+        BitField("aa", 0, 1),
+        BitField("tc", 0, 1),
+        BitField("rd", 1, 1),
+        BitField("ra", 0, 1),
+        BitField("z", 0, 1),
+        # AD and CD bits are defined in RFC 2535
+        BitField("ad", 0, 1),  # Authentic Data
+        BitField("cd", 0, 1),  # Checking Disabled
+        BitEnumField("rcode", 0, 4, {0: "ok", 1: "format-error",
+                                     2: "server-failure", 3: "name-error",
+                                     4: "not-implemented", 5: "refused"}),
+        FieldLenField("qdcount", None, count_of="qd"),
+        FieldLenField("ancount", None, count_of="an"),
+        FieldLenField("nscount", None, count_of="ns"),
+        FieldLenField("arcount", None, count_of="ar"),
+        _DNSPacketListField("qd", [DNSQR()], DNSQR, count_from=lambda pkt: pkt.qdcount),
+        _DNSPacketListField("an", [], _DNSRR, count_from=lambda pkt: pkt.ancount),
+        _DNSPacketListField("ns", [], _DNSRR, count_from=lambda pkt: pkt.nscount),
+        _DNSPacketListField("ar", [], _DNSRR, count_from=lambda pkt: pkt.arcount),
+    ]
+
+    def get_full(self):
+        # Required for DNSCompressedPacket
+        if isinstance(self.underlayer, TCP):
+            return self.original[2:]
+        else:
+            return self.original
+
+    def answers(self, other):
+        return (isinstance(other, DNS) and
+                self.id == other.id and
+                self.qr == 1 and
+                other.qr == 0)
+
+    def mysummary(self):
+        name = ""
+        if self.qr:
+            type = "Ans"
+            if self.an and isinstance(self.an[0], DNSRR):
+                name = ' %s' % self.an[0].rdata
+            elif self.rcode != 0:
+                name = self.sprintf(' %rcode%')
+        else:
+            type = "Qry"
+            if self.qd and isinstance(self.qd[0], DNSQR):
+                name = ' %s' % self.qd[0].qname
+        return 'DNS %s%s' % (type, name)
+
+    def post_build(self, pkt, pay):
+        if isinstance(self.underlayer, TCP) and self.length is None:
+            pkt = struct.pack("!H", len(pkt) - 2) + pkt[2:]
+        return pkt + pay
+
+    def compress(self):
+        """Return the compressed DNS packet (using `dns_compress()`)"""
+        return dns_compress(self)
+
+    def pre_dissect(self, s):
+        """
+        Check that a valid DNS over TCP message can be decoded
+        """
+        if isinstance(self.underlayer, TCP):
+
+            # Compute the length of the DNS packet
+            if len(s) >= 2:
+                dns_len = struct.unpack("!H", s[:2])[0]
+            else:
+                message = "Malformed DNS message: too small!"
+                log_runtime.info(message)
+                raise Scapy_Exception(message)
+
+            # Check if the length is valid
+            if dns_len < 14 or len(s) < dns_len:
+                message = "Malformed DNS message: invalid length!"
+                log_runtime.info(message)
+                raise Scapy_Exception(message)
+
+        return s
+
 
 bind_layers(UDP, DNS, dport=5353)
 bind_layers(UDP, DNS, sport=5353)
 bind_layers(UDP, DNS, dport=53)
 bind_layers(UDP, DNS, sport=53)
 DestIPField.bind_addr(UDP, "224.0.0.251", dport=5353)
-DestIP6Field.bind_addr(UDP, "ff02::fb", dport=5353)
+if conf.ipv6_enabled:
+    from scapy.layers.inet6 import DestIP6Field
+    DestIP6Field.bind_addr(UDP, "ff02::fb", dport=5353)
 bind_layers(TCP, DNS, dport=53)
 bind_layers(TCP, DNS, sport=53)
 
+# Nameserver config
+conf.nameservers = read_nameservers()
+_dns_cache = conf.netcache.new_cache("dns_cache", 300)
+
+
+@conf.commands.register
+def dns_resolve(qname, qtype="A", raw=False, verbose=1, timeout=3, **kwargs):
+    """
+    Perform a simple DNS resolution using conf.nameservers with caching
+
+    :param qname: the name to query
+    :param qtype: the type to query (default A)
+    :param raw: return the whole DNS packet (default False)
+    :param verbose: show verbose errors
+    :param timeout: seconds until timeout (per server)
+    :raise TimeoutError: if no DNS servers were reached in time.
+    """
+    # Unify types
+    qtype = DNSQR.qtype.any2i_one(None, qtype)
+    qname = DNSQR.qname.any2i(None, qname)
+    # Check cache
+    cache_ident = b";".join(
+        [qname, struct.pack("!B", qtype)] +
+        ([b"raw"] if raw else [])
+    )
+    result = _dns_cache.get(cache_ident)
+    if result:
+        return result
+
+    kwargs.setdefault("timeout", timeout)
+    kwargs.setdefault("verbose", 0)
+    res = None
+    for nameserver in conf.nameservers:
+        # Try all nameservers
+        try:
+            # Spawn a UDP socket, connect to the nameserver on port 53
+            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+            sock.settimeout(kwargs["timeout"])
+            sock.connect((nameserver, 53))
+            # Connected. Wrap it with DNS
+            sock = StreamSocket(sock, DNS)
+            # I/O
+            res = sock.sr1(
+                DNS(qd=[DNSQR(qname=qname, qtype=qtype)], id=RandShort()),
+                **kwargs,
+            )
+        except IOError as ex:
+            if verbose:
+                log_runtime.warning(str(ex))
+            continue
+        finally:
+            sock.close()
+        if res:
+            # We have a response ! Check for failure
+            if res[DNS].rcode == 2:  # server failure
+                res = None
+                if verbose:
+                    log_runtime.info(
+                        "DNS: %s answered with failure for %s" % (
+                            nameserver,
+                            qname,
+                        )
+                    )
+            else:
+                break
+    if res is not None:
+        if raw:
+            # Raw
+            result = res
+        else:
+            # Find answers
+            result = [
+                x
+                for x in itertools.chain(res.an, res.ns, res.ar)
+                if x.type == qtype
+            ]
+        if result:
+            # Cache it
+            _dns_cache[cache_ident] = result
+        return result
+    else:
+        raise TimeoutError
+
 
 @conf.commands.register
 def dyndns_add(nameserver, name, rdata, type="A", ttl=10):
     """Send a DNS add message to a nameserver for "name" to have a new "rdata"
 dyndns_add(nameserver, name, rdata, type="A", ttl=10) -> result code (0=ok)
 
 example: dyndns_add("ns1.toto.com", "dyn.toto.com", "127.0.0.1")
@@ -1110,72 +1412,222 @@
     if r and r.haslayer(DNS):
         return r.getlayer(DNS).rcode
     else:
         return -1
 
 
 class DNS_am(AnsweringMachine):
-    function_name = "dns_spoof"
+    function_name = "dnsd"
     filter = "udp port 53"
-    cls = DNS  # We use this automaton for llmnr_spoof
+    cls = DNS  # We also use this automaton for llmnrd
 
     def parse_options(self, joker=None,
-                      match=None, joker6=None, from_ip=None):
+                      match=None,
+                      srvmatch=None,
+                      joker6=False,
+                      relay=False,
+                      from_ip=None,
+                      from_ip6=None,
+                      src_ip=None,
+                      src_ip6=None,
+                      ttl=10,
+                      jokerarpa=None):
         """
         :param joker: default IPv4 for unresolved domains. (Default: None)
                       Set to False to disable, None to mirror the interface's IP.
         :param joker6: default IPv6 for unresolved domains (Default: False)
                        set to False to disable, None to mirror the interface's IPv6.
-        :param match: a dictionary of {names: (ip, ipv6)}
+        :param jokerarpa: answer for .in-addr.arpa PTR requests. (Default: None)
+        :param relay: relay unresolved domains to conf.nameservers (Default: False).
+        :param match: a dictionary of {name: val} where name is a string representing
+                      a domain name (A, AAAA) and val is a tuple of 2 elements, each
+                      representing an IP or a list of IPs. If val is a single element,
+                      (A, None) is assumed.
+        :param srvmatch: a dictionary of {name: (port, target)} used for SRV
         :param from_ip: an source IP to filter. Can contain a netmask
+        :param from_ip6: an source IPv6 to filter. Can contain a netmask
+        :param ttl: the DNS time to live (in seconds)
+        :param src_ip: override the source IP
+        :param src_ip6:
+
+        Example:
+
+            $ sudo iptables -I OUTPUT -p icmp --icmp-type 3/3 -j DROP
+            >>> dnsd(match={"google.com": "1.1.1.1"}, joker="192.168.0.2", iface="eth0")
+            >>> dnsd(srvmatch={
+            ...     "_ldap._tcp.dc._msdcs.DOMAIN.LOCAL.": (389, "srv1.domain.local")
+            ... })
         """
+        def normv(v):
+            if isinstance(v, (tuple, list)) and len(v) == 2:
+                return v
+            elif isinstance(v, str):
+                return (v, None)
+            else:
+                raise ValueError("Bad match value: '%s'" % repr(v))
+
+        def normk(k):
+            k = bytes_encode(k).lower()
+            if not k.endswith(b"."):
+                k += b"."
+            return k
         if match is None:
             self.match = {}
         else:
-            self.match = match
+            self.match = {normk(k): normv(v) for k, v in match.items()}
+        if srvmatch is None:
+            self.srvmatch = {}
+        else:
+            self.srvmatch = {normk(k): normv(v) for k, v in srvmatch.items()}
         self.joker = joker
         self.joker6 = joker6
+        self.jokerarpa = jokerarpa
+        self.relay = relay
         if isinstance(from_ip, str):
             self.from_ip = Net(from_ip)
         else:
             self.from_ip = from_ip
+        if isinstance(from_ip6, str):
+            self.from_ip6 = Net(from_ip6)
+        else:
+            self.from_ip6 = from_ip6
+        self.src_ip = src_ip
+        self.src_ip6 = src_ip6
+        self.ttl = ttl
 
     def is_request(self, req):
         from scapy.layers.inet6 import IPv6
         return (
             req.haslayer(self.cls) and
-            req.getlayer(self.cls).qr == 0 and
-            (not self.from_ip or (
-                req[IPv6].src in req if IPv6 in req else req[IP].src
-            ) in self.from_ip)
+            req.getlayer(self.cls).qr == 0 and (
+                (
+                    not self.from_ip6 or req[IPv6].src in self.from_ip6
+                )
+                if IPv6 in req else
+                (
+                    not self.from_ip or req[IP].src in self.from_ip
+                )
+            )
         )
 
     def make_reply(self, req):
-        IPcls = IPv6 if IPv6 in req else IP
-        resp = IPcls(dst=req[IPcls].src) / UDP(sport=req.dport, dport=req.sport)
-        dns = req.getlayer(self.cls)
-        if req.qd.qtype == 28:
-            # AAAA
-            if self.joker6 is False:
-                return
-            rdata = self.match.get(
-                dns.qd.qname,
-                self.joker or get_if_addr6(self.optsniff.get("iface", conf.iface))
+        resp = req.copy()
+        if Ether in req:
+            resp[Ether].src, resp[Ether].dst = (
+                None if req[Ether].dst == "ff:ff:ff:ff:ff:ff" else req[Ether].dst,
+                req[Ether].src,
             )
-            if isinstance(rdata, (tuple, list)):
-                rdata = rdata[1]
-            resp /= self.cls(id=dns.id, qr=1, qd=dns.qd,
-                             an=DNSRR(rrname=dns.qd.qname, ttl=10, rdata=rdata,
-                                      type=28))
+        from scapy.layers.inet6 import IPv6
+        if IPv6 in req:
+            resp[IPv6].underlayer.remove_payload()
+            resp /= IPv6(dst=req[IPv6].src, src=self.src_ip6 or req[IPv6].dst)
+        elif IP in req:
+            resp[IP].underlayer.remove_payload()
+            resp /= IP(dst=req[IP].src, src=self.src_ip or req[IP].dst)
         else:
-            if self.joker is False:
-                return
-            rdata = self.match.get(
-                dns.qd.qname,
-                self.joker or get_if_addr(self.optsniff.get("iface", conf.iface))
+            warning("No IP or IPv6 layer in %s", req.command())
+            return
+        try:
+            resp /= UDP(sport=req[UDP].dport, dport=req[UDP].sport)
+        except IndexError:
+            warning("No UDP layer in %s", req.command(), exc_info=True)
+            return
+        ans = []
+        try:
+            req = req[self.cls]
+        except IndexError:
+            warning(
+                "No %s layer in %s",
+                self.cls.__name__,
+                req.command(),
+                exc_info=True,
             )
-            if isinstance(rdata, (tuple, list)):
-                # Fallback
-                rdata = rdata[0]
-            resp /= self.cls(id=dns.id, qr=1, qd=dns.qd,
-                             an=DNSRR(rrname=dns.qd.qname, ttl=10, rdata=rdata))
+            return
+        try:
+            queries = req.qd
+        except AttributeError:
+            warning("No qd attribute in %s", req.command(), exc_info=True)
+            return
+        for rq in queries:
+            if isinstance(rq, Raw):
+                warning("Cannot parse qd element %s", rq.command(), exc_info=True)
+                continue
+            if rq.qtype in [1, 28]:
+                # A or AAAA
+                if rq.qtype == 28:
+                    # AAAA
+                    try:
+                        rdata = self.match[rq.qname.lower()][1]
+                    except KeyError:
+                        if self.relay or self.joker6 is False:
+                            rdata = None
+                        else:
+                            rdata = self.joker6 or get_if_addr6(
+                                self.optsniff.get("iface", conf.iface)
+                            )
+                elif rq.qtype == 1:
+                    # A
+                    try:
+                        rdata = self.match[rq.qname.lower()][0]
+                    except KeyError:
+                        if self.relay or self.joker is False:
+                            rdata = None
+                        else:
+                            rdata = self.joker or get_if_addr(
+                                self.optsniff.get("iface", conf.iface)
+                            )
+                if rdata is not None:
+                    # Common A and AAAA
+                    if not isinstance(rdata, list):
+                        rdata = [rdata]
+                    ans.extend([
+                        DNSRR(rrname=rq.qname, ttl=self.ttl, rdata=x, type=rq.qtype)
+                        for x in rdata
+                    ])
+                    continue  # next
+            elif rq.qtype == 33:
+                # SRV
+                try:
+                    port, target = self.srvmatch[rq.qname.lower()]
+                    ans.append(DNSRRSRV(
+                        rrname=rq.qname,
+                        port=port,
+                        target=target,
+                        weight=100,
+                        ttl=self.ttl
+                    ))
+                    continue  # next
+                except KeyError:
+                    # No result
+                    pass
+            elif rq.qtype == 12:
+                # PTR
+                if rq.qname[-14:] == b".in-addr.arpa." and self.jokerarpa:
+                    ans.append(DNSRR(
+                        rrname=rq.qname,
+                        type=rq.qtype,
+                        ttl=self.ttl,
+                        rdata=self.jokerarpa,
+                    ))
+                    continue
+            # It it arrives here, there is currently no answer
+            if self.relay:
+                # Relay mode ?
+                try:
+                    _rslv = dns_resolve(rq.qname, qtype=rq.qtype)
+                    if _rslv:
+                        ans.extend(_rslv)
+                        continue  # next
+                except TimeoutError:
+                    pass
+            # Error
+            break
+        else:
+            if not ans:
+                # No rq was actually answered, as none was valid. Discard.
+                return
+            # All rq were answered
+            resp /= self.cls(id=req.id, qr=1, qd=req.qd, an=ans)
+            return resp
+        # An error happened
+        resp /= self.cls(id=req.id, qr=1, qd=req.qd, rcode=3)
         return resp
```

### Comparing `scapy-2.5.0rc3/scapy/layers/dot11.py` & `scapy-2.6.0rc1/scapy/layers/dot11.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 Wireless LAN according to IEEE 802.11.
 
 This file contains bindings for 802.11 layers and some usual linklayers:
   - PRISM
   - RadioTap
 """
 
-from __future__ import print_function
 import re
 import struct
 from zlib import crc32
 
 from scapy.config import conf, crypto_validator
 from scapy.data import ETHER_ANY, DLT_IEEE802_11, DLT_PRISM_HEADER, \
     DLT_IEEE802_11_RADIO
@@ -35,14 +34,15 @@
     IntField,
     LEFieldLenField,
     LEIntField,
     LELongField,
     LEShortEnumField,
     LEShortField,
     LESignedIntField,
+    MayEnd,
     MultipleTypeField,
     OUIField,
     PacketField,
     PacketListField,
     ReversePadField,
     ScalingField,
     ShortField,
@@ -199,24 +199,24 @@
                 'PartialAID',
                 'res1', 'res2', 'res3', 'res4', 'res5', 'res6', 'res7']
 
 _rt_presentvht = ['STBC', 'TXOP_PS_NOT_ALLOWED', 'GuardInterval',
                   'SGINsysmDis', 'LDPCextraOFDM', 'Beamformed',
                   'res1', 'res2']
 
-_rt_hemuother_per_user_known = {
+_rt_hemuother_per_user_known = [
     'user field position',
     'STA-ID',
     'NSTS',
     'Tx Beamforming',
     'Spatial Configuration',
     'MCS',
     'DCM',
     'Coding',
-}
+]
 
 
 # Radiotap utils
 
 # Note: extended presence masks are dissected pretty dumbly by
 # Wireshark.
 
@@ -956,24 +956,27 @@
     13: "TSPEC",
     14: "TCLAS",
     15: "Schedule",
     16: "Challenge text",
     32: "Power Constraint",
     33: "Power Capability",
     36: "Supported Channels",
+    37: "Channel Switch Announcement",
     42: "ERP",
     45: "HT Capabilities",
     46: "QoS Capability",
     48: "RSN",
     50: "Extended Supported Rates",
     52: "Neighbor Report",
     61: "HT Operation",
+    74: "Overlapping BSS Scan Parameters",
     107: "Interworking",
-    127: "Extendend Capabilities",
+    127: "Extended Capabilities",
     191: "VHT Capabilities",
+    192: "VHT Operation",
     221: "Vendor Specific"
 }
 
 # Backward compatibility
 _dot11_elt_deprecated_names = {
     "Rates": 1,
     "DSset": 3,
@@ -1264,25 +1267,33 @@
 class Dot11EltCountry(Dot11Elt):
     name = "802.11 Country"
     match_subclass = True
     fields_desc = [
         ByteEnumField("ID", 7, _dot11_id_enum),
         ByteField("len", None),
         StrFixedLenField("country_string", b"\0\0\0", length=3),
-        PacketListField(
+        MayEnd(PacketListField(
             "descriptors",
             [],
             Dot11EltCountryConstraintTriplet,
             length_from=lambda pkt: (
                 pkt.len - 3 - (pkt.len % 3)
             )
-        ),
+        )),
+        # When this extension is last, padding appears to be omitted
         ConditionalField(
             ByteField("pad", 0),
-            lambda pkt: (len(pkt.descriptors) + 1) % 2
+            # The length should be 3 bytes per each triplet, and 3 bytes for the
+            # country_string field. The standard dictates that the element length
+            # must be even, so if the result is odd, add a padding byte.
+            # Some transmitters don't comply with the standard, so instead of assuming
+            # the length, we test whether there is a padding byte.
+            # Some edge cases are still not covered, for example, if the tag length
+            # (pkt.len) is an arbitrary number.
+            lambda pkt: ((len(pkt.descriptors) + 1) % 2) if pkt.len is None else (pkt.len % 3)  # noqa: E501
         )
     ]
 
 
 class _RateField(ByteField):
     def i2repr(self, pkt, val):
         if val is None:
@@ -1431,14 +1442,77 @@
     # It appears many WPA implementations ignore the fact
     # that this IE should only have a single cipher and auth suite
     fields_desc = Dot11EltVendorSpecific.fields_desc[:3] + [
         XByteField("type", 0x01)
     ] + Dot11EltRSN.fields_desc[2:8]
 
 
+# 802.11-2016 9.4.2.19
+
+class Dot11EltCSA(Dot11Elt):
+    name = "802.11 CSA Element"
+    fields_desc = [
+        ByteEnumField("ID", 37, _dot11_id_enum),
+        ByteField("len", 3),
+        ByteField("mode", 0),
+        ByteField("new_channel", 0),
+        ByteField("channel_switch_count", 0)
+    ]
+
+
+# 802.11-2016 9.4.2.59
+
+class Dot11EltOBSS(Dot11Elt):
+    name = "802.11 OBSS Scan Parameters Element"
+    fields_desc = [
+        ByteEnumField("ID", 74, _dot11_id_enum),
+        ByteField("len", 14),
+        LEShortField("Passive_Dwell", 0),
+        LEShortField("Active_Dwell", 0),
+        LEShortField("Scan_Interval", 0),
+        LEShortField("Passive_Total_Per_Channel", 0),
+        LEShortField("Active_Total_Per_Channel", 0),
+        LEShortField("Delay", 0),
+        LEShortField("Activity_Threshold", 0),
+    ]
+
+
+# 802.11-2016 9.4.2.159
+
+class Dot11VHTOperationInfo(Packet):
+    name = "802.11 VHT Operation Information"
+    fields_desc = [
+        ByteField("channel_width", 0),
+        ByteField("channel_center0", 36),
+        ByteField("channel_center1", 0),
+    ]
+
+    def extract_padding(self, s):
+        return "", s
+
+
+class Dot11EltVHTOperation(Dot11Elt):
+    name = "802.11 VHT Operation Element"
+    fields_desc = [
+        ByteEnumField("ID", 192, _dot11_id_enum),
+        ByteField("len", 5),
+        PacketField(
+            "VHT_Operation_Info",
+            Dot11VHTOperationInfo(),
+            Dot11VHTOperationInfo
+        ),
+        FieldListField(
+            "mcs_set",
+            [0x00],
+            BitField('SS', 0x00, size=2),
+            count_from=lambda x: 8
+        )
+    ]
+
+
 ######################
 # 802.11 Frame types #
 ######################
 
 # 802.11-2016 9.3
 
 class Dot11Beacon(_Dot11EltUtils):
@@ -1495,28 +1569,270 @@
 class Dot11Auth(_Dot11EltUtils):
     name = "802.11 Authentication"
     fields_desc = [LEShortEnumField("algo", 0, ["open", "sharedkey"]),
                    LEShortField("seqnum", 0),
                    LEShortEnumField("status", 0, status_code)]
 
     def answers(self, other):
-        if self.seqnum == other.seqnum + 1:
+        if self.algo != other.algo:
+            return 0
+
+        if (
+            self.seqnum == other.seqnum + 1 or
+            (self.algo == 3 and self.seqnum == other.seqnum)
+        ):
             return 1
         return 0
 
 
 class Dot11Deauth(Packet):
     name = "802.11 Deauthentication"
     fields_desc = [LEShortEnumField("reason", 1, reason_code)]
 
 
 class Dot11Ack(Packet):
     name = "802.11 Ack packet"
 
 
+# 802.11-2016 9.4.1.11
+
+class Dot11Action(Packet):
+    name = "802.11 Action"
+    fields_desc = [
+        ByteEnumField("category", 0x00, {
+            0x00: "Spectrum Management",
+            0x01: "QoS",
+            0x02: "DLS",
+            0x03: "Block",
+            0x04: "Public",
+            0x05: "Radio Measurement",
+            0x06: "Fast BSS Transition",
+            0x07: "HT",
+            0x08: "SA Query",
+            0x09: "Protected Dual of Public Action",
+            0x0A: "WNM",
+            0x0B: "Unprotected WNM",
+            0x0C: "TDLS",
+            0x0D: "Mesh",
+            0x0E: "Multihop",
+            0x0F: "Self-protected",
+            0x10: "DMG",
+            0x11: "Reserved Wi-Fi Alliance",
+            0x12: "Fast Session Transfer",
+            0x13: "Robust AV Streaming",
+            0x14: "Unprotected DMG",
+            0x15: "VHT"
+        })
+    ]
+
+
+# 802.11-2016 9.6.14.1
+
+class Dot11WNM(Packet):
+    name = "802.11 WNM Action"
+    fields_desc = [
+        ByteEnumField("action", 0x00, {
+            0x00: "Event Request",
+            0x01: "Event Report",
+            0x02: "Diagnostic Request",
+            0x03: "Diagnostic Report",
+            0x04: "Location Configuration Request",
+            0x05: "Location Configuration Response",
+            0x06: "BSS Transition Management Query",
+            0x07: "BSS Transition Management Request",
+            0x08: "BSS Transition Management Response",
+            0x09: "FMS Request",
+            0x0A: "FMS Response",
+            0x0B: "Collocated Interference Request",
+            0x0C: "Collocated Interference Report",
+            0x0D: "TFS Request",
+            0x0E: "TFS Response",
+            0x0F: "TFS Notify",
+            0x10: "WNM Sleep Mode Request",
+            0x11: "WNM Sleep Mode Response",
+            0x12: "TIM Broadcast Request",
+            0x13: "TIM Broadcast Response",
+            0x14: "QoS Traffic Capability Update",
+            0x15: "Channel Usage Request",
+            0x16: "Channel Usage Response",
+            0x17: "DMS Request",
+            0x18: "DMS Response",
+            0x19: "Timing Measurement Request",
+            0x1A: "WNM Notification Request",
+            0x1B: "WNM Notification Response",
+            0x1C: "WNM-Notify Response"
+        })
+    ]
+
+
+# 802.11-2016 9.4.2.37
+
+class SubelemTLV(Packet):
+    fields_desc = [
+        ByteField("type", 0),
+        LEFieldLenField("len", None, fmt="B", length_of="value"),
+        FieldListField(
+            "value",
+            [],
+            ByteField('', 0),
+            length_from=lambda p: p.len
+        )
+    ]
+
+
+class BSSTerminationDuration(Packet):
+    name = "BSS Termination Duration"
+    fields_desc = [
+        ByteField("id", 4),
+        ByteField("len", 10),
+        LELongField("TSF", 0),
+        LEShortField("duration", 0)
+    ]
+
+    def extract_padding(self, s):
+        return "", s
+
+
+class NeighborReport(Packet):
+    name = "Neighbor Report"
+    fields_desc = [
+        ByteField("type", 0),
+        ByteField("len", 13),
+        MACField("BSSID", ETHER_ANY),
+        # BSSID Information
+        BitField("AP_reach", 0, 2, tot_size=-4),
+        BitField("security", 0, 1),
+        BitField("key_scope", 0, 1),
+        BitField("capabilities", 0, 6),
+        BitField("mobility", 0, 1),
+        BitField("HT", 0, 1),
+        BitField("VHT", 0, 1),
+        BitField("FTM", 0, 1),
+        BitField("reserved", 0, 18, end_tot_size=-4),
+        # BSSID Information end
+        ByteField("op_class", 0),
+        ByteField("channel", 0),
+        ByteField("phy_type", 0),
+        ConditionalField(
+            PacketListField(
+                "subelems",
+                SubelemTLV(),
+                SubelemTLV,
+                length_from=lambda p: p.len - 13
+            ),
+            lambda p: p.len > 13
+        )
+    ]
+
+
+# 802.11-2016 9.6.14.9
+
+btm_request_mode = [
+    "Preferred_Candidate_List_Included",
+    "Abridged",
+    "Disassociation_Imminent",
+    "BSS_Termination_Included",
+    "ESS_Disassociation_Imminent"
+]
+
+
+class Dot11BSSTMRequest(Packet):
+    name = "BSS Transition Management Request"
+    fields_desc = [
+        ByteField("token", 0),
+        FlagsField("mode", 0, 8, btm_request_mode),
+        LEShortField("disassociation_timer", 0),
+        ByteField("validity_interval", 0),
+        ConditionalField(
+            PacketField(
+                "termination_duration",
+                BSSTerminationDuration(),
+                BSSTerminationDuration
+            ),
+            lambda p: p.mode and p.mode.BSS_Termination_Included
+        ),
+        ConditionalField(
+            ByteField("url_len", 0),
+            lambda p: p.mode and p.mode.ESS_Disassociation_Imminent
+        ),
+        ConditionalField(
+            StrLenField("url", "", length_from=lambda p: p.url_len),
+            lambda p: p.mode and p.mode.ESS_Disassociation_Imminent != 0
+        ),
+        ConditionalField(
+            PacketListField(
+                "neighbor_report",
+                NeighborReport(),
+                NeighborReport
+            ),
+            lambda p: p.mode and p.mode.Preferred_Candidate_List_Included
+        )
+    ]
+
+
+# 802.11-2016 9.6.14.10
+
+btm_status_code = [
+    "Accept",
+    "Reject-Unspecified_reject_reason",
+    "Reject-Insufficient_Beacon_or_Probe_Response_frames",
+    "Reject-Insufficient_available_capacity_from_all_candidates",
+    "Reject-BSS_termination_undesired",
+    "Reject-BSS_termination_delay_requested",
+    "Reject-STA_BSS_Transition_Candidate_List_provided",
+    "Reject-No_suitable_BSS_transition_candidates",
+    "Reject-Leaving_ESS"
+]
+
+
+class Dot11BSSTMResponse(Packet):
+    name = "BSS Transition Management Response"
+    fields_desc = [
+        ByteField("token", 0),
+        ByteEnumField("status", 0, btm_status_code),
+        ByteField("termination_delay", 0),
+        ConditionalField(
+            MACField("target", ETHER_ANY),
+            lambda p: p.status == 0
+        ),
+        ConditionalField(
+            PacketListField(
+                "neighbor_report",
+                NeighborReport(),
+                NeighborReport
+            ),
+            lambda p: p.status == 6
+        )
+    ]
+
+
+# 802.11-2016 9.6.2.1
+
+class Dot11SpectrumManagement(Packet):
+    name = "802.11 Spectrum Management Action"
+    fields_desc = [
+        ByteEnumField("action", 0x00, {
+            0x00: "Measurement Request",
+            0x01: "Measurement Report",
+            0x02: "TPC Request",
+            0x03: "TPC Report",
+            0x04: "Channel Switch Announcement",
+        })
+    ]
+
+
+# 802.11-2016 9.6.2.6
+
+class Dot11CSA(Packet):
+    name = "Channel Switch Announcement Frame"
+    fields_desc = [
+        PacketField("CSA", Dot11EltCSA(), Dot11EltCSA),
+    ]
+
+
 ###################
 # 802.11 Security #
 ###################
 
 # 802.11-2016 12
 
 class Dot11Encrypted(Packet):
@@ -1649,37 +1965,45 @@
 
 bind_top_down(RadioTap, Dot11FCS, present=2, Flags=16)
 bind_top_down(Dot11, Dot11QoS, type=2, subtype=0xc)
 
 bind_layers(PrismHeader, Dot11,)
 bind_layers(Dot11, LLC, type=2)
 bind_layers(Dot11QoS, LLC,)
+
+# 802.11-2016 9.2.4.1.3 Type and Subtype subfields
 bind_layers(Dot11, Dot11AssoReq, subtype=0, type=0)
 bind_layers(Dot11, Dot11AssoResp, subtype=1, type=0)
 bind_layers(Dot11, Dot11ReassoReq, subtype=2, type=0)
 bind_layers(Dot11, Dot11ReassoResp, subtype=3, type=0)
 bind_layers(Dot11, Dot11ProbeReq, subtype=4, type=0)
 bind_layers(Dot11, Dot11ProbeResp, subtype=5, type=0)
 bind_layers(Dot11, Dot11Beacon, subtype=8, type=0)
 bind_layers(Dot11, Dot11ATIM, subtype=9, type=0)
 bind_layers(Dot11, Dot11Disas, subtype=10, type=0)
 bind_layers(Dot11, Dot11Auth, subtype=11, type=0)
 bind_layers(Dot11, Dot11Deauth, subtype=12, type=0)
+bind_layers(Dot11, Dot11Action, subtype=13, type=0)
 bind_layers(Dot11, Dot11Ack, subtype=13, type=1)
 bind_layers(Dot11Beacon, Dot11Elt,)
 bind_layers(Dot11AssoReq, Dot11Elt,)
 bind_layers(Dot11AssoResp, Dot11Elt,)
 bind_layers(Dot11ReassoReq, Dot11Elt,)
 bind_layers(Dot11ReassoResp, Dot11Elt,)
 bind_layers(Dot11ProbeReq, Dot11Elt,)
 bind_layers(Dot11ProbeResp, Dot11Elt,)
 bind_layers(Dot11Auth, Dot11Elt,)
 bind_layers(Dot11Elt, Dot11Elt,)
 bind_layers(Dot11TKIP, conf.raw_layer)
 bind_layers(Dot11CCMP, conf.raw_layer)
+bind_layers(Dot11Action, Dot11SpectrumManagement, category=0x00)
+bind_layers(Dot11SpectrumManagement, Dot11CSA, action=4)
+bind_layers(Dot11Action, Dot11WNM, category=0x0A)
+bind_layers(Dot11WNM, Dot11BSSTMRequest, action=7)
+bind_layers(Dot11WNM, Dot11BSSTMResponse, action=8)
 
 
 conf.l2types.register(DLT_IEEE802_11, Dot11)
 conf.l2types.register_num2layer(801, Dot11)
 conf.l2types.register(DLT_PRISM_HEADER, PrismHeader)
 conf.l2types.register_num2layer(802, PrismHeader)
 conf.l2types.register(DLT_IEEE802_11_RADIO, RadioTap)
@@ -1733,15 +2057,15 @@
             return 0
         return True
 
     def make_reply(self, p):
         ip = p.getlayer(IP)
         tcp = p.getlayer(TCP)
         pay = raw(tcp.payload)
-        del p.payload.payload.payload
+        p[IP].underlayer.remove_payload()
         p.FCfield = "from-DS"
         p.addr1, p.addr2 = p.addr2, p.addr1
         p /= IP(src=ip.dst, dst=ip.src)
         p /= TCP(sport=tcp.dport, dport=tcp.sport,
                  seq=tcp.ack, ack=tcp.seq + len(pay),
                  flags="PA")
         q = p.copy()
```

### Comparing `scapy-2.5.0rc3/scapy/layers/dot15d4.py` & `scapy-2.6.0rc1/scapy/layers/dot15d4.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/eap.py` & `scapy-2.6.0rc1/scapy/layers/eap.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,24 +3,46 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Extensible Authentication Protocol (EAP)
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 
 import struct
 
-from scapy.fields import BitField, ByteField, XByteField,\
-    ShortField, IntField, XIntField, ByteEnumField, StrLenField, XStrField,\
-    XStrLenField, XStrFixedLenField, LenField, FieldLenField, FieldListField,\
-    PacketField, PacketListField, ConditionalField, PadField
-from scapy.packet import Packet, Padding, bind_layers
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    FieldLenField,
+    FieldListField,
+    IntField,
+    LenField,
+    LongField,
+    PacketField,
+    PacketListField,
+    PadField,
+    ShortField,
+    StrLenField,
+    XByteField,
+    XIntField,
+    XStrField,
+    XStrFixedLenField,
+    XStrLenField,
+)
+from scapy.packet import (
+    Packet,
+    Padding,
+    bind_bottom_up,
+    bind_layers,
+    bind_top_down,
+)
 from scapy.layers.l2 import SourceMACField, Ether, CookedLinux, GRE, SNAP
 from scapy.config import conf
 from scapy.compat import orb, chb
 
 #
 # EAPOL
 #
@@ -403,14 +425,91 @@
         FieldLenField("count", None, "challenge_response", "B", adjust=lambda p, x: len(p.challenge_response)),  # noqa: E501
         XStrLenField("challenge_response", "", length_from=lambda p: 0 or p.count),  # noqa: E501
         StrLenField("username", "", length_from=lambda p: p.len - (8 + (0 or p.count)))  # noqa: E501
     ]
 
 
 #############################################################################
+# IEEE 802.1X-2010 - EAPOL-Key
+#############################################################################
+
+# sect 11.9 of 802.1X-2010
+# AND sect 12.7.2 of 802.11-2016
+
+
+class EAPOL_KEY(Packet):
+    name = "EAPOL_KEY"
+    deprecated_fields = {
+        "key": ("key_data", "2.6.0"),
+        "len": ("key_length", "2.6.0"),
+    }
+    fields_desc = [
+        ByteEnumField("key_descriptor_type", 1, {1: "RC4", 2: "RSN"}),
+        # Key Information
+        BitField("res2", 0, 2),
+        BitField("smk_message", 0, 1),
+        BitField("encrypted_key_data", 0, 1),
+        BitField("request", 0, 1),
+        BitField("error", 0, 1),
+        BitField("secure", 0, 1),
+        BitField("has_key_mic", 1, 1),
+        BitField("key_ack", 0, 1),
+        BitField("install", 0, 1),
+        BitField("res", 0, 2),
+        BitEnumField("key_type", 0, 1, {0: "Group/SMK", 1: "Pairwise"}),
+        BitEnumField("key_descriptor_type_version", 0, 3, {
+            1: "HMAC-MD5+ARC4",
+            2: "HMAC-SHA1-128+AES-128",
+            3: "AES-128-CMAC+AES-128",
+        }),
+        #
+        LenField("key_length", None, "H"),
+        LongField("key_replay_counter", 0),
+        XStrFixedLenField("key_nonce", "", 32),
+        XStrFixedLenField("key_iv", "", 16),
+        XStrFixedLenField("key_rsc", "", 8),
+        XStrFixedLenField("key_id", "", 8),
+        XStrFixedLenField("key_mic", "", 16),  # XXX size can be 24
+        FieldLenField("key_data_length", None, length_of="key_data"),
+        XStrLenField("key_data", "",
+                     length_from=lambda pkt: pkt.key_data_length)
+    ]
+
+    def extract_padding(self, s):
+        return s[:self.key_length], s[self.key_length:]
+
+    def hashret(self):
+        return struct.pack("!B", self.type) + self.payload.hashret()
+
+    def answers(self, other):
+        if isinstance(other, EAPOL_KEY) and \
+                other.descriptor_type == self.descriptor_type:
+            return 1
+        return 0
+
+    def guess_key_number(self):
+        """
+        Determines 4-way handshake key number
+
+        :return: key number (1-4), or 0 if it cannot be determined
+        """
+        if self.key_type == 1:
+            if self.key_ack == 1:
+                if self.key_mic == 0:
+                    return 1
+                if self.install == 1:
+                    return 3
+            else:
+                if self.secure == 0:
+                    return 2
+                return 4
+        return 0
+
+
+#############################################################################
 # IEEE 802.1X-2010 - MACsec Key Agreement (MKA) protocol
 #############################################################################
 
 #########################################################################
 #
 # IEEE 802.1X-2010 standard
 # Section 11.11.1
@@ -763,14 +862,18 @@
         MKAParamSetPacketListField("parameter_sets", [], MKAParamSet),
     ]
 
     def extract_padding(self, s):
         return "", s
 
 
-bind_layers(Ether, EAPOL, type=34958)
-bind_layers(Ether, EAPOL, dst='01:80:c2:00:00:03', type=34958)
-bind_layers(CookedLinux, EAPOL, proto=34958)
-bind_layers(GRE, EAPOL, proto=34958)
+# Bind EAPOL types
 bind_layers(EAPOL, EAP, type=0)
-bind_layers(SNAP, EAPOL, code=34958)
+bind_layers(EAPOL, EAPOL_KEY, type=3)
 bind_layers(EAPOL, MKAPDU, type=5)
+
+bind_bottom_up(Ether, EAPOL, type=0x888e)
+# the reserved IEEE Std 802.1X PAE address
+bind_top_down(Ether, EAPOL, dst='01:80:c2:00:00:03', type=0x888e)
+bind_layers(CookedLinux, EAPOL, proto=0x888e)
+bind_layers(SNAP, EAPOL, code=0x888e)
+bind_layers(GRE, EAPOL, proto=0x888e)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/hsrp.py` & `scapy-2.6.0rc1/scapy/layers/hsrp.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,19 +8,19 @@
 A proprietary redundancy protocol for Cisco routers.
 
 - HSRP Version 1: RFC 2281
 - HSRP Version 2:
     http://www.smartnetworks.jp/2006/02/hsrp_8_hsrp_version_2.html
 """
 
+from scapy.config import conf
 from scapy.fields import ByteEnumField, ByteField, IPField, SourceIPField, \
     StrFixedLenField, XIntField, XShortField
 from scapy.packet import Packet, bind_layers, bind_bottom_up
 from scapy.layers.inet import DestIPField, UDP
-from scapy.layers.inet6 import DestIP6Field
 
 
 class HSRP(Packet):
     name = "HSRP"
     fields_desc = [
         ByteField("version", 0),
         ByteEnumField("opcode", 0, {0: "Hello", 1: "Coup", 2: "Resign", 3: "Advertise"}),  # noqa: E501
@@ -62,8 +62,10 @@
 bind_bottom_up(UDP, HSRP, dport=1985)
 bind_bottom_up(UDP, HSRP, sport=1985)
 bind_bottom_up(UDP, HSRP, dport=2029)
 bind_bottom_up(UDP, HSRP, sport=2029)
 bind_layers(UDP, HSRP, dport=1985, sport=1985)
 bind_layers(UDP, HSRP, dport=2029, sport=2029)
 DestIPField.bind_addr(UDP, "224.0.0.2", dport=1985)
-DestIP6Field.bind_addr(UDP, "ff02::66", dport=2029)
+if conf.ipv6_enabled:
+    from scapy.layers.inet6 import DestIP6Field
+    DestIP6Field.bind_addr(UDP, "ff02::66", dport=2029)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/http.py` & `scapy-2.6.0rc1/scapy/layers/http.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,63 +15,67 @@
 Or (console only)::
 
     >>> load_layer("http")
 
 Note that this layer ISN'T loaded by default, as quite experimental for now.
 
 To follow HTTP packets streams = group packets together to get the
-whole request/answer, use ``TCPSession`` as:
+whole request/answer, use ``TCPSession`` as::
 
     >>> sniff(session=TCPSession)  # Live on-the-flow session
     >>> sniff(offline="./http_chunk.pcap", session=TCPSession)  # pcap
 
 This will decode HTTP packets using ``Content_Length`` or chunks,
 and will also decompress the packets when needed.
 Note: on failure, decompression will be ignored.
 
-You can turn auto-decompression/auto-compression off with:
+You can turn auto-decompression/auto-compression off with::
 
     >>> conf.contribs["http"]["auto_compression"] = False
 
 (Defaults to True)
 """
 
-# This file is a modified version of the former scapy_http plugin.
+# This file is a rewritten version of the former scapy_http plugin.
 # It was reimplemented for scapy 2.4.3+ using sessions, stream handling.
 # Original Authors : Steeve Barbeau, Luca Invernizzi
 
+import gzip
 import io
 import os
 import re
 import socket
 import struct
 import subprocess
 
-from scapy.base_classes import Net
-from scapy.compat import plain_str, bytes_encode, \
-    gzip_compress, gzip_decompress
+from scapy.compat import plain_str, bytes_encode
+
 from scapy.config import conf
 from scapy.consts import WINDOWS
 from scapy.error import warning, log_loading
 from scapy.fields import StrField
 from scapy.packet import Packet, bind_layers, bind_bottom_up, Raw
 from scapy.supersocket import StreamSocket
 from scapy.utils import get_temp_file, ContextManagerSubprocess
 
 from scapy.layers.inet import TCP, TCP_client
 
-from scapy.libs import six
-
 try:
     import brotli
     _is_brotli_available = True
 except ImportError:
     _is_brotli_available = False
 
 try:
+    import lzw
+    _is_lzw_available = True
+except ImportError:
+    _is_lzw_available = False
+
+try:
     import zstandard
     _is_zstd_available = True
 except ImportError:
     _is_zstd_available = False
 
 if "http" not in conf.contribs:
     conf.contribs["http"] = {}
@@ -257,20 +261,22 @@
         stripped_name = _strip_header_name(f.name).lower()
         try:
             _, value = headers.pop(stripped_name)
         except KeyError:
             continue
         obj.setfieldval(f.name, value)
     if headers:
-        headers = dict(six.itervalues(headers))
+        headers = dict(headers.values())
         obj.setfieldval('Unknown_Headers', headers)
     return first_line, body
 
 
 class _HTTPContent(Packet):
+    __slots__ = ["_original_len"]
+
     # https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Transfer-Encoding
     def _get_encodings(self):
         encodings = []
         if isinstance(self, HTTPResponse):
             if self.Transfer_Encoding:
                 encodings += [plain_str(x).strip().lower() for x in
                               plain_str(self.Transfer_Encoding).split(",")]
@@ -279,14 +285,15 @@
                               plain_str(self.Content_Encoding).split(",")]
         return encodings
 
     def hashret(self):
         return b"HTTP1"
 
     def post_dissect(self, s):
+        self._original_len = len(s)
         if not conf.contribs["http"]["auto_compression"]:
             return s
         encodings = self._get_encodings()
         # Un-chunkify
         if "chunked" in encodings:
             data = b""
             while s:
@@ -307,18 +314,23 @@
                 s = data
         # Decompress
         try:
             if "deflate" in encodings:
                 import zlib
                 s = zlib.decompress(s)
             elif "gzip" in encodings:
-                s = gzip_decompress(s)
+                s = gzip.decompress(s)
             elif "compress" in encodings:
-                import lzw
-                s = lzw.decompress(s)
+                if _is_lzw_available:
+                    s = lzw.decompress(s)
+                else:
+                    log_loading.info(
+                        "Can't import lzw. compress decompression "
+                        "will be ignored !"
+                    )
             elif "br" in encodings:
                 if _is_brotli_available:
                     s = brotli.decompress(s)
                 else:
                     log_loading.info(
                         "Can't import brotli. brotli decompression "
                         "will be ignored !"
@@ -346,18 +358,23 @@
             return pkt + pay
         encodings = self._get_encodings()
         # Compress
         if "deflate" in encodings:
             import zlib
             pay = zlib.compress(pay)
         elif "gzip" in encodings:
-            pay = gzip_compress(pay)
+            pay = gzip.compress(pay)
         elif "compress" in encodings:
-            import lzw
-            pay = lzw.compress(pay)
+            if _is_lzw_available:
+                pay = lzw.compress(pay)
+            else:
+                log_loading.info(
+                    "Can't import lzw. compress compression "
+                    "will be ignored !"
+                )
         elif "br" in encodings:
             if _is_brotli_available:
                 pay = brotli.compress(pay)
             else:
                 log_loading.info(
                     "Can't import brotli. brotli compression will "
                     "be ignored !"
@@ -380,56 +397,52 @@
                 "An HTTPResponse/HTTPRequest should always be below an HTTP"
             )
         # Check for cache
         if self.raw_packet_cache is not None:
             return self.raw_packet_cache
         p = b""
         # Walk all the fields, in order
-        for f in self.fields_desc:
+        for i, f in enumerate(self.fields_desc):
             if f.name == "Unknown_Headers":
                 continue
             # Get the field value
             val = self.getfieldval(f.name)
             if not val:
                 # Not specified. Skip
                 continue
-            if f.name not in ['Method', 'Path', 'Reason_Phrase',
-                              'Http_Version', 'Status_Code']:
+
+            if i >= 3:
                 val = _header_line(f.real_name, val)
             # Fields used in the first line have a space as a separator,
             # whereas headers are terminated by a new line
-            if isinstance(self, HTTPRequest):
-                if f.name in ['Method', 'Path']:
-                    separator = b' '
-                else:
-                    separator = b'\r\n'
-            elif isinstance(self, HTTPResponse):
-                if f.name in ['Http_Version', 'Status_Code']:
-                    separator = b' '
-                else:
-                    separator = b'\r\n'
+            if i <= 1:
+                separator = b' '
+            else:
+                separator = b'\r\n'
             # Add the field into the packet
             p = f.addfield(self, p, val + separator)
         # Handle Unknown_Headers
         if self.Unknown_Headers:
             headers_text = b""
-            for name, value in six.iteritems(self.Unknown_Headers):
+            for name, value in self.Unknown_Headers.items():
                 headers_text += _header_line(name, value) + b"\r\n"
             p = self.get_field("Unknown_Headers").addfield(
                 self, p, headers_text
             )
         # The packet might be empty, and in that case it should stay empty.
         if p:
             # Add an additional line after the last header
             p = f.addfield(self, p, b'\r\n')
         return p
 
     def guess_payload_class(self, payload):
         """Detect potential payloads
         """
+        if not hasattr(self, "Connection"):
+            return super(_HTTPContent, self).guess_payload_class(payload)
         if self.Connection and b"Upgrade" in self.Connection:
             from scapy.contrib.http2 import H2Frame
             return H2Frame
         return super(_HTTPContent, self).guess_payload_class(payload)
 
 
 class _HTTPHeaderField(StrField):
@@ -546,14 +559,27 @@
 # General HTTP class + defragmentation
 
 
 class HTTP(Packet):
     name = "HTTP 1"
     fields_desc = []
     show_indent = 0
+    clsreq = HTTPRequest
+    clsresp = HTTPResponse
+    hdr = b"HTTP"
+    reqmethods = b"|".join([
+        b"OPTIONS",
+        b"GET",
+        b"HEAD",
+        b"POST",
+        b"PUT",
+        b"DELETE",
+        b"TRACE",
+        b"CONNECT",
+    ])
 
     @classmethod
     def dispatch_hook(cls, _pkt=None, *args, **kargs):
         if _pkt and len(_pkt) >= 9:
             from scapy.contrib.http2 import _HTTP2_types, H2Frame
             # To detect a valid HTTP2, we check that the type is correct
             # that the Reserved bit is set and length makes sense.
@@ -577,44 +603,51 @@
         return cls
 
     # tcp_reassemble is used by TCPSession in session.py
     @classmethod
     def tcp_reassemble(cls, data, metadata, _):
         detect_end = metadata.get("detect_end", None)
         is_unknown = metadata.get("detect_unknown", True)
+        # General idea of the following is explained at
+        # https://datatracker.ietf.org/doc/html/rfc2616#section-4.4
         if not detect_end or is_unknown:
             metadata["detect_unknown"] = False
-            http_packet = HTTP(data)
+            http_packet = cls(data)
             # Detect packing method
             if not isinstance(http_packet.payload, _HTTPContent):
                 return http_packet
+            is_response = isinstance(http_packet.payload, cls.clsresp)
+            # Packets may have a Content-Length we must honnor
             length = http_packet.Content_Length
-            if length is not None:
+            # Heuristic to try and detect instant HEAD responses, as those include a
+            # Content-Length that must not be honored.
+            if is_response and data.endswith(b"\r\n\r\n"):
+                detect_end = lambda _: True
+            elif length is not None:
                 # The packet provides a Content-Length attribute: let's
                 # use it. When the total size of the frags is high enough,
                 # we have the packet
                 length = int(length)
                 # Subtract the length of the "HTTP*" layer
                 if http_packet.payload.payload or length == 0:
-                    http_length = len(data) - len(http_packet.payload.payload)
+                    http_length = len(data) - http_packet.payload._original_len
                     detect_end = lambda dat: len(dat) - http_length >= length
                 else:
                     # The HTTP layer isn't fully received.
                     detect_end = lambda dat: False
                     metadata["detect_unknown"] = True
             else:
                 # It's not Content-Length based. It could be chunked
-                encodings = http_packet[HTTP].payload._get_encodings()
+                encodings = http_packet[cls].payload._get_encodings()
                 chunked = ("chunked" in encodings)
-                is_response = isinstance(http_packet.payload, HTTPResponse)
                 if chunked:
                     detect_end = lambda dat: dat.endswith(b"0\r\n\r\n")
                 # HTTP Requests that do not have any content,
-                # end with a double CRLF
-                elif isinstance(http_packet.payload, HTTPRequest):
+                # end with a double CRLF. Same for HEAD responses
+                elif isinstance(http_packet.payload, cls.clsreq):
                     detect_end = lambda dat: dat.endswith(b"\r\n\r\n")
                     # In case we are handling a HTTP Request,
                     # we want to continue assessing the data,
                     # to handle requests with a body (POST)
                     metadata["detect_unknown"] = True
                 elif is_response and http_packet.Status_Code == b"101":
                     # If it's an upgrade response, it may also hold a
@@ -628,66 +661,62 @@
                     detect_end = lambda dat: metadata.get("tcp_end", False)
                     metadata["detect_unknown"] = True
             metadata["detect_end"] = detect_end
             if detect_end(data):
                 return http_packet
         else:
             if detect_end(data):
-                http_packet = HTTP(data)
+                http_packet = cls(data)
                 return http_packet
 
     def guess_payload_class(self, payload):
         """Decides if the payload is an HTTP Request or Response, or
         something else.
         """
         try:
             prog = re.compile(
-                br"^(?:OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT) "
-                br"(?:.+?) "
-                br"HTTP/\d\.\d$"
+                br"^(?:" + self.reqmethods + br") " +
+                br"(?:.+?) " +
+                self.hdr + br"/\d\.\d$"
             )
             crlfIndex = payload.index(b"\r\n")
             req = payload[:crlfIndex]
             result = prog.match(req)
             if result:
-                return HTTPRequest
+                return self.clsreq
             else:
-                prog = re.compile(br"^HTTP/\d\.\d \d\d\d .*$")
+                prog = re.compile(b"^" + self.hdr + br"/\d\.\d \d\d\d .*$")
                 result = prog.match(req)
                 if result:
-                    return HTTPResponse
+                    return self.clsresp
         except ValueError:
             # Anything that isn't HTTP but on port 80
             pass
         return Raw
 
 
 def http_request(host, path="/", port=80, timeout=3,
                  display=False, verbose=0,
-                 raw=False, iptables=False, iface=None,
+                 raw=False, iface=None,
                  **headers):
     """Util to perform an HTTP request, using the TCP_client.
 
     :param host: the host to connect to
     :param path: the path of the request (default /)
     :param port: the port (default 80)
     :param timeout: timeout before None is returned
     :param display: display the result in the default browser (default False)
     :param raw: opens a raw socket instead of going through the OS's TCP
                 socket. Scapy will then use its own TCP client.
                 Careful, the OS might cancel the TCP connection with RST.
-    :param iptables: when raw is enabled, this calls iptables to temporarily
-                     prevent the OS from sending TCP RST to the host IP.
-                     On Linux, you'll almost certainly need this.
     :param iface: interface to use. Changing this turns on "raw"
     :param headers: any additional headers passed to the request
 
     :returns: the HTTPResponse packet
     """
-    from scapy.sessions import TCPSession
     http_headers = {
         "Accept_Encoding": b'gzip, deflate',
         "Cache_Control": b'no-cache',
         "Pragma": b'no-cache',
         "Connection": b'keep-alive',
         "Host": host,
         "Path": path,
@@ -696,39 +725,30 @@
     req = HTTP() / HTTPRequest(**http_headers)
     ans = None
 
     # Open a socket
     if iface is not None:
         raw = True
     if raw:
-        # Use TCP_client on a raw socket
-        iptables_rule = "iptables -%c INPUT -s %s -p tcp --sport 80 -j DROP"
-        if iptables:
-            host = str(Net(host))
-            assert os.system(iptables_rule % ('A', host)) == 0
         sock = TCP_client.tcplink(HTTP, host, port, debug=verbose,
                                   iface=iface)
     else:
         # Use a native TCP socket
         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         sock.connect((host, port))
         sock = StreamSocket(sock, HTTP)
     # Send the request and wait for the answer
     try:
         ans = sock.sr1(
             req,
-            session=TCPSession(app=True),
             timeout=timeout,
             verbose=verbose
         )
     finally:
         sock.close()
-        if raw and iptables:
-            host = str(Net(host))
-            assert os.system(iptables_rule % ('D', host)) == 0
     if ans:
         if display:
             if Raw not in ans:
                 warning("No HTTP content returned. Cannot display")
                 return ans
             # Write file
             file = get_temp_file(autoext=".html")
```

### Comparing `scapy-2.5.0rc3/scapy/layers/inet.py` & `scapy-2.6.0rc1/scapy/layers/inet.py`

 * *Files 6% similar despite different names*

```diff
@@ -17,55 +17,65 @@
 
 from scapy.utils import checksum, do_graph, incremental_label, \
     linehexdump, strxor, whois, colgen
 from scapy.ansmachine import AnsweringMachine
 from scapy.base_classes import Gen, Net
 from scapy.data import ETH_P_IP, ETH_P_ALL, DLT_RAW, DLT_RAW_ALT, DLT_IPV4, \
     IP_PROTOS, TCP_SERVICES, UDP_SERVICES
-from scapy.layers.l2 import Ether, Dot3, getmacbyip, CookedLinux, GRE, SNAP, \
-    Loopback
+from scapy.layers.l2 import (
+    CookedLinux,
+    Dot3,
+    Ether,
+    GRE,
+    Loopback,
+    SNAP,
+    arpcachepoison,
+    getmacbyip,
+)
 from scapy.compat import raw, chb, orb, bytes_encode, Optional
 from scapy.config import conf
 from scapy.fields import (
     BitEnumField,
     BitField,
     ByteEnumField,
     ByteField,
     ConditionalField,
     DestField,
     Emph,
     FieldLenField,
     FieldListField,
     FlagsField,
     IPField,
+    IP6Field,
     IntField,
+    MayEnd,
     MultiEnumField,
     MultipleTypeField,
+    PacketField,
     PacketListField,
     ShortEnumField,
     ShortField,
     SourceIPField,
     StrField,
     StrFixedLenField,
     StrLenField,
+    TrailerField,
     XByteField,
     XShortField,
 )
 from scapy.packet import Packet, bind_layers, bind_bottom_up, NoPayload
 from scapy.volatile import RandShort, RandInt, RandBin, RandNum, VolatileValue
 from scapy.sendrecv import sr, sr1
 from scapy.plist import _PacketList, PacketList, SndRcvList
 from scapy.automaton import Automaton, ATMT
 from scapy.error import log_runtime, warning
 from scapy.pton_ntop import inet_pton
 
 import scapy.as_resolvers
 
-import scapy.libs.six as six
-
 ####################
 #  IP Tools class  #
 ####################
 
 
 class IPTools(object):
     """Add more powers to a class with an "src" attribute."""
@@ -346,15 +356,15 @@
         self.size = size
 
     def _fix(self):
         # Pseudo-Random amount of options
         # Random ("NAME", fmt)
         rand_patterns = [
             random.choice(list(
-                (opt, fmt) for opt, fmt in six.itervalues(TCPOptions[0])
+                (opt, fmt) for opt, fmt in TCPOptions[0].values()
                 if opt != 'EOL'
             ))
             for _ in range(self.size)
         ]
         rand_vals = []
         for oname, fmt in rand_patterns:
             if fmt is None:
@@ -517,15 +527,14 @@
     def i2h(self, pkt, x):
         if x is None:
             x = self.dst_from_pkt(pkt)
         return IPField.i2h(self, pkt, x)
 
 
 class IP(Packet, IPTools):
-    __slots__ = ["_defrag_pos"]
     name = "IP"
     fields_desc = [BitField("version", 4, 4),
                    BitField("ihl", None, 4),
                    XByteField("tos", 0),
                    ShortField("len", None),
                    ShortField("id", 1),
                    FlagsField("flags", 0, 3, ["MF", "DF", "evil"]),
@@ -615,56 +624,26 @@
         s = self.sprintf("%IP.src% > %IP.dst% %IP.proto%")
         if self.frag:
             s += " frag:%i" % self.frag
         return s
 
     def fragment(self, fragsize=1480):
         """Fragment IP datagrams"""
-        lastfragsz = fragsize
-        fragsize -= fragsize % 8
-        lst = []
-        fnb = 0
-        fl = self
-        while fl.underlayer is not None:
-            fnb += 1
-            fl = fl.underlayer
-
-        for p in fl:
-            s = raw(p[fnb].payload)
-            if len(s) <= lastfragsz:
-                lst.append(p)
-                continue
-
-            nb = (len(s) - lastfragsz + fragsize - 1) // fragsize + 1
-            for i in range(nb):
-                q = p.copy()
-                del q[fnb].payload
-                del q[fnb].chksum
-                del q[fnb].len
-                if i != nb - 1:
-                    q[fnb].flags |= 1
-                    fragend = (i + 1) * fragsize
-                else:
-                    fragend = i * fragsize + lastfragsz
-                q[fnb].frag += i * fragsize // 8
-                r = conf.raw_layer(load=s[i * fragsize:fragend])
-                r.overload_fields = p[fnb].payload.overload_fields.copy()
-                q.add_payload(r)
-                lst.append(q)
-        return lst
+        return fragment(self, fragsize=fragsize)
 
 
 def in4_pseudoheader(proto, u, plen):
     # type: (int, IP, int) -> bytes
     """IPv4 Pseudo Header as defined in RFC793 as bytes
 
     :param proto: value of upper layer protocol
     :param u: IP layer instance
     :param plen: the length of the upper layer and payload
     """
+    u = u.copy()
     if u.len is not None:
         if u.ihl is None:
             olen = sum(len(x) for x in u.options)
             ihl = 5 + olen // 4 + (1 if olen % 4 else 0)
         else:
             ihl = u.ihl
         ln = max(u.len - 4 * ihl, 0)
@@ -691,15 +670,15 @@
                        ln)
 
 
 def in4_chksum(proto, u, p):
     # type: (int, IP, bytes) -> int
     """IPv4 Pseudo Header checksum as defined in RFC793
 
-    :param nh: value of upper layer protocol
+    :param proto: value of upper layer protocol
     :param u: upper layer instance
     :param p: the payload of the upper layer provided as a string
     """
     if not isinstance(u, IP):
         warning("No IP underlayer to compute checksum. Leaving null.")
         return 0
     psdhdr = in4_pseudoheader(proto, u, len(p))
@@ -885,14 +864,193 @@
             return self.underlayer.sprintf("UDP %IP.src%:%UDP.sport% > %IP.dst%:%UDP.dport%")  # noqa: E501
         elif isinstance(self.underlayer, scapy.layers.inet6.IPv6):
             return self.underlayer.sprintf("UDP %IPv6.src%:%UDP.sport% > %IPv6.dst%:%UDP.dport%")  # noqa: E501
         else:
             return self.sprintf("UDP %UDP.sport% > %UDP.dport%")
 
 
+# RFC 4884 ICMP extensions
+_ICMP_classnums = {
+    # https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-ext-classes
+    1: "MPLS",
+    2: "Interface Information",
+    3: "Interface Identification",
+    4: "Extended Information",
+}
+
+
+class ICMPExtension_Object(Packet):
+    name = "ICMP Extension Object"
+    show_indent = 0
+    fields_desc = [
+        ShortField("len", None),
+        ByteEnumField("classnum", 0, _ICMP_classnums),
+        ByteField("classtype", 0),
+    ]
+
+    def post_build(self, p, pay):
+        if self.len is None:
+            tmp_len = len(p) + len(pay)
+            p = struct.pack("!H", tmp_len) + p[2:]
+        return p + pay
+
+    registered_icmp_exts = {}
+
+    @classmethod
+    def register_variant(cls):
+        cls.registered_icmp_exts[cls.classnum.default] = cls
+
+    @classmethod
+    def dispatch_hook(cls, _pkt=None, *args, **kargs):
+        if _pkt and len(_pkt) >= 4:
+            classnum = _pkt[2]
+            if classnum in cls.registered_icmp_exts:
+                return cls.registered_icmp_exts[classnum]
+        return cls
+
+
+class ICMPExtension_InterfaceInformation(ICMPExtension_Object):
+    name = "ICMP Extension Object - Interface Information Object (RFC5837)"
+
+    fields_desc = [
+        ShortField("len", None),
+        ByteEnumField("classnum", 2, _ICMP_classnums),
+        BitField("classtype", 0, 2),
+        BitField("reserved", 0, 2),
+        BitField("has_ifindex", 0, 1),
+        BitField("has_ipaddr", 0, 1),
+        BitField("has_ifname", 0, 1),
+        BitField("has_mtu", 0, 1),
+        ConditionalField(IntField("ifindex", None), lambda pkt: pkt.has_ifindex == 1),
+        ConditionalField(ShortField("afi", None), lambda pkt: pkt.has_ipaddr == 1),
+        ConditionalField(ShortField("reserved2", 0), lambda pkt: pkt.has_ipaddr == 1),
+        ConditionalField(IPField("ip4", None), lambda pkt: pkt.afi == 1),
+        ConditionalField(IP6Field("ip6", None), lambda pkt: pkt.afi == 2),
+        ConditionalField(
+            FieldLenField("ifname_len", None, fmt="B", length_of="ifname"),
+            lambda pkt: pkt.has_ifname == 1,
+        ),
+        ConditionalField(
+            StrLenField("ifname", None, length_from=lambda pkt: pkt.ifname_len),
+            lambda pkt: pkt.has_ifname == 1,
+        ),
+        ConditionalField(IntField("mtu", None), lambda pkt: pkt.has_mtu == 1),
+    ]
+
+    def self_build(self, **kwargs):
+        if self.afi is None:
+            if self.ip4 is not None:
+                self.afi = 1
+            elif self.ip6 is not None:
+                self.afi = 2
+        return ICMPExtension_Object.self_build(self, **kwargs)
+
+
+class ICMPExtension_Header(Packet):
+    r"""
+    ICMP Extension per RFC4884.
+
+    Example::
+
+        pkt = IP(dst="127.0.0.1", src="127.0.0.1") / ICMP(
+            type="time-exceeded",
+            code="ttl-zero-during-transit",
+            ext=ICMPExtension_Header() / ICMPExtension_InterfaceInformation(
+                has_ifindex=1,
+                has_ipaddr=1,
+                has_ifname=1,
+                ip4="10.10.10.10",
+                ifname="hey",
+            )
+        ) / IPerror(src="12.4.4.4", dst="12.1.1.1") / \
+            UDPerror(sport=42315, dport=33440) /  \
+            b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
+    """
+
+    name = "ICMP Extension Header (RFC4884)"
+    show_indent = 0
+    fields_desc = [
+        BitField("version", 2, 4),
+        BitField("reserved", 0, 12),
+        XShortField("chksum", None),
+    ]
+
+    _min_ieo_len = len(ICMPExtension_Object())
+
+    def post_build(self, p, pay):
+        p += pay
+        if self.chksum is None:
+            ck = checksum(p)
+            p = p[:2] + chb(ck >> 8) + chb(ck & 0xFF) + p[4:]
+        return p
+
+    def guess_payload_class(self, payload):
+        if len(payload) < self._min_ieo_len:
+            return Packet.guess_payload_class(self, payload)
+        return ICMPExtension_Object
+
+
+class _ICMPExtensionField(TrailerField):
+    # We use a TrailerField for building only. Dissection is normal.
+
+    def __init__(self):
+        super(_ICMPExtensionField, self).__init__(
+            PacketField(
+                "ext",
+                None,
+                ICMPExtension_Header,
+            ),
+        )
+
+    def getfield(self, pkt, s):
+        # RFC4884 section 5.2 says if the ICMP packet length
+        # is >144 then ICMP extensions start at byte 137.
+        if len(pkt.original) < 144:
+            return s, None
+        offset = 136 + len(s) - len(pkt.original)
+        data = s[offset:]
+        # Validate checksum
+        if checksum(data) == data[3:5]:
+            return s, None  # failed
+        # Dissect
+        return s[:offset], ICMPExtension_Header(data)
+
+    def addfield(self, pkt, s, val):
+        if val is None:
+            return s
+        data = bytes(val)
+        # Calc how much padding we need, not how much we deserve
+        pad = 136 - len(pkt.payload) - len(s)
+        if pad < 0:
+            warning("ICMPExtension_Header is after the 136th octet of ICMP.")
+            return data
+        return super(_ICMPExtensionField, self).addfield(pkt, s, b"\x00" * pad + data)
+
+
+class _ICMPExtensionPadField(TrailerField):
+    def __init__(self):
+        super(_ICMPExtensionPadField, self).__init__(
+            StrFixedLenField("extpad", "", length=0)
+        )
+
+    def i2repr(self, pkt, s):
+        if s and s == b"\x00" * len(s):
+            return "b'' (%s octets)" % len(s)
+        return self.fld.i2repr(pkt, s)
+
+
+def _ICMP_extpad_post_dissection(self, pkt):
+    # If we have padding, put it in 'extpad' for re-build
+    if pkt.ext:
+        pad = pkt.lastlayer()
+        if isinstance(pad, conf.padding_layer):
+            pad.underlayer.remove_payload()
+            pkt.extpad = pad.load
+
+
 icmptypes = {0: "echo-reply",
              3: "dest-unreach",
              4: "source-quench",
              5: "redirect",
              8: "echo-request",
              9: "router-advertisement",
              10: "router-solicitation",
@@ -944,43 +1102,107 @@
                   1: "authentication-failed",
                   2: "decompression-failed",
                   3: "decryption-failed",
                   4: "need-authentification",
                   5: "need-authorization", }, }
 
 
+_icmp_answers = [
+    (8, 0),
+    (13, 14),
+    (15, 16),
+    (17, 18),
+    (33, 34),
+    (35, 36),
+    (37, 38),
+]
+
 icmp_id_seq_types = [0, 8, 13, 14, 15, 16, 17, 18, 37, 38]
 
 
 class ICMP(Packet):
     name = "ICMP"
-    fields_desc = [ByteEnumField("type", 8, icmptypes),
-                   MultiEnumField("code", 0, icmpcodes, depends_on=lambda pkt:pkt.type, fmt="B"),  # noqa: E501
-                   XShortField("chksum", None),
-                   ConditionalField(XShortField("id", 0), lambda pkt:pkt.type in icmp_id_seq_types),  # noqa: E501
-                   ConditionalField(XShortField("seq", 0), lambda pkt:pkt.type in icmp_id_seq_types),  # noqa: E501
-                   ConditionalField(ICMPTimeStampField("ts_ori", None), lambda pkt:pkt.type in [13, 14]),  # noqa: E501
-                   ConditionalField(ICMPTimeStampField("ts_rx", None), lambda pkt:pkt.type in [13, 14]),  # noqa: E501
-                   ConditionalField(ICMPTimeStampField("ts_tx", None), lambda pkt:pkt.type in [13, 14]),  # noqa: E501
-                   ConditionalField(IPField("gw", "0.0.0.0"), lambda pkt:pkt.type == 5),  # noqa: E501
-                   ConditionalField(ByteField("ptr", 0), lambda pkt:pkt.type == 12),  # noqa: E501
-                   ConditionalField(ByteField("reserved", 0), lambda pkt:pkt.type in [3, 11]),  # noqa: E501
-                   ConditionalField(ByteField("length", 0), lambda pkt:pkt.type in [3, 11, 12]),  # noqa: E501
-                   ConditionalField(IPField("addr_mask", "0.0.0.0"), lambda pkt:pkt.type in [17, 18]),  # noqa: E501
-                   ConditionalField(ShortField("nexthopmtu", 0), lambda pkt:pkt.type == 3),  # noqa: E501
-                   MultipleTypeField(
-                       [
-                           (ShortField("unused", 0),
-                               lambda pkt:pkt.type in [11, 12]),
-                           (IntField("unused", 0),
-                               lambda pkt:pkt.type not in [0, 3, 5, 8, 11, 12,
-                                                           13, 14, 15, 16, 17,
-                                                           18])
-                       ], StrFixedLenField("unused", "", length=0)),
-                   ]
+    fields_desc = [
+        ByteEnumField("type", 8, icmptypes),
+        MultiEnumField("code", 0, icmpcodes,
+                       depends_on=lambda pkt:pkt.type, fmt="B"),
+        XShortField("chksum", None),
+        ConditionalField(
+            XShortField("id", 0),
+            lambda pkt: pkt.type in icmp_id_seq_types
+        ),
+        ConditionalField(
+            XShortField("seq", 0),
+            lambda pkt: pkt.type in icmp_id_seq_types
+        ),
+        ConditionalField(
+            # Timestamp only (RFC792)
+            ICMPTimeStampField("ts_ori", None),
+            lambda pkt: pkt.type in [13, 14]
+        ),
+        ConditionalField(
+            # Timestamp only (RFC792)
+            ICMPTimeStampField("ts_rx", None),
+            lambda pkt: pkt.type in [13, 14]
+        ),
+        ConditionalField(
+            # Timestamp only (RFC792)
+            ICMPTimeStampField("ts_tx", None),
+            lambda pkt: pkt.type in [13, 14]
+        ),
+        ConditionalField(
+            # Redirect only (RFC792)
+            IPField("gw", "0.0.0.0"),
+            lambda pkt: pkt.type == 5
+        ),
+        ConditionalField(
+            # Parameter problem only (RFC792)
+            ByteField("ptr", 0),
+            lambda pkt: pkt.type == 12
+        ),
+        ConditionalField(
+            ByteField("reserved", 0),
+            lambda pkt: pkt.type in [3, 11]
+        ),
+        ConditionalField(
+            ByteField("length", 0),
+            lambda pkt: pkt.type in [3, 11, 12]
+        ),
+        ConditionalField(
+            IPField("addr_mask", "0.0.0.0"),
+            lambda pkt: pkt.type in [17, 18]
+        ),
+        ConditionalField(
+            ShortField("nexthopmtu", 0),
+            lambda pkt: pkt.type == 3
+        ),
+        MultipleTypeField(
+            [
+                (ShortField("unused", 0),
+                    lambda pkt:pkt.type in [11, 12]),
+                (IntField("unused", 0),
+                    lambda pkt:pkt.type not in [0, 3, 5, 8, 11, 12,
+                                                13, 14, 15, 16, 17,
+                                                18])
+            ],
+            StrFixedLenField("unused", "", length=0),
+        ),
+        # RFC4884 ICMP extension
+        ConditionalField(
+            _ICMPExtensionPadField(),
+            lambda pkt: pkt.type in [3, 11, 12],
+        ),
+        ConditionalField(
+            _ICMPExtensionField(),
+            lambda pkt: pkt.type in [3, 11, 12],
+        ),
+    ]
+
+    # To handle extpad
+    post_dissection = _ICMP_extpad_post_dissection
 
     def post_build(self, p, pay):
         p += pay
         if self.chksum is None:
             ck = checksum(p)
             p = p[:2] + chb(ck >> 8) + chb(ck & 0xff) + p[4:]
         return p
@@ -989,33 +1211,40 @@
         if self.type in icmp_id_seq_types:
             return struct.pack("HH", self.id, self.seq) + self.payload.hashret()  # noqa: E501
         return self.payload.hashret()
 
     def answers(self, other):
         if not isinstance(other, ICMP):
             return 0
-        if ((other.type, self.type) in [(8, 0), (13, 14), (15, 16), (17, 18), (33, 34), (35, 36), (37, 38)] and  # noqa: E501
+        if ((other.type, self.type) in _icmp_answers and
             self.id == other.id and
                 self.seq == other.seq):
             return 1
         return 0
 
     def guess_payload_class(self, payload):
         if self.type in [3, 4, 5, 11, 12]:
             return IPerror
         else:
             return None
 
     def mysummary(self):
+        extra = ""
+        if self.ext:
+            extra = self.ext.payload.sprintf(" ext:%classnum%")
         if isinstance(self.underlayer, IP):
-            return self.underlayer.sprintf("ICMP %IP.src% > %IP.dst% %ICMP.type% %ICMP.code%")  # noqa: E501
+            return self.underlayer.sprintf(
+                "ICMP %IP.src% > %IP.dst% %ICMP.type% %ICMP.code%"
+            ) + extra
         else:
-            return self.sprintf("ICMP %ICMP.type% %ICMP.code%")
+            return self.sprintf("ICMP %ICMP.type% %ICMP.code%") + extra
 
 
+# IP / TCP / UDP error packets
+
 class IPerror(IP):
     name = "IP in ICMP"
 
     def answers(self, other):
         if not isinstance(other, IP):
             return 0
 
@@ -1037,14 +1266,20 @@
 
     def mysummary(self):
         return Packet.mysummary(self)
 
 
 class TCPerror(TCP):
     name = "TCP in ICMP"
+    fields_desc = (
+        TCP.fields_desc[:2] +
+        # MayEnd after the 8 first octets.
+        [MayEnd(TCP.fields_desc[2])] +
+        TCP.fields_desc[3:]
+    )
 
     def answers(self, other):
         if not isinstance(other, TCP):
             return 0
         if conf.checkIPsrc:
             if not ((self.sport == other.sport) and
                     (self.dport == other.dport)):
@@ -1111,38 +1346,45 @@
 bind_layers(IPerror, TCPerror, frag=0, proto=6)
 bind_layers(IPerror, UDPerror, frag=0, proto=17)
 bind_layers(IP, IP, frag=0, proto=4)
 bind_layers(IP, ICMP, frag=0, proto=1)
 bind_layers(IP, TCP, frag=0, proto=6)
 bind_layers(IP, UDP, frag=0, proto=17)
 bind_layers(IP, GRE, frag=0, proto=47)
+bind_layers(UDP, GRE, dport=4754)
 
 conf.l2types.register(DLT_RAW, IP)
 conf.l2types.register_num2layer(DLT_RAW_ALT, IP)
 conf.l2types.register(DLT_IPV4, IP)
 
 conf.l3types.register(ETH_P_IP, IP)
 conf.l3types.register_num2layer(ETH_P_ALL, IP)
 
 
 def inet_register_l3(l2, l3):
+    """
+    Resolves the default L2 destination address when IP is used.
+    """
     return getmacbyip(l3.dst)
 
 
 conf.neighbor.register_l3(Ether, IP, inet_register_l3)
 conf.neighbor.register_l3(Dot3, IP, inet_register_l3)
 
 
 ###################
 #  Fragmentation  #
 ###################
 
 @conf.commands.register
 def fragment(pkt, fragsize=1480):
     """Fragment a big IP datagram"""
+    if fragsize < 8:
+        warning("fragsize cannot be lower than 8")
+        fragsize = max(fragsize, 8)
     lastfragsz = fragsize
     fragsize -= fragsize % 8
     lst = []
     for p in pkt:
         s = raw(p[IP].payload)
         nb = (len(s) - lastfragsz + fragsize - 1) // fragsize + 1
         for i in range(nb):
@@ -1179,94 +1421,123 @@
     q[IP].add_payload(overlap)
 
     qfrag = fragment(q, overlap_fragsize)
     qfrag[-1][IP].flags |= 1
     return qfrag + fragment(p, fragsize)
 
 
-def _defrag_list(lst, defrag, missfrag):
-    """Internal usage only. Part of the _defrag_logic"""
-    p = lst[0]
-    lastp = lst[-1]
-    if p.frag > 0 or lastp.flags.MF:  # first or last fragment missing
-        missfrag.extend(lst)
-        return
-    p = p.copy()
-    if conf.padding_layer in p:
-        del p[conf.padding_layer].underlayer.payload
-    ip = p[IP]
-    if ip.len is None or ip.ihl is None:
-        c_len = len(ip.payload)
-    else:
-        c_len = ip.len - (ip.ihl << 2)
-    txt = conf.raw_layer()
-    for q in lst[1:]:
-        if c_len != q.frag << 3:  # Wrong fragmentation offset
-            if c_len > q.frag << 3:
-                warning("Fragment overlap (%i > %i) %r || %r ||  %r" % (c_len, q.frag << 3, p, txt, q))  # noqa: E501
-            missfrag.extend(lst)
-            break
-        if q[IP].len is None or q[IP].ihl is None:
-            c_len += len(q[IP].payload)
+class BadFragments(ValueError):
+    def __init__(self, *args, **kwargs):
+        self.frags = kwargs.pop("frags", None)
+        super(BadFragments, self).__init__(*args, **kwargs)
+
+
+def _defrag_iter_and_check_offsets(frags):
+    """
+    Internal generator used in _defrag_ip_pkt
+    """
+    offset = 0
+    for pkt, o, length in frags:
+        if offset != o:
+            if offset > o:
+                op = ">"
+            else:
+                op = "<"
+            warning("Fragment overlap (%i %s %i) on %r" % (offset, op, o, pkt))
+            raise BadFragments
+        offset += length
+        yield bytes(pkt[IP].payload)
+
+
+def _defrag_ip_pkt(pkt, frags):
+    """
+    Defragment a single IP packet.
+
+    :param pkt: the new pkt
+    :param frags: a defaultdict(list) used for storage
+    :return: a tuple (fragmented, defragmented_value)
+    """
+    ip = pkt[IP]
+    if pkt.frag != 0 or ip.flags.MF:
+        # fragmented !
+        uid = (ip.id, ip.src, ip.dst, ip.proto)
+        if ip.len is None or ip.ihl is None:
+            fraglen = len(ip.payload)
         else:
-            c_len += q[IP].len - (q[IP].ihl << 2)
-        if conf.padding_layer in q:
-            del q[conf.padding_layer].underlayer.payload
-        txt.add_payload(q[IP].payload.copy())
-        if q.time > p.time:
-            p.time = q.time
-    else:
-        ip.flags.MF = False
-        del ip.chksum
-        del ip.len
-        p = p / txt
-        p._defrag_pos = max(x._defrag_pos for x in lst)
-        defrag.append(p)
+            fraglen = ip.len - (ip.ihl << 2)
+        # (pkt, frag offset, frag len)
+        frags[uid].append((pkt, ip.frag << 3, fraglen))
+        if not ip.flags.MF:  # no more fragments = last fragment
+            curfrags = sorted(frags[uid], key=lambda x: x[1])  # sort by offset
+            try:
+                data = b"".join(_defrag_iter_and_check_offsets(curfrags))
+            except ValueError:
+                # bad fragment
+                badfrags = frags[uid]
+                del frags[uid]
+                raise BadFragments(frags=badfrags)
+            # re-build initial packet without fragmentation
+            p = curfrags[0][0].copy()
+            pay_class = p[IP].payload.__class__
+            p[IP].flags.MF = False
+            p[IP].remove_payload()
+            p[IP].len = None
+            p[IP].chksum = None
+            # append defragmented payload
+            p /= pay_class(data)
+            # cleanup
+            del frags[uid]
+            return True, p
+        return True, None
+    return False, pkt
 
 
 def _defrag_logic(plist, complete=False):
-    """Internal function used to defragment a list of packets.
+    """
+    Internal function used to defragment a list of packets.
     It contains the logic behind the defrag() and defragment() functions
     """
-    frags = defaultdict(lambda: [])
+    frags = defaultdict(list)
     final = []
-    pos = 0
-    for p in plist:
-        p._defrag_pos = pos
-        pos += 1
-        if IP in p:
-            ip = p[IP]
-            if ip.frag != 0 or ip.flags.MF:
-                uniq = (ip.id, ip.src, ip.dst, ip.proto)
-                frags[uniq].append(p)
-                continue
-        final.append(p)
-
-    defrag = []
-    missfrag = []
-    for lst in six.itervalues(frags):
-        lst.sort(key=lambda x: x.frag)
-        _defrag_list(lst, defrag, missfrag)
-    defrag2 = []
-    for p in defrag:
-        q = p.__class__(raw(p))
-        q._defrag_pos = p._defrag_pos
-        q.time = p.time
-        defrag2.append(q)
+    notfrag = []
+    badfrag = []
+    # Defrag
+    for i, pkt in enumerate(plist):
+        if IP not in pkt:
+            # no IP layer
+            if complete:
+                final.append(pkt)
+            continue
+        try:
+            fragmented, defragmented_value = _defrag_ip_pkt(
+                pkt,
+                frags,
+            )
+        except BadFragments as ex:
+            if complete:
+                final.extend(ex.frags)
+            else:
+                badfrag.extend(ex.frags)
+            continue
+        if complete and defragmented_value:
+            final.append(defragmented_value)
+        elif defragmented_value:
+            if fragmented:
+                final.append(defragmented_value)
+            else:
+                notfrag.append(defragmented_value)
+    # Return
     if complete:
-        final.extend(defrag2)
-        final.extend(missfrag)
-        final.sort(key=lambda x: x._defrag_pos)
         if hasattr(plist, "listname"):
             name = "Defragmented %s" % plist.listname
         else:
             name = "Defragmented"
         return PacketList(final, name=name)
     else:
-        return PacketList(final), PacketList(defrag2), PacketList(missfrag)
+        return PacketList(notfrag), PacketList(final), PacketList(badfrag)
 
 
 @conf.commands.register
 def defrag(plist):
     """defrag(plist) -> ([not fragmented], [defragmented],
                   [ [bad fragments], [bad fragments], ... ])"""
     return _defrag_logic(plist, complete=False)
@@ -1360,17 +1631,17 @@
         for s, r in self.res:
             if IP not in s:
                 continue
             d = s[IP].dst
             if d not in trace:
                 trace[d] = {}
             trace[d][s[IP].ttl] = r[IP].src, ICMP not in r
-        for k in six.itervalues(trace):
+        for k in trace.values():
             try:
-                m = min(x for x, y in six.iteritems(k) if y[1])
+                m = min(x for x, y in k.items() if y[1])
             except ValueError:
                 continue
             for li in list(k):  # use list(): k is modified in the loop
                 if li > m:
                     del k[li]
         return trace
 
@@ -1493,20 +1764,20 @@
                     col = vpython.color.green
                 else:
                     col = vpython.color.blue
 
                 s = IPsphere(pos=vpython.vec((tmp_len - 1) * vpython.cos(2 * i * vpython.pi / tmp_len), (tmp_len - 1) * vpython.sin(2 * i * vpython.pi / tmp_len), 2 * t),  # noqa: E501
                              ip=r[i][0],
                              color=col)
-                for trlst in six.itervalues(tr3d):
+                for trlst in tr3d.values():
                     if t <= len(trlst):
                         if trlst[t - 1] == i:
                             trlst[t - 1] = s
         forecol = colgen(0.625, 0.4375, 0.25, 0.125)
-        for trlst in six.itervalues(tr3d):
+        for trlst in tr3d.values():
             col = vpython.vec(*next(forecol))
             start = vpython.vec(0, 0, 0)
             for ip in trlst:
                 vpython.cylinder(pos=start, axis=ip.pos - start, color=col, radius=0.2)  # noqa: E501
                 start = ip.pos
 
         vpython.rate(50)
@@ -1635,15 +1906,15 @@
 
         from matplotlib.collections import LineCollection
         from matplotlib import colors as mcolors
         colors_cycle = iter(mcolors.BASE_COLORS)
         lines = []
 
         # Split traceroute measurement
-        for key, trc in six.iteritems(trt):
+        for key, trc in trt.items():
             # Get next color
             color = next(colors_cycle)
             # Gather mesurments data
             data_lines = [(trc[i], trc[i + 1]) for i in range(len(trc) - 1)]
             # Create line collection
             line_col = LineCollection(data_lines, linewidths=2,
                                       label=key[1],
@@ -1886,27 +2157,30 @@
     Usage: the easiest usage is to use it as a SuperSocket.
         >>> a = TCP_client.tcplink(HTTP, "www.google.com", 80)
         >>> a.send(HTTPRequest())
         >>> a.recv()
 
     :param ip: the ip to connect to
     :param port:
+    :param src: (optional) use another source IP
     """
 
-    def parse_args(self, ip, port, *args, **kargs):
+    def parse_args(self, ip, port, srcip=None, **kargs):
         from scapy.sessions import TCPSession
         self.dst = str(Net(ip))
         self.dport = port
         self.sport = random.randrange(0, 2**16)
-        self.l4 = IP(dst=ip) / TCP(sport=self.sport, dport=self.dport, flags=0,
-                                   seq=random.randrange(0, 2**32))
+        self.l4 = IP(dst=ip, src=srcip) / TCP(
+            sport=self.sport, dport=self.dport,
+            flags=0, seq=random.randrange(0, 2**32)
+        )
         self.src = self.l4.src
         self.sack = self.l4[TCP].ack
         self.rel_seq = None
-        self.rcvbuf = TCPSession(prn=self._transmit_packet, store=False)
+        self.rcvbuf = TCPSession()
         bpf = "host %s  and host %s and port %i and port %i" % (self.src,
                                                                 self.dst,
                                                                 self.sport,
                                                                 self.dport)
         Automaton.parse_args(self, filter=bpf, **kargs)
 
     def _transmit_packet(self, pkt):
@@ -1983,15 +2257,17 @@
         if data and self.l4[TCP].ack == pkt[TCP].seq:
             self.sack = self.l4[TCP].ack
             self.l4[TCP].ack += len(data)
             self.l4[TCP].flags = "A"
             # Answer with an Ack
             self.send(self.l4)
             # Process data - will be sent to the SuperSocket through this
-            self.rcvbuf.on_packet_received(pkt)
+            pkt = self.rcvbuf.process(pkt)
+            if pkt:
+                self._transmit_packet(pkt)
 
     @ATMT.ioevent(ESTABLISHED, name="tcp", as_supersocket="tcplink")
     def outgoing_data_received(self, fd):
         raise self.ESTABLISHED().action_parameters(fd.recv())
 
     @ATMT.action(outgoing_data_received)
     def send_data(self, d):
@@ -2158,36 +2434,104 @@
                 if leak not in found:
                     found[leak] = None
                     linehexdump(leak, onlyasc=onlyasc)
     except Exception:
         pass
 
 
+@conf.commands.register
+class connect_from_ip:
+    """
+    Open a TCP socket to a host:port while spoofing another IP.
+
+    :param host: the host to connect to
+    :param port: the port to connect to
+    :param srcip: the IP to spoof. the cache of the gateway will
+                  be poisonned with this IP.
+    :param poison: (optional, default True) ARP poison the gateway (or next hop),
+                   so that it answers us (only one packet).
+    :param timeout: (optional) the socket timeout.
+
+    Example - Connect to 192.168.0.1:80 spoofing 192.168.0.2::
+
+        from scapy.layers.http import HTTP, HTTPRequest
+        client = connect_from_ip("192.168.0.1", 80, "192.168.0.2")
+        sock = SSLStreamSocket(client.sock, HTTP)
+        resp = sock.sr1(HTTP() / HTTPRequest(Path="/"))
+
+    Example - Connect to 192.168.0.1:443 with TLS wrapping spoofing 192.168.0.2::
+
+        import ssl
+        from scapy.layers.http import HTTP, HTTPRequest
+        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
+        context.check_hostname = False
+        context.verify_mode = ssl.CERT_NONE
+        client = connect_from_ip("192.168.0.1", 443, "192.168.0.2")
+        sock = context.wrap_socket(client.sock)
+        sock = SSLStreamSocket(client.sock, HTTP)
+        resp = sock.sr1(HTTP() / HTTPRequest(Path="/"))
+    """
+
+    def __init__(self, host, port, srcip, poison=True, timeout=1, debug=0):
+        host = str(Net(host))
+        if poison:
+            # poison the next hop
+            gateway = conf.route.route(host)[2]
+            if gateway == "0.0.0.0":
+                # on lan
+                gateway = host
+            getmacbyip(gateway)  # cache real gateway before poisoning
+            arpcachepoison(gateway, srcip, count=1, interval=0, verbose=0)
+        # create a socket pair
+        self._sock, self.sock = socket.socketpair()
+        self.sock.settimeout(timeout)
+        self.client = TCP_client(
+            host, port,
+            srcip=srcip,
+            external_fd={"tcp": self._sock},
+            debug=debug,
+        )
+        # start the TCP_client
+        self.client.runbg()
+
+    def close(self):
+        self.client.stop()
+        self.client.destroy()
+        self.sock.close()
+        self._sock.close()
+
+
 class ICMPEcho_am(AnsweringMachine):
     """Responds to ICMP Echo-Requests (ping)"""
     function_name = "icmpechod"
 
     def is_request(self, req):
         if req.haslayer(ICMP):
             icmp_req = req.getlayer(ICMP)
             if icmp_req.type == 8:  # echo-request
                 return True
 
         return False
 
     def print_reply(self, req, reply):
-        print("Replying %s to %s" % (reply.getlayer(IP).dst, req.dst))
+        print("Replying %s to %s" % (reply[IP].dst, req[IP].dst))
 
     def make_reply(self, req):
-        reply = IP(dst=req[IP].src) / ICMP()
+        reply = req.copy()
         reply[ICMP].type = 0  # echo-reply
-        reply[ICMP].seq = req[ICMP].seq
-        reply[ICMP].id = req[ICMP].id
         # Force re-generation of the checksum
         reply[ICMP].chksum = None
+        if req.haslayer(IP):
+            reply[IP].src, reply[IP].dst = req[IP].dst, req[IP].src
+            reply[IP].chksum = None
+        if req.haslayer(Ether):
+            reply[Ether].src, reply[Ether].dst = (
+                None if req[Ether].dst == "ff:ff:ff:ff:ff:ff" else req[Ether].dst,
+                req[Ether].src,
+            )
         return reply
 
 
 conf.stats_classic_protocols += [TCP, UDP, ICMP]
 conf.stats_dot11_protocols += [TCP, UDP, ICMP]
 
 if conf.ipv6_enabled:
```

### Comparing `scapy-2.5.0rc3/scapy/layers/inet6.py` & `scapy-2.6.0rc1/scapy/layers/inet6.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,17 +8,14 @@
 
 
 """
 IPv6 (Internet Protocol v6).
 """
 
 
-from __future__ import absolute_import
-from __future__ import print_function
-
 from hashlib import md5
 import random
 import socket
 import struct
 from time import gmtime, strftime
 
 from scapy.arch import get_if_hwaddr
@@ -33,23 +30,54 @@
     DLT_RAW_ALT,
     ETHER_ANY,
     ETH_P_ALL,
     ETH_P_IPV6,
     MTU,
 )
 from scapy.error import log_runtime, warning
-from scapy.fields import BitEnumField, BitField, ByteEnumField, ByteField, \
-    DestIP6Field, FieldLenField, FlagsField, IntField, IP6Field, \
-    LongField, MACField, PacketLenField, PacketListField, ShortEnumField, \
-    ShortField, SourceIP6Field, StrField, StrFixedLenField, StrLenField, \
-    X3BytesField, XBitField, XIntField, XShortField
-from scapy.layers.inet import IP, IPTools, TCP, TCPerror, TracerouteResult, \
-    UDP, UDPerror
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    ByteEnumField,
+    ByteField,
+    DestIP6Field,
+    FieldLenField,
+    FlagsField,
+    IntField,
+    IP6Field,
+    LongField,
+    MACField,
+    MayEnd,
+    PacketLenField,
+    PacketListField,
+    ShortEnumField,
+    ShortField,
+    SourceIP6Field,
+    StrField,
+    StrFixedLenField,
+    StrLenField,
+    X3BytesField,
+    XBitField,
+    XByteField,
+    XIntField,
+    XShortField,
+)
+from scapy.layers.inet import (
+    _ICMPExtensionField,
+    _ICMPExtensionPadField,
+    _ICMP_extpad_post_dissection,
+    IP,
+    IPTools,
+    TCP,
+    TCPerror,
+    TracerouteResult,
+    UDP,
+    UDPerror,
+)
 from scapy.layers.l2 import CookedLinux, Ether, GRE, Loopback, SNAP
-import scapy.libs.six as six
 from scapy.packet import bind_layers, Packet, Raw
 from scapy.sendrecv import sendp, sniff, sr, srp1
 from scapy.supersocket import SuperSocket
 from scapy.utils import checksum, strxor
 from scapy.pton_ntop import inet_pton, inet_ntop
 from scapy.utils6 import in6_getnsma, in6_getnsmac, in6_isaddr6to4, \
     in6_isaddrllallnodes, in6_isaddrllallservers, in6_isaddrTeredo, \
@@ -79,28 +107,31 @@
 @conf.commands.register
 def neighsol(addr, src, iface, timeout=1, chainCC=0):
     """Sends and receive an ICMPv6 Neighbor Solicitation message
 
     This function sends an ICMPv6 Neighbor Solicitation message
     to get the MAC address of the neighbor with specified IPv6 address address.
 
-    'src' address is used as source of the message. Message is sent on iface.
+    'src' address is used as the source IPv6 address of the message. Message
+    is sent on 'iface'. The source MAC address is retrieved accordingly.
+
     By default, timeout waiting for an answer is 1 second.
 
     If no answer is gathered, None is returned. Else, the answer is
     returned (ethernet frame).
     """
 
     nsma = in6_getnsma(inet_pton(socket.AF_INET6, addr))
     d = inet_ntop(socket.AF_INET6, nsma)
     dm = in6_getnsmac(nsma)
-    p = Ether(dst=dm) / IPv6(dst=d, src=src, hlim=255)
+    sm = get_if_hwaddr(iface)
+    p = Ether(dst=dm, src=sm) / IPv6(dst=d, src=src, hlim=255)
     p /= ICMPv6ND_NS(tgt=addr)
-    p /= ICMPv6NDOptSrcLLAddr(lladdr=get_if_hwaddr(iface))
-    res = srp1(p, type=ETH_P_IPV6, iface=iface, timeout=1, verbose=0,
+    p /= ICMPv6NDOptSrcLLAddr(lladdr=sm)
+    res = srp1(p, type=ETH_P_IPV6, iface=iface, timeout=timeout, verbose=0,
                chainCC=chainCC)
 
     return res
 
 
 @conf.commands.register
 def getmacbyip6(ip6, chainCC=0):
@@ -369,16 +400,16 @@
 
         if self.nh == 60 and isinstance(self.payload, IPv6ExtHdrDestOpt):
             foundhao = None
             for o in self.payload.options:
                 if isinstance(o, HAO):
                     foundhao = o
             if foundhao:
-                nh = self.payload.nh  # XXX what if another extension follows ?
                 ss = foundhao.hoa
+            nh = self.payload.nh  # XXX what if another extension follows ?
 
         if conf.checkIPsrc and conf.checkIPaddr and not in6_ismaddr(sd):
             sd = inet_pton(socket.AF_INET6, sd)
             ss = inet_pton(socket.AF_INET6, ss)
             return strxor(sd, ss) + struct.pack("B", nh) + self.payload.hashret()  # noqa: E501
         else:
             return struct.pack("B", nh) + self.payload.hashret()
@@ -426,15 +457,15 @@
         elif other.nh == 44 and isinstance(other.payload, IPv6ExtHdrFragment):
             return self.payload.answers(other.payload.payload)
         elif other.nh == 43 and isinstance(other.payload, IPv6ExtHdrRouting):
             return self.payload.answers(other.payload.payload)  # Buggy if self.payload is a IPv6ExtHdrRouting  # noqa: E501
         elif other.nh == 43 and isinstance(other.payload, IPv6ExtHdrSegmentRouting):  # noqa: E501
             return self.payload.answers(other.payload.payload)  # Buggy if self.payload is a IPv6ExtHdrRouting  # noqa: E501
         elif other.nh == 60 and isinstance(other.payload, IPv6ExtHdrDestOpt):
-            return self.payload.payload.answers(other.payload.payload)
+            return self.payload.answers(other.payload.payload)
         elif self.nh == 60 and isinstance(self.payload, IPv6ExtHdrDestOpt):  # BU in reply to BRR, for instance  # noqa: E501
             return self.payload.payload.answers(other.payload)
         else:
             if (self.nh != other.nh):
                 return False
             return self.payload.answers(other.payload)
 
@@ -451,14 +482,17 @@
                 return IPv6
         elif kargs.get("version") == 6:
             return IPv6
         return IP
 
 
 def inet6_register_l3(l2, l3):
+    """
+    Resolves the default L2 destination address when IPv6 is used.
+    """
     return getmacbyip6(l3.dst)
 
 
 conf.neighbor.register_l3(Ether, IPv6, inet6_register_l3)
 
 
 class IPerror6(IPv6):
@@ -756,14 +790,35 @@
         delta = x * ((curpos - y + x - 1) // x) + y - curpos
         return delta
 
     def extract_padding(self, p):
         return b"", p
 
 
+class RplOption(Packet):    # RFC 6553 - RPL Option
+    name = "RPL Option"
+    fields_desc = [_OTypeField("otype", 0x63, _hbhopts),
+                   ByteField("optlen", 4),
+                   BitField("Down", 0, 1),
+                   BitField("RankError", 0, 1),
+                   BitField("ForwardError", 0, 1),
+                   BitField("unused", 0, 5),
+                   XByteField("RplInstanceId", 0),
+                   XShortField("SenderRank", 0)]
+
+    def alignment_delta(self, curpos):  # alignment requirement : 2n+0
+        x = 2
+        y = 0
+        delta = x * ((curpos - y + x - 1) // x) + y - curpos
+        return delta
+
+    def extract_padding(self, p):
+        return b"", p
+
+
 class Jumbo(Packet):  # IPv6 Hop-By-Hop Option
     name = "Jumbo Payload"
     fields_desc = [_OTypeField("otype", 0xC2, _hbhopts),
                    ByteField("optlen", 4),
                    IntField("jumboplen", None)]
 
     def alignment_delta(self, curpos):  # alignment requirement : 4n+2
@@ -791,14 +846,15 @@
     def extract_padding(self, p):
         return b"", p
 
 
 _hbhoptcls = {0x00: Pad1,
               0x01: PadN,
               0x05: RouterAlert,
+              0x63: RplOption,
               0xC2: Jumbo,
               0xC9: HAO}
 
 
 #                         Hop-by-Hop Extension Header                       #
 
 class _OptionsField(PacketListField):
@@ -1388,15 +1444,18 @@
                    ByteEnumField("code", 0, {0: "No route to destination",
                                              1: "Communication with destination administratively prohibited",  # noqa: E501
                                              2: "Beyond scope of source address",  # noqa: E501
                                              3: "Address unreachable",
                                              4: "Port unreachable"}),
                    XShortField("cksum", None),
                    ByteField("length", 0),
-                   X3BytesField("unused", 0)]
+                   X3BytesField("unused", 0),
+                   _ICMPExtensionPadField(),
+                   _ICMPExtensionField()]
+    post_dissection = _ICMP_extpad_post_dissection
 
 
 class ICMPv6PacketTooBig(_ICMPv6Error):
     name = "ICMPv6 Packet Too Big"
     fields_desc = [ByteEnumField("type", 2, icmp6types),
                    ByteField("code", 0),
                    XShortField("cksum", None),
@@ -1406,15 +1465,19 @@
 class ICMPv6TimeExceeded(_ICMPv6Error):
     name = "ICMPv6 Time Exceeded"
     fields_desc = [ByteEnumField("type", 3, icmp6types),
                    ByteEnumField("code", 0, {0: "hop limit exceeded in transit",  # noqa: E501
                                              1: "fragment reassembly time exceeded"}),  # noqa: E501
                    XShortField("cksum", None),
                    ByteField("length", 0),
-                   X3BytesField("unused", 0)]
+                   X3BytesField("unused", 0),
+                   _ICMPExtensionPadField(),
+                   _ICMPExtensionField()]
+    post_dissection = _ICMP_extpad_post_dissection
+
 
 # The default pointer value is set to the next header field of
 # the encapsulated IPv6 packet
 
 
 class ICMPv6ParamProblem(_ICMPv6Error):
     name = "ICMPv6 Parameter Problem"
@@ -1694,40 +1757,65 @@
                   # 20: Do Me,
                   # 21: Do Me,
                   # 22: Do Me,
                   23: "ICMPv6NDOptMAP",
                   24: "ICMPv6NDOptRouteInfo",
                   25: "ICMPv6NDOptRDNSS",
                   26: "ICMPv6NDOptEFA",
-                  31: "ICMPv6NDOptDNSSL"
+                  31: "ICMPv6NDOptDNSSL",
+                  37: "ICMPv6NDOptCaptivePortal",
+                  38: "ICMPv6NDOptPREF64",
                   }
 
 icmp6ndraprefs = {0: "Medium (default)",
                   1: "High",
                   2: "Reserved",
                   3: "Low"}  # RFC 4191
 
 
 class _ICMPv6NDGuessPayload:
     name = "Dummy ND class that implements guess_payload_class()"
 
     def guess_payload_class(self, p):
         if len(p) > 1:
-            return icmp6ndoptscls.get(orb(p[0]), Raw)  # s/Raw/ICMPv6NDOptUnknown/g ?  # noqa: E501
+            return icmp6ndoptscls.get(orb(p[0]), ICMPv6NDOptUnknown)
 
 
 # Beginning of ICMPv6 Neighbor Discovery Options.
 
+class ICMPv6NDOptDataField(StrLenField):
+    __slots__ = ["strip_zeros"]
+
+    def __init__(self, name, default, strip_zeros=False, **kwargs):
+        super().__init__(name, default, **kwargs)
+        self.strip_zeros = strip_zeros
+
+    def i2len(self, pkt, x):
+        return len(self.i2m(pkt, x))
+
+    def i2m(self, pkt, x):
+        r = (len(x) + 2) % 8
+        if r:
+            x += b"\x00" * (8 - r)
+        return x
+
+    def m2i(self, pkt, x):
+        if self.strip_zeros:
+            x = x.rstrip(b"\x00")
+        return x
+
+
 class ICMPv6NDOptUnknown(_ICMPv6NDGuessPayload, Packet):
     name = "ICMPv6 Neighbor Discovery Option - Scapy Unimplemented"
-    fields_desc = [ByteField("type", None),
+    fields_desc = [ByteField("type", 0),
                    FieldLenField("len", None, length_of="data", fmt="B",
-                                 adjust=lambda pkt, x: x + 2),
-                   StrLenField("data", "",
-                               length_from=lambda pkt: pkt.len - 2)]
+                                 adjust=lambda pkt, x: (2 + x) // 8),
+                   ICMPv6NDOptDataField("data", "", strip_zeros=False,
+                                        length_from=lambda pkt:
+                                        8 * max(pkt.len, 1) - 2)]
 
 # NOTE: len includes type and len field. Expressed in unit of 8 bytes
 # TODO: Revoir le coup du ETHER_ANY
 
 
 class ICMPv6NDOptSrcLLAddr(_ICMPv6NDGuessPayload, Packet):
     name = "ICMPv6 Neighbor Discovery Option - Source Link-Layer Address"
@@ -1764,52 +1852,30 @@
                             "Router Address %R%")
 
 # TODO: We should also limit the size of included packet to something
 # like (initiallen - 40 - 2)
 
 
 class TruncPktLenField(PacketLenField):
-    __slots__ = ["cur_shift"]
-
-    def __init__(self, name, default, cls, cur_shift, length_from=None, shift=0):  # noqa: E501
-        PacketLenField.__init__(self, name, default, cls, length_from=length_from)  # noqa: E501
-        self.cur_shift = cur_shift
-
-    def getfield(self, pkt, s):
-        tmp_len = self.length_from(pkt)
-        i = self.m2i(pkt, s[:tmp_len])
-        return s[tmp_len:], i
-
-    def m2i(self, pkt, m):
-        s = None
-        try:  # It can happen we have sth shorter than 40 bytes
-            s = self.cls(m)
-        except Exception:
-            return conf.raw_layer(m)
-        return s
-
     def i2m(self, pkt, x):
-        s = raw(x)
+        s = bytes(x)
         tmp_len = len(s)
-        r = (tmp_len + self.cur_shift) % 8
-        tmp_len = tmp_len - r
-        return s[:tmp_len]
+        return s[:tmp_len - (tmp_len % 8)]
 
     def i2len(self, pkt, i):
         return len(self.i2m(pkt, i))
 
 
-# Faire un post_build pour le recalcul de la taille (en multiple de 8 octets)
 class ICMPv6NDOptRedirectedHdr(_ICMPv6NDGuessPayload, Packet):
     name = "ICMPv6 Neighbor Discovery Option - Redirected Header"
     fields_desc = [ByteField("type", 4),
                    FieldLenField("len", None, length_of="pkt", fmt="B",
-                                 adjust=lambda pkt, x:(x + 8) // 8),
-                   StrFixedLenField("res", b"\x00" * 6, 6),
-                   TruncPktLenField("pkt", b"", IPv6, 8,
+                                 adjust=lambda pkt, x: (x + 8) // 8),
+                   MayEnd(StrFixedLenField("res", b"\x00" * 6, 6)),
+                   TruncPktLenField("pkt", b"", IPv6,
                                     length_from=lambda pkt: 8 * pkt.len - 8)]
 
 # See which value should be used for default MTU instead of 1280
 
 
 class ICMPv6NDOptMTU(_ICMPv6NDGuessPayload, Packet):
     name = "ICMPv6 Neighbor Discovery Option - MTU"
@@ -1972,15 +2038,15 @@
                                  adjust=lambda pkt, x: 2 * x + 1),
                    ShortField("res", None),
                    IntField("lifetime", 0xffffffff),
                    IP6ListField("dns", [],
                                 length_from=lambda pkt: 8 * (pkt.len - 1))]
 
     def mysummary(self):
-        return self.sprintf("%name% " + ", ".join(self.dns))
+        return self.sprintf("%name% ") + ", ".join(self.dns)
 
 
 class ICMPv6NDOptEFA(_ICMPv6NDGuessPayload, Packet):  # RFC 5175 (prev. 5075)
     name = "ICMPv6 Neighbor Discovery Option - Expanded Flags Option"
     fields_desc = [ByteField("type", 26),
                    ByteField("len", 1),
                    BitField("res", 0, 48)]
@@ -1999,14 +2065,19 @@
     def __init__(self, name, default, length_from=None, padded=False):  # noqa: E501
         self.padded = padded
         StrLenField.__init__(self, name, default, length_from=length_from)
 
     def i2len(self, pkt, x):
         return len(self.i2m(pkt, x))
 
+    def i2h(self, pkt, x):
+        if not x:
+            return []
+        return x
+
     def m2i(self, pkt, x):
         x = plain_str(x)  # Decode bytes to string
         res = []
         while x:
             # Get a name until \x00 is reached
             cur = []
             while x and ord(x[0]) != 0:
@@ -2049,15 +2120,50 @@
                    IntField("lifetime", 0xffffffff),
                    DomainNameListField("searchlist", [],
                                        length_from=lambda pkt: 8 * pkt.len - 8,
                                        padded=True)
                    ]
 
     def mysummary(self):
-        return self.sprintf("%name% " + ", ".join(self.searchlist))
+        return self.sprintf("%name% ") + ", ".join(self.searchlist)
+
+
+class ICMPv6NDOptCaptivePortal(_ICMPv6NDGuessPayload, Packet):  # RFC 8910
+    name = "ICMPv6 Neighbor Discovery Option - Captive-Portal Option"
+    fields_desc = [ByteField("type", 37),
+                   FieldLenField("len", None, length_of="URI", fmt="B",
+                                 adjust=lambda pkt, x: (2 + x) // 8),
+                   ICMPv6NDOptDataField("URI", "", strip_zeros=True,
+                                        length_from=lambda pkt:
+                                        8 * max(pkt.len, 1) - 2)]
+
+    def mysummary(self):
+        return self.sprintf("%name% %URI%")
+
+
+class _PREF64(IP6Field):
+    def addfield(self, pkt, s, val):
+        return s + self.i2m(pkt, val)[:12]
+
+    def getfield(self, pkt, s):
+        return s[12:], self.m2i(pkt, s[:12] + b"\x00" * 4)
+
+
+class ICMPv6NDOptPREF64(_ICMPv6NDGuessPayload, Packet):  # RFC 8781
+    name = "ICMPv6 Neighbor Discovery Option - PREF64 Option"
+    fields_desc = [ByteField("type", 38),
+                   ByteField("len", 2),
+                   BitField("scaledlifetime", 0, 13),
+                   BitEnumField("plc", 0, 3,
+                                ["/96", "/64", "/56", "/48", "/40", "/32"]),
+                   _PREF64("prefix", "::")]
+
+    def mysummary(self):
+        plc = self.sprintf("%plc%") if self.plc < 6 else f"[invalid PLC({self.plc})]"
+        return self.sprintf("%name% %prefix%") + plc
 
 # End of ICMPv6 Neighbor Discovery Options.
 
 
 class ICMPv6ND_RS(_ICMPv6NDGuessPayload, _ICMPv6):
     name = "ICMPv6 Neighbor Discovery - Router Solicitation"
     fields_desc = [ByteEnumField("type", 133, icmp6types),
@@ -2509,15 +2615,15 @@
         # From that point on, x is the value (second element of the tuple)
 
         if qtype == 2:  # DNS name
             if isinstance(x, (str, bytes)):  # listify the string
                 x = [x]
             if isinstance(x, list):
                 x = [val.encode() if isinstance(val, str) else val for val in x]  # noqa: E501
-            if x and isinstance(x[0], six.integer_types):
+            if x and isinstance(x[0], int):
                 ttl = x[0]
                 names = x[1:]
             else:
                 ttl = 0
                 names = x
             return (2, [ttl, names2dnsrepr(names)])
 
@@ -2527,15 +2633,15 @@
 
             def fixvalue(x):
                 # List elements are not tuples, user probably
                 # omitted ttl value : we will use 0 instead
                 if not isinstance(x, tuple):
                     x = (0, x)
                 # Decode bytes
-                if six.PY3 and isinstance(x[1], bytes):
+                if isinstance(x[1], bytes):
                     x = (x[0], x[1].decode())
                 return x
 
             return (qtype, [fixvalue(d) for d in x])
 
         return (qtype, x)
 
@@ -3326,17 +3432,17 @@
             t = not (ICMPv6TimeExceeded in r or
                      ICMPv6DestUnreach in r or
                      ICMPv6PacketTooBig in r or
                      ICMPv6ParamProblem in r)
 
             trace[d][s[IPv6].hlim] = r[IPv6].src, t
 
-        for k in six.itervalues(trace):
+        for k in trace.values():
             try:
-                m = min(x for x, y in six.iteritems(k) if y[1])
+                m = min(x for x, y in k.items() if y[1])
             except ValueError:
                 continue
             for li in list(k):  # use list(): k is modified in the loop
                 if li > m:
                     del k[li]
 
         return trace
```

### Comparing `scapy-2.5.0rc3/scapy/layers/ipsec.py` & `scapy-2.6.0rc1/scapy/layers/ipsec.py`

 * *Files 2% similar despite different names*

```diff
@@ -26,33 +26,47 @@
 >>> d
 <IP  version=4L ihl=5L tos=0x0 len=48 id=1 flags= frag=0L ttl=64 proto=tcp chksum=0x74c2 src=1.1.1.1 dst=2.2.2.2 |<TCP  sport=45012 dport=http seq=0 ack=0 dataofs=5L reserved=0L flags=S window=8192 chksum=0x1914 urgptr=0 options=[] |<Raw  load='testdata' |>>>  # noqa: E501
 >>>
 >>> d == p
 True
 """
 
-from __future__ import absolute_import
 try:
     from math import gcd
 except ImportError:
     from fractions import gcd
 import os
 import socket
 import struct
 import warnings
 
 from scapy.config import conf, crypto_validator
 from scapy.compat import orb, raw
 from scapy.data import IP_PROTOS
 from scapy.error import log_loading
-from scapy.fields import ByteEnumField, ByteField, IntField, PacketField, \
-    ShortField, StrField, XIntField, XStrField, XStrLenField
-from scapy.packet import Packet, bind_layers, Raw
+from scapy.fields import (
+    ByteEnumField,
+    ByteField,
+    IntField,
+    PacketField,
+    ShortField,
+    StrField,
+    XByteField,
+    XIntField,
+    XStrField,
+    XStrLenField,
+)
+from scapy.packet import (
+    Packet,
+    Raw,
+    bind_bottom_up,
+    bind_layers,
+    bind_top_down,
+)
 from scapy.layers.inet import IP, UDP
-import scapy.libs.six as six
 from scapy.layers.inet6 import IPv6, IPv6ExtHdrHopByHop, IPv6ExtHdrDestOpt, \
     IPv6ExtHdrRouting
 
 
 ###############################################################################
 class AH(Packet):
     """
@@ -112,27 +126,55 @@
 
     fields_desc = [
         XIntField('spi', 0x00000001),
         IntField('seq', 0),
         XStrField('data', None),
     ]
 
+    @classmethod
+    def dispatch_hook(cls, _pkt=None, *args, **kargs):
+        if _pkt:
+            if len(_pkt) >= 4 and struct.unpack("!I", _pkt[0:4])[0] == 0x00:
+                return NON_ESP
+            elif len(_pkt) == 1 and struct.unpack("!B", _pkt)[0] == 0xff:
+                return NAT_KEEPALIVE
+            else:
+                return ESP
+        return cls
+
     overload_fields = {
         IP: {'proto': socket.IPPROTO_ESP},
         IPv6: {'nh': socket.IPPROTO_ESP},
         IPv6ExtHdrHopByHop: {'nh': socket.IPPROTO_ESP},
         IPv6ExtHdrDestOpt: {'nh': socket.IPPROTO_ESP},
         IPv6ExtHdrRouting: {'nh': socket.IPPROTO_ESP},
     }
 
 
+class NON_ESP(Packet):  # RFC 3948, section 2.2
+    fields_desc = [
+        XIntField("non_esp", 0x0)
+    ]
+
+
+class NAT_KEEPALIVE(Packet):  # RFC 3948, section 2.2
+    fields_desc = [
+        XByteField("nat_keepalive", 0xFF)
+    ]
+
+
 bind_layers(IP, ESP, proto=socket.IPPROTO_ESP)
 bind_layers(IPv6, ESP, nh=socket.IPPROTO_ESP)
-bind_layers(UDP, ESP, dport=4500)  # NAT-Traversal encapsulation
-bind_layers(UDP, ESP, sport=4500)  # NAT-Traversal encapsulation
+
+# NAT-Traversal encapsulation
+bind_bottom_up(UDP, ESP, dport=4500)
+bind_bottom_up(UDP, ESP, sport=4500)
+bind_top_down(UDP, ESP, dport=4500, sport=4500)
+bind_top_down(UDP, NON_ESP, dport=4500, sport=4500)
+bind_top_down(UDP, NAT_KEEPALIVE, dport=4500, sport=4500)
 
 ###############################################################################
 
 
 class _ESPPlain(Packet):
     """
     Internal class to represent unencrypted ESP packets.
@@ -162,14 +204,21 @@
     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives.ciphers import (
         aead,
         Cipher,
         algorithms,
         modes,
     )
+    try:
+        # cryptography > 43.0
+        from cryptography.hazmat.decrepit.ciphers import (
+            algorithms as decrepit_algorithms
+        )
+    except ImportError:
+        decrepit_algorithms = algorithms
 else:
     log_loading.info("Can't import python-cryptography v1.7+. "
                      "Disabled IPsec encryption/authentication.")
     default_backend = None
     InvalidTag = Exception
     Cipher = algorithms = modes = None
 
@@ -366,15 +415,19 @@
                     aad = struct.pack('!LL', esp.spi, esp.seq)
             if self.ciphers_aead_api:
                 # New API
                 if self.cipher == aead.AESCCM:
                     cipher = self.cipher(key, tag_length=icv_size)
                 else:
                     cipher = self.cipher(key)
-                data = cipher.encrypt(mode_iv, data, aad)
+                if self.name == 'AES-NULL-GMAC':
+                    # Special case for GMAC (rfc 4543 sect 3)
+                    data = data + cipher.encrypt(mode_iv, b"", aad + esp.iv + data)
+                else:
+                    data = cipher.encrypt(mode_iv, data, aad)
             else:
                 cipher = self.new_cipher(key, mode_iv)
                 encryptor = cipher.encryptor()
 
                 if self.is_aead:
                     encryptor.authenticate_additional_data(aad)
                     data = encryptor.update(data) + encryptor.finalize()
@@ -418,15 +471,19 @@
             if self.ciphers_aead_api:
                 # New API
                 if self.cipher == aead.AESCCM:
                     cipher = self.cipher(key, tag_length=icv_size)
                 else:
                     cipher = self.cipher(key)
                 try:
-                    data = cipher.decrypt(mode_iv, data + icv, aad)
+                    if self.name == 'AES-NULL-GMAC':
+                        # Special case for GMAC (rfc 4543 sect 3)
+                        data = data + cipher.decrypt(mode_iv, icv, aad + iv + data)
+                    else:
+                        data = cipher.decrypt(mode_iv, data + icv, aad)
                 except InvalidTag as err:
                     raise IPSecIntegrityError(err)
             else:
                 cipher = self.new_cipher(key, mode_iv, icv)
                 decryptor = cipher.decryptor()
 
                 if self.is_aead:
@@ -438,16 +495,16 @@
                     raise IPSecIntegrityError(err)
 
         # extract padlen and nh
         padlen = orb(data[-2])
         nh = orb(data[-1])
 
         # then use padlen to determine data and padding
-        data = data[:len(data) - padlen - 2]
         padding = data[len(data) - padlen - 2: len(data) - 2]
+        data = data[:len(data) - padlen - 2]
 
         return _ESPPlain(spi=esp.spi,
                          seq=esp.seq,
                          iv=iv,
                          data=data,
                          padding=padding,
                          padlen=padlen,
@@ -481,14 +538,25 @@
                                        key_size=(16, 24, 32),
                                        mode=None,
                                        salt_size=4,
                                        block_size=1,
                                        iv_size=8,
                                        icv_size=16,
                                        format_mode_iv=_salt_format_mode_iv)
+    # GMAC: rfc 4543, "companion to the AES Galois/Counter Mode ESP"
+    # This is defined as a crypt_algo by rfc, but has the role of an auth_algo
+    CRYPT_ALGOS['AES-NULL-GMAC'] = CryptAlgo('AES-NULL-GMAC',
+                                             cipher=aead.AESGCM,
+                                             key_size=(16, 24, 32),
+                                             mode=None,
+                                             salt_size=4,
+                                             block_size=1,
+                                             iv_size=8,
+                                             icv_size=16,
+                                             format_mode_iv=_salt_format_mode_iv)
     CRYPT_ALGOS['AES-CCM'] = CryptAlgo('AES-CCM',
                                        cipher=aead.AESCCM,
                                        mode=None,
                                        key_size=(16, 24, 32),
                                        block_size=1,
                                        iv_size=8,
                                        salt_size=3,
@@ -500,42 +568,43 @@
                                                  key_size=32,
                                                  block_size=1,
                                                  iv_size=8,
                                                  salt_size=4,
                                                  icv_size=16,
                                                  format_mode_iv=_salt_format_mode_iv)  # noqa: E501
 
-    # XXX: RFC7321 states that DES *MUST NOT* be implemented.
-    # XXX: Keep for backward compatibility?
     # Using a TripleDES cipher algorithm for DES is done by using the same 64
     # bits key 3 times (done by cryptography when given a 64 bits key)
     CRYPT_ALGOS['DES'] = CryptAlgo('DES',
-                                   cipher=algorithms.TripleDES,
+                                   cipher=decrepit_algorithms.TripleDES,
                                    mode=modes.CBC,
                                    key_size=(8,))
     CRYPT_ALGOS['3DES'] = CryptAlgo('3DES',
-                                    cipher=algorithms.TripleDES,
+                                    cipher=decrepit_algorithms.TripleDES,
                                     mode=modes.CBC)
-    try:
+    if decrepit_algorithms is algorithms:
+        # cryptography < 43 raises a DeprecationWarning
         from cryptography.utils import CryptographyDeprecationWarning
         with warnings.catch_warnings():
             # Hide deprecation warnings
             warnings.filterwarnings("ignore",
                                     category=CryptographyDeprecationWarning)
             CRYPT_ALGOS['CAST'] = CryptAlgo('CAST',
-                                            cipher=algorithms.CAST5,
+                                            cipher=decrepit_algorithms.CAST5,
                                             mode=modes.CBC)
-            # XXX: Flagged as weak by 'cryptography'.
-            # Kept for backward compatibility
             CRYPT_ALGOS['Blowfish'] = CryptAlgo('Blowfish',
-                                                cipher=algorithms.Blowfish,
+                                                cipher=decrepit_algorithms.Blowfish,
                                                 mode=modes.CBC)
-    except AttributeError:
-        # Future-proof, if ever removed from cryptography
-        pass
+    else:
+        CRYPT_ALGOS['CAST'] = CryptAlgo('CAST',
+                                        cipher=decrepit_algorithms.CAST5,
+                                        mode=modes.CBC)
+        CRYPT_ALGOS['Blowfish'] = CryptAlgo('Blowfish',
+                                            cipher=decrepit_algorithms.Blowfish,
+                                            mode=modes.CBC)
 
 
 ###############################################################################
 if conf.crypto_valid:
     from cryptography.hazmat.primitives.hmac import HMAC
     from cryptography.hazmat.primitives.cmac import CMAC
     from cryptography.hazmat.primitives import hashes
@@ -609,24 +678,25 @@
         """
         if not self.mac:
             return pkt
 
         mac = self.new_mac(key)
 
         if pkt.haslayer(ESP):
-            mac.update(raw(pkt[ESP]))
+            mac.update(bytes(pkt[ESP]))
+            if esn_en:
+                # RFC4303 sect 2.2.1
+                mac.update(struct.pack('!L', esn))
             pkt[ESP].data += mac.finalize()[:self.icv_size]
 
         elif pkt.haslayer(AH):
-            clone = zero_mutable_fields(pkt.copy(), sending=True)
+            mac.update(bytes(zero_mutable_fields(pkt.copy(), sending=True)))
             if esn_en:
-                temp = raw(clone) + struct.pack('!L', esn)
-            else:
-                temp = raw(clone)
-            mac.update(temp)
+                # RFC4302 sect 2.5.1
+                mac.update(struct.pack('!L', esn))
             pkt[AH].icv = mac.finalize()[:self.icv_size]
 
         return pkt
 
     def verify(self, pkt, key, esn_en=False, esn=0):
         """
         Check that the integrity check value (icv) of a packet is valid.
@@ -647,29 +717,31 @@
 
         pkt_icv = 'not found'
 
         if isinstance(pkt, ESP):
             pkt_icv = pkt.data[len(pkt.data) - self.icv_size:]
             clone = pkt.copy()
             clone.data = clone.data[:len(clone.data) - self.icv_size]
-            temp = raw(clone)
+            mac.update(bytes(clone))
+            if esn_en:
+                # RFC4303 sect 2.2.1
+                mac.update(struct.pack('!L', esn))
 
         elif pkt.haslayer(AH):
             if len(pkt[AH].icv) != self.icv_size:
                 # Fill padding since we know the actual icv_size
                 pkt[AH].padding = pkt[AH].icv[self.icv_size:]
                 pkt[AH].icv = pkt[AH].icv[:self.icv_size]
             pkt_icv = pkt[AH].icv
             clone = zero_mutable_fields(pkt.copy(), sending=False)
+            mac.update(bytes(clone))
             if esn_en:
-                temp = raw(clone) + struct.pack('!L', esn)
-            else:
-                temp = raw(clone)
+                # RFC4302 sect 2.5.1
+                mac.update(struct.pack('!L', esn))
 
-        mac.update(temp)
         computed_icv = mac.finalize()[:self.icv_size]
 
         # XXX: Cannot use mac.verify because the ICV can be truncated
         if pkt_icv != computed_icv:
             raise IPSecIntegrityError('pkt_icv=%r, computed_icv=%r' %
                                       (pkt_icv, computed_icv))
 
@@ -877,18 +949,18 @@
                              for NAT-Traversal.
         :param esn_en: extended sequence number enable which allows to use
                        64-bit sequence number instead of 32-bit when using an
                        AEAD algorithm
         :param esn: extended sequence number (32 MSB)
         """
 
-        if proto not in (ESP, AH, ESP.name, AH.name):
+        if proto not in {ESP, AH, ESP.name, AH.name}:
             raise ValueError("proto must be either ESP or AH")
-        if isinstance(proto, six.string_types):
-            self.proto = eval(proto)
+        if isinstance(proto, str):
+            self.proto = {ESP.name: ESP, AH.name: AH}[proto]
         else:
             self.proto = proto
 
         self.spi = spi
         self.seq_num = seq_num
         self.esn_en = esn_en
         # Get Extended Sequence (32 MSB)
@@ -968,38 +1040,40 @@
 
         esp = self.crypt_algo.pad(esp)
         esp = self.crypt_algo.encrypt(self, esp, self.crypt_key,
                                       self.crypt_icv_size,
                                       esn_en=esn_en or self.esn_en,
                                       esn=esn or self.esn)
 
-        self.auth_algo.sign(esp, self.auth_key)
+        self.auth_algo.sign(esp,
+                            self.auth_key,
+                            esn_en=esn_en or self.esn_en,
+                            esn=esn or self.esn)
 
         if self.nat_t_header:
             nat_t_header = self.nat_t_header.copy()
             nat_t_header.chksum = 0
             del nat_t_header.len
             if ip_header.version == 4:
                 del ip_header.proto
             else:
                 del ip_header.nh
             ip_header /= nat_t_header
 
         if ip_header.version == 4:
-            ip_header.len = len(ip_header) + len(esp)
+            del ip_header.len
             del ip_header.chksum
-            ip_header = ip_header.__class__(raw(ip_header))
         else:
-            ip_header.plen = len(ip_header.payload) + len(esp)
+            del ip_header.plen
 
         # sequence number must always change, unless specified by the user
         if seq_num is None:
             self.seq_num += 1
 
-        return ip_header / esp
+        return ip_header.__class__(raw(ip_header / esp))
 
     def _encrypt_ah(self, pkt, seq_num=None, esn_en=False, esn=0):
 
         ah = AH(spi=self.spi, seq=seq_num or self.seq_num,
                 icv=b"\x00" * self.auth_algo.icv_size)
 
         if self.tunnel_header:
@@ -1080,15 +1154,17 @@
 
     def _decrypt_esp(self, pkt, verify=True, esn_en=None, esn=None):
 
         encrypted = pkt[ESP]
 
         if verify:
             self.check_spi(pkt)
-            self.auth_algo.verify(encrypted, self.auth_key)
+            self.auth_algo.verify(encrypted, self.auth_key,
+                                  esn_en=esn_en or self.esn_en,
+                                  esn=esn or self.esn)
 
         esp = self.crypt_algo.decrypt(self, encrypted, self.crypt_key,
                                       self.crypt_icv_size or
                                       self.crypt_algo.icv_size or
                                       self.auth_algo.icv_size,
                                       esn_en=esn_en or self.esn_en,
                                       esn=esn or self.esn)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/ir.py` & `scapy-2.6.0rc1/scapy/layers/ir.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/l2.py` & `scapy-2.6.0rc1/scapy/layers/l2.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,30 +3,28 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Classes and functions for layer 2 protocols.
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
+import itertools
+import socket
 import struct
 import time
-import socket
 
 from scapy.ansmachine import AnsweringMachine
 from scapy.arch import get_if_addr, get_if_hwaddr
 from scapy.base_classes import Gen, Net
 from scapy.compat import chb, orb
 from scapy.config import conf
 from scapy import consts
 from scapy.data import ARPHDR_ETHER, ARPHDR_LOOPBACK, ARPHDR_METRICOM, \
     DLT_ETHERNET_MPACKET, DLT_LINUX_IRDA, DLT_LINUX_SLL, DLT_LINUX_SLL2, \
-    DLT_LOOP, DLT_NULL, ETHER_ANY, ETHER_BROADCAST, ETHER_TYPES, ETH_P_ARP, \
-    ETH_P_MACSEC
+    DLT_LOOP, DLT_NULL, ETHER_ANY, ETHER_BROADCAST, ETHER_TYPES, ETH_P_ARP, ETH_P_MACSEC
 from scapy.error import warning, ScapyNoDstMacException, log_runtime
 from scapy.fields import (
     BCDFloatField,
     BitField,
     ByteEnumField,
     ByteField,
     ConditionalField,
@@ -42,43 +40,48 @@
     OUIField,
     ShortEnumField,
     ShortField,
     SourceIP6Field,
     SourceIPField,
     StrFixedLenField,
     StrLenField,
+    ThreeBytesField,
     XByteField,
     XIntField,
     XShortEnumField,
     XShortField,
 )
-from scapy.interfaces import _GlobInterfaceType
-from scapy.libs.six import viewitems
+from scapy.interfaces import _GlobInterfaceType, resolve_iface
 from scapy.packet import bind_layers, Packet
 from scapy.plist import (
     PacketList,
     QueryAnswer,
     SndRcvList,
     _PacketList,
 )
 from scapy.sendrecv import sendp, srp, srp1, srploop
 from scapy.utils import checksum, hexdump, hexstr, inet_ntoa, inet_aton, \
     mac2str, valid_mac, valid_net, valid_net6
-from scapy.compat import (
+
+# Typing imports
+from typing import (
     Any,
     Callable,
     Dict,
+    Iterable,
     List,
     Optional,
     Tuple,
     Type,
     Union,
     cast,
 )
 from scapy.interfaces import NetworkInterface
+
+
 if conf.route is None:
     # unused import, only to initialize conf.route
     import scapy.route  # noqa: F401
 
 
 # type definitions
 _ResolverCallable = Callable[[Packet, Packet], Optional[str]]
@@ -94,15 +97,15 @@
         self.resolvers = {}  # type: Dict[Tuple[Type[Packet], Type[Packet]], _ResolverCallable] # noqa: E501
 
     def register_l3(self, l2, l3, resolve_method):
         # type: (Type[Packet], Type[Packet], _ResolverCallable) -> None
         self.resolvers[l2, l3] = resolve_method
 
     def resolve(self, l2inst, l3inst):
-        # type: (Ether, Packet) -> Optional[str]
+        # type: (Packet, Packet) -> Optional[str]
         k = l2inst.__class__, l3inst.__class__
         if k in self.resolvers:
             return self.resolvers[k](l2inst, l3inst)
         return None
 
     def __repr__(self):
         # type: () -> str
@@ -157,31 +160,35 @@
 
 class DestMACField(MACField):
     def __init__(self, name):
         # type: (str) -> None
         MACField.__init__(self, name, None)
 
     def i2h(self, pkt, x):
-        # type: (Optional[Ether], Optional[str]) -> str
+        # type: (Optional[Packet], Optional[str]) -> str
+        if x is None and pkt is not None:
+            x = "None (resolved on build)"
+        return super(DestMACField, self).i2h(pkt, x)
+
+    def i2m(self, pkt, x):
+        # type: (Optional[Packet], Optional[str]) -> bytes
         if x is None and pkt is not None:
             try:
                 x = conf.neighbor.resolve(pkt, pkt.payload)
             except socket.error:
                 pass
             if x is None:
                 if conf.raise_no_dst_mac:
                     raise ScapyNoDstMacException()
                 else:
                     x = "ff:ff:ff:ff:ff:ff"
-                    warning("Mac address to reach destination not found. Using broadcast.")  # noqa: E501
-        return super(DestMACField, self).i2h(pkt, x)
-
-    def i2m(self, pkt, x):
-        # type: (Optional[Ether], Optional[str]) -> bytes
-        return MACField.i2m(self, pkt, self.i2h(pkt, x))
+                    warning(
+                        "MAC address to reach destination not found. Using broadcast."
+                    )
+        return super(DestMACField, self).i2m(pkt, x)
 
 
 class SourceMACField(MACField):
     __slots__ = ["getif"]
 
     def __init__(self, name, getif=None):
         # type: (str, Optional[Any]) -> None
@@ -191,25 +198,22 @@
     def i2h(self, pkt, x):
         # type: (Optional[Packet], Optional[str]) -> str
         if x is None:
             iff = self.getif(pkt)
             if iff is None:
                 iff = conf.iface
             if iff:
-                try:
-                    x = get_if_hwaddr(iff)
-                except Exception as e:
-                    warning("Could not get the source MAC: %s" % e)
+                x = resolve_iface(iff).mac
             if x is None:
                 x = "00:00:00:00:00:00"
         return super(SourceMACField, self).i2h(pkt, x)
 
     def i2m(self, pkt, x):
-        # type: (Optional[Ether], Optional[Any]) -> bytes
-        return MACField.i2m(self, pkt, self.i2h(pkt, x))
+        # type: (Optional[Packet], Optional[Any]) -> bytes
+        return super(SourceMACField, self).i2m(pkt, self.i2h(pkt, x))
 
 
 # Layers
 
 HARDWARE_TYPES = {
     1: "Ethernet (10Mb)",
     2: "Ethernet (3Mb)",
@@ -230,15 +234,16 @@
     17: "HDLC",
     18: "Fibre Channel",
     19: "ATM",
     20: "Serial Line",
     21: "ATM",
 }
 
-ETHER_TYPES[0x88a8] = '802_AD'
+ETHER_TYPES[0x88a8] = '802_1AD'
+ETHER_TYPES[0x88e7] = '802_1AH'
 ETHER_TYPES[ETH_P_MACSEC] = '802_1AE'
 
 
 class Ether(Packet):
     name = "Ethernet"
     fields_desc = [DestMACField("dst"),
                    SourceMACField("src"),
@@ -277,15 +282,15 @@
 
     def extract_padding(self, s):
         # type: (bytes) -> Tuple[bytes, bytes]
         tmp_len = self.len
         return s[:tmp_len], s[tmp_len:]
 
     def answers(self, other):
-        # type: (Ether) -> int
+        # type: (Packet) -> int
         if isinstance(other, Dot3):
             return self.payload.answers(other.payload)
         return 0
 
     def mysummary(self):
         # type: () -> str
         return "802.3 %s > %s" % (self.src, self.dst)
@@ -302,16 +307,18 @@
 class LLC(Packet):
     name = "LLC"
     fields_desc = [XByteField("dsap", 0x00),
                    XByteField("ssap", 0x00),
                    ByteField("ctrl", 0)]
 
 
-def l2_register_l3(l2, l3):
-    # type: (Packet, Packet) -> Optional[str]
+def l2_register_l3(l2: Packet, l3: Packet) -> Optional[str]:
+    """
+    Delegates resolving the default L2 destination address to the payload of L3.
+    """
     neighbor = conf.neighbor  # type: Neighbor
     return neighbor.resolve(l2, l3.payload)
 
 
 conf.neighbor.register_l3(Ether, LLC, l2_register_l3)
 conf.neighbor.register_l3(Dot3, LLC, l2_register_l3)
 
@@ -364,17 +371,20 @@
 conf.neighbor.register_l3(Dot3, SNAP, l2_register_l3)
 
 
 class Dot1Q(Packet):
     name = "802.1Q"
     aliastypes = [Ether]
     fields_desc = [BitField("prio", 0, 3),
-                   BitField("id", 0, 1),
+                   BitField("dei", 0, 1),
                    BitField("vlan", 1, 12),
                    XShortEnumField("type", 0x0000, ETHER_TYPES)]
+    deprecated_fields = {
+        "id": ("dei", "2.5.0"),
+    }
 
     def answers(self, other):
         # type: (Packet) -> int
         if isinstance(other, Dot1Q):
             if ((self.type == other.type) and
                     (self.vlan == other.vlan)):
                 return self.payload.answers(other.payload)
@@ -542,23 +552,36 @@
         if self.op == 1:
             return self.sprintf("ARP who has %pdst% says %psrc%")
         if self.op == 2:
             return self.sprintf("ARP is at %hwsrc% says %psrc%")
         return self.sprintf("ARP %op% %psrc% > %pdst%")
 
 
-def l2_register_l3_arp(l2, l3):
-    # type: (Packet, Packet) -> Optional[str]
-    # TODO: support IPv6?
-    plen = l3.plen if l3.plen is not None else l3.get_field("pdst").i2len(l3, l3.pdst)
+def l2_register_l3_arp(l2: Packet, l3: Packet) -> Optional[str]:
+    """
+    Resolves the default L2 destination address when ARP is used.
+    """
+    if l3.op == 1:  # who-has
+        return "ff:ff:ff:ff:ff:ff"
+    elif l3.op == 2:  # is-at
+        log_runtime.warning(
+            "You should be providing the Ethernet destination MAC address when "
+            "sending an is-at ARP."
+        )
+    # Need ARP request to send ARP request...
+    plen = l3.get_field("pdst").i2len(l3, l3.pdst)
     if plen == 4:
         return getmacbyip(l3.pdst)
+    elif plen == 32:
+        from scapy.layers.inet6 import getmacbyip6
+        return getmacbyip6(l3.pdst)
+    # Can't even do that
     log_runtime.warning(
-        "Unable to guess L2 MAC address from an ARP packet with a "
-        "non-IPv4 pdst. Provide it manually !"
+        "You should be providing the Ethernet destination mac when sending this "
+        "kind of ARP packets."
     )
     return None
 
 
 conf.neighbor.register_l3(Ether, ARP, l2_register_l3_arp)
 
 
@@ -661,93 +684,141 @@
 LOOPBACK_TYPES = {0x2: "IPv4",
                   0x7: "OSI",
                   0x10: "Appletalk",
                   0x17: "Netware IPX/SPX",
                   0x18: "IPv6", 0x1c: "IPv6", 0x1e: "IPv6"}
 
 
-class Loopback(Packet):
-    r"""\*BSD loopback layer"""
+# On OpenBSD, Loopback = LoopbackOpenBSD. On other platforms, the 2 are available.
+# This is to be compatible with both tcpdump and tshark
 
+class Loopback(Packet):
+    r"""
+    \*BSD loopback layer
+    """
+    __slots__ = ["_defrag_pos"]
     name = "Loopback"
     if consts.OPENBSD:
         fields_desc = [IntEnumField("type", 0x2, LOOPBACK_TYPES)]
     else:
         fields_desc = [LoIntEnumField("type", 0x2, LOOPBACK_TYPES)]
-    __slots__ = ["_defrag_pos"]
+
+
+if consts.OPENBSD:
+    LoopbackOpenBSD = Loopback
+else:
+    class LoopbackOpenBSD(Loopback):
+        name = "OpenBSD Loopback"
+        fields_desc = [IntEnumField("type", 0x2, LOOPBACK_TYPES)]
 
 
 class Dot1AD(Dot1Q):
     name = '802_1AD'
 
 
+class Dot1AH(Packet):
+    name = "802_1AH"
+    fields_desc = [BitField("prio", 0, 3),
+                   BitField("dei", 0, 1),
+                   BitField("nca", 0, 1),
+                   BitField("res1", 0, 1),
+                   BitField("res2", 0, 2),
+                   ThreeBytesField("isid", 0)]
+
+    def answers(self, other):
+        # type: (Packet) -> int
+        if isinstance(other, Dot1AH):
+            if self.isid == other.isid:
+                return self.payload.answers(other.payload)
+        return 0
+
+    def mysummary(self):
+        # type: () -> str
+        return self.sprintf("802.1ah (isid=%Dot1AH.isid%")
+
+
+conf.neighbor.register_l3(Ether, Dot1AH, l2_register_l3)
+
+
 bind_layers(Dot3, LLC)
 bind_layers(Ether, LLC, type=122)
 bind_layers(Ether, LLC, type=34928)
 bind_layers(Ether, Dot1Q, type=33024)
 bind_layers(Ether, Dot1AD, type=0x88a8)
+bind_layers(Ether, Dot1AH, type=0x88e7)
 bind_layers(Dot1AD, Dot1AD, type=0x88a8)
 bind_layers(Dot1AD, Dot1Q, type=0x8100)
+bind_layers(Dot1AD, Dot1AH, type=0x88e7)
 bind_layers(Dot1Q, Dot1AD, type=0x88a8)
+bind_layers(Dot1Q, Dot1AH, type=0x88e7)
+bind_layers(Dot1AH, Ether)
 bind_layers(Ether, Ether, type=1)
 bind_layers(Ether, ARP, type=2054)
 bind_layers(CookedLinux, LLC, proto=122)
 bind_layers(CookedLinux, Dot1Q, proto=33024)
 bind_layers(CookedLinux, Dot1AD, type=0x88a8)
+bind_layers(CookedLinux, Dot1AH, type=0x88e7)
 bind_layers(CookedLinux, Ether, proto=1)
 bind_layers(CookedLinux, ARP, proto=2054)
 bind_layers(MPacketPreamble, Ether)
 bind_layers(GRE, LLC, proto=122)
 bind_layers(GRE, Dot1Q, proto=33024)
 bind_layers(GRE, Dot1AD, type=0x88a8)
+bind_layers(GRE, Dot1AH, type=0x88e7)
 bind_layers(GRE, Ether, proto=0x6558)
 bind_layers(GRE, ARP, proto=2054)
 bind_layers(GRE, GRErouting, {"routing_present": 1})
 bind_layers(GRErouting, conf.raw_layer, {"address_family": 0, "SRE_len": 0})
 bind_layers(GRErouting, GRErouting)
 bind_layers(LLC, STP, dsap=66, ssap=66, ctrl=3)
 bind_layers(LLC, SNAP, dsap=170, ssap=170, ctrl=3)
 bind_layers(SNAP, Dot1Q, code=33024)
 bind_layers(SNAP, Dot1AD, type=0x88a8)
+bind_layers(SNAP, Dot1AH, type=0x88e7)
 bind_layers(SNAP, Ether, code=1)
 bind_layers(SNAP, ARP, code=2054)
 bind_layers(SNAP, STP, code=267)
 
 conf.l2types.register(ARPHDR_ETHER, Ether)
 conf.l2types.register_num2layer(ARPHDR_METRICOM, Ether)
 conf.l2types.register_num2layer(ARPHDR_LOOPBACK, Ether)
 conf.l2types.register_layer2num(ARPHDR_ETHER, Dot3)
 conf.l2types.register(DLT_LINUX_SLL, CookedLinux)
 conf.l2types.register(DLT_LINUX_SLL2, CookedLinuxV2)
 conf.l2types.register(DLT_ETHERNET_MPACKET, MPacketPreamble)
 conf.l2types.register_num2layer(DLT_LINUX_IRDA, CookedLinux)
-conf.l2types.register(DLT_LOOP, Loopback)
-conf.l2types.register_num2layer(DLT_NULL, Loopback)
+conf.l2types.register(DLT_NULL, Loopback)
+conf.l2types.register(DLT_LOOP, LoopbackOpenBSD)
 
 conf.l3types.register(ETH_P_ARP, ARP)
 
 
 # Techniques
 
 
 @conf.commands.register
 def arpcachepoison(
     target,  # type: Union[str, List[str]]
     addresses,  # type: Union[str, Tuple[str, str], List[Tuple[str, str]]]
+    broadcast=False,  # type: bool
+    count=None,  # type: Optional[int]
     interval=15,  # type: int
+    **kwargs,  # type: Any
 ):
     # type: (...) -> None
     """Poison targets' ARP cache
 
     :param target: Can be an IP, subnet (string) or a list of IPs. This lists the IPs
-                   or subnets that will be poisoned.
+                   or the subnet that will be poisoned.
     :param addresses: Can be either a string, a tuple of a list of tuples.
-                      If it's a string, it's the IP to usurpate in the victim,
+                      If it's a string, it's the IP to advertise to the victim,
                       with the local interface's MAC. If it's a tuple,
-                      it's ("IP", "MAC"). It it's a list, it's [("IP", "MAC")]
+                      it's ("IP", "MAC"). It it's a list, it's [("IP", "MAC")].
+                      "IP" can be a subnet of course.
+    :param broadcast: Use broadcast ethernet
 
     Examples for target "192.168.0.2"::
 
         >>> arpcachepoison("192.168.0.2", "192.168.0.1")
         >>> arpcachepoison("192.168.0.1/24", "192.168.0.1")
         >>> arpcachepoison(["192.168.0.2", "192.168.0.3"], "192.168.0.1")
         >>> arpcachepoison("192.168.0.2", ("192.168.0.1", get_if_hwaddr("virbr0")))
@@ -763,97 +834,148 @@
         str_target = target[0]
     if isinstance(addresses, str):
         couple_list = [(addresses, get_if_hwaddr(conf.route.route(str_target)[0]))]
     elif isinstance(addresses, tuple):
         couple_list = [addresses]
     else:
         couple_list = addresses
-    p = [
-        Ether(src=y) / ARP(op="who-has", psrc=x, pdst=targets,
-                           hwsrc=y, hwdst="ff:ff:ff:ff:ff:ff")
+    p: List[Packet] = [
+        Ether(src=y, dst="ff:ff:ff:ff:ff:ff" if broadcast else None) /
+        ARP(op="who-has", psrc=x, pdst=targets,
+            hwsrc=y, hwdst="00:00:00:00:00:00")
         for x, y in couple_list
     ]
+    if count is not None:
+        sendp(p, iface_hint=str_target, count=count, inter=interval, **kwargs)
+        return
     try:
         while True:
-            sendp(p, iface_hint=str_target)
+            sendp(p, iface_hint=str_target, **kwargs)
             time.sleep(interval)
     except KeyboardInterrupt:
         pass
 
 
 @conf.commands.register
 def arp_mitm(
     ip1,  # type: str
     ip2,  # type: str
-    mac1=None,  # type: Optional[str]
-    mac2=None,  # type: Optional[str]
+    mac1=None,  # type: Optional[Union[str, List[str]]]
+    mac2=None,  # type: Optional[Union[str, List[str]]]
+    broadcast=False,  # type: bool
     target_mac=None,  # type: Optional[str]
     iface=None,  # type: Optional[_GlobInterfaceType]
     inter=3,  # type: int
 ):
     # type: (...) -> None
-    """ARP MitM: poison 2 target's ARP cache
+    r"""ARP MitM: poison 2 target's ARP cache
 
     :param ip1: IPv4 of the first machine
     :param ip2: IPv4 of the second machine
     :param mac1: MAC of the first machine (optional: will ARP otherwise)
     :param mac2: MAC of the second machine (optional: will ARP otherwise)
+    :param broadcast: if True, will use broadcast mac for MitM by default
     :param target_mac: MAC of the attacker (optional: default to the interface's one)
     :param iface: the network interface. (optional: default, route for ip1)
 
     Example usage::
 
         $ sysctl net.ipv4.conf.virbr0.send_redirects=0  # virbr0 = interface
         $ sysctl net.ipv4.ip_forward=1
         $ sudo scapy
         >>> arp_mitm("192.168.122.156", "192.168.122.17")
 
+    Alternative usages:
+        >>> arp_mitm("10.0.0.1", "10.1.1.0/21", iface="eth1")
+        >>> arp_mitm("10.0.0.1", "10.1.1.2",
+        ...          target_mac="aa:aa:aa:aa:aa:aa",
+        ...          mac2="00:1e:eb:bf:c1:ab")
+
+    .. warning::
+        If using a subnet, this will first perform an arping, unless broadcast is on!
+
     Remember to change the sysctl settings back..
     """
     if not iface:
         iface = conf.route.route(ip1)[0]
     if not target_mac:
         target_mac = get_if_hwaddr(iface)
-    if mac1 is None:
-        mac1 = getmacbyip(ip1)
-        if not mac1:
-            print("Can't resolve mac for %s" % ip1)
-            return
-    if mac2 is None:
-        mac2 = getmacbyip(ip2)
-        if not mac2:
-            print("Can't resolve mac for %s" % ip2)
-            return
-    print("MITM on %s: %s <--> %s <--> %s" % (iface, mac1, target_mac, mac2))
+
+    def _tups(ip, mac):
+        # type: (str, Optional[Union[str, List[str]]]) -> Iterable[Tuple[str, str]]
+        if mac is None:
+            if broadcast:
+                # ip can be a Net/list/etc and will be iterated upon while sending
+                return [(ip, "ff:ff:ff:ff:ff:ff")]
+            return [(x.query.pdst, x.answer.hwsrc)
+                    for x in arping(ip, verbose=0)[0]]
+        elif isinstance(mac, list):
+            return [(ip, x) for x in mac]
+        else:
+            return [(ip, mac)]
+
+    tup1 = _tups(ip1, mac1)
+    if not tup1:
+        raise OSError(f"Could not resolve {ip1}")
+    tup2 = _tups(ip2, mac2)
+    if not tup2:
+        raise OSError(f"Could not resolve {ip2}")
+    print(f"MITM on {iface}: %s <--> {target_mac} <--> %s" % (
+        [x[1] for x in tup1],
+        [x[1] for x in tup2],
+    ))
     # We loop who-has requests
     srploop(
-        [
-            Ether(dst=mac1, src=target_mac) /
-            ARP(op="who-has", psrc=ip2, pdst=ip1,
-                hwsrc=target_mac, hwdst="ff:ff:ff:ff:ff:ff"),
-            Ether(dst=mac2, src=target_mac) /
-            ARP(op="who-has", psrc=ip1, pdst=ip2,
-                hwsrc=target_mac, hwdst="ff:ff:ff:ff:ff:ff")
-        ],
+        list(itertools.chain(
+            (x
+             for ipa, maca in tup1
+             for ipb, _ in tup2
+             for x in
+             Ether(dst=maca, src=target_mac) /
+             ARP(op="who-has", psrc=ipb, pdst=ipa,
+                 hwsrc=target_mac, hwdst="00:00:00:00:00:00")
+             ),
+            (x
+             for ipb, macb in tup2
+             for ipa, _ in tup1
+             for x in
+             Ether(dst=macb, src=target_mac) /
+             ARP(op="who-has", psrc=ipa, pdst=ipb,
+                 hwsrc=target_mac, hwdst="00:00:00:00:00:00")
+             ),
+        )),
         filter="arp and arp[7] = 2",
         inter=inter,
         iface=iface,
         timeout=0.5,
         verbose=1,
         store=0,
     )
     print("Restoring...")
-    sendp([
-        Ether(dst=mac1, src=target_mac) /
-        ARP(op="who-has", psrc=ip2, pdst=ip1,
-            hwsrc=mac2, hwdst="ff:ff:ff:ff:ff:ff"),
-        Ether(dst=mac2, src=target_mac) /
-        ARP(op="who-has", psrc=ip1, pdst=ip2,
-            hwsrc=mac1, hwdst="ff:ff:ff:ff:ff:ff")
-    ], iface=iface)
+    sendp(
+        list(itertools.chain(
+            (x
+             for ipa, maca in tup1
+             for ipb, macb in tup2
+             for x in
+             Ether(dst=maca, src=macb) /
+             ARP(op="who-has", psrc=ipb, pdst=ipa,
+                 hwsrc=macb, hwdst="00:00:00:00:00:00")
+             ),
+            (x
+             for ipb, macb in tup2
+             for ipa, maca in tup1
+             for x in
+             Ether(dst=macb, src=maca) /
+             ARP(op="who-has", psrc=ipa, pdst=ipb,
+                 hwsrc=maca, hwdst="00:00:00:00:00:00")
+             ),
+        )),
+        iface=iface
+    )
 
 
 class ARPingResult(SndRcvList):
     def __init__(self,
                  res=None,  # type: Optional[Union[_PacketList[QueryAnswer], List[QueryAnswer]]]  # noqa: E501
                  name="ARPing",  # type: str
                  stats=None  # type: Optional[List[Type[Packet]]]
@@ -878,26 +1000,40 @@
         for src, manuf, psrc in data:
             print("  %-17s %-*s %s" % (src, padding, manuf, psrc))
 
 
 @conf.commands.register
 def arping(net, timeout=2, cache=0, verbose=None, **kargs):
     # type: (str, int, int, Optional[int], **Any) -> Tuple[ARPingResult, PacketList] # noqa: E501
-    """Send ARP who-has requests to determine which hosts are up
-arping(net, [cache=0,] [iface=conf.iface,] [verbose=conf.verb]) -> None
-Set cache=True if you want arping to modify internal ARP-Cache"""
+    """
+    Send ARP who-has requests to determine which hosts are up::
+
+        arping(net, [cache=0,] [iface=conf.iface,] [verbose=conf.verb]) -> None
+
+    Set cache=True if you want arping to modify internal ARP-Cache
+    """
     if verbose is None:
         verbose = conf.verb
+
+    hwaddr = None
+    if "iface" in kargs:
+        hwaddr = get_if_hwaddr(kargs["iface"])
+    r = conf.route.route(str(net), verbose=False)
+
     ans, unans = srp(
-        Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst=net),
+        Ether(dst="ff:ff:ff:ff:ff:ff", src=hwaddr) / ARP(
+            pdst=net,
+            psrc=r[1],
+            hwsrc=hwaddr
+        ),
         verbose=verbose,
         filter="arp and arp[7] = 2",
         timeout=timeout,
         iface_hint=net,
-        **kargs
+        **kargs,
     )
     ans = ARPingResult(ans.res)
 
     if cache and ans is not None:
         for pair in ans:
             _arp_cache[pair[1].psrc] = pair[1].hwsrc
     if ans is not None and verbose:
@@ -920,15 +1056,15 @@
     # type: (str, int, str, **Any) -> Tuple[ARPingResult, PacketList]
     """Send ARP who-has requests to determine which hosts are in promiscuous mode
     promiscping(net, iface=conf.iface)"""
     ans, unans = srp(Ether(dst=fake_bcast) / ARP(pdst=net),
                      filter="arp and arp[7] = 2", timeout=timeout, iface_hint=net, **kargs)  # noqa: E501
     ans = ARPingResult(ans.res, name="PROMISCPing")
 
-    ans.display()
+    ans.show()
     return ans, unans
 
 
 class ARP_am(AnsweringMachine[Packet]):
     """Fake ARP Relay Daemon (farpd)
 
     example:
@@ -968,15 +1104,15 @@
         if isinstance(from_ip, str):
             self.from_ip = Net(from_ip)  # type: Optional[Net]
         else:
             self.from_ip = from_ip
         self.ARP_addr = ARP_addr
 
     def is_request(self, req):
-        # type: (Ether) -> bool
+        # type: (Packet) -> bool
         if not req.haslayer(ARP):
             return False
         arp = req[ARP]
         return (
             arp.op == 1 and
             (self.IP_addr is None or arp.pdst in self.IP_addr) and
             (self.from_ip is None or arp.psrc in self.from_ip)
@@ -1033,15 +1169,15 @@
     # type: (str, int, int, **Any) -> Tuple[SndRcvList, PacketList]
     """Exploit ARP leak flaws, like NetBSD-SA2017-002.
 
 https://ftp.netbsd.org/pub/NetBSD/security/advisories/NetBSD-SA2017-002.txt.asc
 
     """
     # We want explicit packets
-    pkts_iface = {}  # type: Dict[str, List[Ether]]
+    pkts_iface = {}  # type: Dict[str, List[Packet]]
     for pkt in ARP(pdst=target):
         # We have to do some of Scapy's work since we mess with
         # important values
         iface = conf.route.route(pkt.pdst)[0]
         psrc = get_if_addr(iface)
         hwsrc = get_if_hwaddr(iface)
         pkt.plen = plen
@@ -1055,15 +1191,15 @@
             pkt.hwsrc = hwsrc
         else:
             pkt.hwsrc = mac2str(hwsrc)[:hwlen]
         pkts_iface.setdefault(iface, []).append(
             Ether(src=hwsrc, dst=ETHER_BROADCAST) / pkt
         )
     ans, unans = SndRcvList(), PacketList(name="Unanswered")
-    for iface, pkts in viewitems(pkts_iface):
+    for iface, pkts in pkts_iface.items():
         ans_new, unans_new = srp(pkts, iface=iface, filter="arp", **kargs)
         ans += ans_new
         unans += unans_new
         ans.listname = "Results"
         unans.listname = "Unanswered"
     for _, rcv in ans:
         if ARP not in rcv:
```

### Comparing `scapy-2.5.0rc3/scapy/layers/l2tp.py` & `scapy-2.6.0rc1/scapy/layers/l2tp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/llmnr.py` & `scapy-2.6.0rc1/scapy/layers/llmnr.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,61 +10,65 @@
 
 LLMNR is based on the DNS packet format (RFC1035 Section 4)
 RFC also envisions LLMNR over TCP. Like vista, we don't support it -- arno
 """
 
 import struct
 
-from scapy.fields import BitEnumField, BitField, ShortField
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    DestField,
+    DestIP6Field,
+    ShortField,
+)
 from scapy.packet import Packet, bind_layers, bind_bottom_up
 from scapy.compat import orb
 from scapy.layers.inet import UDP
 from scapy.layers.dns import (
-    DNSQRField,
-    DNSRRField,
-    DNSRRCountField,
+    DNSCompressedPacket,
     DNS_am,
+    DNS,
 )
 
 
 _LLMNR_IPv6_mcast_Addr = "FF02:0:0:0:0:0:1:3"
 _LLMNR_IPv4_mcast_addr = "224.0.0.252"
 
 
-class LLMNRQuery(Packet):
+class LLMNRQuery(DNSCompressedPacket):
     name = "Link Local Multicast Node Resolution - Query"
-    fields_desc = [ShortField("id", 0),
-                   BitField("qr", 0, 1),
-                   BitEnumField("opcode", 0, 4, {0: "QUERY"}),
-                   BitField("c", 0, 1),
-                   BitField("tc", 0, 2),
-                   BitField("z", 0, 4),
-                   BitEnumField("rcode", 0, 4, {0: "ok"}),
-                   DNSRRCountField("qdcount", None, "qd"),
-                   DNSRRCountField("ancount", None, "an"),
-                   DNSRRCountField("nscount", None, "ns"),
-                   DNSRRCountField("arcount", None, "ar"),
-                   DNSQRField("qd", "qdcount", None),
-                   DNSRRField("an", "ancount", None),
-                   DNSRRField("ns", "nscount", None),
-                   DNSRRField("ar", "arcount", None, 0)]
+    qd = []
+    fields_desc = [
+        ShortField("id", 0),
+        BitField("qr", 0, 1),
+        BitEnumField("opcode", 0, 4, {0: "QUERY"}),
+        BitField("c", 0, 1),
+        BitField("tc", 0, 1),
+        BitField("t", 0, 1),
+        BitField("z", 0, 4)
+    ] + DNS.fields_desc[-9:]
     overload_fields = {UDP: {"sport": 5355, "dport": 5355}}
 
+    def get_full(self):
+        # Required for DNSCompressedPacket
+        return self.original
+
     def hashret(self):
         return struct.pack("!H", self.id)
 
     def mysummary(self):
         if self.an:
             return "LLMNRResponse '%s' is at '%s'" % (
-                self.an.rrname.decode(),
-                self.an.rdata,
+                self.an[0].rrname.decode(errors="backslashreplace"),
+                self.an[0].rdata,
             ), [UDP]
         if self.qd:
             return "LLMNRQuery who has '%s'" % (
-                self.qd.qname.decode(),
+                self.qd[0].qname.decode(errors="backslashreplace"),
             ), [UDP]
 
 
 class LLMNRResponse(LLMNRQuery):
     name = "Link Local Multicast Node Resolution - Response"
     qr = 1
 
@@ -86,15 +90,20 @@
         return cls
 
 
 bind_bottom_up(UDP, _LLMNR, dport=5355)
 bind_bottom_up(UDP, _LLMNR, sport=5355)
 bind_layers(UDP, _LLMNR, sport=5355, dport=5355)
 
+DestField.bind_addr(LLMNRQuery, _LLMNR_IPv4_mcast_addr, dport=5355)
+DestField.bind_addr(LLMNRResponse, _LLMNR_IPv4_mcast_addr, dport=5355)
+DestIP6Field.bind_addr(LLMNRQuery, _LLMNR_IPv6_mcast_Addr, dport=5355)
+DestIP6Field.bind_addr(LLMNRResponse, _LLMNR_IPv6_mcast_Addr, dport=5355)
+
 
 class LLMNR_am(DNS_am):
-    function_name = "llmnr_spoof"
+    function_name = "llmnrd"
     filter = "udp port 5355"
     cls = LLMNRQuery
 
 
 # LLMNRQuery(id=RandShort(), qd=DNSQR(qname="vista.")))
```

### Comparing `scapy-2.5.0rc3/scapy/layers/lltd.py` & `scapy-2.6.0rc1/scapy/layers/lltd.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,28 +5,26 @@
 
 """LLTD Protocol
 
 https://msdn.microsoft.com/en-us/library/cc233983.aspx
 
 """
 
-from __future__ import absolute_import
 from array import array
 
 from scapy.fields import BitField, FlagsField, ByteField, ByteEnumField, \
     ShortField, ShortEnumField, ThreeBytesField, IntField, IntEnumField, \
     LongField, MultiEnumField, FieldLenField, FieldListField, \
     PacketListField, StrLenField, StrLenFieldUtf16, ConditionalField, MACField
 from scapy.packet import Packet, Padding, bind_layers
 from scapy.plist import PacketList
 from scapy.layers.l2 import Ether
 from scapy.layers.inet import IPField
 from scapy.layers.inet6 import IP6Field
 from scapy.data import ETHER_ANY
-import scapy.libs.six as six
 from scapy.compat import orb, chb
 
 
 # Protocol layers
 ##################
 
 
@@ -295,15 +293,15 @@
 
     @classmethod
     def dispatch_hook(cls, _pkt=None, *_, **kargs):
         if _pkt:
             cmd = orb(_pkt[0])
         elif "type" in kargs:
             cmd = kargs["type"]
-            if isinstance(cmd, six.string_types):
+            if isinstance(cmd, str):
                 cmd = cls.fields_desc[0].s2i[cmd]
         else:
             return cls
         return SPECIFIC_CLASSES.get(cmd, cls)
 
 
 SPECIFIC_CLASSES = {}
@@ -713,15 +711,15 @@
     name = "LLTD Attribute - Machine Name"
     fields_desc = [
         FieldLenField("len", None, length_of="hostname", fmt="B"),
         StrLenFieldUtf16("hostname", "", length_from=lambda pkt: pkt.len),
     ]
 
     def mysummary(self):
-        return (self.sprintf("Hostname: %r" % self.hostname),
+        return (f"Hostname: {self.hostname!r}",
                 [LLTD, LLTDAttributeHostID])
 
 
 @_register_lltd_specific_class(18)
 class LLTDAttributeDeviceUUID(LLTDAttribute):
     name = "LLTD Attribute - Device UUID"
     fields_desc = [
@@ -838,8 +836,8 @@
     def get_data(self):
         """Returns a dictionary object, keys are strings "source >
         destincation [content type]", and values are the content
         fetched, also as a string.
 
         """
         return {key: "".join(chr(byte) for byte in data)
-                for key, data in six.iteritems(self.data)}
+                for key, data in self.data.items()}
```

### Comparing `scapy-2.5.0rc3/scapy/layers/mgcp.py` & `scapy-2.6.0rc1/scapy/layers/mgcp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/mobileip.py` & `scapy-2.6.0rc1/scapy/layers/mobileip.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/mspac.py` & `scapy-2.6.0rc1/scapy/layers/msrpce/mspac.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
-# Copyright (C) Gabriel Potter <gabriel[]potter[]fr>
+# Copyright (C) Gabriel Potter
 
 """
 [MS-PAC]
 
 https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962
+Up to date with version: 23.0
 """
 
 import struct
 
 from scapy.config import conf
 from scapy.error import log_runtime
 from scapy.fields import (
@@ -19,112 +20,123 @@
     FieldListField,
     FlagsField,
     LEIntEnumField,
     LELongField,
     LEIntField,
     LEShortField,
     MultipleTypeField,
-    PacketLenField,
+    PacketField,
     PacketListField,
     StrField,
     StrFieldUtf16,
     StrFixedLenField,
     StrLenFieldUtf16,
     UTCTimeField,
     XStrField,
     XStrLenField,
 )
 from scapy.packet import Packet
-from scapy.layers.kerberos import _AUTHORIZATIONDATA_VALUES
+from scapy.layers.kerberos import (
+    _AUTHORIZATIONDATA_VALUES,
+    _KRB_S_TYPES,
+)
 from scapy.layers.dcerpc import (
-    _NDRConfField,
     NDRByteField,
+    NDRConfFieldListField,
+    NDRConfPacketListField,
     NDRConfStrLenField,
-    NDRConfVarStrLenField,
     NDRConfVarStrLenFieldUtf16,
-    NDRConfPacketListField,
-    NDRConfFieldListField,
     NDRConfVarStrNullFieldUtf16,
     NDRConformantString,
+    NDRFieldListField,
     NDRFullPointerField,
     NDRInt3264EnumField,
     NDRIntField,
     NDRLongField,
     NDRPacket,
     NDRPacketField,
     NDRSerialization1Header,
+    NDRSerializeType1PacketLenField,
     NDRShortField,
     NDRSignedLongField,
     NDRUnionField,
+    _NDRConfField,
     ndr_deserialize1,
     ndr_serialize1,
 )
 from scapy.layers.ntlm import (
     _NTLMPayloadField,
     _NTLMPayloadPacket,
-    _NTLM_post_build,
 )
+from scapy.layers.smb2 import WINNT_SID
 
 # sect 2.4
 
 
 class PAC_INFO_BUFFER(Packet):
     fields_desc = [
         LEIntEnumField(
             "ulType",
             0x00000001,
             {
                 0x00000001: "Logon information",
                 0x00000002: "Credentials information",
-                0x00000006: "Server checksum",
-                0x00000007: "KDC checksum",
+                0x00000006: "Server Signature",
+                0x00000007: "KDC Signature",
                 0x0000000A: "Client name and ticket information",
                 0x0000000B: "Constrained delegation information",
                 0x0000000C: "UPN and DNS information",
                 0x0000000D: "Client claims information",
                 0x0000000E: "Device information",
                 0x0000000F: "Device claims information",
-                0x00000010: "Ticket checksum",
+                0x00000010: "Ticket Signature",
                 0x00000011: "PAC Attributes",
                 0x00000012: "PAC Requestor",
+                0x00000013: "Extended KDC Signature",
             },
         ),
         LEIntField("cbBufferSize", None),
         LELongField("Offset", None),
     ]
 
     def default_payload_class(self, payload):
         return conf.padding_layer
 
 
 _PACTYPES = {}
 
-# sect 2.5 - NDR PACKETS AUTO-GENERATED
+
+# sect 2.5 - NDR PACKETS
 
 
 class RPC_UNICODE_STRING(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRShortField("Length", 0),
-        NDRShortField("MaximumLength", 0),
+        NDRShortField("Length", None, size_of="Buffer", adjust=lambda _, x: (x * 2)),
+        NDRShortField(
+            "MaximumLength", None, size_of="Buffer", adjust=lambda _, x: (x * 2)
+        ),
         NDRFullPointerField(
             NDRConfVarStrLenFieldUtf16(
-                "Buffer", "", length_from=lambda pkt: (pkt.Length // 2)
+                "Buffer",
+                "",
+                size_is=lambda pkt: (pkt.MaximumLength // 2),
+                length_is=lambda pkt: (pkt.Length // 2),
             ),
             deferred=True,
         ),
     ]
 
 
 class FILETIME(NDRPacket):
     ALIGNMENT = (4, 4)
     fields_desc = [NDRIntField("dwLowDateTime", 0), NDRIntField("dwHighDateTime", 0)]
 
 
-class PGROUP_MEMBERSHIP(NDRPacket):
+class GROUP_MEMBERSHIP(NDRPacket):
     ALIGNMENT = (4, 4)
     fields_desc = [NDRIntField("RelativeId", 0), NDRIntField("Attributes", 0)]
 
 
 class CYPHER_BLOCK(NDRPacket):
     fields_desc = [StrFixedLenField("data", "", length=8)]
 
@@ -133,39 +145,42 @@
     fields_desc = [PacketListField("data", [], CYPHER_BLOCK, count_from=lambda _: 2)]
 
 
 class RPC_SID_IDENTIFIER_AUTHORITY(NDRPacket):
     fields_desc = [StrFixedLenField("Value", "", length=6)]
 
 
-class PSID(NDRPacket):
+class SID(NDRPacket):
     ALIGNMENT = (4, 8)
-    CONFORMANT_COUNT = 1
+    DEPORTED_CONFORMANTS = ["SubAuthority"]
     fields_desc = [
         NDRByteField("Revision", 0),
-        NDRByteField("SubAuthorityCount", 0),
+        NDRByteField("SubAuthorityCount", None, size_of="SubAuthority"),
         NDRPacketField(
             "IdentifierAuthority",
             RPC_SID_IDENTIFIER_AUTHORITY(),
             RPC_SID_IDENTIFIER_AUTHORITY,
         ),
         NDRConfFieldListField(
             "SubAuthority",
             [],
             NDRIntField("", 0),
-            count_from=lambda pkt: pkt.SubAuthorityCount,
+            size_is=lambda pkt: pkt.SubAuthorityCount,
             conformant_in_struct=True,
         ),
     ]
 
+    def summary(self):
+        return WINNT_SID.summary(self)
 
-class PKERB_SID_AND_ATTRIBUTES(NDRPacket):
+
+class KERB_SID_AND_ATTRIBUTES(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRFullPointerField(NDRPacketField("Sid", PSID(), PSID), deferred=True),
+        NDRFullPointerField(NDRPacketField("Sid", SID(), SID), deferred=True),
         NDRIntField("Attributes", 0),
     ]
 
 
 class KERB_VALIDATION_INFO(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
@@ -181,67 +196,59 @@
         NDRPacketField("ProfilePath", RPC_UNICODE_STRING(), RPC_UNICODE_STRING),
         NDRPacketField("HomeDirectory", RPC_UNICODE_STRING(), RPC_UNICODE_STRING),
         NDRPacketField("HomeDirectoryDrive", RPC_UNICODE_STRING(), RPC_UNICODE_STRING),
         NDRShortField("LogonCount", 0),
         NDRShortField("BadPasswordCount", 0),
         NDRIntField("UserId", 0),
         NDRIntField("PrimaryGroupId", 0),
-        NDRIntField("GroupCount", 0),
+        NDRIntField("GroupCount", None, size_of="GroupIds"),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "GroupIds",
-                [PGROUP_MEMBERSHIP()],
-                PGROUP_MEMBERSHIP,
-                count_from=lambda pkt: pkt.GroupCount,
+                [GROUP_MEMBERSHIP()],
+                GROUP_MEMBERSHIP,
+                size_is=lambda pkt: pkt.GroupCount,
             ),
             deferred=True,
         ),
         NDRIntField("UserFlags", 0),
         NDRPacketField("UserSessionKey", USER_SESSION_KEY(), USER_SESSION_KEY),
         NDRPacketField("LogonServer", RPC_UNICODE_STRING(), RPC_UNICODE_STRING),
         NDRPacketField("LogonDomainName", RPC_UNICODE_STRING(), RPC_UNICODE_STRING),
-        NDRFullPointerField(
-            NDRPacketField("LogonDomainId", PSID(), PSID), deferred=True
-        ),
-        FieldListField("Reserved1", [], NDRIntField("", 0), count_from=lambda _: 2),
+        NDRFullPointerField(NDRPacketField("LogonDomainId", SID(), SID), deferred=True),
+        NDRFieldListField("Reserved1", [], NDRIntField("", 0), length_is=lambda _: 2),
         NDRIntField("UserAccountControl", 0),
-        FieldListField("Reserved3", [], NDRIntField("", 0), count_from=lambda _: 7),
-        NDRIntField("SidCount", 0),
+        NDRFieldListField("Reserved3", [], NDRIntField("", 0), length_is=lambda _: 7),
+        NDRIntField("SidCount", None, size_of="ExtraSids"),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "ExtraSids",
-                [PKERB_SID_AND_ATTRIBUTES()],
-                PKERB_SID_AND_ATTRIBUTES,
-                count_from=lambda pkt: pkt.SidCount,
+                [KERB_SID_AND_ATTRIBUTES()],
+                KERB_SID_AND_ATTRIBUTES,
+                size_is=lambda pkt: pkt.SidCount,
             ),
             deferred=True,
         ),
         NDRFullPointerField(
-            NDRPacketField("ResourceGroupDomainSid", PSID(), PSID), deferred=True
+            NDRPacketField("ResourceGroupDomainSid", SID(), SID), deferred=True
         ),
-        NDRIntField("ResourceGroupCount", 0),
+        NDRIntField("ResourceGroupCount", None, size_of="ResourceGroupIds"),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "ResourceGroupIds",
-                [PGROUP_MEMBERSHIP()],
-                PGROUP_MEMBERSHIP,
-                count_from=lambda pkt: pkt.ResourceGroupCount,
+                [GROUP_MEMBERSHIP()],
+                GROUP_MEMBERSHIP,
+                size_is=lambda pkt: pkt.ResourceGroupCount,
             ),
             deferred=True,
         ),
     ]
 
 
-class KERB_VALIDATION_INFO_WRAP(NDRPacket):
-    # Extra packing class to handle all deferred pointers
-    # (usually, this would be the packing RPC request/response)
-    fields_desc = [NDRPacketField("data", None, KERB_VALIDATION_INFO)]
-
-
-_PACTYPES[1] = KERB_VALIDATION_INFO_WRAP
+_PACTYPES[1] = KERB_VALIDATION_INFO
 
 # sect 2.6
 
 
 class PAC_CREDENTIAL_INFO(Packet):
     fields_desc = [
         LEIntField("Version", 0),
@@ -263,56 +270,91 @@
 _PACTYPES[2] = PAC_CREDENTIAL_INFO
 
 # sect 2.7
 
 
 class PAC_CLIENT_INFO(Packet):
     fields_desc = [
-        UTCTimeField("ClientId", None, fmt="<Q", custom_scaling=1e8),
+        UTCTimeField(
+            "ClientId", None, fmt="<Q", epoch=[1601, 1, 1, 0, 0, 0], custom_scaling=1e7
+        ),
         FieldLenField("NameLength", None, length_of="Name", fmt="<H"),
         StrLenFieldUtf16("Name", b"", length_from=lambda pkt: pkt.NameLength),
     ]
 
 
 _PACTYPES[0xA] = PAC_CLIENT_INFO
 
 # sect 2.8
 
 
 class PAC_SIGNATURE_DATA(Packet):
     fields_desc = [
         LEIntEnumField(
             "SignatureType",
-            0,
-            {
-                0xFFFFFF76: "KERB_CHECKSUM_HMAC_MD5",
-                0x0000000F: "HMAC_SHA1_96_AES128",
-                0x00000010: "HMAC_SHA1_96_AES256",
-            },
+            None,
+            _KRB_S_TYPES,
         ),
         XStrLenField(
             "Signature",
             b"",
             length_from=lambda pkt: {
+                0x1: 4,
                 0xFFFFFF76: 16,
                 0x0000000F: 12,
                 0x00000010: 12,
             }.get(pkt.SignatureType, 0),
         ),
         StrField("RODCIdentifier", b""),
     ]
 
 
 _PACTYPES[6] = PAC_SIGNATURE_DATA
 _PACTYPES[7] = PAC_SIGNATURE_DATA
 _PACTYPES[0x10] = PAC_SIGNATURE_DATA
+_PACTYPES[0x13] = PAC_SIGNATURE_DATA
+
+# sect 2.9
+
+
+class S4U_DELEGATION_INFO(NDRPacket):
+    ALIGNMENT = (4, 8)
+    fields_desc = [
+        NDRPacketField("S4U2proxyTarget", RPC_UNICODE_STRING(), RPC_UNICODE_STRING),
+        NDRIntField("TransitedListSize", None, size_of="S4UTransitedServices"),
+        NDRFullPointerField(
+            NDRConfPacketListField(
+                "S4UTransitedServices",
+                [RPC_UNICODE_STRING()],
+                RPC_UNICODE_STRING,
+                size_is=lambda pkt: pkt.TransitedListSize,
+            ),
+            deferred=True,
+        ),
+    ]
+
 
 # sect 2.10
 
 
+def _pac_post_build(self, p, pay_offset, fields):
+    """Util function to build the offset and populate the lengths"""
+    for field_name, value in self.fields["Payload"]:
+        length = self.get_field("Payload").fields_map[field_name].i2len(self, value)
+        offset = fields[field_name]
+        # Length
+        if self.getfieldval(field_name + "Len") is None:
+            p = p[:offset] + struct.pack("<H", length) + p[offset + 2 :]
+        # Offset
+        if self.getfieldval(field_name + "BufferOffset") is None:
+            p = p[: offset + 2] + struct.pack("<H", pay_offset) + p[offset + 4 :]
+        pay_offset += length
+    return p
+
+
 class UPN_DNS_INFO(_NTLMPayloadPacket):
     fields_desc = [
         LEShortField("UpnLen", None),
         LEShortField("UpnBufferOffset", None),
         LEShortField("DnsDomainNameLen", None),
         LEShortField("DnsDomainNameBufferOffset", None),
         FlagsField(
@@ -351,15 +393,15 @@
                     _NTLMPayloadField(
                         "Payload",
                         20,
                         [
                             StrFieldUtf16("Upn", b""),
                             StrFieldUtf16("DnsDomainName", b""),
                             StrFieldUtf16("SamName", b""),
-                            XStrField("Sid", b""),
+                            PacketField("Sid", WINNT_SID(), WINNT_SID),
                         ],
                     ),
                     lambda pkt: pkt.Flags.S,
                 )
             ],
             # Not-extended
             _NTLMPayloadField(
@@ -371,31 +413,37 @@
                 ],
             ),
         ),
     ]
 
     def post_build(self, pkt, pay):
         # type: (bytes, bytes) -> bytes
+        offset = 12
+        fields = {
+            "Upn": 0,
+            "DnsDomainName": 4,
+        }
+        if self.Flags.S:
+            offset = 20
+            fields["SamName"] = 12
+            fields["Sid"] = 16
         return (
-            _NTLM_post_build(
+            _pac_post_build(
                 self,
                 pkt,
-                self.OFFSET,
-                {
-                    "Upn": 0,
-                    "DnsDomainName": 4,
-                },
-            ) +
-            pay
+                offset,
+                fields,
+            )
+            + pay
         )
 
 
 _PACTYPES[0xC] = UPN_DNS_INFO
 
-# sect 2.11 - NDR PACKETS AUTO-GENERATED
+# sect 2.11 - NDR PACKETS
 
 try:
     from enum import IntEnum
 except ImportError:
     IntEnum = object
 
 
@@ -414,300 +462,306 @@
 class CLAIMS_COMPRESSION_FORMAT(IntEnum):
     COMPRESSION_FORMAT_NONE = 0
     COMPRESSION_FORMAT_LZNT1 = 2
     COMPRESSION_FORMAT_XPRESS = 3
     COMPRESSION_FORMAT_XPRESS_HUFF = 4
 
 
-class u_sub0(NDRPacket):
+class CLAIM_ENTRY_sub0(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRIntField("ValueCount", 0),
+        NDRIntField("ValueCount", None, size_of="Int64Values"),
         NDRFullPointerField(
             NDRConfFieldListField(
                 "Int64Values",
                 [],
                 NDRSignedLongField,
-                count_from=lambda pkt: pkt.ValueCount,
+                size_is=lambda pkt: pkt.ValueCount,
             ),
             deferred=True,
         ),
     ]
 
 
-class u_sub1(NDRPacket):
+class CLAIM_ENTRY_sub1(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRIntField("ValueCount", 0),
+        NDRIntField("ValueCount", None, size_of="Uint64Values"),
         NDRFullPointerField(
             NDRConfFieldListField(
-                "Uint64Values", [], NDRLongField, count_from=lambda pkt: pkt.ValueCount
+                "Uint64Values", [], NDRLongField, size_is=lambda pkt: pkt.ValueCount
             ),
             deferred=True,
         ),
     ]
 
 
-class u_sub2(NDRPacket):
+class CLAIM_ENTRY_sub2(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRIntField("ValueCount", 0),
+        NDRIntField("ValueCount", None, size_of="StringValues"),
         NDRFullPointerField(
             NDRConfFieldListField(
                 "StringValues",
                 [],
                 NDRFullPointerField(
                     NDRConfVarStrNullFieldUtf16("StringVal", ""),
                     deferred=True,
                 ),
-                count_from=lambda pkt: pkt.ValueCount,
+                size_is=lambda pkt: pkt.ValueCount,
             ),
             deferred=True,
         ),
     ]
 
 
-class u_sub3(NDRPacket):
+class CLAIM_ENTRY_sub3(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRIntField("ValueCount", 0),
+        NDRIntField("ValueCount", None, size_of="BooleanValues"),
         NDRFullPointerField(
             NDRConfFieldListField(
-                "BooleanValues", [], NDRLongField, count_from=lambda pkt: pkt.ValueCount
+                "BooleanValues", [], NDRLongField, size_is=lambda pkt: pkt.ValueCount
             ),
             deferred=True,
         ),
     ]
 
 
 class CLAIM_ENTRY(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
         NDRFullPointerField(NDRConfVarStrNullFieldUtf16("Id", ""), deferred=True),
         NDRInt3264EnumField("Type", 0, CLAIM_TYPE),
         NDRUnionField(
             [
                 (
-                    NDRPacketField("Values", u_sub0(), u_sub0),
+                    NDRPacketField("Values", CLAIM_ENTRY_sub0(), CLAIM_ENTRY_sub0),
                     (
                         (
-                            lambda pkt: getattr(pkt, "Type", None) ==
-                            CLAIM_TYPE.CLAIM_TYPE_INT64
+                            lambda pkt: getattr(pkt, "Type", None)
+                            == CLAIM_TYPE.CLAIM_TYPE_INT64
                         ),
                         (lambda _, val: val.tag == CLAIM_TYPE.CLAIM_TYPE_INT64),
                     ),
                 ),
                 (
-                    NDRPacketField("Values", u_sub1(), u_sub1),
+                    NDRPacketField("Values", CLAIM_ENTRY_sub1(), CLAIM_ENTRY_sub1),
                     (
                         (
-                            lambda pkt: getattr(pkt, "Type", None) ==
-                            CLAIM_TYPE.CLAIM_TYPE_UINT64
+                            lambda pkt: getattr(pkt, "Type", None)
+                            == CLAIM_TYPE.CLAIM_TYPE_UINT64
                         ),
                         (lambda _, val: val.tag == CLAIM_TYPE.CLAIM_TYPE_UINT64),
                     ),
                 ),
                 (
-                    NDRPacketField("Values", u_sub2(), u_sub2),
+                    NDRPacketField("Values", CLAIM_ENTRY_sub2(), CLAIM_ENTRY_sub2),
                     (
                         (
-                            lambda pkt: getattr(pkt, "Type", None) ==
-                            CLAIM_TYPE.CLAIM_TYPE_STRING
+                            lambda pkt: getattr(pkt, "Type", None)
+                            == CLAIM_TYPE.CLAIM_TYPE_STRING
                         ),
                         (lambda _, val: val.tag == CLAIM_TYPE.CLAIM_TYPE_STRING),
                     ),
                 ),
                 (
-                    NDRPacketField("Values", u_sub3(), u_sub3),
+                    NDRPacketField("Values", CLAIM_ENTRY_sub3(), CLAIM_ENTRY_sub3),
                     (
                         (
-                            lambda pkt: getattr(pkt, "Type", None) ==
-                            CLAIM_TYPE.CLAIM_TYPE_BOOLEAN
+                            lambda pkt: getattr(pkt, "Type", None)
+                            == CLAIM_TYPE.CLAIM_TYPE_BOOLEAN
                         ),
                         (lambda _, val: val.tag == CLAIM_TYPE.CLAIM_TYPE_BOOLEAN),
                     ),
                 ),
             ],
             StrFixedLenField("Values", "", length=0),
             align=(2, 8),
-            switch_fmt=("<H", "<I"),
+            switch_fmt=("H", "I"),
         ),
     ]
 
 
 class CLAIMS_ARRAY(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
         NDRInt3264EnumField("usClaimsSourceType", 0, CLAIMS_SOURCE_TYPE),
-        NDRIntField("ulClaimsCount", 0),
+        NDRIntField("ulClaimsCount", None, size_of="ClaimEntries"),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "ClaimEntries",
                 [CLAIM_ENTRY()],
                 CLAIM_ENTRY,
-                count_from=lambda pkt: pkt.ulClaimsCount,
+                size_is=lambda pkt: pkt.ulClaimsCount,
             ),
             deferred=True,
         ),
     ]
 
 
 class CLAIMS_SET(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRIntField("ulClaimsArrayCount", 0),
+        NDRIntField("ulClaimsArrayCount", None, size_of="ClaimsArrays"),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "ClaimsArrays",
                 [CLAIMS_ARRAY()],
                 CLAIMS_ARRAY,
-                count_from=lambda pkt: pkt.ulClaimsArrayCount,
+                size_is=lambda pkt: pkt.ulClaimsArrayCount,
             ),
             deferred=True,
         ),
         NDRShortField("usReservedType", 0),
-        NDRIntField("ulReservedFieldSize", 0),
+        NDRIntField("ulReservedFieldSize", None, size_of="ReservedField"),
         NDRFullPointerField(
             NDRConfStrLenField(
-                "ReservedField", "", length_from=lambda pkt: pkt.ulReservedFieldSize
+                "ReservedField", "", size_is=lambda pkt: pkt.ulReservedFieldSize
             ),
             deferred=True,
         ),
     ]
 
 
-class CLAIMS_SET_WRAP(NDRPacket):
-    # Extra packing class to handle all deferred pointers
-    # (usually, this would be the packing RPC request/response)
-    fields_desc = [NDRPacketField("data", None, CLAIMS_SET)]
-
+class _CLAIMSClaimSet(_NDRConfField, NDRSerializeType1PacketLenField):
+    CONFORMANT_STRING = True
+    LENGTH_FROM = True
 
-class _CLAIMSClaimSet(_NDRConfField, PacketLenField):
     def m2i(self, pkt, s):
         if pkt.usCompressionFormat == CLAIMS_COMPRESSION_FORMAT.COMPRESSION_FORMAT_NONE:
-            return ndr_deserialize1(s, CLAIMS_SET_WRAP)
+            return ndr_deserialize1(s, CLAIMS_SET, ndr64=False)
         else:
             # TODO: There are 3 funky compression formats... see sect 2.2.18.4
             return NDRConformantString(value=s)
 
+    def i2m(self, pkt, val):
+        val = val[0]
+        if pkt.usCompressionFormat == CLAIMS_COMPRESSION_FORMAT.COMPRESSION_FORMAT_NONE:
+            return ndr_serialize1(val)
+        else:
+            # funky
+            return bytes(val)
+
+    def valueof(self, pkt, x):
+        if pkt.usCompressionFormat == CLAIMS_COMPRESSION_FORMAT.COMPRESSION_FORMAT_NONE:
+            return self._subval(x)[0]
+        else:
+            return x
+
 
 class CLAIMS_SET_METADATA(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRIntField("ulClaimsSetSize", 0),
+        NDRIntField("ulClaimsSetSize", None, size_of="ClaimsSet"),
         NDRFullPointerField(
             _CLAIMSClaimSet(
-                "ClaimsSet", None, None, length_from=lambda pkt: pkt.ulClaimsSetSize
+                "ClaimsSet", None, None, size_is=lambda pkt: pkt.ulClaimsSetSize
             ),
             deferred=True,
         ),
         NDRInt3264EnumField(
             "usCompressionFormat",
             0,
             CLAIMS_COMPRESSION_FORMAT,
         ),
-        NDRIntField("ulUncompressedClaimsSetSize", 0),
+        # this size_of is technically wrong. we just assume it's uncompressed...
+        NDRIntField("ulUncompressedClaimsSetSize", None, size_of="ClaimsSet"),
         NDRShortField("usReservedType", 0),
-        NDRIntField("ulReservedFieldSize", 0),
+        NDRIntField("ulReservedFieldSize", None, size_of="ReservedField"),
         NDRFullPointerField(
-            NDRConfVarStrLenField(
-                "ReservedField", "", length_from=lambda pkt: pkt.ulReservedFieldSize
+            NDRConfStrLenField(
+                "ReservedField", "", size_is=lambda pkt: pkt.ulReservedFieldSize
             ),
             deferred=True,
         ),
     ]
 
 
 class PAC_CLIENT_CLAIMS_INFO(NDRPacket):
-    fields_desc = [NDRPacketField("Claims", None, CLAIMS_SET_METADATA)]
+    fields_desc = [NDRPacketField("Claims", CLAIMS_SET_METADATA(), CLAIMS_SET_METADATA)]
 
 
 if IntEnum != object:
     # If not available, ignore. I can't be bothered
     _PACTYPES[0xD] = PAC_CLIENT_CLAIMS_INFO
 
 
-# sect 2.12 - NDR PACKETS AUTO-GENERATED
+# sect 2.12 - NDR PACKETS
 
 
-class PDOMAIN_GROUP_MEMBERSHIP(NDRPacket):
+class DOMAIN_GROUP_MEMBERSHIP(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
-        NDRFullPointerField(NDRPacketField("DomainId", PSID(), PSID), deferred=True),
+        NDRFullPointerField(NDRPacketField("DomainId", SID(), SID), deferred=True),
         NDRIntField("GroupCount", 0),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "GroupIds",
-                [PGROUP_MEMBERSHIP()],
-                PGROUP_MEMBERSHIP,
-                count_from=lambda pkt: pkt.GroupCount,
+                [GROUP_MEMBERSHIP()],
+                GROUP_MEMBERSHIP,
+                size_is=lambda pkt: pkt.GroupCount,
             ),
             deferred=True,
         ),
     ]
 
 
 class PAC_DEVICE_INFO(NDRPacket):
     ALIGNMENT = (4, 8)
     fields_desc = [
         NDRIntField("UserId", 0),
         NDRIntField("PrimaryGroupId", 0),
         NDRFullPointerField(
-            NDRPacketField("AccountDomainId", PSID(), PSID), deferred=True
+            NDRPacketField("AccountDomainId", SID(), SID), deferred=True
         ),
         NDRIntField("AccountGroupCount", 0),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "AccountGroupIds",
-                [PGROUP_MEMBERSHIP()],
-                PGROUP_MEMBERSHIP,
-                count_from=lambda pkt: pkt.AccountGroupCount,
+                [GROUP_MEMBERSHIP()],
+                GROUP_MEMBERSHIP,
+                size_is=lambda pkt: pkt.AccountGroupCount,
             ),
             deferred=True,
         ),
         NDRIntField("SidCount", 0),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "ExtraSids",
-                [PKERB_SID_AND_ATTRIBUTES()],
-                PKERB_SID_AND_ATTRIBUTES,
-                count_from=lambda pkt: pkt.SidCount,
+                [KERB_SID_AND_ATTRIBUTES()],
+                KERB_SID_AND_ATTRIBUTES,
+                size_is=lambda pkt: pkt.SidCount,
             ),
             deferred=True,
         ),
         NDRIntField("DomainGroupCount", 0),
         NDRFullPointerField(
             NDRConfPacketListField(
                 "DomainGroup",
-                [PDOMAIN_GROUP_MEMBERSHIP()],
-                PDOMAIN_GROUP_MEMBERSHIP,
-                count_from=lambda pkt: pkt.DomainGroupCount,
+                [DOMAIN_GROUP_MEMBERSHIP()],
+                DOMAIN_GROUP_MEMBERSHIP,
+                size_is=lambda pkt: pkt.DomainGroupCount,
             ),
             deferred=True,
         ),
     ]
 
 
-class PAC_DEVICE_INFO_WRAP(NDRPacket):
-    # Extra packing class to handle all deferred pointers
-    # (usually, this would be the packing RPC request/response)
-    fields_desc = [NDRPacketField("data", None, PAC_DEVICE_INFO)]
-
-
-_PACTYPES[0xE] = PAC_DEVICE_INFO_WRAP
+_PACTYPES[0xE] = PAC_DEVICE_INFO
 
 # sect 2.14 - PAC_ATTRIBUTES_INFO
 
 
 class PAC_ATTRIBUTES_INFO(Packet):
     fields_desc = [
-        LEIntField("FlagsLength", 0),
+        LEIntField("FlagsLength", 2),
         FieldListField(
             "Flags",
-            [],
+            ["PAC_WAS_REQUESTED"],
             FlagsField(
                 "",
                 0,
                 -32,
                 {
                     0x00000001: "PAC_WAS_REQUESTED",
                     0x00000002: "PAC_WAS_GIVEN_IMPLICITLY",
@@ -720,15 +774,17 @@
 
 _PACTYPES[0x11] = PAC_ATTRIBUTES_INFO
 
 # sect 2.15 - PAC_REQUESTOR
 
 
 class PAC_REQUESTOR(Packet):
-    fields_desc = [XStrField("Sid", b"")]
+    fields_desc = [
+        PacketField("Sid", WINNT_SID(), WINNT_SID),
+    ]
 
 
 _PACTYPES[0x12] = PAC_REQUESTOR
 
 # sect 2.3
 
 
@@ -738,15 +794,19 @@
         res = b""
         if len(val) != len(pkt.Payloads):
             log_runtime.warning("Size of 'Buffers' does not match size of 'Payloads' !")
             return super(_PACTYPEBuffers, self).addfield(pkt, s, val)
         offset = 16 * len(pkt.Payloads) + 8
         for i, v in enumerate(val):
             x = self.i2m(pkt, v)
-            lgth = len(pkt.Payloads[i])
+            pay = pkt.Payloads[i]
+            if isinstance(pay, NDRPacket) or isinstance(pay, NDRSerialization1Header):
+                lgth = len(ndr_serialize1(pay))
+            else:
+                lgth = len(pay)
             if v.cbBufferSize is None:
                 x = x[:4] + struct.pack("<I", lgth) + x[8:]
             if v.Offset is None:
                 x = x[:8] + struct.pack("<Q", offset) + x[16:]
             offset += lgth
             offset += (-offset) % 8  # Account for padding
             res += x
@@ -766,27 +826,35 @@
             return s, []
         result = []
         for i in range(len(pkt.Buffers)):
             buf = pkt.Buffers[i]
             offset = buf.Offset - 16 * len(pkt.Buffers) - 8
             try:
                 cls = _PACTYPES[buf.ulType]
+                if buf.cbBufferSize == 0:
+                    # empty size
+                    raise KeyError
                 if issubclass(cls, NDRPacket):
                     val = ndr_deserialize1(
-                        s[offset: offset + buf.cbBufferSize], cls, ndr64=False
+                        s[offset : offset + buf.cbBufferSize],
+                        cls,
+                        ndr64=False,
                     )
                 else:
-                    val = cls(s[offset: offset + buf.cbBufferSize])
+                    val = cls(s[offset : offset + buf.cbBufferSize])
                 if conf.raw_layer in val:
                     pad = conf.padding_layer(load=val[conf.raw_layer].load)
                     lay = val[conf.raw_layer].underlayer
+                    if not lay:
+                        val.show()
+                        raise ValueError("Dissection failed")
                     lay.remove_payload()
                     lay.add_payload(pad)
             except KeyError:
-                val = conf.padding_layer(s[offset: offset + buf.cbBufferSize])
+                val = conf.padding_layer(s[offset : offset + buf.cbBufferSize])
             result.append(val)
         return b"", result
 
 
 class PACTYPE(Packet):
     name = "PACTYPE - PAC"
     fields_desc = [
```

### Comparing `scapy-2.5.0rc3/scapy/layers/netbios.py` & `scapy-2.6.0rc1/scapy/layers/netbios.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 [RFC 1001/1002]
 """
 
 import struct
 from scapy.arch import get_if_addr
 from scapy.base_classes import Net
 from scapy.ansmachine import AnsweringMachine
+from scapy.compat import bytes_encode
 from scapy.config import conf
 
 from scapy.packet import Packet, bind_bottom_up, bind_layers, bind_top_down
 from scapy.fields import (
     BitEnumField,
     BitField,
     ByteEnumField,
@@ -30,15 +31,15 @@
     ShortEnumField,
     ShortField,
     StrFixedLenField,
     XShortField,
     XStrFixedLenField
 )
 from scapy.layers.inet import IP, UDP, TCP
-from scapy.layers.l2 import SourceMACField
+from scapy.layers.l2 import Ether, SourceMACField
 
 
 class NetBIOS_DS(Packet):
     name = "NetBIOS datagram service"
     fields_desc = [
         ByteEnumField("type", 17, {17: "direct_group"}),
         ByteField("flags", 0),
@@ -138,15 +139,15 @@
                    ShortEnumField("SUFFIX", 0x4141, _NETBIOS_SUFFIXES),
                    ByteField("NULL", 0),
                    ShortEnumField("QUESTION_TYPE", 0x20, _NETBIOS_QRTYPES),
                    ShortEnumField("QUESTION_CLASS", 1, _NETBIOS_QRCLASS)]
 
     def mysummary(self):
         return "NBNSQueryRequest who has '\\\\%s'" % (
-            self.QUESTION_NAME.strip().decode()
+            self.QUESTION_NAME.strip().decode(errors="backslashreplace")
         )
 
 
 bind_layers(NBNSHeader, NBNSQueryRequest,
             OPCODE=0x0, NM_FLAGS=0x11, QDCOUNT=1)
 
 
@@ -177,15 +178,15 @@
                                    length_from=lambda pkt: pkt.RDLENGTH)
                    ]
 
     def mysummary(self):
         if not self.ADDR_ENTRY:
             return "NBNSQueryResponse"
         return "NBNSQueryResponse '\\\\%s' is at %s" % (
-            self.RR_NAME.strip().decode(),
+            self.RR_NAME.strip().decode(errors="backslashreplace"),
             self.ADDR_ENTRY[0].NB_ADDRESS
         )
 
 
 bind_layers(NBNSHeader, NBNSQueryResponse,
             OPCODE=0x0, NM_FLAGS=0x50, RESPONSE=1, ANCOUNT=1)
 
@@ -195,15 +196,15 @@
 class NBNSNodeStatusRequest(NBNSQueryRequest):
     name = "NBNS status request"
     QUESTION_NAME = b"*" + b"\x00" * 14
     QUESTION_TYPE = 0x21
 
     def mysummary(self):
         return "NBNSNodeStatusRequest who has '\\\\%s'" % (
-            self.QUESTION_NAME.strip().decode()
+            self.QUESTION_NAME.strip().decode(errors="backslashreplace")
         )
 
 
 bind_bottom_up(NBNSHeader, NBNSNodeStatusRequest, OPCODE=0x0, NM_FLAGS=0, QDCOUNT=1)
 bind_layers(NBNSHeader, NBNSNodeStatusRequest, OPCODE=0x0, NM_FLAGS=1, QDCOUNT=1)
 
 # Node Status Response
@@ -273,15 +274,19 @@
         BitEnumField("G", 0, 1, _NETBIOS_GNAMES),
         BitEnumField("OWNER_NODE_TYPE", 00, 2,
                      _NETBIOS_OWNER_MODE_TYPES),
         BitEnumField("UNUSED", 0, 13, {0: "Unused"}),
         IPField("NB_ADDRESS", "127.0.0.1")
     ]
 
+    def mysummary(self):
+        return self.sprintf("Register %G% %QUESTION_NAME% at %NB_ADDRESS%")
+
 
+bind_bottom_up(NBNSHeader, NBNSRegistrationRequest, OPCODE=0x5)
 bind_layers(NBNSHeader, NBNSRegistrationRequest,
             OPCODE=0x5, NM_FLAGS=0x11, QDCOUNT=1, ARCOUNT=1)
 
 
 # Wait for Acknowledgement Response
 
 
@@ -306,91 +311,116 @@
 class NBTDatagram(Packet):
     name = "NBT Datagram Packet"
     fields_desc = [ByteField("Type", 0x10),
                    ByteField("Flags", 0x02),
                    ShortField("ID", 0),
                    IPField("SourceIP", "127.0.0.1"),
                    ShortField("SourcePort", 138),
-                   ShortField("Length", 272),
+                   ShortField("Length", None),
                    ShortField("Offset", 0),
                    NetBIOSNameField("SourceName", "windows"),
                    ShortEnumField("SUFFIX1", 0x4141, _NETBIOS_SUFFIXES),
                    ByteField("NULL1", 0),
                    NetBIOSNameField("DestinationName", "windows"),
                    ShortEnumField("SUFFIX2", 0x4141, _NETBIOS_SUFFIXES),
                    ByteField("NULL2", 0)]
 
+    def post_build(self, pkt, pay):
+        if self.Length is None:
+            length = len(pay) + 68
+            pkt = pkt[:10] + struct.pack("!H", length) + pkt[12:]
+        return pkt + pay
+
+
 # SESSION SERVICE PACKETS
 
 
 class NBTSession(Packet):
     name = "NBT Session Packet"
+    MAXLENGTH = 0x3ffff
     fields_desc = [ByteEnumField("TYPE", 0, {0x00: "Session Message",
                                              0x81: "Session Request",
                                              0x82: "Positive Session Response",
                                              0x83: "Negative Session Response",
                                              0x84: "Retarget Session Response",
                                              0x85: "Session Keepalive"}),
                    BitField("RESERVED", 0x00, 7),
                    BitField("LENGTH", None, 17)]
 
     def post_build(self, pkt, pay):
         if self.LENGTH is None:
-            length = len(pay) & (2**18 - 1)
+            length = len(pay) & self.MAXLENGTH
             pkt = pkt[:1] + struct.pack("!I", length)[1:]
         return pkt + pay
 
+    def extract_padding(self, s):
+        return s[:self.LENGTH], s[self.LENGTH:]
+
+    @classmethod
+    def tcp_reassemble(cls, data, *args, **kwargs):
+        if len(data) < 4:
+            return None
+        length = struct.unpack("!I", data[:4])[0] & cls.MAXLENGTH
+        if len(data) >= length + 4:
+            return cls(data)
+
 
 bind_bottom_up(UDP, NBNSHeader, dport=137)
 bind_bottom_up(UDP, NBNSHeader, sport=137)
 bind_top_down(UDP, NBNSHeader, sport=137, dport=137)
 
-bind_layers(UDP, NBTDatagram, dport=138)
+bind_bottom_up(UDP, NBTDatagram, dport=138)
+bind_bottom_up(UDP, NBTDatagram, sport=138)
+bind_top_down(UDP, NBTDatagram, sport=138, dport=138)
 
 bind_bottom_up(TCP, NBTSession, dport=445)
 bind_bottom_up(TCP, NBTSession, sport=445)
 bind_bottom_up(TCP, NBTSession, dport=139)
 bind_bottom_up(TCP, NBTSession, sport=139)
 bind_layers(TCP, NBTSession, dport=139, sport=139)
 
 
 class NBNS_am(AnsweringMachine):
-    function_name = "nbns_spoof"
+    function_name = "nbnsd"
     filter = "udp port 137"
     sniff_options = {"store": 0}
 
     def parse_options(self, server_name=None, from_ip=None, ip=None):
         """
         NBNS answering machine
 
         :param server_name: the netbios server name to match
         :param from_ip: an IP (can have a netmask) to filter on
         :param ip: the IP to answer with
         """
-        self.ServerName = server_name
+        self.ServerName = bytes_encode(server_name or "")
         self.ip = ip
         if isinstance(from_ip, str):
             self.from_ip = Net(from_ip)
         else:
             self.from_ip = from_ip
 
     def is_request(self, req):
         if self.from_ip and IP in req and req[IP].src not in self.from_ip:
             return False
         return NBNSQueryRequest in req and (
             not self.ServerName or
-            req[NBNSQueryRequest].QUESTION_NAME.decode().strip() ==
-            self.ServerName
+            req[NBNSQueryRequest].QUESTION_NAME.strip() == self.ServerName
         )
 
     def make_reply(self, req):
         # type: (Packet) -> Packet
-        resp = IP(dst=req[IP].src) / UDP(sport=req.dport, dport=req.sport)
-        address = self.ip or get_if_addr(
-            self.optsniff.get("iface", conf.iface))
+        resp = Ether(
+            dst=req[Ether].src,
+            src=None if req[Ether].dst == "ff:ff:ff:ff:ff:ff" else req[Ether].dst,
+        ) / IP(dst=req[IP].src) / UDP(
+            sport=req.dport,
+            dport=req.sport,
+        )
+        address = self.ip or get_if_addr(self.optsniff.get("iface", conf.iface))
         resp /= NBNSHeader() / NBNSQueryResponse(
             RR_NAME=self.ServerName or req.QUESTION_NAME,
             SUFFIX=req.SUFFIX,
             ADDR_ENTRY=[NBNS_ADD_ENTRY(NB_ADDRESS=address)]
         )
         resp.NAME_TRN_ID = req.NAME_TRN_ID
         return resp
```

### Comparing `scapy-2.5.0rc3/scapy/layers/ntlm.py` & `scapy-2.6.0rc1/scapy/layers/ldap.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,1265 +1,1412 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
-# Copyright (C) Philippe Biondi <gabriel[]potter[]fr>
+# Copyright (C) Gabriel Potter <gabriel[]potter[]fr>
 
 """
-NTLM
+LDAP
 
-https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-NLMP/%5bMS-NLMP%5d.pdf
+RFC 1777 - LDAP v2
+RFC 4511 - LDAP v3
+
+Note: to mimic Microsoft Windows LDAP packets, you must set::
+
+    conf.ASN1_default_long_size = 4
 """
 
+import collections
 import ssl
 import socket
 import struct
-import threading
+import uuid
+
+from enum import Enum
 
 from scapy.arch import get_if_addr
-from scapy.asn1.asn1 import ASN1_STRING, ASN1_Codecs
-from scapy.asn1.mib import conf  # loads conf.mib
+from scapy.ansmachine import AnsweringMachine
+from scapy.asn1.asn1 import (
+    ASN1_STRING,
+    ASN1_Class,
+    ASN1_Codecs,
+)
+from scapy.asn1.ber import BERcodec_STRING
 from scapy.asn1fields import (
-    ASN1F_OID,
-    ASN1F_PRINTABLE_STRING,
+    ASN1F_BOOLEAN,
+    ASN1F_CHOICE,
+    ASN1F_ENUMERATED,
+    ASN1F_INTEGER,
+    ASN1F_NULL,
+    ASN1F_PACKET,
     ASN1F_SEQUENCE,
-    ASN1F_SEQUENCE_OF
+    ASN1F_SEQUENCE_OF,
+    ASN1F_SET_OF,
+    ASN1F_STRING,
+    ASN1F_optional,
 )
 from scapy.asn1packet import ASN1_Packet
-from scapy.automaton import Automaton, ObjectPipe
-from scapy.compat import bytes_base64
+from scapy.config import conf
+from scapy.error import log_runtime
 from scapy.fields import (
-    Field,
-    ByteEnumField,
-    ByteField,
-    ConditionalField,
-    FieldLenField,
     FlagsField,
-    LEIntField,
-    _StrField,
-    LEShortEnumField,
-    MultipleTypeField,
-    PacketField,
-    PacketListField,
-    LEShortField,
-    StrField,
-    StrFieldUtf16,
-    StrFixedLenField,
-    LEIntEnumField,
-    LEThreeBytesField,
-    StrLenFieldUtf16,
-    UTCTimeField,
-    XStrField,
-    XStrFixedLenField,
-    XStrLenField,
+    ThreeBytesField,
+)
+from scapy.packet import (
+    Packet,
+    bind_bottom_up,
+    bind_layers,
 )
-from scapy.packet import Packet
-from scapy.sessions import StringBuffer
-from scapy.supersocket import SSLStreamSocket, StreamSocket
-
-from scapy.layers.tls.crypto.hash import Hash_MD5
-
-from scapy.compat import (
-    Any,
-    Callable,
-    Dict,
-    List,
-    Tuple,
-    Optional,
+from scapy.sendrecv import send
+from scapy.supersocket import (
+    SimpleSocket,
+    StreamSocket,
 )
 
-# Crypto imports
+from scapy.layers.dns import dns_resolve
+from scapy.layers.inet import IP, TCP, UDP
+from scapy.layers.inet6 import IPv6
+from scapy.layers.gssapi import (
+    GSS_C_FLAGS,
+    GSS_S_COMPLETE,
+    GSSAPI_BLOB,
+    GSSAPI_BLOB_SIGNATURE,
+    SSP,
+)
+from scapy.layers.kerberos import (
+    _ASN1FString_PacketField,
+)
+from scapy.layers.netbios import NBTDatagram
+from scapy.layers.smb import (
+    NETLOGON,
+    NETLOGON_SAM_LOGON_RESPONSE_EX,
+)
 
-from scapy.layers.tls.crypto.hash import Hash_MD4
 
-if conf.crypto_valid:
-    from cryptography.hazmat.primitives import hashes, hmac
-else:
-    hashes = hmac = None
-
-##########
-# Fields #
-##########
-
-
-class _NTLMPayloadField(_StrField[List[Tuple[str, Any]]]):
-    """Special field used to dissect NTLM payloads.
-    This isn't trivial because the offsets are variable."""
-    __slots__ = ["fields", "fields_map", "offset", "length_from"]
-    islist = True
-
-    def __init__(self,
-                 name,  # type: str
-                 offset,  # type: int
-                 fields,  # type: List[Field[Any, Any]]
-                 length_from=None  # type: Optional[Callable[[Packet], int]]
-                 ):
-        # type: (...) -> None
-        self.offset = offset
-        self.fields = fields
-        self.fields_map = {field.name: field for field in fields}
-        self.length_from = length_from
-        super(_NTLMPayloadField, self).__init__(
-            name,
-            [(field.name, field.default) for field in fields
-             if field.default is not None]
-        )
+# Elements of protocol
+# https://datatracker.ietf.org/doc/html/rfc1777#section-4
 
-    def _on_payload(self, pkt, x, func):
-        # type: (Optional[Packet], bytes, str) -> List[Tuple[str, Any]]
-        if not pkt or not x:
-            return []
-        results = []
-        for field_name, value in x:
-            if field_name not in self.fields_map:
-                continue
-            if not isinstance(self.fields_map[field_name], PacketListField) \
-                    and not isinstance(value, Packet):
-                value = getattr(self.fields_map[field_name], func)(pkt, value)
-            results.append((
-                field_name,
-                value
-            ))
-        return results
-
-    def i2h(self, pkt, x):
-        # type: (Optional[Packet], bytes) -> List[Tuple[str, str]]
-        return self._on_payload(pkt, x, "i2h")
-
-    def h2i(self, pkt, x):
-        # type: (Optional[Packet], bytes) -> List[Tuple[str, str]]
-        return self._on_payload(pkt, x, "h2i")
-
-    def i2repr(self, pkt, x):
-        # type: (Optional[Packet], bytes) -> str
-        return repr(self._on_payload(pkt, x, "i2repr"))
-
-    def addfield(self, pkt, s, val):
-        # type: (Optional[Packet], bytes, Optional[List[Tuple[str, str]]]) -> bytes
-        buf = StringBuffer()
-        for field_name, value in val:
-            if field_name not in self.fields_map:
-                continue
-            field = self.fields_map[field_name]
-            offset = pkt.getfieldval(field_name + "BufferOffset")
-            if offset is not None:
-                offset -= self.offset
-            else:
-                offset = len(buf)
-            buf.append(field.addfield(pkt, b"", value), offset + 1)
-        return s + bytes(buf)
-
-    def getfield(self, pkt, s):
-        # type: (Packet, bytes) -> Tuple[bytes, List[Tuple[str, str]]]
-        if self.length_from is None:
-            ret, remain = b"", s
-        else:
-            len_pkt = self.length_from(pkt)
-            ret, remain = s[len_pkt:], s[:len_pkt]
-        if not pkt or not remain:
-            return s, []
-        results = []
-        max_offset = 0
-        for field in self.fields:
-            offset = pkt.getfieldval(field.name + "BufferOffset") - self.offset
-            try:
-                length = pkt.getfieldval(field.name + "Len")
-            except AttributeError:
-                length = len(remain) - offset
-            if offset < 0:
-                continue
-            max_offset = max(offset + length, max_offset)
-            if remain[offset:offset + length]:
-                results.append((offset, field.name, field.getfield(
-                    pkt, remain[offset:offset + length])[1]))
-        if max_offset:
-            ret += remain[max_offset:]
-        results.sort(key=lambda x: x[0])
-        return ret, [x[1:] for x in results]
+LDAPString = ASN1F_STRING
+LDAPOID = ASN1F_STRING
+LDAPDN = LDAPString
+RelativeLDAPDN = LDAPString
+AttributeType = LDAPString
+AttributeValue = ASN1F_STRING
+URI = LDAPString
 
 
-class _NTLMPayloadPacket(Packet):
-    _NTLM_PAYLOAD_FIELD_NAME = "Payload"
+class AttributeValueAssertion(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        AttributeType("attributeType", "organizationName"),
+        AttributeValue("attributeValue", ""),
+    )
 
-    def __getattr__(self, attr):
-        # Ease compatibility with _NTLMPayloadField
-        try:
-            return super(_NTLMPayloadPacket, self).__getattr__(attr)
-        except AttributeError:
-            try:
-                return next(
-                    x[1]
-                    for x in super(_NTLMPayloadPacket, self).__getattr__(
-                        self._NTLM_PAYLOAD_FIELD_NAME
-                    )
-                    if x[0] == attr
-                )
-            except StopIteration:
-                raise AttributeError(attr)
 
-    def setfieldval(self, attr, val):
-        # Ease compatibility with _NTLMPayloadField
-        try:
-            return super(_NTLMPayloadPacket, self).setfieldval(attr, val)
-        except AttributeError:
-            Payload = super(_NTLMPayloadPacket, self).__getattr__(
-                self._NTLM_PAYLOAD_FIELD_NAME
-            )
-            if attr not in self.get_field(self._NTLM_PAYLOAD_FIELD_NAME).fields_map:
-                raise AttributeError(attr)
-            try:
-                Payload.pop(next(
-                    i
-                    for i, x in enumerate(
-                        super(_NTLMPayloadPacket, self).__getattr__(
-                            self._NTLM_PAYLOAD_FIELD_NAME
-                        ))
-                    if x[0] == attr
-                ))
-            except StopIteration:
-                pass
-            Payload.append([attr, val])
-            super(_NTLMPayloadPacket, self).setfieldval(
-                self._NTLM_PAYLOAD_FIELD_NAME,
-                Payload
-            )
+class LDAPReferral(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = LDAPString("uri", "")
 
 
-def _NTLM_post_build(self, p, pay_offset, fields):
-    # type: (Packet, bytes, int, Dict[str, Tuple[str, int]]) -> bytes
-    """Util function to build the offset and populate the lengths"""
-    for field_name, value in self.fields["Payload"]:
-        length = self.get_field(
-            "Payload").fields_map[field_name].i2len(self, value)
-        offset = fields[field_name]
-        # Length
-        if self.getfieldval(field_name + "Len") is None:
-            p = p[:offset] + \
-                struct.pack("<H", length) + p[offset + 2:]
-        # MaxLength
-        if self.getfieldval(field_name + "MaxLen") is None:
-            p = p[:offset + 2] + \
-                struct.pack("<H", length) + p[offset + 4:]
-        # Offset
-        if self.getfieldval(field_name + "BufferOffset") is None:
-            p = p[:offset + 4] + \
-                struct.pack("<I", pay_offset) + p[offset + 8:]
-        pay_offset += length
-    return p
-
-
-##############
-# Structures #
-##############
+LDAPResult = (
+    ASN1F_ENUMERATED(
+        "resultCode",
+        0,
+        {
+            0: "success",
+            1: "operationsError",
+            2: "protocolError",
+            3: "timeLimitExceeded",
+            4: "sizeLimitExceeded",
+            5: "compareFalse",
+            6: "compareTrue",
+            7: "authMethodNotSupported",
+            8: "strongAuthRequired",
+            10: "referral",
+            11: "adminLimitExceeded",
+            14: "saslBindInProgress",
+            16: "noSuchAttribute",
+            17: "undefinedAttributeType",
+            18: "inappropriateMatching",
+            19: "constraintViolation",
+            20: "attributeOrValueExists",
+            21: "invalidAttributeSyntax",
+            32: "noSuchObject",
+            33: "aliasProblem",
+            34: "invalidDNSyntax",
+            35: "isLeaf",
+            36: "aliasDereferencingProblem",
+            48: "inappropriateAuthentication",
+            49: "invalidCredentials",
+            50: "insufficientAccessRights",
+            51: "busy",
+            52: "unavailable",
+            53: "unwillingToPerform",
+            54: "loopDetect",
+            64: "namingViolation",
+            65: "objectClassViolation",
+            66: "notAllowedOnNonLeaf",
+            67: "notAllowedOnRDN",
+            68: "entryAlreadyExists",
+            69: "objectClassModsProhibited",
+            70: "resultsTooLarge",  # CLDAP
+            80: "other",
+        },
+    ),
+    LDAPDN("matchedDN", ""),
+    LDAPString("diagnosticMessage", ""),
+    # LDAP v3 only
+    ASN1F_optional(ASN1F_SEQUENCE_OF("referral", [], LDAPReferral, implicit_tag=0xA3)),
+)
 
 
-# Sect 2.2
+# ldap APPLICATION
 
 
-class NTLM_Header(Packet):
-    name = "NTLM Header"
-    fields_desc = [
-        StrFixedLenField('Signature', b'NTLMSSP\0', length=8),
-        LEIntEnumField('MessageType', 3, {1: 'NEGOTIATE_MESSAGE',
-                                          2: 'CHALLENGE_MESSAGE',
-                                          3: 'AUTHENTICATE_MESSAGE'}),
-    ]
+class ASN1_Class_LDAP(ASN1_Class):
+    name = "LDAP"
+    # APPLICATION + CONSTRUCTED = 0x40 | 0x20
+    BindRequest = 0x60
+    BindResponse = 0x61
+    UnbindRequest = 0x42  # not constructed
+    SearchRequest = 0x63
+    SearchResultEntry = 0x64
+    SearchResultDone = 0x65
+    SearchResultReference = 0x66
+    ModifyRequest = 0x67
+    ModifyResponse = 0x68
+    AddRequest = 0x69
+    AddResponse = 0x6A
+    DelRequest = 0x6B
+    DelResponse = 0x6C
+    ModifyDNRequest = 0x6D
+    ModifyDNResponse = 0x6E
+    CompareRequest = 0x6F
+    CompareResponse = 0x70
+    AbandonRequest = 0x71
+    ExtendedRequest = 0x72
+    ExtendedResponse = 0x73
 
-    @classmethod
-    def dispatch_hook(cls, _pkt=None, *args, **kargs):
-        if _pkt and len(_pkt) >= 10:
-            MessageType = struct.unpack("<H", _pkt[8:10])[0]
-            if MessageType == 1:
-                return NTLM_NEGOTIATE
-            elif MessageType == 2:
-                return NTLM_CHALLENGE
-            elif MessageType == 3:
-                return NTLM_AUTHENTICATE_V2
-        return cls
-
-
-# Sect 2.2.2.5
-_negotiateFlags = [
-    "NTLMSSP_NEGOTIATE_UNICODE",  # A
-    "NTLM_NEGOTIATE_OEM",  # B
-    "NTLMSSP_REQUEST_TARGET",  # C
-    "r10",
-    "NTLMSSP_NEGOTIATE_SIGN",  # D
-    "NTLMSSP_NEGOTIATE_SEAL",  # E
-    "NTLMSSP_NEGOTIATE_DATAGRAM",  # F
-    "NTLMSSP_NEGOTIATE_LM_KEY",  # G
-    "r9",
-    "NTLMSSP_NEGOTIATE_NTLM",  # H
-    "r8",
-    "J",
-    "NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED",  # K
-    "NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED",  # L
-    "r7",
-    "NTLMSSP_NEGOTIATE_ALWAYS_SIGN",  # M
-    "NTLMSSP_TARGET_TYPE_DOMAIN",  # N
-    "NTLMSSP_TARGET_TYPE_SERVER",  # O
-    "r6",
-    "NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY",  # P
-    "NTLMSSP_NEGOTIATE_IDENTIFY",  # Q
-    "r5",
-    "NTLMSSP_REQUEST_NON_NT_SESSION_KEY",  # R
-    "NTLMSSP_NEGOTIATE_TARGET_INFO",  # S
-    "r4",
-    "NTLMSSP_NEGOTIATE_VERSION",  # T
-    "r3",
-    "r2",
-    "r1",
-    "NTLMSSP_NEGOTIATE_128",  # U
-    "NTLMSSP_NEGOTIATE_KEY_EXCH",  # V
-    "NTLMSSP_NEGOTIATE_56",  # W
-]
-
-
-def _NTLMStrField(name, default):
-    return MultipleTypeField(
-        [
-            (StrFieldUtf16(name, default),
-             lambda pkt: pkt.NegotiateFlags.NTLMSSP_NEGOTIATE_UNICODE)
-        ],
-        StrField(name, default),
-    )
 
-# Sect 2.2.2.10
+# Bind operation
+# https://datatracker.ietf.org/doc/html/rfc1777#section-4.1
 
 
-class _NTLM_Version(Packet):
-    fields_desc = [
-        ByteField('ProductMajorVersion', 0),
-        ByteField('ProductMinorVersion', 0),
-        LEShortField('ProductBuild', 0),
-        LEThreeBytesField('res_ver', 0),
-        ByteEnumField('NTLMRevisionCurrent', 0x0F, {0x0F: "v15"}),
-    ]
+class ASN1_Class_LDAP_Authentication(ASN1_Class):
+    name = "LDAP Authentication"
+    # CONTEXT-SPECIFIC = 0x80
+    simple = 0x80
+    krbv42LDAP = 0x81
+    krbv42DSA = 0x82
+    sasl = 0xA3  # CONTEXT-SPECIFIC | CONSTRUCTED
+    # [MS-ADTS] sect 5.1.1.1
+    sicilyPackageDiscovery = 0x89
+    sicilyNegotiate = 0x8A
+    sicilyResponse = 0x8B
 
-# Sect 2.2.1.1
 
+# simple
+class LDAP_Authentication_simple(ASN1_STRING):
+    tag = ASN1_Class_LDAP_Authentication.simple
 
-class NTLM_NEGOTIATE(_NTLMPayloadPacket):
-    name = "NTLM Negotiate"
-    messageType = 1
-    OFFSET = 40
-    fields_desc = [
-        NTLM_Header,
-        FlagsField('NegotiateFlags', 0, -32, _negotiateFlags),
-        # DomainNameFields
-        LEShortField('DomainNameLen', None),
-        LEShortField('DomainNameMaxLen', None),
-        LEIntField('DomainNameBufferOffset', None),
-        # WorkstationFields
-        LEShortField('WorkstationNameLen', None),
-        LEShortField('WorkstationNameMaxLen', None),
-        LEIntField('WorkstationNameBufferOffset', None),
-        # VERSION
-        _NTLM_Version,
-        # Payload
-        _NTLMPayloadField(
-            'Payload', OFFSET, [
-                _NTLMStrField('DomainName', b''),
-                _NTLMStrField('WorkstationName', b'')
-            ])
-    ]
 
-    def post_build(self, pkt, pay):
-        # type: (bytes, bytes) -> bytes
-        return _NTLM_post_build(self, pkt, self.OFFSET, {
-            "DomainName": 16,
-            "WorkstationName": 24,
-        }) + pay
+class BERcodec_LDAP_Authentication_simple(BERcodec_STRING):
+    tag = ASN1_Class_LDAP_Authentication.simple
 
-# Challenge
 
+class ASN1F_LDAP_Authentication_simple(ASN1F_STRING):
+    ASN1_tag = ASN1_Class_LDAP_Authentication.simple
 
-class Single_Host_Data(Packet):
-    fields_desc = [
-        LEIntField("Size", 0),
-        LEIntField("Z4", 0),
-        XStrFixedLenField("CustomData", b"", length=8),
-        XStrFixedLenField("MachineID", b"", length=32),
-    ]
 
-    def default_payload_class(self, payload):
-        return conf.padding_layer
+# krbv42LDAP
+class LDAP_Authentication_krbv42LDAP(ASN1_STRING):
+    tag = ASN1_Class_LDAP_Authentication.krbv42LDAP
 
 
-class AV_PAIR(Packet):
-    name = "NTLM AV Pair"
-    fields_desc = [
-        LEShortEnumField('AvId', 0, {
-            0x0000: "MsvAvEOL",
-            0x0001: "MsvAvNbComputerName",
-            0x0002: "MsvAvNbDomainName",
-            0x0003: "MsvAvDnsComputerName",
-            0x0004: "MsvAvDnsDomainName",
-            0x0005: "MsvAvDnsTreeName",
-            0x0006: "MsvAvFlags",
-            0x0007: "MsvAvTimestamp",
-            0x0008: "MsvAvSingleHost",
-            0x0009: "MsvAvTargetName",
-            0x000A: "MsvAvChannelBindings",
-        }),
-        FieldLenField('AvLen', None, length_of="Value", fmt="<H"),
-        MultipleTypeField([
-            (LEIntEnumField('Value', 1, {
-                0x0001: "constrained",
-                0x0002: "MIC integrity",
-                0x0004: "SPN from untrusted source"}),
-             lambda pkt: pkt.AvId == 0x0006),
-            (UTCTimeField("Value", None, epoch=[
-                1601, 1, 1, 0, 0, 0], custom_scaling=1e7,
-                fmt="<Q"),
-                lambda pkt: pkt.AvId == 0x0007),
-            (PacketField('Value', Single_Host_Data(), Single_Host_Data),
-             lambda pkt: pkt.AvId == 0x0008),
-            (XStrLenField('Value', b"", length_from=lambda pkt: pkt.AvLen),
-             lambda pkt: pkt.AvId == 0x000A),
-        ],
-            StrLenFieldUtf16('Value', b"", length_from=lambda pkt: pkt.AvLen)
-        )
-    ]
+class BERcodec_LDAP_Authentication_krbv42LDAP(BERcodec_STRING):
+    tag = ASN1_Class_LDAP_Authentication.krbv42LDAP
 
-    def default_payload_class(self, payload):
-        return conf.padding_layer
 
+class ASN1F_LDAP_Authentication_krbv42LDAP(ASN1F_STRING):
+    ASN1_tag = ASN1_Class_LDAP_Authentication.krbv42LDAP
 
-class NTLM_CHALLENGE(_NTLMPayloadPacket):
-    name = "NTLM Challenge"
-    messageType = 2
-    OFFSET = 56
-    fields_desc = [
-        NTLM_Header,
-        # TargetNameFields
-        LEShortField('TargetNameLen', None),
-        LEShortField('TargetNameMaxLen', None),
-        LEIntField('TargetNameBufferOffset', None),
-        #
-        FlagsField('NegotiateFlags', 0, -32, _negotiateFlags),
-        XStrFixedLenField('ServerChallenge', None, length=8),
-        XStrFixedLenField('Reserved', None, length=8),
-        # TargetInfoFields
-        LEShortField('TargetInfoLen', None),
-        LEShortField('TargetInfoMaxLen', None),
-        LEIntField('TargetInfoBufferOffset', None),
-        # VERSION
-        _NTLM_Version,
-        # Payload
-        _NTLMPayloadField(
-            'Payload', OFFSET, [
-                _NTLMStrField('TargetName', b''),
-                PacketListField('TargetInfo', [AV_PAIR()], AV_PAIR)
-            ])
-    ]
 
-    def post_build(self, pkt, pay):
-        # type: (bytes, bytes) -> bytes
-        return _NTLM_post_build(self, pkt, self.OFFSET, {
-            "TargetName": 12,
-            "TargetInfo": 40,
-        }) + pay
+# krbv42DSA
+class LDAP_Authentication_krbv42DSA(ASN1_STRING):
+    tag = ASN1_Class_LDAP_Authentication.krbv42DSA
 
 
-# Authenticate
+class BERcodec_LDAP_Authentication_krbv42DSA(BERcodec_STRING):
+    tag = ASN1_Class_LDAP_Authentication.krbv42DSA
 
-class LM_RESPONSE(Packet):
-    fields_desc = [
-        StrFixedLenField("Response", b"", length=24),
-    ]
 
+class ASN1F_LDAP_Authentication_krbv42DSA(ASN1F_STRING):
+    ASN1_tag = ASN1_Class_LDAP_Authentication.krbv42DSA
 
-class LMv2_RESPONSE(Packet):
-    fields_desc = [
-        StrFixedLenField("Response", b"", length=16),
-        StrFixedLenField("ChallengeFromClient", b"", length=8),
-    ]
 
+# sicilyPackageDiscovery
+class LDAP_Authentication_sicilyPackageDiscovery(ASN1_STRING):
+    tag = ASN1_Class_LDAP_Authentication.sicilyPackageDiscovery
 
-class NTLM_RESPONSE(Packet):
-    fields_desc = [
-        StrFixedLenField("Response", b"", length=24),
-    ]
 
+class BERcodec_LDAP_Authentication_sicilyPackageDiscovery(BERcodec_STRING):
+    tag = ASN1_Class_LDAP_Authentication.sicilyPackageDiscovery
 
-class NTLMv2_CLIENT_CHALLENGE(Packet):
-    fields_desc = [
-        ByteField("RespType", 0),
-        ByteField("HiRespType", 0),
-        LEShortField("Reserved1", 0),
-        LEIntField("Reserved2", 0),
-        UTCTimeField("TimeStamp", None, fmt="<Q", epoch=[
-                     1601, 1, 1, 0, 0, 0], custom_scaling=1e7),
-        StrFixedLenField("ChallengeFromClient", b"12345678", length=8),
-        LEIntField("Reserved3", 0),
-        PacketListField("AvPairs", [AV_PAIR()], AV_PAIR)
-    ]
 
+class ASN1F_LDAP_Authentication_sicilyPackageDiscovery(ASN1F_STRING):
+    ASN1_tag = ASN1_Class_LDAP_Authentication.sicilyPackageDiscovery
 
-class NTLMv2_RESPONSE(Packet):
-    fields_desc = [
-        XStrFixedLenField("NTProofStr", b"", length=16),
-        NTLMv2_CLIENT_CHALLENGE
-    ]
 
-    def computeNTProofStr(self, ResponseKeyNT, ServerChallenge):
-        """
-        Set temp to ConcatenationOf(Responserversion, HiResponserversion,
-            Z(6), Time, ClientChallenge, Z(4), ServerName, Z(4))
-        Set NTProofStr to HMAC_MD5(ResponseKeyNT,
-            ConcatenationOf(CHALLENGE_MESSAGE.ServerChallenge,temp))
+# sicilyNegotiate
+class LDAP_Authentication_sicilyNegotiate(ASN1_STRING):
+    tag = ASN1_Class_LDAP_Authentication.sicilyNegotiate
 
-        Remember ServerName = AvPairs
-        """
-        Responserversion = b"\x01"
-        HiResponserversion = b"\x01"
 
-        def ServerNameGen():
-            for x in self.AvPairs:
-                yield bytes(x)
-                if x.AvId == 0:
-                    return
-        ServerName = b"".join(iter(ServerNameGen()))
-        temp = b"".join([
-            Responserversion,
-            HiResponserversion,
-            b"\x00" * 6,
-            struct.pack("<Q", self.TimeStamp),
-            self.ChallengeFromClient,
-            b"\x00" * 4,
-            ServerName,
-            b"\x00" * 4,
-        ])
-        return HMAC_MD5(ResponseKeyNT, ServerChallenge + temp)
+class BERcodec_LDAP_Authentication_sicilyNegotiate(BERcodec_STRING):
+    tag = ASN1_Class_LDAP_Authentication.sicilyNegotiate
 
 
-class NTLM_AUTHENTICATE(_NTLMPayloadPacket):
-    name = "NTLM Authenticate"
-    messageType = 3
-    OFFSET = 88
-    NTLM_VERSION = 1
-    fields_desc = [
-        NTLM_Header,
-        # LmChallengeResponseFields
-        LEShortField('LmChallengeResponseLen', None),
-        LEShortField('LmChallengeResponseMaxLen', None),
-        LEIntField('LmChallengeResponseBufferOffset', None),
-        # NtChallengeResponseFields
-        LEShortField('NtChallengeResponseLen', None),
-        LEShortField('NtChallengeResponseMaxLen', None),
-        LEIntField('NtChallengeResponseBufferOffset', None),
-        # DomainNameFields
-        LEShortField('DomainNameLen', None),
-        LEShortField('DomainNameMaxLen', None),
-        LEIntField('DomainNameBufferOffset', None),
-        # UserNameFields
-        LEShortField('UserNameLen', None),
-        LEShortField('UserNameMaxLen', None),
-        LEIntField('UserNameBufferOffset', None),
-        # WorkstationFields
-        LEShortField('WorkstationLen', None),
-        LEShortField('WorkstationMaxLen', None),
-        LEIntField('WorkstationBufferOffset', None),
-        # EncryptedRandomSessionKeyFields
-        LEShortField('EncryptedRandomSessionKeyLen', None),
-        LEShortField('EncryptedRandomSessionKeyMaxLen', None),
-        LEIntField('EncryptedRandomSessionKeyBufferOffset', None),
-        # NegotiateFlags
-        FlagsField('NegotiateFlags', 0, -32, _negotiateFlags),
-        # VERSION
-        _NTLM_Version,
-        # MIC
-        ConditionalField(
-            XStrFixedLenField('MIC', b"", length=16),
-            lambda pkt: pkt.fields.get('MIC', b"") is not None
-        ),
-        # Payload
-        _NTLMPayloadField(
-            'Payload', OFFSET, [
-                MultipleTypeField(
-                    [(PacketField('LmChallengeResponse', LMv2_RESPONSE(),
-                      LMv2_RESPONSE), lambda pkt: pkt.NTLM_VERSION == 2)],
-                    PacketField('LmChallengeResponse',
-                                LM_RESPONSE(), LM_RESPONSE)
+class ASN1F_LDAP_Authentication_sicilyNegotiate(ASN1F_STRING):
+    ASN1_tag = ASN1_Class_LDAP_Authentication.sicilyNegotiate
+
+
+# sicilyResponse
+class LDAP_Authentication_sicilyResponse(ASN1_STRING):
+    tag = ASN1_Class_LDAP_Authentication.sicilyResponse
+
+
+class BERcodec_LDAP_Authentication_sicilyResponse(BERcodec_STRING):
+    tag = ASN1_Class_LDAP_Authentication.sicilyResponse
+
+
+class ASN1F_LDAP_Authentication_sicilyResponse(ASN1F_STRING):
+    ASN1_tag = ASN1_Class_LDAP_Authentication.sicilyResponse
+
+
+_SASL_MECHANISMS = {b"GSS-SPNEGO": GSSAPI_BLOB, b"GSSAPI": GSSAPI_BLOB}
+
+
+class _SaslCredentialsField(_ASN1FString_PacketField):
+    def m2i(self, pkt, s):
+        val = super(_SaslCredentialsField, self).m2i(pkt, s)
+        if not val[0].val:
+            return val
+        if pkt.mechanism.val in _SASL_MECHANISMS:
+            return (
+                _SASL_MECHANISMS[pkt.mechanism.val](val[0].val, _underlayer=pkt),
+                val[1],
+            )
+        return val
+
+
+class LDAP_Authentication_SaslCredentials(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        LDAPString("mechanism", ""),
+        ASN1F_optional(
+            _SaslCredentialsField("credentials", ""),
+        ),
+        implicit_tag=ASN1_Class_LDAP_Authentication.sasl,
+    )
+
+
+class LDAP_BindRequest(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_INTEGER("version", 3),
+        LDAPDN("bind_name", ""),
+        ASN1F_CHOICE(
+            "authentication",
+            None,
+            ASN1F_LDAP_Authentication_simple,
+            ASN1F_LDAP_Authentication_krbv42LDAP,
+            ASN1F_LDAP_Authentication_krbv42DSA,
+            LDAP_Authentication_SaslCredentials,
+        ),
+        implicit_tag=ASN1_Class_LDAP.BindRequest,
+    )
+
+
+class LDAP_BindResponse(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        *(
+            LDAPResult
+            + (
+                ASN1F_optional(
+                    # For GSSAPI, the response is wrapped in
+                    # LDAP_Authentication_SaslCredentials
+                    ASN1F_STRING("serverSaslCredsWrap", "", implicit_tag=0xA7),
                 ),
-                MultipleTypeField(
-                    [(PacketField('NtChallengeResponse', NTLMv2_RESPONSE(),
-                      NTLMv2_RESPONSE), lambda pkt: pkt.NTLM_VERSION == 2)],
-                    PacketField('NtChallengeResponse',
-                                NTLM_RESPONSE(), NTLM_RESPONSE)
+            )
+            + (
+                ASN1F_optional(
+                    ASN1F_STRING("serverSaslCreds", "", implicit_tag=0x87),
                 ),
-                _NTLMStrField('DomainName', b''),
-                _NTLMStrField('UserName', b''),
-                _NTLMStrField('Workstation', b''),
-                XStrField('EncryptedRandomSessionKey', b''),
-            ])
-    ]
+            )
+        ),
+        implicit_tag=ASN1_Class_LDAP.BindResponse,
+    )
+
+    @property
+    def serverCreds(self):
+        """
+        serverCreds field in SicilyBindResponse
+        """
+        return self.matchedDN.val
+
+    @serverCreds.setter
+    def serverCreds(self, val):
+        """
+        serverCreds field in SicilyBindResponse
+        """
+        self.matchedDN = ASN1_STRING(val)
+
+    @property
+    def serverSaslCredsData(self):
+        """
+        Get serverSaslCreds or serverSaslCredsWrap depending on what's available
+        """
+        if self.serverSaslCredsWrap and self.serverSaslCredsWrap.val:
+            wrap = LDAP_Authentication_SaslCredentials(self.serverSaslCredsWrap.val)
+            val = wrap.credentials
+            if isinstance(val, ASN1_STRING):
+                return val.val
+            return bytes(val)
+        elif self.serverSaslCreds and self.serverSaslCreds.val:
+            return self.serverSaslCreds.val
+        else:
+            return None
+
+
+# Unbind operation
+# https://datatracker.ietf.org/doc/html/rfc1777#section-4.2
+
 
-    def post_build(self, pkt, pay):
-        # type: (bytes, bytes) -> bytes
-        return _NTLM_post_build(self, pkt, self.OFFSET, {
-            "LmChallengeResponse": 12,
-            "NtChallengeResponse": 20,
-            "DomainName": 28,
-            "UserName": 36,
-            "Workstation": 44,
-            "EncryptedRandomSessionKey": 52
-        }) + pay
-
-
-class NTLM_AUTHENTICATE_V2(NTLM_AUTHENTICATE):
-    NTLM_VERSION = 2
-
-
-def HTTP_ntlm_negotiate(ntlm_negotiate):
-    """Create an HTTP NTLM negotiate packet from an NTLM_NEGOTIATE message"""
-    assert isinstance(ntlm_negotiate, NTLM_NEGOTIATE)
-    from scapy.layers.http import HTTP, HTTPRequest
-    return HTTP() / HTTPRequest(
-        Authorization=b"NTLM " + bytes_base64(bytes(ntlm_negotiate))
+class LDAP_UnbindRequest(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_NULL("info", 0),
+        implicit_tag=ASN1_Class_LDAP.UnbindRequest,
     )
 
-# Answering machine
 
+# Search operation
+# https://datatracker.ietf.org/doc/html/rfc1777#section-4.3
 
-class _NTLM_Automaton(Automaton):
-    def __init__(self, sock, **kwargs):
-        # type: (StreamSocket, Any) -> None
-        self.token_pipe = ObjectPipe()
-        self.values = {}
-        for key, dflt in [("DROP_MIC_v1", False), ("DROP_MIC_v2", False)]:
-            setattr(self, key, kwargs.pop(key, dflt))
-        self.DROP_MIC = self.DROP_MIC_v1 or self.DROP_MIC_v2
-        super(_NTLM_Automaton, self).__init__(
-            recvsock=lambda **kwargs: sock,
-            ll=lambda **kwargs: sock,
-            **kwargs
-        )
 
-    def _get_token(self, token):
-        if not token:
-            return None, None, None, None
-
-        from scapy.layers.gssapi import (
-            GSSAPI_BLOB,
-            SPNEGO_negToken,
-            SPNEGO_Token
-        )
+class LDAP_SubstringFilterInitial(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = LDAPString("initial", "")
 
-        negResult = None
-        MIC = None
-        rawToken = False
-
-        if isinstance(token, bytes):
-            # SMB 1 - non extended
-            return (token, None, None, True)
-        if isinstance(token, (NTLM_NEGOTIATE,
-                              NTLM_CHALLENGE,
-                              NTLM_AUTHENTICATE,
-                              NTLM_AUTHENTICATE_V2)):
-            ntlm = token
-            rawToken = True
-        else:
-            if isinstance(token, GSSAPI_BLOB):
-                token = token.innerContextToken
-            if isinstance(token, SPNEGO_negToken):
-                token = token.token
-            if hasattr(token, "mechListMIC") and token.mechListMIC:
-                MIC = token.mechListMIC.value
-            if hasattr(token, "negResult"):
-                negResult = token.negResult
-            try:
-                ntlm = token.mechToken
-            except AttributeError:
-                ntlm = token.responseToken
-            if isinstance(ntlm, SPNEGO_Token):
-                ntlm = ntlm.value
-            if isinstance(ntlm, ASN1_STRING):
-                ntlm = NTLM_Header(ntlm.val)
-            if isinstance(ntlm, conf.raw_layer):
-                ntlm = NTLM_Header(ntlm.load)
-        if self.DROP_MIC_v1 or self.DROP_MIC_v2:
-            if isinstance(ntlm, NTLM_AUTHENTICATE):
-                ntlm.MIC = b"\0" * 16
-                ntlm.NtChallengeResponseLen = None
-                ntlm.NtChallengeResponseMaxLen = None
-                ntlm.EncryptedRandomSessionKeyBufferOffset = None
-                if self.DROP_MIC_v2:
-                    ChallengeResponse = next(
-                        v[1] for v in ntlm.Payload
-                        if v[0] == 'NtChallengeResponse'
-                    )
-                    i = next(
-                        i for i, k in enumerate(ChallengeResponse.AvPairs)
-                        if k.AvId == 0x0006
-                    )
-                    ChallengeResponse.AvPairs.insert(
-                        i + 1,
-                        AV_PAIR(AvId="MsvAvFlags", Value=0)
-                    )
-        return ntlm, negResult, MIC, rawToken
 
-    def received_ntlm_token(self, ntlm):
-        self.token_pipe.send(ntlm)
+class LDAP_SubstringFilterAny(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = LDAPString("any", "")
 
-    def get(self, attr, default=None):
-        if default is not None:
-            return self.values.get(attr, default)
-        return self.values[attr]
 
-    def end(self):
-        self.listen_sock.close()
-        self.stop()
+class LDAP_SubstringFilterFinal(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = LDAPString("final", "")
 
 
-class NTLM_Client(_NTLM_Automaton):
-    """
-    A class to overload to create a client automaton when using
-    NTLM.
-    """
-    port = 445
-    cls = conf.raw_layer
-    ssl = False
-    kwargs_cls = {}
+class LDAP_SubstringFilterStr(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_CHOICE(
+        "str",
+        ASN1_STRING(""),
+        ASN1F_PACKET(
+            "initial",
+            LDAP_SubstringFilterInitial(),
+            LDAP_SubstringFilterInitial,
+            implicit_tag=0x80,
+        ),
+        ASN1F_PACKET(
+            "any", LDAP_SubstringFilterAny(), LDAP_SubstringFilterAny, implicit_tag=0x81
+        ),
+        ASN1F_PACKET(
+            "final",
+            LDAP_SubstringFilterFinal(),
+            LDAP_SubstringFilterFinal,
+            implicit_tag=0x82,
+        ),
+    )
 
-    def __init__(self, *args, **kwargs):
-        self.client_pipe = ObjectPipe()
-        super(NTLM_Client, self).__init__(*args, **kwargs)
 
-    def bind(self, srv_atmt):
-        # type: (NTLM_Server) -> None
-        self.srv_atmt = srv_atmt
+class LDAP_SubstringFilter(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        AttributeType("type", ""),
+        ASN1F_SEQUENCE_OF("filters", [], LDAP_SubstringFilterStr),
+    )
 
-    def set_srv(self, attr, value):
-        self.srv_atmt.values[attr] = value
 
-    def get_token(self):
-        return self.srv_atmt.token_pipe.recv()
+_LDAP_Filter = lambda *args, **kwargs: LDAP_Filter(*args, **kwargs)
 
-    def echo(self, pkt):
-        return self.srv_atmt.send(pkt)
 
-    def wait_server(self):
-        kwargs = self.client_pipe.recv()
-        self.client_pipe.close()
-        return kwargs
+class LDAP_FilterAnd(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SET_OF("and_", [], _LDAP_Filter)
 
 
-class NTLM_Server(_NTLM_Automaton):
-    """
-    A class to overload to create a server automaton when using
-    NTLM.
+class LDAP_FilterOr(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SET_OF("or_", [], _LDAP_Filter)
 
-    :param NTLM_VALUES: a dict whose keys are
-        - "NetbiosDomainName"
-        - "NetbiosComputerName"
-        - "DnsDomainName"
-        - "DnsComputerName"
-        - "DnsTreeName"
-        - "Flags"
-        - "Timestamp"
-
-    :param IDENTITIES: a dict {"username": NTOWFv2("password", "username", "domain")}
-                       (this is the KeyResponseNT). Setting this value enables
-                       signature computation and authenticates inbound users.
-    :param DOMAIN_AUTH: a tuple ("<DC IP>", "machineName", b"machinePassword") to
-                        use for domain authentication, used to establish the netlogon
-                        session. (UNIMPLEMENTED)
-    """
-    port = 445
-    cls = conf.raw_layer
 
-    def __init__(self, *args, **kwargs):
-        self.cli_atmt = None
-        self.cli_values = dict()
-        self.ntlm_values = kwargs.pop("NTLM_VALUES", None)
-        self.ntlm_state = 0
-        self.DOMAIN_AUTH = kwargs.pop("DOMAIN_AUTH", None)
-        self.IDENTITIES = kwargs.pop("IDENTITIES", None)
-        self.CHECK_LOGIN = bool(self.IDENTITIES) or bool(self.DOMAIN_AUTH)
-        self.SigningSessionKey = None
-        self.Challenge = None
-        super(NTLM_Server, self).__init__(*args, **kwargs)
-
-    def bind(self, cli_atmt):
-        # type: (NTLM_Client) -> None
-        self.cli_atmt = cli_atmt
-
-    def get_token(self, negoex=False):
-        if negoex:
-            # Special case: negoex
-            if self.cli_atmt:
-                return self.cli_atmt.token_pipe.recv()
-            else:
-                self.token_pipe.clear()
-            return None, None, None, None
-        from random import randint
-        if self.ntlm_state == 0:
-            # First token asked (after negotiate)
-            self.ntlm_state = 1
-            negResult, MIC, rawToken = None, None, False
-            # Take a default token
-            tok = NTLM_CHALLENGE(
-                ServerChallenge=struct.pack("<Q", randint(0, 2**64)),
-                MessageType=2,
-                NegotiateFlags=0xe2898215,
-                ProductMajorVersion=10,
-                ProductMinorVersion=0,
-                Payload=[('TargetName', ""),
-                         ('TargetInfo', [
-                          # MsvAvNbComputerName
-                          AV_PAIR(AvId=1, Value="SRV"),
-                          # MsvAvNbDomainName
-                          AV_PAIR(AvId=2, Value="DOMAIN"),
-                          # MsvAvDnsComputerName
-                          AV_PAIR(AvId=3, Value="SRV.DOMAIN.local"),
-                          # MsvAvDnsDomainName
-                          AV_PAIR(AvId=4, Value="DOMAIN.local"),
-                          # MsvAvDnsTreeName
-                          AV_PAIR(AvId=5, Value="DOMAIN.local"),
-                          # MsvAvTimestamp
-                          AV_PAIR(AvId=7, Value=0.0),
-                          # MsvAvEOL
-                          AV_PAIR(AvId=0),
-                          ])]
-            )
-            if self.cli_atmt:
-                # from client
-                tok, negResult, MIC, rawToken = self.cli_atmt.token_pipe.recv()
-            else:
-                # we act as a standalone server
-                rawToken = self.token_pipe.recv()[3]
-            if self.ntlm_values:
-                # Update that token with the customs one
-                for key in ["ServerChallenge",
-                            "NegotiateFlags",
-                            "ProductMajorVersion",
-                            "ProductMinorVersion",
-                            "TargetName"]:
-                    if key in self.ntlm_values:
-                        setattr(tok, key, self.ntlm_values[key])
-                avpairs = {x.AvId: x.Value for x in tok.TargetInfo}
-                tok.TargetInfo = [
-                    AV_PAIR(AvId=i, Value=self.ntlm_values.get(x, avpairs[i]))
-                    for (i, x) in [
-                        (2, "NetbiosDomainName"),
-                        (1, "NetbiosComputerName"),
-                        (4, "DnsDomainName"),
-                        (3, "DnsComputerName"),
-                        (5, "DnsTreeName"),
-                        (6, "Flags"),
-                        (7, "Timestamp"),
-                        (0, None),
-                    ]
-                    if (x in self.ntlm_values) or (i in avpairs)]
-            self.Challenge = tok
-            return tok, negResult, MIC, rawToken
-        elif self.ntlm_state == 1:
-            # After auth. We return "success"
-            self.ntlm_state = 0
-            rawToken = False
-            if self.cli_atmt:
-                return self.cli_atmt.token_pipe.recv()
-            else:
-                # we act as a standalone server
-                auth_tok, _, _, rawToken = self.token_pipe.recv()
-                if NTLM_AUTHENTICATE_V2 not in auth_tok:
-                    raise ValueError("Unexpected state :(")
-                if self.CHECK_LOGIN:
-                    if auth_tok.UserNameLen:
-                        username = auth_tok.UserName
-                    else:
-                        username = None
-                    # Check the NTProofStr
-                    if self.SigningSessionKey:
-                        if self.DOMAIN_AUTH:
-                            # Domain auth: if we have the session key, ntproofstr was ok
-                            return None, 0, None, rawToken  # "success"
-                        elif username in self.IDENTITIES:
-                            # Local auth: We should know this user's KeyResponseNT
-                            NTProofStr = auth_tok.NtChallengeResponse.computeNTProofStr(
-                                self.IDENTITIES[username],
-                                self.Challenge.ServerChallenge,
-                            )
-                            if NTProofStr == auth_tok.NtChallengeResponse.NTProofStr:
-                                return None, 0, None, rawToken  # "success"
-                    # Bad NTProofStr or unknown user
-                    self.Challenge.ServerChallenge = struct.pack(
-                        "<Q",
-                        randint(0, 2**64)
-                    )
-                    return self.Challenge, 2, None, rawToken  # fail
-                return None, 0, None, rawToken  # "success"
+class LDAP_FilterPresent(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeType("present", "")
 
-    def get_SessionBaseKey(self, ntlm):
-        if ntlm.UserNameLen:
-            username = ntlm.UserName
-        else:
-            username = None
-        if self.IDENTITIES and username in self.IDENTITIES:
-            return NTLMv2_ComputeSessionBaseKey(
-                self.IDENTITIES[username],
-                ntlm.NtChallengeResponse.NTProofStr
-            )
-
-    def received_ntlm_token(self, ntlm_tuple):
-        ntlm = ntlm_tuple[0]
-        if isinstance(ntlm, NTLM_AUTHENTICATE_V2) and self.CHECK_LOGIN:
-            SessionBaseKey = self.get_SessionBaseKey(ntlm)
-            if SessionBaseKey:
-                # [MS-NLMP] sect 3.2.5.1.2
-                KeyExchangeKey = SessionBaseKey  # Only true for NTLMv2
-                if ntlm.NegotiateFlags.NTLMSSP_NEGOTIATE_KEY_EXCH:
-                    ExportedSessionKey = RC4K(
-                        KeyExchangeKey,
-                        ntlm.EncryptedRandomSessionKey
-                    )
-                else:
-                    ExportedSessionKey = KeyExchangeKey
-                self.SigningSessionKey = ExportedSessionKey  # [MS-SMB] 3.2.5.3
-        super(NTLM_Server, self).received_ntlm_token(ntlm_tuple)
-
-    def set_cli(self, attr, value):
-        if self.cli_atmt:
-            self.cli_atmt.values[attr] = value
-        else:
-            self.cli_values[attr] = value
 
-    def echo(self, pkt):
-        if self.cli_atmt:
-            return self.cli_atmt.send(pkt)
-
-    def start_client(self, **kwargs):
-        assert self.cli_atmt, "Cannot start NTLM client: not provided"
-        self.cli_atmt.client_pipe.send(kwargs)
-
-
-def ntlm_relay(serverCls,
-               remoteIP,
-               remoteClientCls,
-               # Classic attacks
-               DROP_MIC_v1=False,
-               DROP_MIC_v2=False,
-               DROP_EXTENDED_SECURITY=False,  # SMB1
-               # Optional arguments
-               ALLOW_SMB2=None,
-               server_kwargs=None,
-               client_kwargs=None,
-               iface=None,
-               debug=2):
-    """
-    NTLM Relay
+class LDAP_FilterEqual(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeValueAssertion.ASN1_root
 
-    This class aims at implementing a simple pass-the-hash attack across
-    various protocols.
 
-    Usage example:
-        ntlm_relay(port=445,
-                   remoteIP="192.168.122.65",
-                   remotePort=445,
-                   iface="eth0")
-
-    :param port: the port to open the relay on
-    :param remoteIP: the address IP of the server to connect to for auth
-    :param remotePort: the proto to connect to the server into
-    """
+class LDAP_FilterGreaterOrEqual(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeValueAssertion.ASN1_root
 
-    assert issubclass(
-        serverCls, NTLM_Server), "Specify a correct NTLM server class"
-    assert issubclass(
-        remoteClientCls, NTLM_Client), "Specify a correct NTLM client class"
-    assert remoteIP, "Specify a valid remote IP address"
-
-    ssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    ssock.bind(
-        (get_if_addr(iface or conf.iface), serverCls.port))
-    ssock.listen(5)
-    sniffers = []
-    server_kwargs = server_kwargs or {}
-    client_kwargs = client_kwargs or {}
-    if DROP_MIC_v1:
-        server_kwargs["DROP_MIC_v1"] = client_kwargs["DROP_MIC_v1"] = True
-    if DROP_MIC_v2:
-        server_kwargs["DROP_MIC_v2"] = client_kwargs["DROP_MIC_v2"] = True
-    if DROP_EXTENDED_SECURITY:
-        client_kwargs["EXTENDED_SECURITY"] = False
-        server_kwargs["EXTENDED_SECURITY"] = False
-    if ALLOW_SMB2 is not None:
-        client_kwargs["ALLOW_SMB2"] = server_kwargs["ALLOW_SMB2"] = ALLOW_SMB2
-    for k, v in remoteClientCls.kwargs_cls.get(serverCls, {}).items():
-        if k not in server_kwargs:
-            server_kwargs[k] = v
-    try:
-        evt = threading.Event()
-        while not evt.is_set():
-            clientsocket, address = ssock.accept()
-            sock = StreamSocket(clientsocket, serverCls.cls)
-            srv_atmt = serverCls(sock, debug=debug, **server_kwargs)
-            # Connect to real server
-            _sock = socket.socket()
-            _sock.connect(
-                (remoteIP, remoteClientCls.port)
-            )
-            remote_sock = None
-            # SSL?
-            if remoteClientCls.ssl:
-                context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
-                # Disable all SSL checks...
-                context.check_hostname = False
-                context.verify_mode = ssl.CERT_NONE
-                _sock = context.wrap_socket(_sock)
-                remote_sock = SSLStreamSocket(_sock, remoteClientCls.cls)
-            else:
-                remote_sock = StreamSocket(_sock, remoteClientCls.cls)
-            print("%s connected -> %s" %
-                  (repr(address), repr(_sock.getsockname())))
-            cli_atmt = remoteClientCls(remote_sock, debug=debug, **client_kwargs)
-            sock_tup = ((srv_atmt, cli_atmt), (sock, remote_sock))
-            sniffers.append(sock_tup)
-            # Bind NTLM functions
-            srv_atmt.bind(cli_atmt)
-            cli_atmt.bind(srv_atmt)
-            # Start automatons
-            srv_atmt.runbg()
-            cli_atmt.runbg()
-    except KeyboardInterrupt:
-        print("Exiting.")
-    finally:
-        for atmts, socks in sniffers:
-            for atmt in atmts:
-                try:
-                    atmt.forcestop(wait=False)
-                except Exception:
-                    pass
-            for sock in socks:
-                try:
-                    sock.close()
-                except Exception:
-                    pass
-        ssock.close()
-
-
-def ntlm_server(serverCls,
-                server_kwargs=None,
-                iface=None,
-                debug=2):
-    """
-    Starts a standalone NTLM server class
-    """
-    assert issubclass(
-        serverCls, NTLM_Server), "Specify a correct NTLM server class"
 
-    ssock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    ssock.bind(
-        (get_if_addr(iface or conf.iface), serverCls.port))
-    ssock.listen(5)
-    print(conf.color_theme.green(
-        "Server %s started. Waiting..." % serverCls.__name__
-    ))
-    sniffers = []
-    server_kwargs = server_kwargs or {}
-    try:
-        evt = threading.Event()
-        while not evt.is_set():
-            clientsocket, address = ssock.accept()
-            sock = StreamSocket(clientsocket, serverCls.cls)
-            srv_atmt = serverCls(sock, debug=debug, **server_kwargs)
-            sniffers.append((srv_atmt, sock))
-            print(conf.color_theme.gold("-> %s connected " % repr(address)))
-            # Start automatons
-            srv_atmt.runbg()
-    except KeyboardInterrupt:
-        print("Exiting.")
-    finally:
-        for atmt, sock in sniffers:
-            try:
-                atmt.forcestop(wait=False)
-            except Exception:
-                pass
-            try:
-                sock.close()
-            except Exception:
-                pass
-        ssock.close()
+class LDAP_FilterLesserOrEqual(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeValueAssertion.ASN1_root
+
+
+class LDAP_FilterLessOrEqual(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeValueAssertion.ASN1_root
+
+
+class LDAP_FilterApproxMatch(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeValueAssertion.ASN1_root
+
+
+class ASN1_Class_LDAP_Filter(ASN1_Class):
+    name = "LDAP Filter"
+    # CONTEXT-SPECIFIC + CONSTRUCTED = 0x80 | 0x20
+    And = 0xA0
+    Or = 0xA1
+    Not = 0xA2
+    EqualityMatch = 0xA3
+    Substrings = 0xA4
+    GreaterOrEqual = 0xA5
+    LessOrEqual = 0xA6
+    Present = 0x87  # not constructed
+    ApproxMatch = 0xA8
+
 
+class LDAP_Filter(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_CHOICE(
+        "filter",
+        LDAP_FilterPresent(),
+        ASN1F_PACKET(
+            "and_", None, LDAP_FilterAnd, implicit_tag=ASN1_Class_LDAP_Filter.And
+        ),
+        ASN1F_PACKET(
+            "or_", None, LDAP_FilterOr, implicit_tag=ASN1_Class_LDAP_Filter.Or
+        ),
+        ASN1F_PACKET(
+            "not_", None, _LDAP_Filter, implicit_tag=ASN1_Class_LDAP_Filter.Not
+        ),
+        ASN1F_PACKET(
+            "equalityMatch",
+            None,
+            LDAP_FilterEqual,
+            implicit_tag=ASN1_Class_LDAP_Filter.EqualityMatch,
+        ),
+        ASN1F_PACKET(
+            "substrings",
+            None,
+            LDAP_SubstringFilter,
+            implicit_tag=ASN1_Class_LDAP_Filter.Substrings,
+        ),
+        ASN1F_PACKET(
+            "greaterOrEqual",
+            None,
+            LDAP_FilterGreaterOrEqual,
+            implicit_tag=ASN1_Class_LDAP_Filter.GreaterOrEqual,
+        ),
+        ASN1F_PACKET(
+            "lessOrEqual",
+            None,
+            LDAP_FilterLessOrEqual,
+            implicit_tag=ASN1_Class_LDAP_Filter.LessOrEqual,
+        ),
+        ASN1F_PACKET(
+            "present",
+            None,
+            LDAP_FilterPresent,
+            implicit_tag=ASN1_Class_LDAP_Filter.Present,
+        ),
+        ASN1F_PACKET(
+            "approxMatch",
+            None,
+            LDAP_FilterApproxMatch,
+            implicit_tag=ASN1_Class_LDAP_Filter.ApproxMatch,
+        ),
+    )
 
-# Experimental - Reversed stuff
 
-# This is the GSSAPI NegoEX Exchange metadata blob. This is not documented
-# but described as an "opaque blob": this was reversed and everything is a
-# placeholder.
+class LDAP_SearchRequestAttribute(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeType("type", "")
+
 
-class NEGOEX_EXCHANGE_NTLM_ITEM(ASN1_Packet):
+class LDAP_SearchRequest(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SEQUENCE(
-        ASN1F_SEQUENCE(
-            ASN1F_SEQUENCE(
-                ASN1F_OID("oid", ""),
-                ASN1F_PRINTABLE_STRING("token", ""),
-                explicit_tag=0x31
-            ),
-            explicit_tag=0x80
-        )
+        LDAPDN("baseObject", ""),
+        ASN1F_ENUMERATED(
+            "scope", 0, {0: "baseObject", 1: "singleLevel", 2: "wholeSubtree"}
+        ),
+        ASN1F_ENUMERATED(
+            "derefAliases",
+            0,
+            {
+                0: "neverDerefAliases",
+                1: "derefInSearching",
+                2: "derefFindingBaseObj",
+                3: "derefAlways",
+            },
+        ),
+        ASN1F_INTEGER("sizeLimit", 0),
+        ASN1F_INTEGER("timeLimit", 0),
+        ASN1F_BOOLEAN("attrsOnly", False),
+        ASN1F_PACKET("filter", LDAP_Filter(), LDAP_Filter),
+        ASN1F_SEQUENCE_OF("attributes", [], LDAP_SearchRequestAttribute),
+        implicit_tag=ASN1_Class_LDAP.SearchRequest,
     )
 
 
-class NEGOEX_EXCHANGE_NTLM(ASN1_Packet):
-    """
-    GSSAPI NegoEX Exchange metadata blob
-    This was reversed and may be meaningless
-    """
+class LDAP_SearchResponseEntryAttributeValue(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = AttributeValue("value", "")
+
+
+class LDAP_SearchResponseEntryAttribute(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        AttributeType("type", ""),
+        ASN1F_SET_OF("values", [], LDAP_SearchResponseEntryAttributeValue),
+    )
+
+
+class LDAP_SearchResponseEntry(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        LDAPDN("objectName", ""),
+        ASN1F_SEQUENCE_OF(
+            "attributes",
+            LDAP_SearchResponseEntryAttribute(),
+            LDAP_SearchResponseEntryAttribute,
+        ),
+        implicit_tag=ASN1_Class_LDAP.SearchResultEntry,
+    )
+
+
+class LDAP_SearchResponseResultDone(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        *LDAPResult,
+        implicit_tag=ASN1_Class_LDAP.SearchResultDone,
+    )
+
+
+class LDAP_AbandonRequest(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_INTEGER("messageID", 0),
+        implicit_tag=ASN1_Class_LDAP.AbandonRequest,
+    )
+
+
+# LDAP v3
+
+
+class LDAP_Control(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SEQUENCE(
-        ASN1F_SEQUENCE(
-            ASN1F_SEQUENCE_OF(
-                "items", [],
-                NEGOEX_EXCHANGE_NTLM_ITEM
+        LDAPOID("controlType", ""),
+        ASN1F_optional(
+            ASN1F_BOOLEAN("criticality", False),
+        ),
+        ASN1F_optional(ASN1F_STRING("controlValue", "")),
+    )
+
+
+# LDAP
+
+
+class LDAP(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_INTEGER("messageID", 0),
+        ASN1F_CHOICE(
+            "protocolOp",
+            LDAP_SearchRequest(),
+            LDAP_BindRequest,
+            LDAP_BindResponse,
+            LDAP_SearchRequest,
+            LDAP_SearchResponseEntry,
+            LDAP_SearchResponseResultDone,
+            LDAP_AbandonRequest,
+            LDAP_UnbindRequest,
+        ),
+        # LDAP v3 only
+        ASN1F_optional(
+            ASN1F_SEQUENCE_OF("Controls", None, LDAP_Control, implicit_tag=0xA0)
+        ),
+    )
+
+    def answers(self, other):
+        return isinstance(other, LDAP) and other.messageID == self.messageID
+
+    def mysummary(self):
+        return (
+            "%s(%s)"
+            % (
+                self.protocolOp.__class__.__name__.replace("_", " "),
+                self.messageID.val,
             ),
-            implicit_tag=0xa0
+            [LDAP],
+        )
+
+
+bind_layers(LDAP, LDAP)
+
+bind_bottom_up(TCP, LDAP, dport=389)
+bind_bottom_up(TCP, LDAP, sport=389)
+bind_bottom_up(TCP, LDAP, dport=3268)
+bind_bottom_up(TCP, LDAP, sport=3268)
+bind_layers(TCP, LDAP, sport=389, dport=389)
+
+# CLDAP - rfc1798
+
+
+class CLDAP(ASN1_Packet):
+    ASN1_codec = ASN1_Codecs.BER
+    ASN1_root = ASN1F_SEQUENCE(
+        LDAP.ASN1_root.seq[0],  # messageID
+        ASN1F_optional(
+            LDAPDN("user", ""),
         ),
+        LDAP.ASN1_root.seq[1],  # protocolOp
     )
 
+    def answers(self, other):
+        return isinstance(other, CLDAP) and other.messageID == self.messageID
 
-# Crypto - [MS-NLMP]
 
+bind_layers(CLDAP, CLDAP)
+
+bind_bottom_up(UDP, CLDAP, dport=389)
+bind_bottom_up(UDP, CLDAP, sport=389)
+bind_layers(UDP, CLDAP, sport=389, dport=389)
+
+
+# Small CLDAP Answering machine: [MS-ADTS] 6.3.3 - Ldap ping
+
+
+class LdapPing_am(AnsweringMachine):
+    function_name = "ldappingd"
+    filter = "udp port 389 or 138"
+    send_function = staticmethod(send)
+
+    def parse_options(
+        self,
+        NetbiosDomainName="DOMAIN",
+        DomainGuid=uuid.UUID("192bc4b3-0085-4521-83fe-062913ef59f2"),
+        DcSiteName="Default-First-Site-Name",
+        NetbiosComputerName="SRV1",
+        DnsForestName=None,
+        DnsHostName=None,
+        src_ip=None,
+        src_ip6=None,
+    ):
+        self.NetbiosDomainName = NetbiosDomainName
+        self.DnsForestName = DnsForestName or (NetbiosDomainName + ".LOCAL")
+        self.DomainGuid = DomainGuid
+        self.DcSiteName = DcSiteName
+        self.NetbiosComputerName = NetbiosComputerName
+        self.DnsHostName = DnsHostName or (
+            NetbiosComputerName + "." + self.DnsForestName
+        )
+        self.src_ip = src_ip
+        self.src_ip6 = src_ip6
+
+    def is_request(self, req):
+        # [MS-ADTS] 6.3.3 - Example:
+        # (&(DnsDomain=abcde.corp.microsoft.com)(Host=abcdefgh-dev)(User=abcdefgh-
+        # dev$)(AAC=\80\00\00\00)(DomainGuid=\3b\b0\21\ca\d3\6d\d1\11\8a\7d\b8\df\b1\56\87\1f)(NtVer
+        # =\06\00\00\00))
+        if NBTDatagram in req:
+            # special case: mailslot ping
+            from scapy.layers.smb import SMBMailslot_Write, NETLOGON_SAM_LOGON_REQUEST
+            try:
+                return (
+                    SMBMailslot_Write in req and
+                    NETLOGON_SAM_LOGON_REQUEST in req.Data
+                )
+            except AttributeError:
+                return False
+        if CLDAP not in req or not isinstance(req.protocolOp, LDAP_SearchRequest):
+            return False
+        req = req.protocolOp
+        return (
+            req.attributes
+            and req.attributes[0].type.val.lower() == b"netlogon"
+            and req.filter
+            and isinstance(req.filter.filter, LDAP_FilterAnd)
+            and any(
+                x.filter.attributeType.val == b"NtVer" for x in req.filter.filter.and_
+            )
+        )
+
+    def make_reply(self, req):
+        if NBTDatagram in req:
+            # Special case
+            return self.make_mailslot_ping_reply(req)
+        if IPv6 in req:
+            resp = IPv6(dst=req[IPv6].src, src=self.src_ip6 or req[IPv6].dst)
+        else:
+            resp = IP(dst=req[IP].src, src=self.src_ip or req[IP].dst)
+        resp /= UDP(sport=req.dport, dport=req.sport)
+        # get the DnsDomainName from the request
+        try:
+            DnsDomainName = next(
+                x.filter.attributeValue.val
+                for x in req.protocolOp.filter.filter.and_
+                if x.filter.attributeType.val == b"DnsDomain"
+            )
+        except StopIteration:
+            return
+        return (
+            resp
+            / CLDAP(
+                protocolOp=LDAP_SearchResponseEntry(
+                    attributes=[
+                        LDAP_SearchResponseEntryAttribute(
+                            values=[
+                                LDAP_SearchResponseEntryAttributeValue(
+                                    value=ASN1_STRING(
+                                        val=bytes(
+                                            NETLOGON_SAM_LOGON_RESPONSE_EX(
+                                                # Mandatory fields
+                                                DnsDomainName=DnsDomainName,
+                                                NtVersion="V1+V5",
+                                                LmNtToken=65535,
+                                                Lm20Token=65535,
+                                                # Below can be customized
+                                                Flags=0x3F3FD,
+                                                DomainGuid=self.DomainGuid,
+                                                DnsForestName=self.DnsForestName,
+                                                DnsHostName=self.DnsHostName,
+                                                NetbiosDomainName=self.NetbiosDomainName,  # noqa: E501
+                                                NetbiosComputerName=self.NetbiosComputerName,  # noqa: E501
+                                                UserName=b".",
+                                                DcSiteName=self.DcSiteName,
+                                                ClientSiteName=self.DcSiteName,
+                                            )
+                                        )
+                                    )
+                                )
+                            ],
+                            type=ASN1_STRING(b"Netlogon"),
+                        )
+                    ],
+                ),
+                messageID=req.messageID,
+                user=None,
+            )
+            / CLDAP(
+                protocolOp=LDAP_SearchResponseResultDone(
+                    referral=None,
+                    resultCode=0,
+                ),
+                messageID=req.messageID,
+                user=None,
+            )
+        )
 
-def HMAC_MD5(key, data):
-    h = hmac.HMAC(key, hashes.MD5())
-    h.update(data)
-    return h.finalize()
+    def make_mailslot_ping_reply(self, req):
+        # type: (Packet) -> Packet
+        from scapy.layers.smb import (
+            SMBMailslot_Write,
+            SMB_Header,
+            DcSockAddr,
+            NETLOGON_SAM_LOGON_RESPONSE_EX,
+        )
+        resp = IP(dst=req[IP].src) / UDP(
+            sport=req.dport,
+            dport=req.sport,
+        )
+        address = self.src_ip or get_if_addr(self.optsniff.get("iface", conf.iface))
+        resp /= NBTDatagram(
+            SourceName=req.DestinationName,
+            SUFFIX1=req.SUFFIX2,
+            DestinationName=req.SourceName,
+            SUFFIX2=req.SUFFIX1,
+            SourceIP=address,
+        ) / SMB_Header() / SMBMailslot_Write(
+            Name=req.Data.MailslotName,
+        )
+        NetbiosDomainName = req.DestinationName.strip()
+        resp.Data = NETLOGON_SAM_LOGON_RESPONSE_EX(
+            # Mandatory fields
+            NetbiosDomainName=NetbiosDomainName,
+            DcSockAddr=DcSockAddr(
+                sin_addr=address,
+            ),
+            NtVersion="V1+V5EX+V5EX_WITH_IP",
+            LmNtToken=65535,
+            Lm20Token=65535,
+            # Below can be customized
+            Flags=0x3F3FD,
+            DomainGuid=self.DomainGuid,
+            DnsForestName=self.DnsForestName,
+            DnsDomainName=self.DnsForestName,
+            DnsHostName=self.DnsHostName,
+            NetbiosComputerName=self.NetbiosComputerName,
+            DcSiteName=self.DcSiteName,
+            ClientSiteName=self.DcSiteName,
+        )
+        return resp
 
 
-def MD4(x):
-    return Hash_MD4().digest(x)
+_located_dc = collections.namedtuple("LocatedDC", ["ip", "samlogon"])
+_dclocatorcache = conf.netcache.new_cache("dclocator", 600)
 
 
-def RC4Init(key):
-    """Alleged RC4"""
-    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
-    algorithm = algorithms.ARC4(key)
-    cipher = Cipher(algorithm, mode=None)
-    encryptor = cipher.encryptor()
-    return encryptor
+@conf.commands.register
+def dclocator(
+    realm, qtype="A", mode="ldap", port=None, timeout=1, NtVersion=None, debug=0
+):
+    """
+    Perform a DC Locator as per [MS-ADTS] sect 6.3.6 or RFC4120.
 
+    :param realm: the kerberos realm to locate
+    :param mode: Detect if a server is up and joinable thanks to one of:
 
-def RC4(handle, data):
-    """The RC4 Encryption Algorithm"""
-    return handle.update(data)
+    - 'nocheck': Do not check that servers are online.
+    - 'ldap': Use the LDAP ping (CLDAP) per [MS-ADTS]. Default.
+              This will however not work with MIT Kerberos servers.
+    - 'connect': connect to specified port to test the connection.
 
+    :param mode: in connect mode, the port to connect to. (e.g. 88)
+    :param debug: print debug logs
 
-def RC4K(key, data):
-    """Indicates the encryption of data item D with the key K using the
-    RC4 algorithm.
+    This is cached in conf.netcache.dclocator.
     """
-    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
-    algorithm = algorithms.ARC4(key)
-    cipher = Cipher(algorithm, mode=None)
-    encryptor = cipher.encryptor()
-    return encryptor.update(data) + encryptor.finalize()
+    if NtVersion is None:
+        # Windows' default
+        NtVersion = (
+            0x00000002  # V5
+            | 0x00000004  # V5EX
+            | 0x00000010  # V5EX_WITH_CLOSEST_SITE
+            | 0x01000000  # AVOID_NT4EMUL
+            | 0x20000000  # IP
+        )
+    # Check cache
+    cache_ident = ";".join([realm, qtype, mode, str(NtVersion)]).lower()
+    if cache_ident in _dclocatorcache:
+        return _dclocatorcache[cache_ident]
+    # Perform DNS-Based discovery (6.3.6.1)
+    # 1. SRV records
+    qname = "_kerberos._tcp.dc._msdcs.%s" % realm.lower()
+    if debug:
+        log_runtime.info("DC Locator: requesting SRV for '%s' ..." % qname)
+    try:
+        hosts = [
+            x.target
+            for x in dns_resolve(
+                qname=qname,
+                qtype="SRV",
+                timeout=timeout,
+            )
+        ]
+    except TimeoutError:
+        raise TimeoutError("Resolution of %s timed out" % qname)
+    if not hosts:
+        raise ValueError("No DNS record found for %s" % qname)
+    elif debug:
+        log_runtime.info(
+            "DC Locator: got %s. Resolving %s records ..." % (hosts, qtype)
+        )
+    # 2. A records
+    ips = []
+    for host in hosts:
+        arec = dns_resolve(
+            qname=host,
+            qtype=qtype,
+            timeout=timeout,
+        )
+        if arec:
+            ips.extend(x.rdata for x in arec)
+    if not ips:
+        raise ValueError("Could not get any %s records for %s" % (qtype, hosts))
+    elif debug:
+        log_runtime.info("DC Locator: got %s . Mode: %s" % (ips, mode))
+    # Pick first online host. We have three options
+    if mode == "nocheck":
+        # Don't check anything. Not recommended
+        return _located_dc(ips[0], None)
+    elif mode == "connect":
+        assert port is not None, "Must provide a port in connect mode !"
+        # Compatibility with MIT Kerberos servers
+        for ip in ips:  # TODO: "addresses in weighted random order [RFC2782]"
+            if debug:
+                log_runtime.info("DC Locator: connecting to %s on %s ..." % (ip, port))
+            try:
+                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+                sock.settimeout(timeout)
+                sock.connect((ip, port))
+                # Success
+                result = _located_dc(ip, None)
+                # Cache
+                _dclocatorcache[cache_ident] = result
+                return result
+            except OSError:
+                # Host timed out, No route to host, etc.
+                if debug:
+                    log_runtime.info("DC Locator: %s timed out." % ip)
+                continue
+            finally:
+                sock.close()
+        raise ValueError("No host was reachable on port %s among %s" % (port, ips))
+    elif mode == "ldap":
+        # Real 'LDAP Ping' per [MS-ADTS]
+        for ip in ips:  # TODO: "addresses in weighted random order [RFC2782]"
+            if debug:
+                log_runtime.info("DC Locator: LDAP Ping %s on ..." % ip)
+            try:
+                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+                sock.settimeout(timeout)
+                sock.connect((ip, 389))
+                sock = SimpleSocket(sock, CLDAP)
+                pkt = sock.sr1(
+                    CLDAP(
+                        protocolOp=LDAP_SearchRequest(
+                            filter=LDAP_Filter(
+                                filter=LDAP_FilterAnd(
+                                    and_=[
+                                        LDAP_Filter(
+                                            filter=LDAP_FilterEqual(
+                                                attributeType=ASN1_STRING(b"DnsDomain"),
+                                                attributeValue=ASN1_STRING(realm),
+                                            )
+                                        ),
+                                        LDAP_Filter(
+                                            filter=LDAP_FilterEqual(
+                                                attributeType=ASN1_STRING(b"NtVer"),
+                                                attributeValue=ASN1_STRING(
+                                                    struct.pack("<I", NtVersion)
+                                                ),
+                                            )
+                                        ),
+                                    ]
+                                )
+                            ),
+                            attributes=[
+                                LDAP_SearchRequestAttribute(
+                                    type=ASN1_STRING(b"Netlogon")
+                                )
+                            ],
+                        ),
+                        user=None,
+                    ),
+                    timeout=timeout,
+                    verbose=0,
+                )
+                if pkt:
+                    # Check if we have a search response
+                    response = None
+                    if isinstance(pkt.protocolOp, LDAP_SearchResponseEntry):
+                        try:
+                            response = next(
+                                NETLOGON(x.values[0].value.val)
+                                for x in pkt.protocolOp.attributes
+                                if x.type.val == b"Netlogon"
+                            )
+                        except StopIteration:
+                            pass
+                    result = _located_dc(ip, response)
+                    # Cache
+                    _dclocatorcache[cache_ident] = result
+                    return result
+            except OSError:
+                # Host timed out, No route to host, etc.
+                if debug:
+                    log_runtime.info("DC Locator: %s timed out." % ip)
+                continue
+            finally:
+                sock.close()
+        raise ValueError("No LDAP ping succeeded on any of %s. Try another mode?" % ips)
 
-# sect 2.2.2.9 - With Extended Session Security
 
+#####################
+# Basic LDAP client #
+#####################
+
+
+class LDAP_BIND_MECHS(Enum):
+    NONE = "NONE"
+    SIMPLE = "SIMPLE"
+    SASL_GSSAPI = "GSSAPI"
+    SASL_GSS_SPNEGO = "GSS-SPNEGO"
+    SASL_EXTERNAL = "EXTERNAL"
+    SASL_DIGEST_MD5 = "DIGEST-MD5"
+    # [MS-ADTS] extension
+    SICILY = "SICILY"
+
+
+class LDAP_SASL_GSSAPI_SsfCap(Packet):
+    """
+    RFC2222 sect 7.2.1 and 7.2.2 negotiate token
+    """
 
-class NTLMSSP_MESSAGE_SIGNATURE(Packet):
     fields_desc = [
-        LEIntField("Version", 1),
-        StrFixedLenField("Checksum", b"", length=8),
-        LEIntField("SeqNum", 0),
+        FlagsField(
+            "supported_security_layers",
+            0,
+            -8,
+            {
+                # https://github.com/cyrusimap/cyrus-sasl/blob/7e2feaeeb2e37d38cb5fa957d0e8a599ced22612/plugins/gssapi.c#L221
+                0x01: "NONE",
+                0x02: "INTEGRITY",
+                0x04: "CONFIDENTIALITY",
+            },
+        ),
+        ThreeBytesField("max_output_token_size", 0),
     ]
 
-# sect 3.3.2
 
+class LDAP_Client(object):
+    """
+    A basic LDAP client
 
-def NTOWFv2(Passwd, User, UserDom):
-    """Computes the ResponseKeyNT"""
-    return HMAC_MD5(MD4(Passwd.encode("utf-16le")),
-                    (User.upper() + UserDom).encode("utf-16le"))
+    :param mech: one of LDAP_BIND_MECHS
+    :param ssl: whether to use LDAPS or not
+    :param ssp: the SSP object to use for binding
 
+    :param sign: request signing when binding
+    :param encrypt: request encryption when binding
 
-def NTLMv2_ComputeSessionBaseKey(ResponseKeyNT, NTProofStr):
-    return HMAC_MD5(ResponseKeyNT, NTProofStr)
+    Example 1 - SICILY - NTLM::
 
+        ssp = NTLMSSP(UPN="Administrator", PASSWORD="Password1!")
+        client = LDAP_Client(
+            LDAP_BIND_MECHS.SICILY,
+            ssp=ssp,
+        )
+        client.connect("192.168.0.100")
+        client.bind()
 
-# sect 3.4.4.2 - With Extended Session Security
+    Example 2 - SASL_GSSAPI - Kerberos::
 
-def MAC(Handle, SigningKey, SeqNum, Message):
-    chksum = HMAC_MD5(SigningKey, struct.pack("<i", SeqNum) + Message)[:8]
-    if Handle:
-        chksum = RC4(Handle, chksum)
-    return NTLMSSP_MESSAGE_SIGNATURE(
-        Version=0x00000001,
-        Checksum=chksum,
-        SeqNum=SeqNum,
-    )
+        ssp = KerberosSSP(UPN="Administrator@domain.local", PASSWORD="Password1!",
+                          SPN="ldap/dc1.domain.local")
+        client = LDAP_Client(
+            LDAP_BIND_MECHS.SASL_GSSAPI,
+            ssp=ssp,
+        )
+        client.connect("192.168.0.100")
+        client.bind()
 
-# sect 3.4.3
+    Example 3 - SASL_GSS_SPNEGO - NTLM / Kerberos::
 
+        ssp = SPNEGOSSP([
+            NTLMSSP(UPN="Administrator", PASSWORD="Password1!"),
+            KerberosSSP(UPN="Administrator@domain.local", PASSWORD="Password1!",
+                          SPN="ldap/dc1.domain.local"),
+        ])
+        client = LDAP_Client(
+            LDAP_BIND_MECHS.SASL_GSS_SPNEGO,
+            ssp=ssp,
+        )
+        client.connect("192.168.0.100")
+        client.bind()
 
-def SEAL(Handle, SigningKey, SeqNum, Message):
-    sealed_message = RC4(Handle, Message)
-    signature = MAC(Handle, SigningKey, SeqNum, Message)
-    return sealed_message, signature
+    Example 4 - Simple bind::
 
-# sect 3.4.5.2
+        client = LDAP_Client(LDAP_BIND_MECHS.SIMPLE)
+        client.connect("192.168.0.100")
+        client.bind(simple_username="Administrator",
+                    simple_password="Password1!")
+    """
 
+    def __init__(
+        self,
+        mech,
+        verb=True,
+        ssl=False,
+        sslcontext=None,
+        ssp=None,
+        sign=False,
+        encrypt=False,
+    ):
+        self.sock = None
+        self.mech = mech
+        self.verb = verb
+        self.ssl = ssl
+        self.sslcontext = sslcontext
+        self.ssp = ssp  # type: SSP
+        assert isinstance(mech, LDAP_BIND_MECHS)
+        if mech == LDAP_BIND_MECHS.SASL_GSSAPI:
+            from scapy.layers.kerberos import KerberosSSP
+
+            if not isinstance(self.ssp, KerberosSSP):
+                raise ValueError("Only raw KerberosSSP is supported with SASL_GSSAPI !")
+        elif mech == LDAP_BIND_MECHS.SASL_GSS_SPNEGO:
+            from scapy.layers.spnego import SPNEGOSSP
+
+            if not isinstance(self.ssp, SPNEGOSSP):
+                raise ValueError("Only SPNEGOSSP is supported with SASL_GSS_SPNEGO !")
+        elif mech == LDAP_BIND_MECHS.SICILY:
+            from scapy.layers.ntlm import NTLMSSP
+
+            if not isinstance(self.ssp, NTLMSSP):
+                raise ValueError("Only raw NTLMSSP is supported with SICILY !")
+        if self.ssp is not None and mech in [
+            LDAP_BIND_MECHS.NONE,
+            LDAP_BIND_MECHS.SIMPLE,
+        ]:
+            raise ValueError("%s cannot be used with a ssp !" % mech.value)
+        self.sspcontext = None
+        self.sign = sign
+        self.encrypt = encrypt
+        self.messageID = 0
 
-def SIGNKEY(NegFlg, ExportedSessionKey, Mode):
-    if NegFlg.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:
-        if Mode == "Client":
-            return Hash_MD5().digest(
-                ExportedSessionKey +
-                b"session key to client-to-server signing key magic constant\x00"
+    def connect(self, ip, port=None, timeout=5):
+        """
+        Initiate a connection
+        """
+        if port is None:
+            if self.ssl:
+                port = 636
+            else:
+                port = 389
+        sock = socket.socket()
+        sock.settimeout(timeout)
+        if self.verb:
+            print(
+                "\u2503 Connecting to %s on port %s%s..."
+                % (
+                    ip,
+                    port,
+                    " with SSL" if self.ssl else "",
+                )
             )
-        else:
-            return Hash_MD5().digest(
-                ExportedSessionKey +
-                b"session key to server-to-client signing key magic constant\x00"
-            )
-    else:
-        return None
-
-# sect 3.4.5.3
-
-
-def SEALKEY(NegFlg, ExportedSessionKey, Mode):
-    if NegFlg.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:
-        if NegFlg.NTLMSSP_NEGOTIATE_128:
-            SealKey = ExportedSessionKey
-        elif NegFlg.NTLMSSP_NEGOTIATE_56:
-            SealKey = ExportedSessionKey[:7]
-        else:
-            SealKey = ExportedSessionKey[:5]
-        if Mode == "Client":
-            return Hash_MD5().digest(
-                SealKey +
-                b"session key to client-to-server sealing key magic constant\x00"
+        sock.connect((ip, port))
+        if self.verb:
+            print(
+                conf.color_theme.green(
+                    "\u2514 Connected from %s" % repr(sock.getsockname())
+                )
             )
-        else:
-            return Hash_MD5().digest(
-                SealKey +
-                b"session key to server-to-client sealing key magic constant\x00"
-            )
-    elif NegFlg.NTLMSSP_NEGOTIATE_LM_KEY:
-        if NegFlg.NTLMSSP_NEGOTIATE_56:
-            return ExportedSessionKey[:6] + b"\xA0"
-        else:
-            return ExportedSessionKey[:4] + b"\xe5\x38\xb0"
-    else:
-        return ExportedSessionKey
-
-
-# def _NTLMv2_ComputeResponse(ResponseKeyNT,
-#                             ServerChallenge, ClientChallenge, Time,
-#                             ServerName):
-#     """
-#     Compute the NTLMv2 response : NtChallengeResponse + SessionBaseKey
-#
-#     Remember ServerName = AvPairs
-#     """
-#     Responserversion = b"\x01"
-#     HiResponserversion = b"\x01"
-#     temp = b"".join([Responserversion, HiResponserversion,
-#                      Z(6), Time, ClientChallenge, Z(4), ServerName, Z(4)])
-#     NTProofStr = HMAC_MD5(ResponseKeyNT, ServerChallenge + temp)
-#     NtChallengeResponse = NTProofStr + temp
-#     SessionBaseKey = NTLMv2_ComputeSessionBaseKey(ResponseKeyNT, NTProofStr)
-#     return NtChallengeResponse, SessionBaseKey
+        if self.ssl:
+            if self.sslcontext is None:
+                context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
+                context.check_hostname = False
+                context.verify_mode = ssl.CERT_NONE
+            else:
+                context = self.sslcontext
+            sock = context.wrap_socket(sock)
+        self.sock = StreamSocket(sock, LDAP)
+
+    def sr1(self, protocolOp, controls=None, **kwargs):
+        self.messageID += 1
+        if self.verb:
+            print(conf.color_theme.opening(">> %s" % protocolOp.__class__.__name__))
+        resp = self.sock.sr1(
+            LDAP(
+                messageID=self.messageID,
+                protocolOp=protocolOp,
+                Controls=controls,
+            ),
+            verbose=0,
+            **kwargs,
+        )
+        if self.verb:
+            print(
+                conf.color_theme.success(
+                    "<< %s"
+                    % (
+                        resp.protocolOp.__class__.__name__
+                        if LDAP in resp
+                        else resp.__class__.__name__
+                    )
+                )
+            )
+        return resp
+
+    def bind(self, simple_username=None, simple_password=None):
+        """
+        Send Bind request.
+        This acts differently based on the :mech: provided during initialization.
+        """
+        if self.mech == LDAP_BIND_MECHS.SIMPLE:
+            # Simple binding
+            resp = self.sr1(
+                LDAP_BindRequest(
+                    bind_name=ASN1_STRING(simple_username or ""),
+                    authentication=LDAP_Authentication_simple(
+                        simple_password or "",
+                    ),
+                )
+            )
+            if (
+                LDAP not in resp
+                or not isinstance(resp.protocolOp, LDAP_BindResponse)
+                or resp.protocolOp.resultCode != 0
+            ):
+                if self.verb:
+                    resp.show()
+                raise RuntimeError("LDAP simple bind failed !")
+        elif self.mech == LDAP_BIND_MECHS.SICILY:
+            # [MS-ADTS] sect 5.1.1.1.3
+            # 1. Package Discovery
+            resp = self.sr1(
+                LDAP_BindRequest(
+                    bind_name=ASN1_STRING(b""),
+                    authentication=LDAP_Authentication_sicilyPackageDiscovery(b""),
+                )
+            )
+            if resp.protocolOp.resultCode != 0:
+                resp.show()
+                raise RuntimeError("Sicily package discovery failed !")
+            # 2. First exchange: Negotiate
+            self.sspcontext, token, status = self.ssp.GSS_Init_sec_context(
+                self.sspcontext,
+                req_flags=(
+                    GSS_C_FLAGS.GSS_C_REPLAY_FLAG
+                    | GSS_C_FLAGS.GSS_C_SEQUENCE_FLAG
+                    | GSS_C_FLAGS.GSS_C_MUTUAL_FLAG
+                    | (GSS_C_FLAGS.GSS_C_INTEG_FLAG if self.sign else 0)
+                    | (GSS_C_FLAGS.GSS_C_CONF_FLAG if self.encrypt else 0)
+                ),
+            )
+            resp = self.sr1(
+                LDAP_BindRequest(
+                    bind_name=ASN1_STRING(b"NTLM"),
+                    authentication=LDAP_Authentication_sicilyNegotiate(
+                        bytes(token),
+                    ),
+                )
+            )
+            val = resp.protocolOp.serverCreds
+            if not val:
+                resp.show()
+                raise RuntimeError("Sicily negotiate failed !")
+            # 3. Second exchange: Response
+            self.sspcontext, token, status = self.ssp.GSS_Init_sec_context(
+                self.sspcontext, GSSAPI_BLOB(val)
+            )
+            resp = self.sr1(
+                LDAP_BindRequest(
+                    bind_name=ASN1_STRING(b"NTLM"),
+                    authentication=LDAP_Authentication_sicilyResponse(
+                        bytes(token),
+                    ),
+                )
+            )
+            if resp.protocolOp.resultCode != 0:
+                resp.show()
+                raise RuntimeError("Sicily response failed !")
+        elif self.mech in [
+            LDAP_BIND_MECHS.SASL_GSS_SPNEGO,
+            LDAP_BIND_MECHS.SASL_GSSAPI,
+        ]:
+            # GSSAPI or SPNEGO
+            self.sspcontext, token, status = self.ssp.GSS_Init_sec_context(
+                self.sspcontext,
+                req_flags=(
+                    GSS_C_FLAGS.GSS_C_REPLAY_FLAG
+                    | GSS_C_FLAGS.GSS_C_SEQUENCE_FLAG
+                    | GSS_C_FLAGS.GSS_C_MUTUAL_FLAG
+                    | (GSS_C_FLAGS.GSS_C_INTEG_FLAG if self.sign else 0)
+                    | (GSS_C_FLAGS.GSS_C_CONF_FLAG if self.encrypt else 0)
+                ),
+            )
+            while token:
+                resp = self.sr1(
+                    LDAP_BindRequest(
+                        bind_name=ASN1_STRING(b""),
+                        authentication=LDAP_Authentication_SaslCredentials(
+                            mechanism=ASN1_STRING(self.mech.value),
+                            credentials=ASN1_STRING(bytes(token)),
+                        ),
+                    )
+                )
+                if not isinstance(resp.protocolOp, LDAP_BindResponse):
+                    if self.verb:
+                        print("%s bind failed !" % self.mech.name)
+                        resp.show()
+                    return
+                val = resp.protocolOp.serverSaslCredsData
+                if not val:
+                    status = resp.protocolOp.resultCode
+                    break
+                self.sspcontext, token, status = self.ssp.GSS_Init_sec_context(
+                    self.sspcontext, GSSAPI_BLOB(val)
+                )
+        if status != GSS_S_COMPLETE:
+            raise RuntimeError("%s bind returned %s !" % (self.mech.name, status))
+        elif self.mech == LDAP_BIND_MECHS.SASL_GSSAPI:
+            # GSSAPI has 2 extra exchanges
+            # https://datatracker.ietf.org/doc/html/rfc2222#section-7.2.1
+            resp = self.sr1(
+                LDAP_BindRequest(
+                    bind_name=ASN1_STRING(b""),
+                    authentication=LDAP_Authentication_SaslCredentials(
+                        mechanism=ASN1_STRING(self.mech.value),
+                        credentials=None,
+                    ),
+                )
+            )
+            # Parse server-supported layers
+            saslOptions = GSSAPI_BLOB_SIGNATURE(resp.protocolOp.serverSaslCredsData)
+            saslOptions.show()
+            saslOptions = LDAP_SASL_GSSAPI_SsfCap(
+                self.ssp.GSS_Unwrap(self.sspcontext, b"", saslOptions)
+            )
+            if self.sign and not saslOptions.supported_security_layers.INTEGRITY:
+                raise RuntimeError("GSSAPI SASL failed to negotiate INTEGRITY !")
+            if (
+                self.encrypt
+                and not saslOptions.supported_security_layers.CONFIDENTIALITY
+            ):
+                raise RuntimeError("GSSAPI SASL failed to negotiate CONFIDENTIALITY !")
+            # Announce client-supported layers
+            saslOptions = LDAP_SASL_GSSAPI_SsfCap(
+                supported_security_layers=(
+                    "NONE"
+                    + ("+INTEGRITY" if self.sign else "")
+                    + ("+CONFIDENTIALITY" if self.encrypt else "")
+                ),
+                max_output_token_size=0xA00000,
+            )
+            resp = self.sr1(
+                LDAP_BindRequest(
+                    bind_name=ASN1_STRING(b""),
+                    authentication=LDAP_Authentication_SaslCredentials(
+                        mechanism=ASN1_STRING(self.mech.value),
+                        credentials=self.ssp.GSS_Wrap(
+                            self.sspcontext, bytes(saslOptions), False
+                        )[1],
+                    ),
+                )
+            )
+            if resp.protocolOp.resultCode != 0:
+                resp.show()
+                raise RuntimeError(
+                    "GSSAPI SASL failed to negotiate client security flags !"
+                )
+        if self.verb:
+            print("%s bind succeeded !" % self.mech.name)
+
+    def close(self):
+        if self.verb:
+            print("X Connection closed\n")
+        self.sock.close()
```

### Comparing `scapy-2.5.0rc3/scapy/layers/ntp.py` & `scapy-2.6.0rc1/scapy/layers/ntp.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,32 +4,50 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 NTP (Network Time Protocol).
 References : RFC 5905, RC 1305, ntpd source code
 """
 
-from __future__ import absolute_import
 import struct
 import time
 import datetime
 
 from scapy.packet import Packet, bind_layers
-from scapy.fields import BitField, BitEnumField, ByteField, ByteEnumField, \
-    XByteField, SignedByteField, FlagsField, ShortField, LEShortField, \
-    IntField, LEIntField, FixedPointField, IPField, StrField, \
-    StrFixedLenField, StrFixedLenEnumField, XStrFixedLenField, PacketField, \
-    PacketLenField, PacketListField, FieldListField, ConditionalField, \
-    PadField
-from scapy.layers.inet6 import IP6Field
+from scapy.fields import (
+    BitEnumField,
+    BitField,
+    ByteEnumField,
+    ByteField,
+    ConditionalField,
+    FieldListField,
+    FixedPointField,
+    FlagsField,
+    IP6Field,
+    IPField,
+    IntField,
+    LEIntField,
+    LEShortField,
+    MayEnd,
+    PacketField,
+    PacketLenField,
+    PacketListField,
+    PadField,
+    ShortField,
+    SignedByteField,
+    StrField,
+    StrFixedLenEnumField,
+    StrFixedLenField,
+    XByteField,
+    XStrFixedLenField,
+)
 from scapy.layers.inet import UDP
 from scapy.utils import lhex
 from scapy.compat import orb
 from scapy.config import conf
-import scapy.libs.six as six
 
 
 #############################################################################
 # Constants
 #############################################################################
 
 _NTP_AUTH_MD5_MIN_SIZE = 68
@@ -74,22 +92,22 @@
         FixedPointField.__init__(self, name, default, 64, 32)
 
     def i2repr(self, pkt, val):
         if val is None:
             return "--"
         val = self.i2h(pkt, val)
         if val < _NTP_BASETIME:
-            return val
+            return str(val)
         return time.strftime(
             "%a, %d %b %Y %H:%M:%S +0000",
             time.gmtime(int(val - _NTP_BASETIME))
         )
 
     def any2i(self, pkt, val):
-        if isinstance(val, six.string_types):
+        if isinstance(val, str):
             val = int(time.mktime(time.strptime(val))) + _NTP_BASETIME
         elif isinstance(val, datetime.datetime):
             val = int(val.strftime("%s")) + _NTP_BASETIME
         return FixedPointField.any2i(self, pkt, val)
 
     def i2m(self, pkt, val):
         if val is None:
@@ -206,15 +224,17 @@
         if length < _NTP_PACKET_MIN_SIZE:
             err = " ({}".format(length) + " is < _NTP_PACKET_MIN_SIZE "
             err += "({})).".format(_NTP_PACKET_MIN_SIZE)
             raise _NTPInvalidDataException(err)
         return s
 
     def mysummary(self):
-        return self.sprintf("NTP v%ir,NTP.version%, %NTP.mode%")
+        return self.sprintf(
+            "NTP v%ir,{0}.version%, %{0}.mode%".format(self.__class__.__name__)
+        )
 
 
 class _NTPAuthenticatorPaddingField(StrField):
     """
     StrField handling the padding that may be found before the
     "authenticator" field.
     """
@@ -424,16 +444,16 @@
     name = "NTPHeader"
     match_subclass = True
     fields_desc = [
         BitEnumField("leap", 0, 2, _leap_indicator),
         BitField("version", 4, 3),
         BitEnumField("mode", 3, 3, _ntp_modes),
         BitField("stratum", 2, 8),
-        BitField("poll", 0xa, 8),
-        BitField("precision", 0, 8),
+        SignedByteField("poll", 0xa),
+        SignedByteField("precision", 0),
         FixedPointField("delay", 0, size=32, frac_bits=16),
         FixedPointField("dispersion", 0, size=32, frac_bits=16),
         ConditionalField(IPField("id", "127.0.0.1"), lambda p: p.stratum > 1),
         ConditionalField(
             StrFixedLenEnumField(
                 "ref_id",
                 "",
@@ -737,14 +757,16 @@
 
     """
     PacketField handling the "data" field of NTP control messages.
     """
 
     def m2i(self, pkt, m):
         ret = None
+        if not m:
+            return ret
 
         # op_code == CTL_OP_READSTAT
         if pkt.op_code == 1:
             if pkt.association_id == 0:
                 # Data contains association ID and peer status
                 ret = NTPPeerStatusDataPacket(m)
             else:
@@ -792,28 +814,28 @@
     #
 
     name = "Control message"
     match_subclass = True
     fields_desc = [
         BitField("zeros", 0, 2),
         BitField("version", 2, 3),
-        BitField("mode", 6, 3),
+        BitEnumField("mode", 6, 3, _ntp_modes),
         BitField("response", 0, 1),
         BitField("err", 0, 1),
         BitField("more", 0, 1),
         BitEnumField("op_code", 0, 5, _op_codes),
         ShortField("sequence", 0),
         ConditionalField(NTPControlStatusField(
             "status_word", "", Packet), lambda p: p.response == 1),
         ConditionalField(ShortField("status", 0), lambda p: p.response == 0),
         ShortField("association_id", 0),
         ShortField("offset", 0),
         ShortField("count", None),
-        NTPControlDataPacketLenField(
-            "data", "", Packet, length_from=lambda p: p.count),
+        MayEnd(NTPControlDataPacketLenField(
+               "data", "", Packet, length_from=lambda p: p.count)),
         PacketField("authenticator", "", NTPAuthenticator),
     ]
 
     def post_build(self, p, pay):
         if self.count is None:
             length = 0
             if self.data:
@@ -1094,15 +1116,15 @@
 
     name = "info_sys"
     fields_desc = [
         IPField("peer", "0.0.0.0"),
         ByteField("peer_mode", 0),
         ByteField("leap", 0),
         ByteField("stratum", 0),
-        ByteField("precision", 0),
+        SignedByteField("precision", 0),
         FixedPointField("rootdelay", 0, size=32, frac_bits=16),
         FixedPointField("rootdispersion", 0, size=32, frac_bits=16),
         IPField("refid", 0),
         TimeStampField("reftime", 0),
         IntField("poll", 0),
         FlagsField("flags", 0, 8, _sys_info_flags),
         ByteField("unused1", 0),
@@ -1152,15 +1174,16 @@
         IntField("findpeer_calls", 0),
         IntField("allocations", 0),
         IntField("demobilizations", 0),
         FieldListField(
             "hashcount",
             [0.0 for i in range(0, _NTP_HASH_SIZE)],
             ByteField("", 0),
-            count_from=lambda p: _NTP_HASH_SIZE
+            count_from=lambda p: _NTP_HASH_SIZE,
+            max_count=_NTP_HASH_SIZE
         )
     ]
 
 
 class NTPInfoIOStats(Packet):
     """
     I/O statistics.
@@ -1774,15 +1797,15 @@
 
     name = "Private (mode 7)"
     match_subclass = True
     fields_desc = [
         BitField("response", 0, 1),
         BitField("more", 0, 1),
         BitField("version", 2, 3),
-        BitField("mode", 0, 3),
+        BitEnumField("mode", 7, 3, _ntp_modes),
         BitField("auth", 0, 1),
         BitField("seq", 0, 7),
         ByteEnumField("implementation", 0, _implementations),
         ByteEnumField("request_code", 0, _request_codes),
         BitEnumField("err", 0, 4, _ntpd_private_errors),
         BitField("nb_items", 0, 12),
         BitField("mbz", 0, 4),
```

### Comparing `scapy-2.5.0rc3/scapy/layers/pflog.py` & `scapy-2.6.0rc1/scapy/layers/pflog.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/ppp.py` & `scapy-2.6.0rc1/scapy/layers/ppp.py`

 * *Files 1% similar despite different names*

```diff
@@ -34,15 +34,14 @@
     ShortEnumField,
     ShortField,
     StrLenField,
     XByteField,
     XShortField,
     XStrLenField,
 )
-from scapy.libs import six
 
 
 class PPPoE(Packet):
     name = "PPP over Ethernet"
     fields_desc = [BitField("version", 1, 4),
                    BitField("type", 1, 4),
                    ByteEnumField("code", 0, {0: "Session"}),
@@ -289,32 +288,46 @@
 
 class _PPPProtoField(EnumField):
     """
     A field that can be either Byte or Short, depending on the PPP RFC.
 
     See RFC 1661 section 2
     <https://tools.ietf.org/html/rfc1661#section-2>
+
+    The generated proto field is two bytes when not specified, or when specified
+    as an integer or a string:
+      PPP()
+      PPP(proto=0x21)
+      PPP(proto="Internet Protocol version 4")
+    To explicitly forge a one byte proto field, use the bytes representation:
+      PPP(proto=b'\x21')
     """
     def getfield(self, pkt, s):
         if ord(s[:1]) & 0x01:
             self.fmt = "!B"
             self.sz = 1
         else:
             self.fmt = "!H"
             self.sz = 2
         self.struct = struct.Struct(self.fmt)
         return super(_PPPProtoField, self).getfield(pkt, s)
 
     def addfield(self, pkt, s, val):
-        if val < 0x100:
-            self.fmt = "!B"
-            self.sz = 1
+        if isinstance(val, bytes):
+            if len(val) == 1:
+                fmt, sz = "!B", 1
+            elif len(val) == 2:
+                fmt, sz = "!H", 2
+            else:
+                raise TypeError('Invalid length for PPP proto')
+            val = struct.Struct(fmt).unpack(val)[0]
         else:
-            self.fmt = "!H"
-            self.sz = 2
+            fmt, sz = "!H", 2
+        self.fmt = fmt
+        self.sz = sz
         self.struct = struct.Struct(self.fmt)
         return super(_PPPProtoField, self).addfield(pkt, s, val)
 
 
 class PPP(Packet):
     name = "PPP Link Layer"
     fields_desc = [_PPPProtoField("proto", 0x0021, _PPP_PROTOCOLS)]
@@ -749,15 +762,15 @@
     @classmethod
     def dispatch_hook(cls, _pkt=None, *_, **kargs):
         code = None
         if _pkt:
             code = orb(_pkt[0])
         elif "code" in kargs:
             code = kargs["code"]
-            if isinstance(code, six.string_types):
+            if isinstance(code, str):
                 code = cls.fields_desc[0].s2i[code]
 
         if code == 1:
             return PPP_PAP_Request
         elif code in [2, 3]:
             return PPP_PAP_Response
         return cls
@@ -830,15 +843,15 @@
     @classmethod
     def dispatch_hook(cls, _pkt=None, *_, **kargs):
         code = None
         if _pkt:
             code = orb(_pkt[0])
         elif "code" in kargs:
             code = kargs["code"]
-            if isinstance(code, six.string_types):
+            if isinstance(code, str):
                 code = cls.fields_desc[0].s2i[code]
 
         if code in (1, 2):
             return PPP_CHAP_ChallengeResponse
         return cls
 
     def extract_padding(self, pay):
```

### Comparing `scapy-2.5.0rc3/scapy/layers/pptp.py` & `scapy-2.6.0rc1/scapy/layers/pptp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/radius.py` & `scapy-2.6.0rc1/scapy/layers/radius.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/rip.py` & `scapy-2.6.0rc1/scapy/layers/rip.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/rtp.py` & `scapy-2.6.0rc1/scapy/layers/rtp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/sctp.py` & `scapy-2.6.0rc1/scapy/layers/sctp.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,15 +4,14 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 # Copyright (C) 6WIND <olivier.matz@6wind.com>
 
 """
 SCTP (Stream Control Transmission Protocol).
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.compat import orb, raw
 from scapy.volatile import RandBin
 from scapy.config import conf
 from scapy.packet import Packet, bind_layers
 from scapy.fields import (
@@ -156,16 +155,21 @@
     7: "SCTPChunkShutdown",
     8: "SCTPChunkShutdownAck",
     9: "SCTPChunkError",
     10: "SCTPChunkCookieEcho",
     11: "SCTPChunkCookieAck",
     14: "SCTPChunkShutdownComplete",
     15: "SCTPChunkAuthentication",
+    64: "SCTPChunkIData",
+    130: "SCTPChunkReConfig",
+    132: "SCTPChunkPad",
     0x80: "SCTPChunkAddressConfAck",
+    192: "SCTPChunkForwardTSN",
     0xc1: "SCTPChunkAddressConf",
+    194: "SCTPChunkIForwardTSN",
 }
 
 sctpchunktypes = {
     0: "data",
     1: "init",
     2: "init-ack",
     3: "sack",
@@ -175,27 +179,38 @@
     7: "shutdown",
     8: "shutdown-ack",
     9: "error",
     10: "cookie-echo",
     11: "cookie-ack",
     14: "shutdown-complete",
     15: "authentication",
+    64: "i-data",
+    130: "re-config",
+    132: "pad",
     0x80: "address-configuration-ack",
+    192: "forward-tsn",
     0xc1: "address-configuration",
+    194: "i-forward-tsn",
 }
 
 sctpchunkparamtypescls = {
     1: "SCTPChunkParamHeartbeatInfo",
     5: "SCTPChunkParamIPv4Addr",
     6: "SCTPChunkParamIPv6Addr",
     7: "SCTPChunkParamStateCookie",
     8: "SCTPChunkParamUnrocognizedParam",
     9: "SCTPChunkParamCookiePreservative",
     11: "SCTPChunkParamHostname",
     12: "SCTPChunkParamSupportedAddrTypes",
+    13: "SCTPChunkParamOutgoingSSNResetRequest",
+    14: "SCTPChunkParamIncomingSSNResetRequest",
+    15: "SCTPChunkParamSSNTSNResetRequest",
+    16: "SCTPChunkParamReConfigurationResponse",
+    17: "SCTPChunkParamAddOutgoingStreamRequest",
+    18: "SCTPChunkParamAddIncomingStreamRequest",
     0x8000: "SCTPChunkParamECNCapable",
     0x8002: "SCTPChunkParamRandom",
     0x8003: "SCTPChunkParamChunkList",
     0x8004: "SCTPChunkParamRequestedHMACFunctions",
     0x8008: "SCTPChunkParamSupportedExtensions",
     0xc000: "SCTPChunkParamFwdTSN",
     0xc001: "SCTPChunkParamAddIPAddr",
@@ -211,14 +226,20 @@
     5: "IPv4",
     6: "IPv6",
     7: "state-cookie",
     8: "unrecognized-param",
     9: "cookie-preservative",
     11: "hostname",
     12: "addrtypes",
+    13: "out-ssn-reset-req",
+    14: "in-ssn-reset-req",
+    15: "ssn-tsn-reset-req",
+    16: "re-configuration-response",
+    17: "add-outgoing-stream-req",
+    18: "add-incoming-stream-req",
     0x8000: "ecn-capable",
     0x8002: "random",
     0x8003: "chunk-list",
     0x8004: "requested-HMAC-functions",
     0x8008: "supported-extensions",
     0xc000: "fwd-tsn-supported",
     0xc001: "add-IP",
@@ -281,14 +302,25 @@
     def mysummary(self):
         return Packet.mysummary(self)
 
 
 # SCTP Chunk variable params
 
 
+resultcode = {
+    0: "Success - Nothing to do",
+    1: "Success - Performed",
+    2: "Denied",
+    3: "Error - Wrong SSN",
+    4: "Error - Request already in progress",
+    5: "Error - Bad Sequence Number",
+    6: "In Progress"
+}
+
+
 class ChunkParamField(PacketListField):
     def __init__(self, name, default, count_from=None, length_from=None):
         PacketListField.__init__(self, name, default, conf.raw_layer, count_from=count_from, length_from=length_from)  # noqa: E501
 
     def m2i(self, p, m):
         cls = conf.raw_layer
         if len(m) >= 4:
@@ -364,14 +396,70 @@
                                  adjust=lambda pkt, x:x + 4),
                    PadField(FieldListField("addr_type_list", ["IPv4"],
                                            ShortEnumField("addr_type", 5, sctpchunkparamtypes),  # noqa: E501
                                            length_from=lambda pkt: pkt.len - 4),  # noqa: E501
                             4, padwith=b"\x00"), ]
 
 
+class SCTPChunkParamOutSSNResetReq(_SCTPChunkParam, Packet):
+    fields_desc = [ShortEnumField("type", 13, sctpchunkparamtypes),
+                   FieldLenField("len", None, length_of="stream_num_list",
+                                 adjust=lambda pkt, x:x + 16),
+                   XIntField("re_conf_req_seq_num", None),
+                   XIntField("re_conf_res_seq_num", None),
+                   XIntField("tsn", None),
+                   PadField(FieldListField("stream_num_list", [],
+                                           XShortField("stream_num", None),
+                                           length_from=lambda pkt: pkt.len - 16),
+                            4, padwith=b"\x00"),
+                   ]
+
+
+class SCTPChunkParamInSSNResetReq(_SCTPChunkParam, Packet):
+    fields_desc = [ShortEnumField("type", 14, sctpchunkparamtypes),
+                   FieldLenField("len", None, length_of="stream_num_list",
+                                 adjust=lambda pkt, x:x + 8),
+                   XIntField("re_conf_req_seq_num", None),
+                   PadField(FieldListField("stream_num_list", [],
+                                           XShortField("stream_num", None),
+                                           length_from=lambda pkt: pkt.len - 8),
+                            4, padwith=b"\x00"),
+                   ]
+
+
+class SCTPChunkParamSSNTSNResetReq(_SCTPChunkParam, Packet):
+    fields_desc = [ShortEnumField("type", 15, sctpchunkparamtypes),
+                   XShortField("len", 8),
+                   XIntField("re_conf_req_seq_num", None),
+                   ]
+
+
+class SCTPChunkParamReConfigRes(_SCTPChunkParam, Packet):
+    fields_desc = [ShortEnumField("type", 16, sctpchunkparamtypes),
+                   XShortField("len", 12),
+                   XIntField("re_conf_res_seq_num", None),
+                   IntEnumField("result", None, resultcode),
+                   XIntField("sender_next_tsn", None),
+                   XIntField("receiver_next_tsn", None),
+                   ]
+
+
+class SCTPChunkParamAddOutgoingStreamReq(_SCTPChunkParam, Packet):
+    fields_desc = [ShortEnumField("type", 17, sctpchunkparamtypes),
+                   XShortField("len", 12),
+                   XIntField("re_conf_req_seq_num", None),
+                   XShortField("num_new_stream", None),
+                   XShortField("reserved", None),
+                   ]
+
+
+class SCTPChunkParamAddIncomingStreamReq(SCTPChunkParamAddOutgoingStreamReq):
+    type = 18
+
+
 class SCTPChunkParamECNCapable(_SCTPChunkParam, Packet):
     fields_desc = [ShortEnumField("type", 0x8000, sctpchunkparamtypes),
                    ShortField("len", 4), ]
 
 
 class SCTPChunkParamRandom(_SCTPChunkParam, Packet):
     fields_desc = [ShortEnumField("type", 0x8002, sctpchunkparamtypes),
@@ -550,14 +638,71 @@
                    XShortField("stream_seq", None),
                    IntEnumField("proto_id", None, SCTP_PAYLOAD_PROTOCOL_INDENTIFIERS),  # noqa: E501
                    PadField(StrLenField("data", None, length_from=lambda pkt: pkt.len - 16),  # noqa: E501
                             4, padwith=b"\x00"),
                    ]
 
 
+class SCTPChunkIData(_SCTPChunkGuessPayload, Packet):
+    fields_desc = [ByteEnumField("type", 64, sctpchunktypes),
+                   BitField("reserved", None, 4),
+                   BitField("delay_sack", 0, 1),    # immediate bit
+                   BitField("unordered", 0, 1),
+                   BitField("beginning", 0, 1),
+                   BitField("ending", 0, 1),
+                   FieldLenField("len", None, length_of="data",
+                                 adjust=lambda pkt, x:x + 20),
+                   XIntField("tsn", None),
+                   XShortField("stream_id", None),
+                   XShortField("reserved_16", None),
+                   XIntField("message_id", None),
+                   MultipleTypeField(
+                       [
+                           (IntEnumField("ppid_fsn", None,
+                                         SCTP_PAYLOAD_PROTOCOL_INDENTIFIERS),
+                            lambda pkt: pkt.beginning == 1),
+                           (XIntField("ppid_fsn", None),
+                            lambda pkt: pkt.beginning == 0),
+                       ],
+                       XIntField("ppid_fsn", None)),
+                   PadField(StrLenField("data", None,
+                                        length_from=lambda pkt: pkt.len - 20),
+                            4, padwith=b"\x00"),
+                   ]
+
+
+class SCTPForwardSkip(_SCTPChunkParam, Packet):
+    fields_desc = [ShortField("stream_id", None),
+                   ShortField("stream_seq", None)
+                   ]
+
+
+class SCTPChunkForwardTSN(_SCTPChunkGuessPayload, Packet):
+    fields_desc = [ByteEnumField("type", 192, sctpchunktypes),
+                   XByteField("flags", None),
+                   FieldLenField("len", None, length_of="skips",
+                                 adjust=lambda pkt, x:x + 8),
+                   IntField("new_tsn", None),
+                   ChunkParamField("skips", None,
+                                   length_from=lambda pkt: pkt.len - 8)
+                   ]
+
+
+class SCTPIForwardSkip(_SCTPChunkParam, Packet):
+    fields_desc = [ShortField("stream_id", None),
+                   BitField("reserved", None, 15),
+                   BitField("unordered", None, 1),
+                   IntField("message_id", None)
+                   ]
+
+
+class SCTPChunkIForwardTSN(SCTPChunkForwardTSN):
+    type = 194
+
+
 class SCTPChunkInit(_SCTPChunkGuessPayload, Packet):
     fields_desc = [ByteEnumField("type", 1, sctpchunktypes),
                    XByteField("flags", None),
                    FieldLenField("len", None, length_of="params", adjust=lambda pkt, x:x + 20),  # noqa: E501
                    XIntField("init_tag", None),
                    IntField("a_rwnd", None),
                    ShortField("n_out_streams", None),
@@ -697,14 +842,34 @@
                    FieldLenField("len", None, length_of="params",
                                  adjust=lambda pkt, x:x + 8),
                    IntField("seq", 0),
                    ChunkParamField("params", None, length_from=lambda pkt:pkt.len - 8),  # noqa: E501
                    ]
 
 
+class SCTPChunkReConfig(_SCTPChunkGuessPayload, Packet):
+    fields_desc = [ByteEnumField("type", 130, sctpchunktypes),
+                   XByteField("flags", None),
+                   FieldLenField("len", None, length_of="params",
+                                 adjust=lambda pkt, x:x + 4),
+                   ChunkParamField("params", None, length_from=lambda pkt: pkt.len - 4),
+                   ]
+
+
+class SCTPChunkPad(_SCTPChunkGuessPayload, Packet):
+    fields_desc = [ByteEnumField("type", 132, sctpchunktypes),
+                   XByteField("flags", None),
+                   FieldLenField("len", None, length_of="padding",
+                                 adjust=lambda pkt, x:x + 8),
+                   PadField(StrLenField("padding", None,
+                                        length_from=lambda pkt: pkt.len - 8),
+                            4, padwith=b"\x00")
+                   ]
+
+
 class SCTPChunkAddressConfAck(SCTPChunkAddressConf):
     type = 0x80
 
 
 bind_layers(IP, SCTP, proto=IPPROTO_SCTP)
 bind_layers(IPerror, SCTPerror, proto=IPPROTO_SCTP)
 bind_layers(IPv6, SCTP, nh=IPPROTO_SCTP)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/sixlowpan.py` & `scapy-2.6.0rc1/scapy/layers/sixlowpan.py`

 * *Files 1% similar despite different names*

```diff
@@ -54,15 +54,15 @@
 from scapy.compat import chb, orb, raw
 from scapy.data import ETHER_TYPES
 
 from scapy.packet import Packet, bind_layers, bind_top_down
 from scapy.fields import (
     BitEnumField,
     BitField,
-    BitFixedLenField,
+    BitLenField,
     BitScalingField,
     ByteEnumField,
     ByteField,
     ConditionalField,
     FieldLenField,
     MultipleTypeField,
     PacketField,
@@ -278,15 +278,15 @@
             lambda pkt: pkt.nh == 1 and pkt.hc2 and not pkt.hc2Field.lc
         ),
         ConditionalField(
             XBitField("udpChecksum", 0, 16),
             lambda pkt: pkt.nh == 1 and pkt.hc2
         ),
         # Out of spec
-        BitFixedLenField("pad", 0, _get_hc1_pad)
+        BitLenField("pad", 0, _get_hc1_pad)
     ]
 
     def post_dissect(self, data):
         # uncompress payload
         packet = IPv6()
         packet.version = IPHC_DEFAULT_VERSION
         packet.tc = self.traffic_class
```

### Comparing `scapy-2.5.0rc3/scapy/layers/skinny.py` & `scapy-2.6.0rc1/scapy/layers/skinny.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/snmp.py` & `scapy-2.6.0rc1/scapy/layers/snmp.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,20 +3,19 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 SNMP (Simple Network Management Protocol).
 """
 
-from __future__ import print_function
 from scapy.packet import bind_layers, bind_bottom_up
 from scapy.asn1packet import ASN1_Packet
 from scapy.asn1fields import ASN1F_INTEGER, ASN1F_IPADDRESS, ASN1F_OID, \
     ASN1F_SEQUENCE, ASN1F_SEQUENCE_OF, ASN1F_STRING, ASN1F_TIME_TICKS, \
-    ASN1F_enum_INTEGER, ASN1F_field, ASN1F_CHOICE
+    ASN1F_enum_INTEGER, ASN1F_field, ASN1F_CHOICE, ASN1F_optional, ASN1F_NULL
 from scapy.asn1.asn1 import ASN1_Class_UNIVERSAL, ASN1_Codecs, ASN1_NULL, \
     ASN1_SEQUENCE
 from scapy.asn1.ber import BERcodec_SEQUENCE
 from scapy.sendrecv import sr1
 from scapy.volatile import RandShort, IntAutoTime
 from scapy.layers.inet import UDP, IP, ICMP
 
@@ -174,17 +173,25 @@
                    5: "egp_neigh_loss",
                    6: "enterprise_specific",
                    }
 
 
 class SNMPvarbind(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
-    ASN1_root = ASN1F_SEQUENCE(ASN1F_OID("oid", "1.3"),
-                               ASN1F_field("value", ASN1_NULL(0))
-                               )
+    ASN1_root = ASN1F_SEQUENCE(
+        ASN1F_OID("oid", "1.3"),
+        ASN1F_optional(
+            ASN1F_field("value", ASN1_NULL(0))
+        ),
+
+        # exceptions in responses
+        ASN1F_optional(ASN1F_NULL("noSuchObject", None, implicit_tag=0x80)),
+        ASN1F_optional(ASN1F_NULL("noSuchInstance", None, implicit_tag=0x81)),
+        ASN1F_optional(ASN1F_NULL("endOfMibView", None, implicit_tag=0x82)),
+    )
 
 
 class SNMPget(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SNMP_PDU_GET(ASN1F_INTEGER("id", 0),
                                    ASN1F_enum_INTEGER("error", 0, SNMP_error),
                                    ASN1F_INTEGER("error_index", 0),
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tftp.py` & `scapy-2.6.0rc1/scapy/layers/tftp.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 TFTP (Trivial File Transfer Protocol).
 """
 
-from __future__ import absolute_import
 import os
 import random
 
 from scapy.packet import Packet, bind_layers, split_bottom_up, bind_bottom_up
 from scapy.fields import PacketListField, ShortEnumField, ShortField, \
     StrNullField
 from scapy.automaton import ATMT, Automaton
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/__init__.py` & `scapy-2.6.0rc1/scapy/layers/tls/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -50,14 +50,16 @@
 
     - Reading a SSLv2 handshake between s_client and s_server, without PFS.
 
     - Test our TLS server against s_client with different cipher suites.
 
     - Test our TLS client against our TLS server (s_server is unscriptable).
 
+    - Test our TLS client against python's SSL Socket wrapper (for TLS 1.3)
+
 
 TODO list (may it be carved away by good souls):
 
     - Features to add (or wait for) in the cryptography library:
 
         - the compressed EC point format.
 
@@ -72,24 +74,19 @@
 
         - Add some examples which illustrate how the automatons could be used.
           Typically, we could showcase this with Heartbleed.
 
         - Allow the server to store both one RSA key and one ECDSA key, and
           select the right one to use according to the ClientHello suites.
 
-        - Find a way to shutdown the automatons sockets properly without
-          simultaneously breaking the unit tests.
-
 
     - Miscellaneous:
 
         - Define several Certificate Transparency objects.
 
-        - Add the extended master secret and encrypt-then-mac logic.
-
         - Mostly unused features : DSS, fixed DH, SRP, char2 curves...
 """
 
 from scapy.config import conf
 
 if not conf.crypto_valid:
     import logging
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/all.py` & `scapy-2.6.0rc1/scapy/layers/tls/all.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/automaton.py` & `scapy-2.6.0rc1/scapy/layers/tls/automaton.py`

 * *Files 4% similar despite different names*

```diff
@@ -60,14 +60,19 @@
 
     However, note that the flights from the opposite side may be spread wildly
     across TLS records and TCP packets. This is why we use a 'get_next_msg'
     method for feeding a list of received messages, 'buffer_in'. Raw data
     which has not yet been interpreted as a TLS record is kept in 'remain_in'.
     """
 
+    def __init__(self, *args, **kwargs):
+        kwargs["ll"] = lambda *args, **kwargs: None
+        kwargs["recvsock"] = lambda *args, **kwargs: None
+        super(_TLSAutomaton, self).__init__(*args, **kwargs)
+
     def parse_args(self, mycert=None, mykey=None, **kargs):
 
         self.verbose = kargs.pop("verbose", True)
 
         super(_TLSAutomaton, self).parse_args(**kargs)
 
         self.socket = None
@@ -202,24 +207,31 @@
         If the next message to be processed has type 'pkt_cls', raise 'state'.
         If there is no message waiting to be processed, we try to get one with
         the default 'get_next_msg' parameters.
         """
         # Maybe we already parsed the expected packet, maybe not.
         if get_next_msg:
             self.get_next_msg()
-        from scapy.layers.tls.handshake import TLSClientHello
         if (not self.buffer_in or
-                (not isinstance(self.buffer_in[0], pkt_cls) and
-                 not (isinstance(self.buffer_in[0], TLSClientHello) and
-                 self.cur_session.advertised_tls_version == 0x0304))):
+                not isinstance(self.buffer_in[0], pkt_cls)):
             return
         self.cur_pkt = self.buffer_in[0]
         self.buffer_in = self.buffer_in[1:]
         raise state()
 
+    def in_handshake(self, pkt_cls):
+        """
+        Return True if the pkt_cls was present during the handshake.
+        This is used to detect whether Certificates were requested, etc.
+        """
+        return any(
+            isinstance(m, pkt_cls)
+            for m in self.cur_session.handshake_messages_parsed
+        )
+
     def add_record(self, is_sslv2=None, is_tls13=None, is_tls12=None):
         """
         Add a new TLS or SSLv2 or TLS 1.3 record to the packets buffered out.
         """
         if is_sslv2 is None and is_tls13 is None and is_tls12 is None:
             v = (self.cur_session.tls_version or
                  self.cur_session.advertised_tls_version)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/automaton_cli.py` & `scapy-2.6.0rc1/scapy/layers/tls/automaton_cli.py`

 * *Files 2% similar despite different names*

```diff
@@ -26,37 +26,42 @@
     while True:
         a.recv()
 
 You can also use the io with a TCPSession, e.g. to get an HTTPS answer::
 
     from scapy.all import *
     from scapy.layers.http import *
-    from scapy.layers.tls import *
+    from scapy.layers.tls.automaton_cli import *
     a = TLSClientAutomaton.tlslink(HTTP, server="www.google.com", dport=443)
     pkt = a.sr1(HTTP()/HTTPRequest(), session=TCPSession(app=True),
                 timeout=2)
 """
 
-from __future__ import print_function
 import socket
 import binascii
 import struct
 import time
 
 from scapy.config import conf
 from scapy.utils import randstring, repr_hex
 from scapy.automaton import ATMT, select_objects
 from scapy.error import warning
 from scapy.layers.tls.automaton import _TLSAutomaton
 from scapy.layers.tls.basefields import _tls_version, _tls_version_options
 from scapy.layers.tls.session import tlsSession
-from scapy.layers.tls.extensions import TLS_Ext_SupportedGroups, \
-    TLS_Ext_SupportedVersion_CH, TLS_Ext_SignatureAlgorithms, \
-    TLS_Ext_SupportedVersion_SH, TLS_Ext_PSKKeyExchangeModes, \
-    TLS_Ext_ServerName, ServerName
+from scapy.layers.tls.extensions import (
+    ServerName,
+    TLS_Ext_PSKKeyExchangeModes,
+    TLS_Ext_PostHandshakeAuth,
+    TLS_Ext_ServerName,
+    TLS_Ext_SignatureAlgorithms,
+    TLS_Ext_SupportedGroups,
+    TLS_Ext_SupportedVersion_CH,
+    TLS_Ext_SupportedVersion_SH,
+)
 from scapy.layers.tls.handshake import TLSCertificate, TLSCertificateRequest, \
     TLSCertificateVerify, TLSClientHello, TLSClientKeyExchange, \
     TLSEncryptedExtensions, TLSFinished, TLSServerHello, TLSServerHelloDone, \
     TLSServerKeyExchange, TLS13Certificate, TLS13ClientHello,  \
     TLS13ServerHello, TLS13HelloRetryRequest, TLS13CertificateRequest, \
     _ASN1CertAndExt, TLS13KeyUpdate, TLS13NewSessionTicket
 from scapy.layers.tls.handshake_sslv2 import SSLv2ClientHello, \
@@ -68,15 +73,14 @@
     TLS_Ext_PreSharedKey_CH
 from scapy.layers.tls.record import TLSAlert, TLSChangeCipherSpec, \
     TLSApplicationData
 from scapy.layers.tls.crypto.suites import _tls_cipher_suites, \
     _tls_cipher_suites_cls
 from scapy.layers.tls.crypto.groups import _tls_named_groups
 from scapy.layers.tls.crypto.hkdf import TLS13_HKDF
-from scapy.libs import six
 from scapy.packet import Raw
 from scapy.compat import bytes_encode
 
 
 class TLSClientAutomaton(_TLSAutomaton):
     """
     A simple TLS test client automaton. Try to overload some states or
@@ -85,16 +89,16 @@
     Rather than with an interruption, the best way to stop this client is by
     typing 'quit'. This won't be a message sent to the server.
 
     :param server: the server IP or hostname. defaults to 127.0.0.1
     :param dport: the server port. defaults to 4433
     :param server_name: the SNI to use. It does not need to be set
     :param mycert:
-    :param mykey: may be provided as filenames. They will be used in
-        the handshake, should the server ask for client authentication.
+    :param mykey: may be provided as filenames. They will be used in the (or post)
+        handshake, should the server ask for client authentication.
     :param client_hello: may hold a TLSClientHello or SSLv2ClientHello to be
         sent to the server. This is particularly useful for extensions
         tweaking. If not set, a default is populated accordingly.
     :param version: is a quicker way to advertise a protocol version ("sslv2",
         "tls1", "tls12", etc.) It may be overridden by the previous
         'client_hello'.
     :param data: is a list of raw data to be sent to the server once the
@@ -108,51 +112,59 @@
                    resumption_master_secret=None,
                    session_ticket_file_in=None,
                    session_ticket_file_out=None,
                    psk=None, psk_mode=None,
                    data=None,
                    ciphersuite=None,
                    curve=None,
+                   supported_groups=None,
                    **kargs):
 
         super(TLSClientAutomaton, self).parse_args(mycert=mycert,
                                                    mykey=mykey,
                                                    **kargs)
         tmp = socket.getaddrinfo(server, dport)
         self.remote_family = tmp[0][0]
         self.remote_ip = tmp[0][4][0]
         self.remote_port = dport
         self.server_name = server_name
         self.local_ip = None
         self.local_port = None
         self.socket = None
 
-        if isinstance(client_hello, (TLSClientHello, TLS13ClientHello)):
+        if isinstance(client_hello, (SSLv2ClientHello, TLSClientHello,
+                                     TLS13ClientHello)):
             self.client_hello = client_hello
         else:
             self.client_hello = None
         self.advertised_tls_version = None
         if version:
             v = _tls_version_options.get(version, None)
             if not v:
                 self.vprint("Unrecognized TLS version option.")
             else:
                 self.advertised_tls_version = v
 
         self.linebreak = False
         if isinstance(data, bytes):
             self.data_to_send = [data]
-        elif isinstance(data, six.string_types):
+        elif isinstance(data, str):
             self.data_to_send = [bytes_encode(data)]
         elif isinstance(data, list):
             self.data_to_send = list(bytes_encode(d) for d in reversed(data))
         else:
             self.data_to_send = []
-        self.curve = None
 
+        if supported_groups is None:
+            supported_groups = ["secp256r1", "secp384r1", "x448"]
+            if conf.crypto_valid_advanced:
+                supported_groups.append("x25519")
+        self.supported_groups = supported_groups
+
+        self.curve = None
         if self.advertised_tls_version == 0x0304:
             self.ciphersuite = 0x1301
             if ciphersuite is not None:
                 cs = int(ciphersuite, 16)
                 if cs in _tls_cipher_suites.keys():
                     self.ciphersuite = cs
             if conf.crypto_valid_advanced:
@@ -162,14 +174,15 @@
                 # Or secp256r1 otherwise
                 self.curve = 23
             self.resumption_master_secret = resumption_master_secret
             self.session_ticket_file_in = session_ticket_file_in
             self.session_ticket_file_out = session_ticket_file_out
             self.tls13_psk_secret = psk
             self.tls13_psk_mode = psk_mode
+            self.tls13_doing_client_postauth = False
             if curve is not None:
                 for (group_id, ng) in _tls_named_groups.items():
                     if ng == curve:
                         if curve == "x25519":
                             if conf.crypto_valid_advanced:
                                 self.curve = group_id
                         else:
@@ -290,24 +303,24 @@
 
     @ATMT.condition(PREPARE_CLIENTFLIGHT1)
     def should_add_ClientHello(self):
         if self.client_hello:
             p = self.client_hello
         else:
             p = TLSClientHello()
-        ext = []
-        # Add TLS_Ext_SignatureAlgorithms for TLS 1.2 ClientHello
-        if self.cur_session.advertised_tls_version == 0x0303:
-            ext += [TLS_Ext_SignatureAlgorithms(sig_algs=["sha256+rsa"])]
-        # Add TLS_Ext_ServerName
-        if self.server_name:
-            ext += TLS_Ext_ServerName(
-                servernames=[ServerName(servername=self.server_name)]
-            )
-        p.ext = ext
+            ext = []
+            # Add TLS_Ext_SignatureAlgorithms for TLS 1.2 ClientHello
+            if self.cur_session.advertised_tls_version == 0x0303:
+                ext += [TLS_Ext_SignatureAlgorithms(sig_algs=["sha256+rsa"])]
+            # Add TLS_Ext_ServerName
+            if self.server_name:
+                ext += TLS_Ext_ServerName(
+                    servernames=[ServerName(servername=self.server_name)]
+                )
+            p.ext = ext
         self.add_msg(p)
         raise self.ADDED_CLIENTHELLO()
 
     @ATMT.state()
     def ADDED_CLIENTHELLO(self):
         pass
 
@@ -420,15 +433,15 @@
         self.raise_on_packet(TLSServerHelloDone,
                              self.HANDLED_SERVERHELLODONE)
 
     @ATMT.condition(HANDLED_SERVERKEYEXCHANGE, prio=1)
     def should_handle_ServerHelloDone_from_ServerKeyExchange(self):
         return self.should_handle_ServerHelloDone()
 
-    @ATMT.condition(HANDLED_CERTIFICATEREQUEST, prio=4)
+    @ATMT.condition(HANDLED_CERTIFICATEREQUEST)
     def should_handle_ServerHelloDone_from_CertificateRequest(self):
         return self.should_handle_ServerHelloDone()
 
     @ATMT.condition(HANDLED_SERVERCERTIFICATE, prio=4)
     def should_handle_ServerHelloDone_from_ServerCertificate(self):
         return self.should_handle_ServerHelloDone()
 
@@ -446,20 +459,21 @@
         If the server sent a CertificateRequest, we send a Certificate message.
         If no certificate is available, an empty Certificate message is sent:
         - this is a SHOULD in RFC 4346 (Section 7.4.6)
         - this is a MUST in RFC 5246 (Section 7.4.6)
 
         XXX We may want to add a complete chain.
         """
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if TLSCertificateRequest not in hs_msg:
+        if not self.in_handshake(TLSCertificateRequest):
             return
+
         certs = []
         if self.mycert:
             certs = [self.mycert]
+
         self.add_msg(TLSCertificate(certs=certs))
         raise self.ADDED_CLIENTCERTIFICATE()
 
     @ATMT.state()
     def ADDED_CLIENTCERTIFICATE(self):
         pass
 
@@ -484,18 +498,17 @@
         """
         XXX Section 7.4.7.1 of RFC 5246 states that the CertificateVerify
         message is only sent following a client certificate that has signing
         capability (i.e. not those containing fixed DH params).
         We should verify that before adding the message. We should also handle
         the case when the Certificate message was empty.
         """
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if (TLSCertificateRequest not in hs_msg or
-            self.mycert is None or
-                self.mykey is None):
+        if not self.in_handshake(TLSCertificateRequest):
+            return
+        if self.mycert is None or self.mykey is None:
             return
         self.add_msg(TLSCertificateVerify())
         raise self.ADDED_CERTIFICATEVERIFY()
 
     @ATMT.state()
     def ADDED_CERTIFICATEVERIFY(self):
         pass
@@ -587,15 +600,15 @@
                 fd = select_objects([self.ioin["tls"]], 0)
                 if fd:
                     self.add_record()
                     self.add_msg(TLSApplicationData(data=fd[0].recv()))
                     raise self.ADDED_CLIENTDATA()
                 raise self.WAITING_SERVERDATA()
             else:
-                data = six.moves.input().replace('\\r', '\r').replace('\\n', '\n').encode()  # noqa: E501
+                data = input().replace('\\r', '\r').replace('\\n', '\n').encode()
         else:
             data = self.data_to_send.pop()
         if data == b"quit":
             return
         # Command to skip sending
         elif data == b"wait":
             raise self.WAITING_SERVERDATA()
@@ -628,72 +641,118 @@
     @ATMT.state()
     def SENT_CLIENTDATA(self):
         raise self.WAITING_SERVERDATA()
 
     @ATMT.state()
     def WAITING_SERVERDATA(self):
         self.get_next_msg(0.3, 1)
+        if not self.buffer_in:
+            raise self.WAIT_CLIENTDATA()
         raise self.RECEIVED_SERVERDATA()
 
     @ATMT.state()
     def RECEIVED_SERVERDATA(self):
         pass
 
     @ATMT.condition(RECEIVED_SERVERDATA, prio=1)
+    def should_handle_CertificateRequest_postauth(self):
+        self.raise_on_packet(TLS13CertificateRequest,
+                             self.TLS13_RECEIVED_POST_AUTHENTICATION_REQUEST)
+
+    @ATMT.state()
+    def TLS13_RECEIVED_POST_AUTHENTICATION_REQUEST(self):
+        self.vprint("Server asked for a certificate...")
+        self.tls13_doing_client_postauth = True
+        if not self.mykey or not self.mycert:
+            self.vprint("No client certificate to send!")
+            self.vprint("Will try and send an empty Certificate message...")
+        self.add_record(is_tls13=True)
+
+    @ATMT.condition(TLS13_RECEIVED_POST_AUTHENTICATION_REQUEST, prio=1)
+    def should_send_CertificateRequest_postauth(self):
+        if self.cur_session.post_handshake_auth:
+            self.tls13_should_add_ClientCertificate()
+
+    @ATMT.condition(TLS13_RECEIVED_POST_AUTHENTICATION_REQUEST, prio=2)
+    def should_fail_CertificateRequest_postauth(self):
+        self.add_msg(TLSAlert(level=2, descr=0x0A))
+        self.flush_records()
+        self.vprint(
+            "Received CertificateRequest without post_handshake_auth extension!"
+        )
+        raise self.FINAL()
+
+    @ATMT.condition(RECEIVED_SERVERDATA, prio=2)
+    def should_handle_NewSessionTicket(self):
+        self.raise_on_packet(TLS13NewSessionTicket,
+                             self.TLS13_RECEIVED_NEW_SESSION_TICKET)
+
+    @ATMT.state()
+    def TLS13_RECEIVED_NEW_SESSION_TICKET(self):
+        pass
+
+    @ATMT.condition(TLS13_RECEIVED_NEW_SESSION_TICKET)
+    def should_store_session_ticket_file(self):
+        # If arg session_ticket_file_out is set, we save
+        # the ticket for resumption...
+        if self.session_ticket_file_out:
+            # Struct of ticket file :
+            #  * ciphersuite_len (1 byte)
+            #  * ciphersuite (ciphersuite_len bytes) :
+            #       we need to the store the ciphersuite for resumption
+            #  * ticket_nonce_len (1 byte)
+            #  * ticket_nonce (ticket_nonce_len bytes) :
+            #       we need to store the nonce to compute the PSK
+            #       for resumption
+            #  * ticket_age_len (2 bytes)
+            #  * ticket_age (ticket_age_len bytes) :
+            #       we need to store the time we received the ticket for
+            #       computing the obfuscated_ticket_age when resuming
+            #  * ticket_age_add_len (2 bytes)
+            #  * ticket_age_add (ticket_age_add_len bytes) :
+            #       we need to store the ticket_age_add value from the
+            #       ticket to compute the obfuscated ticket age
+            #  * ticket_len (2 bytes)
+            #  * ticket (ticket_len bytes)
+            with open(self.session_ticket_file_out, 'wb') as f:
+                f.write(struct.pack("B", 2))
+                # we choose wcs arbitrarily...
+                f.write(struct.pack("!H",
+                                    self.cur_session.wcs.ciphersuite.val))
+                f.write(struct.pack("B", self.cur_pkt.noncelen))
+                f.write(self.cur_pkt.ticket_nonce)
+                f.write(struct.pack("!H", 4))
+                f.write(struct.pack("!I", int(time.time())))
+                f.write(struct.pack("!H", 4))
+                f.write(struct.pack("!I", self.cur_pkt.ticket_age_add))
+                f.write(struct.pack("!H", self.cur_pkt.ticketlen))
+                f.write(self.cur_session.client_session_ticket)
+            self.vprint(
+                "Received a TLS 1.3 NewSessionTicket that was stored to %s" % (
+                    self.session_ticket_file_out
+                )
+            )
+        else:
+            self.vprint("Ignored TLS 1.3 NewSessionTicket.")
+        raise self.WAIT_CLIENTDATA()
+
+    @ATMT.condition(RECEIVED_SERVERDATA, prio=3)
     def should_handle_ServerData(self):
-        if not self.buffer_in:
-            raise self.WAIT_CLIENTDATA()
         p = self.buffer_in[0]
         if isinstance(p, TLSApplicationData):
             if self.is_atmt_socket:
                 # Socket mode
                 self.oi.tls.send(p.data)
             else:
-                print("> Received: %r" % p.data)
+                self.vprint("Received: %r" % p.data)
         elif isinstance(p, TLSAlert):
-            print("> Received: %r" % p)
+            self.vprint("Received: %r" % p)
             raise self.CLOSE_NOTIFY()
-        elif isinstance(p, TLS13NewSessionTicket):
-            print("> Received: %r " % p)
-            # If arg session_ticket_file_out is set, we save
-            # the ticket for resumption...
-            if self.session_ticket_file_out:
-                # Struct of ticket file :
-                #  * ciphersuite_len (1 byte)
-                #  * ciphersuite (ciphersuite_len bytes) :
-                #       we need to the store the ciphersuite for resumption
-                #  * ticket_nonce_len (1 byte)
-                #  * ticket_nonce (ticket_nonce_len bytes) :
-                #       we need to store the nonce to compute the PSK
-                #       for resumption
-                #  * ticket_age_len (2 bytes)
-                #  * ticket_age (ticket_age_len bytes) :
-                #       we need to store the time we received the ticket for
-                #       computing the obfuscated_ticket_age when resuming
-                #  * ticket_age_add_len (2 bytes)
-                #  * ticket_age_add (ticket_age_add_len bytes) :
-                #       we need to store the ticket_age_add value from the
-                #       ticket to compute the obfuscated ticket age
-                #  * ticket_len (2 bytes)
-                #  * ticket (ticket_len bytes)
-                with open(self.session_ticket_file_out, 'wb') as f:
-                    f.write(struct.pack("B", 2))
-                    # we choose wcs arbitrarily...
-                    f.write(struct.pack("!H",
-                                        self.cur_session.wcs.ciphersuite.val))
-                    f.write(struct.pack("B", p.noncelen))
-                    f.write(p.ticket_nonce)
-                    f.write(struct.pack("!H", 4))
-                    f.write(struct.pack("!I", int(time.time())))
-                    f.write(struct.pack("!H", 4))
-                    f.write(struct.pack("!I", p.ticket_age_add))
-                    f.write(struct.pack("!H", p.ticketlen))
-                    f.write(self.cur_session.client_session_ticket)
         else:
-            print("> Received: %r" % p)
+            self.vprint("Received: %r" % p)
         self.buffer_in = self.buffer_in[1:]
         raise self.HANDLED_SERVERDATA()
 
     @ATMT.state()
     def HANDLED_SERVERDATA(self):
         raise self.WAIT_CLIENTDATA()
 
@@ -802,16 +861,15 @@
                              get_next_msg=False)
 
     @ATMT.state()
     def SSLv2_HANDLED_SERVERVERIFY(self):
         pass
 
     def sslv2_should_add_ClientFinished(self):
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if SSLv2ClientFinished in hs_msg:
+        if self.in_handshake(SSLv2ClientFinished):
             return
         self.add_record(is_sslv2=True)
         self.add_msg(SSLv2ClientFinished())
         raise self.SSLv2_ADDED_CLIENTFINISHED()
 
     @ATMT.condition(SSLv2_HANDLED_SERVERVERIFY, prio=1)
     def sslv2_should_add_ClientFinished_from_ServerVerify(self):
@@ -841,16 +899,15 @@
     @ATMT.condition(SSLv2_ADDED_CLIENTFINISHED)
     def sslv2_should_send_ClientFinished(self):
         self.flush_records()
         raise self.SSLv2_SENT_CLIENTFINISHED()
 
     @ATMT.state()
     def SSLv2_SENT_CLIENTFINISHED(self):
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if SSLv2ServerVerify in hs_msg:
+        if self.in_handshake(SSLv2ServerVerify):
             raise self.SSLv2_WAITING_SERVERFINISHED()
         else:
             self.get_next_msg()
             raise self.SSLv2_RECEIVED_SERVERVERIFY()
 
     @ATMT.state()
     def SSLv2_WAITING_SERVERFINISHED(self):
@@ -925,18 +982,18 @@
     @ATMT.state()
     def SSLv2_WAITING_CLIENTDATA(self):
         pass
 
     @ATMT.condition(SSLv2_WAITING_CLIENTDATA, prio=1)
     def sslv2_add_ClientData(self):
         if not self.data_to_send:
-            data = six.moves.input().replace('\\r', '\r').replace('\\n', '\n').encode()  # noqa: E501
+            data = input().replace('\\r', '\r').replace('\\n', '\n').encode()
         else:
             data = self.data_to_send.pop()
-            self.vprint("> Read from list: %s" % data)
+            self.vprint("Read from list: %s" % data)
         if data == "quit":
             return
         if self.linebreak:
             data += "\n"
         self.add_record(is_sslv2=True)
         self.add_msg(Raw(data))
         raise self.SSLv2_ADDED_CLIENTDATA()
@@ -968,15 +1025,15 @@
         pass
 
     @ATMT.condition(SSLv2_RECEIVED_SERVERDATA)
     def sslv2_should_handle_ServerData(self):
         if not self.buffer_in:
             raise self.SSLv2_WAITING_CLIENTDATA()
         p = self.buffer_in[0]
-        print("> Received: %r" % p.load)
+        self.vprint("Received: %r" % p.load)
         if p.load.startswith(b"goodbye"):
             raise self.SSLv2_CLOSE_NOTIFY()
         self.buffer_in = self.buffer_in[1:]
         raise self.SSLv2_HANDLED_SERVERDATA()
 
     @ATMT.state()
     def SSLv2_HANDLED_SERVERDATA(self):
@@ -1007,44 +1064,51 @@
     @ATMT.state()
     def TLS13_START(self):
         pass
 
     @ATMT.condition(TLS13_START)
     def tls13_should_add_ClientHello(self):
         # we have to use the legacy, plaintext TLS record here
-        supported_groups = ["secp256r1", "secp384r1", "x448"]
-        if conf.crypto_valid_advanced:
-            supported_groups.append("x25519")
         self.add_record(is_tls13=False)
         if self.client_hello:
             p = self.client_hello
         else:
             if self.ciphersuite is None:
                 c = 0x1301
             else:
                 c = self.ciphersuite
             p = TLS13ClientHello(ciphers=c)
 
         ext = []
-        ext += TLS_Ext_SupportedVersion_CH(versions=["TLS 1.3"])
+        ext += TLS_Ext_SupportedVersion_CH(versions=[self.advertised_tls_version])
 
         s = self.cur_session
 
+        # Add TLS_Ext_ServerName
+        if self.server_name:
+            ext += TLS_Ext_ServerName(
+                servernames=[ServerName(servername=self.server_name)]
+            )
+
+        # Add TLS_Ext_PostHandshakeAuth
+        if self.mycert is not None and self.mykey is not None:
+            ext += TLS_Ext_PostHandshakeAuth()
+
         if s.tls13_psk_secret:
             # Check if DHE is need (both for out of band and resumption PSK)
             if self.tls13_psk_mode == "psk_dhe_ke":
                 ext += TLS_Ext_PSKKeyExchangeModes(kxmodes="psk_dhe_ke")
-                ext += TLS_Ext_SupportedGroups(groups=supported_groups)
+                ext += TLS_Ext_SupportedGroups(groups=self.supported_groups)
                 ext += TLS_Ext_KeyShare_CH(
                     client_shares=[KeyShareEntry(group=self.curve)]
                 )
             else:
                 ext += TLS_Ext_PSKKeyExchangeModes(kxmodes="psk_ke")
 
-            # RFC844, section 4.2.11.
+            # RFC8446, section 4.2.11.
             # "The "pre_shared_key" extension MUST be the last extension
             # in the ClientHello "
             # Compute the pre_shared_key extension for resumption PSK
             if s.client_session_ticket:
                 cs_cls = _tls_cipher_suites_cls[s.tls13_ticket_ciphersuite]  # noqa: E501
                 hkdf = TLS13_HKDF(cs_cls.hash_alg.name.lower())
                 hash_len = hkdf.hash.digest_size
@@ -1075,25 +1139,20 @@
                 # XXX see how to not pass binder as argument
                 psk_binder_entry = PSKBinderEntry(binder_len=hash_len,
                                                   binder=b"\x00" * hash_len)
 
                 ext += TLS_Ext_PreSharedKey_CH(identities=[psk_id],
                                                binders=[psk_binder_entry])
         else:
-            ext += TLS_Ext_SupportedGroups(groups=supported_groups)
+            ext += TLS_Ext_SupportedGroups(groups=self.supported_groups)
             ext += TLS_Ext_KeyShare_CH(
                 client_shares=[KeyShareEntry(group=self.curve)]
             )
             ext += TLS_Ext_SignatureAlgorithms(sig_algs=["sha256+rsaepss",
                                                          "sha256+rsa"])
-        # Add TLS_Ext_ServerName
-        if self.server_name:
-            ext += TLS_Ext_ServerName(
-                servernames=[ServerName(servername=self.server_name)]
-            )
         p.ext = ext
         self.add_msg(p)
         raise self.TLS13_ADDED_CLIENTHELLO()
 
     @ATMT.state()
     def TLS13_ADDED_CLIENTHELLO(self):
         raise self.TLS13_SENDING_CLIENTFLIGHT1()
@@ -1139,14 +1198,21 @@
                              self.TLS13_HELLO_RETRY_REQUESTED)
 
     @ATMT.condition(TLS13_RECEIVED_SERVERFLIGHT1, prio=3)
     def tls13_should_handle_AlertMessage_(self):
         self.raise_on_packet(TLSAlert,
                              self.TLS13_HANDLED_ALERT_FROM_SERVERFLIGHT1)
 
+    @ATMT.condition(TLS13_RECEIVED_SERVERFLIGHT1, prio=4)
+    def tls13_should_handle_ChangeCipherSpec_after_tls13_retry(self):
+        # Middlebox compatibility mode after a HelloRetryRequest.
+        if self.cur_session.tls13_retry:
+            self.raise_on_packet(TLSChangeCipherSpec,
+                                 self.TLS13_RECEIVED_SERVERFLIGHT1)
+
     @ATMT.state()
     def TLS13_HANDLED_ALERT_FROM_SERVERFLIGHT1(self):
         self.vprint("Received Alert message !")
         self.vprint(self.cur_pkt.mysummary())
         raise self.CLOSE_NOTIFY()
 
     @ATMT.condition(TLS13_RECEIVED_SERVERFLIGHT1, prio=4)
@@ -1157,85 +1223,36 @@
     def TLS13_HELLO_RETRY_REQUESTED(self):
         pass
 
     @ATMT.condition(TLS13_HELLO_RETRY_REQUESTED)
     def tls13_should_add_ClientHello_Retry(self):
         s = self.cur_session
         s.tls13_retry = True
-        # we have to use the legacy, plaintext TLS record here
-        self.add_record(is_tls13=False)
         # We retrieve the group to be used and the selected version from the
         # previous message
-        hrr = s.handshake_messages_parsed[-1]
-        if isinstance(hrr, TLS13HelloRetryRequest):
-            pass
-        ciphersuite = hrr.cipher
+        hrr = self.cur_pkt
+        self.ciphersuite = hrr.cipher
+        # "The server's extensions MUST contain supported_versions."
+        self.advertised_tls_version = None
         if hrr.ext:
             for e in hrr.ext:
                 if isinstance(e, TLS_Ext_KeyShare_HRR):
-                    selected_group = e.selected_group
+                    self.curve = e.selected_group
                 if isinstance(e, TLS_Ext_SupportedVersion_SH):
-                    selected_version = e.version
-        if not selected_group or not selected_version:
-            raise self.CLOSE_NOTIFY()
-
-        ext = []
-        ext += TLS_Ext_SupportedVersion_CH(versions=[_tls_version[selected_version]])  # noqa: E501
-
-        if s.tls13_psk_secret:
-            if self.tls13_psk_mode == "psk_dhe_ke":
-                ext += TLS_Ext_PSKKeyExchangeModes(kxmodes="psk_dhe_ke"),
-                ext += TLS_Ext_SupportedGroups(groups=[_tls_named_groups[selected_group]])  # noqa: E501
-                ext += TLS_Ext_KeyShare_CH(client_shares=[KeyShareEntry(group=selected_group)])  # noqa: E501
-            else:
-                ext += TLS_Ext_PSKKeyExchangeModes(kxmodes="psk_ke")
-
-            if s.client_session_ticket:
-
-                # XXX Retrieve parameters from first ClientHello...
-                cs_cls = _tls_cipher_suites_cls[s.tls13_ticket_ciphersuite]
-                hkdf = TLS13_HKDF(cs_cls.hash_alg.name.lower())
-                hash_len = hkdf.hash.digest_size
+                    self.advertised_tls_version = e.version
 
-                # We compute the client's view of the age of the ticket (ie
-                # the time since the receipt of the ticket) in ms
-                agems = int((time.time() - s.client_ticket_age) * 1000)
-
-                # Then we compute the obfuscated version of the ticket age by
-                # adding the "ticket_age_add" value included in the ticket
-                # (modulo 2^32)
-                obfuscated_age = ((agems + s.client_session_ticket_age_add) &
-                                  0xffffffff)
-
-                psk_id = PSKIdentity(identity=s.client_session_ticket,
-                                     obfuscated_ticket_age=obfuscated_age)
-
-                psk_binder_entry = PSKBinderEntry(binder_len=hash_len,
-                                                  binder=b"\x00" * hash_len)
-
-                ext += TLS_Ext_PreSharedKey_CH(identities=[psk_id],
-                                               binders=[psk_binder_entry])
-            else:
-                hkdf = TLS13_HKDF("sha256")
-                hash_len = hkdf.hash.digest_size
-                psk_id = PSKIdentity(identity='Client_identity')
-                psk_binder_entry = PSKBinderEntry(binder_len=hash_len,
-                                                  binder=b"\x00" * hash_len)
-
-                ext += TLS_Ext_PreSharedKey_CH(identities=[psk_id],
-                                               binders=[psk_binder_entry])
+        if _tls_named_groups[self.curve] not in self.supported_groups:
+            self.vprint("No common groups found in TLS 1.3 Hello Retry Request!")
+            raise self.CLOSE_NOTIFY()
 
-        else:
-            ext += TLS_Ext_SupportedGroups(groups=[_tls_named_groups[selected_group]])  # noqa: E501
-            ext += TLS_Ext_KeyShare_CH(client_shares=[KeyShareEntry(group=selected_group)])  # noqa: E501
-            ext += TLS_Ext_SignatureAlgorithms(sig_algs=["sha256+rsaepss"])
+        if not self.advertised_tls_version:
+            self.vprint("No supported_versions found in TLS 1.3 Hello Retry Request!")
+            raise self.CLOSE_NOTIFY()
 
-        p = TLS13ClientHello(ciphers=ciphersuite, ext=ext)
-        self.add_msg(p)
-        raise self.TLS13_ADDED_CLIENTHELLO()
+        self.tls13_should_add_ClientHello()
 
     @ATMT.state()
     def TLS13_HANDLED_SERVERHELLO(self):
         pass
 
     @ATMT.condition(TLS13_HANDLED_SERVERHELLO, prio=1)
     def tls13_should_handle_encrytpedExtensions(self):
@@ -1332,43 +1349,48 @@
         If the server sent a CertificateRequest, we send a Certificate message.
         If no certificate is available, an empty Certificate message is sent:
         - this is a SHOULD in RFC 4346 (Section 7.4.6)
         - this is a MUST in RFC 5246 (Section 7.4.6)
 
         XXX We may want to add a complete chain.
         """
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if TLS13CertificateRequest not in hs_msg:
-            raise self.TLS13_ADDED_CLIENTCERTIFICATE()
-            # return
+        if not (isinstance(self.cur_pkt, TLS13CertificateRequest) or
+                self.in_handshake(TLS13CertificateRequest)):
+            return
+
         certs = []
         if self.mycert:
             certs += _ASN1CertAndExt(cert=self.mycert)
 
-        self.add_msg(TLS13Certificate(certs=certs))
+        self.add_msg(
+            TLS13Certificate(
+                certs=certs,
+                cert_req_ctxt=self.cur_session.tls13_cert_req_ctxt,
+            )
+        )
         raise self.TLS13_ADDED_CLIENTCERTIFICATE()
 
     @ATMT.state()
     def TLS13_ADDED_CLIENTCERTIFICATE(self):
         pass
 
+    @ATMT.condition(TLS13_ADDED_CLIENTCERTIFICATE, prio=0)
+    def tls13_should_skip_ClientCertificateVerify(self):
+        if not self.mycert:
+            return self.tls13_should_add_ClientFinished()
+
     @ATMT.condition(TLS13_ADDED_CLIENTCERTIFICATE, prio=1)
     def tls13_should_add_ClientCertificateVerify(self):
         """
         XXX Section 7.4.7.1 of RFC 5246 states that the CertificateVerify
         message is only sent following a client certificate that has signing
         capability (i.e. not those containing fixed DH params).
         We should verify that before adding the message. We should also handle
         the case when the Certificate message was empty.
         """
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if (TLS13CertificateRequest not in hs_msg or
-                self.mycert is None or
-                self.mykey is None):
-            return self.tls13_should_add_ClientFinished()
         self.add_msg(TLSCertificateVerify())
         raise self.TLS13_ADDED_CERTIFICATEVERIFY()
 
     @ATMT.state()
     def TLS13_ADDED_CERTIFICATEVERIFY(self):
         return self.tls13_should_add_ClientFinished()
 
@@ -1384,14 +1406,18 @@
     @ATMT.condition(TLS13_ADDED_CLIENTFINISHED)
     def tls13_should_send_ClientFlight2(self):
         self.flush_records()
         raise self.TLS13_SENT_CLIENTFLIGHT2()
 
     @ATMT.state()
     def TLS13_SENT_CLIENTFLIGHT2(self):
+        if self.tls13_doing_client_postauth:
+            self.tls13_doing_client_postauth = False
+            self.vprint("TLS 1.3 post-handshake authentication sent!")
+            raise self.WAIT_CLIENTDATA()
         self.vprint("TLS 1.3 handshake completed!")
         self.vprint_sessioninfo()
         self.vprint("You may send data or use 'quit'.")
         raise self.WAIT_CLIENTDATA()
 
     @ATMT.state()
     def SOCKET_CLOSED(self):
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/automaton_srv.py` & `scapy-2.6.0rc1/scapy/layers/tls/automaton_srv.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 
 """
 TLS server automaton. This makes for a primitive TLS stack.
 Obviously you need rights for network access.
 
 We support versions SSLv2 to TLS 1.3, along with many features.
 
-In order to run a server listening on tcp/4433:
-> from scapy.all import *
-> t = TLSServerAutomaton(mycert='<cert.pem>', mykey='<key.pem>')
-> t.run()
+In order to run a server listening on tcp/4433::
+
+    from scapy.layers.tls import *
+    t = TLSServerAutomaton(mycert='<cert.pem>', mykey='<key.pem>')
+    t.run()
 """
 
-from __future__ import print_function
 import socket
 import binascii
 import struct
 import time
 
 from scapy.config import conf
 from scapy.packet import Raw
@@ -208,14 +208,15 @@
             self.vprint("Maybe some server is already listening there?")
             self.vprint()
             raise self.FINAL()
         raise self.WAITING_CLIENT()
 
     @ATMT.state()
     def SOCKET_CLOSED(self):
+        self.socket.close()
         raise self.WAITING_CLIENT()
 
     @ATMT.state()
     def WAITING_CLIENT(self):
         self.buffer_out = []
         self.buffer_in = []
         self.vprint()
@@ -259,14 +260,17 @@
 
     #                           TLS handshake                                 #
 
     @ATMT.condition(RECEIVED_CLIENTFLIGHT1, prio=1)
     def tls13_should_handle_ClientHello(self):
         self.raise_on_packet(TLS13ClientHello,
                              self.tls13_HANDLED_CLIENTHELLO)
+        if self.cur_session.advertised_tls_version == 0x0304:
+            self.raise_on_packet(TLSClientHello,
+                                 self.tls13_HANDLED_CLIENTHELLO)
 
     @ATMT.condition(RECEIVED_CLIENTFLIGHT1, prio=2)
     def should_handle_ClientHello(self):
         self.raise_on_packet(TLSClientHello,
                              self.HANDLED_CLIENTHELLO)
 
     @ATMT.state()
@@ -1166,26 +1170,24 @@
 
     @ATMT.state()
     def SSLv2_HANDLED_CLIENTFINISHED(self):
         pass
 
     @ATMT.condition(SSLv2_HANDLED_CLIENTFINISHED, prio=1)
     def sslv2_should_add_ServerVerify_from_ClientFinished(self):
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if SSLv2ServerVerify in hs_msg:
+        if self.in_handshake(SSLv2ServerVerify):
             return
         self.add_record(is_sslv2=True)
         p = SSLv2ServerVerify(challenge=self.cur_session.sslv2_challenge)
         self.add_msg(p)
         raise self.SSLv2_ADDED_SERVERVERIFY()
 
     @ATMT.condition(SSLv2_RECEIVED_CLIENTFINISHED, prio=2)
     def sslv2_should_add_ServerVerify_from_NoClientFinished(self):
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if SSLv2ServerVerify in hs_msg:
+        if self.in_handshake(SSLv2ServerVerify):
             return
         self.add_record(is_sslv2=True)
         p = SSLv2ServerVerify(challenge=self.cur_session.sslv2_challenge)
         self.add_msg(p)
         raise self.SSLv2_ADDED_SERVERVERIFY()
 
     @ATMT.condition(SSLv2_RECEIVED_CLIENTFINISHED, prio=3)
@@ -1204,26 +1206,24 @@
     @ATMT.condition(SSLv2_ADDED_SERVERVERIFY)
     def sslv2_should_send_ServerVerify(self):
         self.flush_records()
         raise self.SSLv2_SENT_SERVERVERIFY()
 
     @ATMT.state()
     def SSLv2_SENT_SERVERVERIFY(self):
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if SSLv2ClientFinished in hs_msg:
+        if self.in_handshake(SSLv2ClientFinished):
             raise self.SSLv2_HANDLED_CLIENTFINISHED()
         else:
             raise self.SSLv2_RECEIVED_CLIENTFINISHED()
 
     #                       SSLv2 client authentication                       #
 
     @ATMT.condition(SSLv2_HANDLED_CLIENTFINISHED, prio=2)
     def sslv2_should_add_RequestCertificate(self):
-        hs_msg = [type(m) for m in self.cur_session.handshake_messages_parsed]
-        if not self.client_auth or SSLv2RequestCertificate in hs_msg:
+        if not self.client_auth or self.in_handshake(SSLv2RequestCertificate):
             return
         self.add_record(is_sslv2=True)
         self.add_msg(SSLv2RequestCertificate(challenge=randstring(16)))
         raise self.SSLv2_ADDED_REQUESTCERTIFICATE()
 
     @ATMT.state()
     def SSLv2_ADDED_REQUESTCERTIFICATE(self):
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/basefields.py` & `scapy-2.6.0rc1/scapy/layers/tls/basefields.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 """
 TLS base fields, used for record parsing/building. As several operations depend
 upon the TLS version or ciphersuite, the packet has to provide a TLS context.
 """
 import struct
 
 from scapy.fields import ByteField, ShortEnumField, ShortField, StrField
-import scapy.libs.six as six
 from scapy.compat import orb
 
 _tls_type = {20: "change_cipher_spec",
              21: "alert",
              22: "handshake",
              23: "application_data"}
 
@@ -164,16 +163,18 @@
         return x
 
     def addfield(self, pkt, s, val):
         # We add nothing here. This is done in .post_build() if needed.
         return s
 
     def getfield(self, pkt, s):
-        if (pkt.tls_session.rcs.cipher.type != "aead" and
-                False in six.itervalues(pkt.tls_session.rcs.cipher.ready)):
+        if (
+            pkt.tls_session.rcs.cipher.type != "aead" and
+            False in pkt.tls_session.rcs.cipher.ready.values()
+        ):
             # XXX Find a more proper way to handle the still-encrypted case
             return s, b""
         tmp_len = pkt.tls_session.rcs.mac_len
         return s[tmp_len:], self.m2i(pkt, s[:tmp_len])
 
     def i2repr(self, pkt, x):
         # XXX Provide status when dissection has been performed successfully?
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/cert.py` & `scapy-2.6.0rc1/scapy/layers/tls/cert.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,39 +23,51 @@
     c.tbsCertificate.serialNumber = 0x4B1D
     k = PrivKey('key.pem')
     new_x509_cert = k.resignCert(c)
 
 No need for obnoxious openssl tweaking anymore. :)
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 import base64
 import os
 import time
 
 from scapy.config import conf, crypto_validator
-import scapy.libs.six as six
 from scapy.error import warning
 from scapy.utils import binrepr
 from scapy.asn1.asn1 import ASN1_BIT_STRING
 from scapy.asn1.mib import hash_by_oid
 from scapy.layers.x509 import (X509_SubjectPublicKeyInfo,
                                RSAPublicKey, RSAPrivateKey,
                                ECDSAPublicKey, ECDSAPrivateKey,
                                RSAPrivateKey_OpenSSL, ECDSAPrivateKey_OpenSSL,
                                X509_Cert, X509_CRL)
 from scapy.layers.tls.crypto.pkcs1 import pkcs_os2ip, _get_hash, \
     _EncryptAndVerifyRSA, _DecryptAndSignRSA
 from scapy.compat import raw, bytes_encode
+
 if conf.crypto_valid:
+    from cryptography.exceptions import InvalidSignature
     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives import serialization
     from cryptography.hazmat.primitives.asymmetric import rsa, ec
-    from cryptography.hazmat.backends.openssl.ec import InvalidSignature
+
+    # cryptography raised the minimum RSA key length to 1024 in 43.0+
+    # https://github.com/pyca/cryptography/pull/10278
+    # but we need still 512 for EXPORT40 ciphers (yes EXPORT is terrible)
+    # https://datatracker.ietf.org/doc/html/rfc2246#autoid-66
+    # The following detects the change and hacks around it using the backend
+
+    try:
+        rsa.generate_private_key(public_exponent=65537, key_size=512)
+        _RSA_512_SUPPORTED = True
+    except ValueError:
+        # cryptography > 43.0
+        _RSA_512_SUPPORTED = False
+        from cryptography.hazmat.primitives.asymmetric.rsa import rust_openssl
 
 
 # Maximum allowed size in bytes for a certificate file, to avoid
 # loading huge file when importing a cert
 _MAX_KEY_SIZE = 50 * 1024
 _MAX_CERT_SIZE = 50 * 1024
 _MAX_CRL_SIZE = 10 * 1024 * 1024   # some are that big
@@ -237,15 +249,15 @@
                 raise Exception("Unable to import public key")
 
         if obj.frmt == "DER":
             obj.pem = der2pem(obj.der, marker)
         return obj
 
 
-class PubKey(six.with_metaclass(_PubKeyFactory, object)):
+class PubKey(metaclass=_PubKeyFactory):
     """
     Parent class for both PubKeyRSA and PubKeyECDSA.
     Provides a common verifyCert() method.
     """
 
     def verifyCert(self, cert):
         """ Verifies either a Cert or an X509_Cert. """
@@ -262,17 +274,26 @@
     Use the 'key' attribute to access original object.
     """
     @crypto_validator
     def fill_and_store(self, modulus=None, modulusLen=None, pubExp=None):
         pubExp = pubExp or 65537
         if not modulus:
             real_modulusLen = modulusLen or 2048
-            private_key = rsa.generate_private_key(public_exponent=pubExp,
-                                                   key_size=real_modulusLen,
-                                                   backend=default_backend())
+            if real_modulusLen < 1024 and not _RSA_512_SUPPORTED:
+                # cryptography > 43.0 compatibility
+                private_key = rust_openssl.rsa.generate_private_key(
+                    public_exponent=pubExp,
+                    key_size=real_modulusLen,
+                )
+            else:
+                private_key = rsa.generate_private_key(
+                    public_exponent=pubExp,
+                    key_size=real_modulusLen,
+                    backend=default_backend(),
+                )
             self.pubkey = private_key.public_key()
         else:
             real_modulusLen = len(binrepr(modulus))
             if modulusLen and real_modulusLen != modulusLen:
                 warning("modulus and modulusLen do not match!")
             pubNum = rsa.RSAPublicNumbers(n=modulus, e=pubExp)
             self.pubkey = pubNum.public_key(default_backend())
@@ -411,15 +432,15 @@
 class _Raw_ASN1_BIT_STRING(ASN1_BIT_STRING):
     """A ASN1_BIT_STRING that ignores BER encoding"""
     def __bytes__(self):
         return self.val_readable
     __str__ = __bytes__
 
 
-class PrivKey(six.with_metaclass(_PrivKeyFactory, object)):
+class PrivKey(metaclass=_PrivKeyFactory):
     """
     Parent class for both PrivKeyRSA and PrivKeyECDSA.
     Provides common signTBSCert() and resignCert() methods.
     """
 
     def signTBSCert(self, tbsCert, h="sha256"):
         """
@@ -469,17 +490,26 @@
         pubExp = pubExp or 65537
         if None in [modulus, prime1, prime2, coefficient, privExp,
                     exponent1, exponent2]:
             # note that the library requires every parameter
             # in order to call RSAPrivateNumbers(...)
             # if one of these is missing, we generate a whole new key
             real_modulusLen = modulusLen or 2048
-            self.key = rsa.generate_private_key(public_exponent=pubExp,
-                                                key_size=real_modulusLen,
-                                                backend=default_backend())
+            if real_modulusLen < 1024 and not _RSA_512_SUPPORTED:
+                # cryptography > 43.0 compatibility
+                self.key = rust_openssl.rsa.generate_private_key(
+                    public_exponent=pubExp,
+                    key_size=real_modulusLen,
+                )
+            else:
+                self.key = rsa.generate_private_key(
+                    public_exponent=pubExp,
+                    key_size=real_modulusLen,
+                    backend=default_backend(),
+                )
             self.pubkey = self.key.public_key()
         else:
             real_modulusLen = len(binrepr(modulus))
             if modulusLen and real_modulusLen != modulusLen:
                 warning("modulus and modulusLen do not match!")
             pubNum = rsa.RSAPublicNumbers(n=modulus, e=pubExp)
             privNum = rsa.RSAPrivateNumbers(p=prime1, q=prime2,
@@ -566,15 +596,15 @@
             cert = X509_Cert(obj.der)
         except Exception:
             raise Exception("Unable to import certificate")
         obj.import_from_asn1pkt(cert)
         return obj
 
 
-class Cert(six.with_metaclass(_CertMaker, object)):
+class Cert(metaclass=_CertMaker):
     """
     Wrapper for the X509_Cert from layers/x509.py.
     Use the 'x509Cert' attribute to access original object.
     """
 
     def import_from_asn1pkt(self, cert):
         error_msg = "Unable to import certificate"
@@ -755,15 +785,15 @@
             crl = X509_CRL(obj.der)
         except Exception:
             raise Exception("Unable to import CRL")
         obj.import_from_asn1pkt(crl)
         return obj
 
 
-class CRL(six.with_metaclass(_CRLMaker, object)):
+class CRL(metaclass=_CRLMaker):
     """
     Wrapper for the X509_CRL from layers/x509.py.
     Use the 'x509CRL' attribute to access original object.
     """
 
     def import_from_asn1pkt(self, crl):
         error_msg = "Unable to import CRL"
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/cipher_aead.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/cipher_aead.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,22 +9,20 @@
 
 RFC 5288 introduces new ciphersuites for TLS 1.2 which are based on AES in
 Galois/Counter Mode (GCM). RFC 6655 in turn introduces AES_CCM ciphersuites.
 The related AEAD algorithms are defined in RFC 5116. Later on, RFC 7905
 introduced cipher suites based on a ChaCha20-Poly1305 construction.
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.config import conf
 from scapy.layers.tls.crypto.pkcs1 import pkcs_i2osp, pkcs_os2ip
 from scapy.layers.tls.crypto.common import CipherError
 from scapy.utils import strxor
-import scapy.libs.six as six
 
 if conf.crypto_valid:
     from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes  # noqa: E501
     from cryptography.hazmat.backends import default_backend
     from cryptography.exceptions import InvalidTag
 if conf.crypto_valid_advanced:
     from cryptography.hazmat.primitives.ciphers.aead import (AESCCM,
@@ -54,15 +52,15 @@
 class AEADTagError(Exception):
     """
     Raised when MAC verification fails.
     """
     pass
 
 
-class _AEADCipher(six.with_metaclass(_AEADCipherMetaclass, object)):
+class _AEADCipher(metaclass=_AEADCipherMetaclass):
     """
     The hasattr(self, "pc_cls") tests correspond to the legacy API of the
     crypto library. With cryptography v2.0, both CCM and GCM should follow
     the else case.
 
     Note that the "fixed_iv" in TLS RFCs is called "salt" in the AEAD RFC 5116.
     """
@@ -141,15 +139,15 @@
         authentication tag is directly appended with the most recent crypto
         API. Additional data may be authenticated without encryption (as A).
 
         The 'seq_num' should never be used here, it is only a safeguard needed
         because one cipher (ChaCha20Poly1305) using TLS 1.2 logic in record.py
         actually is a _AEADCipher_TLS13 (even though others are not).
         """
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(P, A)
 
         if hasattr(self, "pc_cls"):
             self._cipher.mode._initialization_vector = self._get_nonce()
             self._cipher.mode._tag = None
             encryptor = self._cipher.encryptor()
             encryptor.authenticate_additional_data(A)
@@ -181,15 +179,15 @@
         because one cipher (ChaCha20Poly1305) using TLS 1.2 logic in record.py
         actually is a _AEADCipher_TLS13 (even though others are not).
         """
         nonce_explicit_str, C, mac = (C[:self.nonce_explicit_len],
                                       C[self.nonce_explicit_len:-self.tag_len],
                                       C[-self.tag_len:])
 
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(nonce_explicit_str, C, mac)
 
         self.nonce_explicit = pkcs_os2ip(nonce_explicit_str)
         if add_length:
             A += struct.pack("!H", len(C))
 
         if hasattr(self, "pc_cls"):
@@ -244,15 +242,15 @@
     class Cipher_AES_128_CCM_8(Cipher_AES_128_CCM):
         tag_len = 8
 
     class Cipher_AES_256_CCM_8(Cipher_AES_128_CCM_8):
         key_len = 32
 
 
-class _AEADCipher_TLS13(six.with_metaclass(_AEADCipherMetaclass, object)):
+class _AEADCipher_TLS13(metaclass=_AEADCipherMetaclass):
     """
     The hasattr(self, "pc_cls") enable support for the legacy implementation
     of GCM in the cryptography library. They should not be used, and might
     eventually be removed, with cryptography v2.0. XXX
     """
     type = "aead"
 
@@ -313,15 +311,15 @@
     def auth_encrypt(self, P, A, seq_num):
         """
         Encrypt the data, and append the computed authentication code.
         The additional data for TLS 1.3 is the record header.
 
         Note that the cipher's authentication tag must be None when encrypting.
         """
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(P, A)
 
         if hasattr(self, "pc_cls"):
             self._cipher.mode._tag = None
             self._cipher.mode._initialization_vector = self._get_nonce(seq_num)
             encryptor = self._cipher.encryptor()
             encryptor.authenticate_additional_data(A)
@@ -339,15 +337,15 @@
         """
         Decrypt the data and verify the authentication code (in this order).
         If the verification fails, an AEADTagError is raised. It is the user's
         responsibility to catch it if deemed useful. If we lack the key, we
         raise a CipherError which contains the encrypted input.
         """
         C, mac = C[:-self.tag_len], C[-self.tag_len:]
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(C, mac)
 
         if hasattr(self, "pc_cls"):
             self._cipher.mode._initialization_vector = self._get_nonce(seq_num)
             self._cipher.mode._tag = mac
             decryptor = self._cipher.decryptor()
             decryptor.authenticate_additional_data(A)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/cipher_block.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/cipher_block.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,25 +8,23 @@
 Block ciphers.
 """
 
 import warnings
 
 from scapy.config import conf
 from scapy.layers.tls.crypto.common import CipherError
-import scapy.libs.six as six
 
 if conf.crypto_valid:
     from cryptography.utils import (
         CryptographyDeprecationWarning,
     )
     from cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes,  # noqa: E501
                                                         BlockCipherAlgorithm,
                                                         CipherAlgorithm)
-    from cryptography.hazmat.backends.openssl.backend import (backend,
-                                                              GetCipherByName)
+    from cryptography.hazmat.backends.openssl.backend import backend
 
 
 _tls_block_cipher_algs = {}
 
 
 class _BlockCipherMetaclass(type):
     """
@@ -39,15 +37,15 @@
         the_class = super(_BlockCipherMetaclass, cls).__new__(cls, ciph_name,
                                                               bases, dct)
         if ciph_name != "_BlockCipher":
             _tls_block_cipher_algs[ciph_name[7:]] = the_class
         return the_class
 
 
-class _BlockCipher(six.with_metaclass(_BlockCipherMetaclass, object)):
+class _BlockCipher(metaclass=_BlockCipherMetaclass):
     type = "block"
 
     def __init__(self, key=None, iv=None):
         self.ready = {"key": True, "iv": True}
         if key is None:
             self.ready["key"] = False
             if hasattr(self, "expanded_key_len"):
@@ -79,28 +77,28 @@
         super(_BlockCipher, self).__setattr__(name, val)
 
     def encrypt(self, data):
         """
         Encrypt the data. Also, update the cipher iv. This is needed for SSLv3
         and TLS 1.0. For TLS 1.1/1.2, it is overwritten in TLS.post_build().
         """
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(data)
         encryptor = self._cipher.encryptor()
         tmp = encryptor.update(data) + encryptor.finalize()
         self.iv = tmp[-self.block_size:]
         return tmp
 
     def decrypt(self, data):
         """
         Decrypt the data. Also, update the cipher iv. This is needed for SSLv3
         and TLS 1.0. For TLS 1.1/1.2, it is overwritten in TLS.pre_dissect().
         If we lack the key, we raise a CipherError which contains the input.
         """
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(data)
         decryptor = self._cipher.decryptor()
         tmp = decryptor.update(data) + decryptor.finalize()
         self.iv = data[-self.block_size:]
         return tmp
 
     def snapshot(self):
@@ -188,41 +186,54 @@
 
 # We need some black magic for RC2, which is not registered by default
 # to the openssl backend of the cryptography library.
 # If the current version of openssl does not support rc2, the RC2 ciphers are
 # silently not declared, and the corresponding suites will have 'usable' False.
 
 if conf.crypto_valid:
-    class _ARC2(BlockCipherAlgorithm, CipherAlgorithm):
-        name = "RC2"
-        block_size = 64
-        key_sizes = frozenset([128])
-
-        def __init__(self, key):
-            self.key = algorithms._verify_key_size(self, key)
-
-        @property
-        def key_size(self):
-            return len(self.key) * 8
-
-    _gcbn_format = "{cipher.name}-{mode.name}"
-    if GetCipherByName(_gcbn_format)(backend, _ARC2, modes.CBC) != \
-            backend._ffi.NULL:
+    try:
+        from cryptography.hazmat.decrepit.ciphers.algorithms import RC2
+        rc2_available = backend.cipher_supported(
+            RC2(b"0" * 16), modes.CBC(b"0" * 8)
+        )
+    except ImportError:
+        # Legacy path for cryptography < 43.0.0
+        from cryptography.hazmat.backends.openssl.backend import (
+            GetCipherByName
+        )
+        _gcbn_format = "{cipher.name}-{mode.name}"
+
+        class RC2(BlockCipherAlgorithm, CipherAlgorithm):
+            name = "RC2"
+            block_size = 64
+            key_sizes = frozenset([128])
+
+            def __init__(self, key):
+                self.key = algorithms._verify_key_size(self, key)
+
+            @property
+            def key_size(self):
+                return len(self.key) * 8
+        if GetCipherByName(_gcbn_format)(backend, RC2, modes.CBC) != \
+                backend._ffi.NULL:
+            rc2_available = True
+            backend.register_cipher_adapter(RC2,
+                                            modes.CBC,
+                                            GetCipherByName(_gcbn_format))
+        else:
+            rc2_available = False
 
+    if rc2_available:
         class Cipher_RC2_CBC(_BlockCipher):
-            pc_cls = _ARC2
+            pc_cls = RC2
             pc_cls_mode = modes.CBC
             block_size = 8
             key_len = 16
 
         class Cipher_RC2_CBC_40(Cipher_RC2_CBC):
             expanded_key_len = 16
             key_len = 5
 
-        backend.register_cipher_adapter(Cipher_RC2_CBC.pc_cls,
-                                        Cipher_RC2_CBC.pc_cls_mode,
-                                        GetCipherByName(_gcbn_format))
-
         _sslv2_block_cipher_algs["RC2_128_CBC"] = Cipher_RC2_CBC
 
 
 _tls_block_cipher_algs.update(_sslv2_block_cipher_algs)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/cipher_stream.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/cipher_stream.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,18 +4,16 @@
 # Copyright (C) 2007, 2008, 2009 Arnaud Ebalard
 #               2015, 2016, 2017 Maxence Tury
 
 """
 Stream ciphers.
 """
 
-from __future__ import absolute_import
 from scapy.config import conf
 from scapy.layers.tls.crypto.common import CipherError
-import scapy.libs.six as six
 
 if conf.crypto_valid:
     from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
     from cryptography.hazmat.backends import default_backend
 
 
 _tls_stream_cipher_algs = {}
@@ -32,15 +30,15 @@
         the_class = super(_StreamCipherMetaclass, cls).__new__(cls, ciph_name,
                                                                bases, dct)
         if ciph_name != "_StreamCipher":
             _tls_stream_cipher_algs[ciph_name[7:]] = the_class
         return the_class
 
 
-class _StreamCipher(six.with_metaclass(_StreamCipherMetaclass, object)):
+class _StreamCipher(metaclass=_StreamCipherMetaclass):
     type = "stream"
 
     def __init__(self, key=None):
         """
         Note that we have to keep the encryption/decryption state in unique
         encryptor and decryptor objects. This differs from _BlockCipher.
 
@@ -78,21 +76,21 @@
                 self._cipher.algorithm.key = val
                 self.encryptor = self._cipher.encryptor()
                 self.decryptor = self._cipher.decryptor()
             self.ready["key"] = True
         super(_StreamCipher, self).__setattr__(name, val)
 
     def encrypt(self, data):
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(data)
         self._enc_updated_with += data
         return self.encryptor.update(data)
 
     def decrypt(self, data):
-        if False in six.itervalues(self.ready):
+        if False in self.ready.values():
             raise CipherError(data)
         self._dec_updated_with += data
         return self.decryptor.update(data)
 
     def snapshot(self):
         c = self.__class__(self.key)
         c.ready = self.ready.copy()
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/ciphers.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/ciphers.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/compression.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/compression.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,19 +4,17 @@
 # Copyright (C) 2007, 2008, 2009 Arnaud Ebalard
 #               2015, 2016 Maxence Tury
 
 """
 TLS compression.
 """
 
-from __future__ import absolute_import
 import zlib
 
 from scapy.error import warning
-import scapy.libs.six as six
 
 
 _tls_compression_algs = {}
 _tls_compression_algs_cls = {}
 
 
 class _GenericCompMetaclass(type):
@@ -30,15 +28,15 @@
         val = dct.get("val")
         if comp_name:
             _tls_compression_algs[val] = comp_name
             _tls_compression_algs_cls[val] = the_class
         return the_class
 
 
-class _GenericComp(six.with_metaclass(_GenericCompMetaclass, object)):
+class _GenericComp(metaclass=_GenericCompMetaclass):
     pass
 
 
 class Comp_NULL(_GenericComp):
     """
     The default and advised compression method for TLS: doing nothing.
     """
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/groups.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/groups.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,58 +9,28 @@
 At this time the groups from RFC 7919 have not been registered by openssl,
 thus they cannot be imported from the cryptography library.
 
 We also provide TLS identifiers for these DH groups and also the ECDH groups.
 (Note that the equivalent of _ffdh_groups for ECDH is ec._CURVE_TYPES.)
 """
 
-from __future__ import absolute_import
 
 from scapy.config import conf
 from scapy.compat import bytes_int, int_bytes
 from scapy.error import warning
 from scapy.utils import long_converter
-import scapy.libs.six as six
 if conf.crypto_valid:
     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives.asymmetric import dh, ec
     from cryptography.hazmat.primitives import serialization
+    from cryptography.hazmat.primitives.asymmetric.dh import DHParameterNumbers
 if conf.crypto_valid_advanced:
     from cryptography.hazmat.primitives.asymmetric import x25519
     from cryptography.hazmat.primitives.asymmetric import x448
 
-# We have to start by a dirty hack in order to allow long generators,
-# which some versions of openssl love to use...
-
-if conf.crypto_valid:
-    from cryptography.hazmat.primitives.asymmetric.dh import DHParameterNumbers
-
-    try:
-        # We test with dummy values whether the size limitation has been removed.  # noqa: E501
-        pn_test = DHParameterNumbers(2, 7)
-    except ValueError:
-        # We get rid of the limitation through the cryptography v1.9 __init__.
-
-        def DHParameterNumbers__init__hack(self, p, g, q=None):
-            if (
-                not isinstance(p, six.integer_types) or
-                not isinstance(g, six.integer_types)
-            ):
-                raise TypeError("p and g must be integers")
-            if q is not None and not isinstance(q, six.integer_types):
-                raise TypeError("q must be integer or None")
-
-            self._p = p
-            self._g = g
-            self._q = q
-
-        DHParameterNumbers.__init__ = DHParameterNumbers__init__hack
-
-    # End of hack.
-
 
 _ffdh_groups = {}
 
 
 class _FFDHParamsMetaclass(type):
     def __new__(cls, ffdh_name, bases, dct):
         the_class = super(_FFDHParamsMetaclass, cls).__new__(cls, ffdh_name,
@@ -68,15 +38,15 @@
         if conf.crypto_valid and ffdh_name != "_FFDHParams":
             pn = DHParameterNumbers(the_class.m, the_class.g)
             params = pn.parameters(default_backend())
             _ffdh_groups[ffdh_name] = [params, the_class.mLen]
         return the_class
 
 
-class _FFDHParams(six.with_metaclass(_FFDHParamsMetaclass)):
+class _FFDHParams(metaclass=_FFDHParamsMetaclass):
     pass
 
 
 class modp768(_FFDHParams):
     g = 0x02
     m = long_converter("""
     FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08
@@ -457,15 +427,20 @@
             if conf.crypto_valid_advanced:
                 if _tls_named_curves[group] == "x25519":
                     import_point = x25519.X25519PublicKey.from_public_bytes
                 else:
                     import_point = x448.X448PublicKey.from_public_bytes
                 return import_point(pubbytes)
         else:
-            curve = ec._CURVE_TYPES[_tls_named_curves[group]]()
+            curve = ec._CURVE_TYPES[_tls_named_curves[group]]
+            try:
+                # cryptography < 42
+                curve = curve()
+            except TypeError:
+                pass
             try:  # cryptography >= 2.5
                 return ec.EllipticCurvePublicKey.from_encoded_point(
                     curve,
                     pubbytes
                 )
             except AttributeError:
                 pub_num = ec.EllipticCurvePublicNumbers.from_encoded_point(
@@ -475,15 +450,15 @@
                 return pub_num.public_key(default_backend())
 
 
 def _tls_named_groups_pubbytes(privkey):
     if isinstance(privkey, dh.DHPrivateKey):
         # https://datatracker.ietf.org/doc/html/rfc8446#section-4.2.8.1
         pubkey = privkey.public_key()
-        return int_bytes(pubkey.public_numbers().y, privkey.key_size)
+        return int_bytes(pubkey.public_numbers().y, privkey.key_size // 8)
     elif isinstance(privkey, (x25519.X25519PrivateKey,
                               x448.X448PrivateKey)):
         # https://datatracker.ietf.org/doc/html/rfc8446#section-4.2.8.2
         pubkey = privkey.public_key()
         return pubkey.public_bytes(
             serialization.Encoding.Raw,
             serialization.PublicFormat.Raw
@@ -514,15 +489,20 @@
                 else:
                     return x448.X448PrivateKey.generate()
             else:
                 warning(
                     "Your cryptography version doesn't support " + group_name
                 )
         else:
-            curve = ec._CURVE_TYPES[_tls_named_curves[group]]()
+            curve = ec._CURVE_TYPES[_tls_named_curves[group]]
+            try:
+                # cryptography < 42
+                curve = curve()
+            except TypeError:
+                pass
             return ec.generate_private_key(curve, default_backend())
 
 # Below lies ghost code since the shift from 'ecdsa' to 'cryptography' lib.
 # Part of the code has been kept, but commented out, in case anyone would like
 # to improve ECC support in 'cryptography' (namely for the compressed point
 # format and additional curves).
 #
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/h_mac.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/h_mac.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,19 +4,17 @@
 # Copyright (C) 2007, 2008, 2009 Arnaud Ebalard
 #               2015, 2016 Maxence Tury
 
 """
 HMAC classes.
 """
 
-from __future__ import absolute_import
 import hmac
 
 from scapy.layers.tls.crypto.hash import _tls_hash_algs
-import scapy.libs.six as six
 from scapy.compat import bytes_encode
 
 _SSLv3_PAD1_MD5 = b"\x36" * 48
 _SSLv3_PAD1_SHA1 = b"\x36" * 40
 _SSLv3_PAD2_MD5 = b"\x5c" * 48
 _SSLv3_PAD2_SHA1 = b"\x5c" * 40
 
@@ -49,15 +47,15 @@
 class HMACError(Exception):
     """
     Raised when HMAC verification fails.
     """
     pass
 
 
-class _GenericHMAC(six.with_metaclass(_GenericHMACMetaclass, object)):
+class _GenericHMAC(metaclass=_GenericHMACMetaclass):
     def __init__(self, key=None):
         if key is None:
             self.key = b""
         else:
             self.key = bytes_encode(key)
 
     def digest(self, tbd):
@@ -91,14 +89,18 @@
     def digest(self, tbd):
         return b""
 
     def digest_sslv3(self, tbd):
         return b""
 
 
+class Hmac_MD4(_GenericHMAC):
+    pass
+
+
 class Hmac_MD5(_GenericHMAC):
     pass
 
 
 class Hmac_SHA(_GenericHMAC):
     pass
 
@@ -113,7 +115,14 @@
 
 class Hmac_SHA384(_GenericHMAC):
     pass
 
 
 class Hmac_SHA512(_GenericHMAC):
     pass
+
+
+def Hmac(key, hashtype):
+    """
+    Return Hmac object from Hash object and key
+    """
+    return _tls_hmac_algs[f"HMAC-{hashtype.name}"](key=key)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/hash.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/hash.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,16 +7,14 @@
 """
 Hash classes.
 """
 
 from hashlib import md5, sha1, sha224, sha256, sha384, sha512
 from scapy.layers.tls.crypto.md4 import MD4 as md4
 
-import scapy.libs.six as six
-
 
 _tls_hash_algs = {}
 
 
 class _GenericHashMetaclass(type):
     """
     Hash classes are automatically registered through this metaclass.
@@ -28,15 +26,15 @@
         the_class = super(_GenericHashMetaclass, cls).__new__(cls, hash_name,
                                                               bases, dct)
         if hash_name != "_GenericHash":
             _tls_hash_algs[hash_name[5:]] = the_class
         return the_class
 
 
-class _GenericHash(six.with_metaclass(_GenericHashMetaclass, object)):
+class _GenericHash(metaclass=_GenericHashMetaclass):
     def digest(self, tbd):
         return self.hash_cls(tbd).digest()
 
 
 class Hash_NULL(_GenericHash):
     hash_len = 0
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/hkdf.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/hkdf.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,56 +5,62 @@
 
 """
 Stateless HKDF for TLS 1.3.
 """
 
 import struct
 
-from scapy.config import conf
+from scapy.config import conf, crypto_validator
 from scapy.layers.tls.crypto.pkcs1 import _get_hash
 
 if conf.crypto_valid:
     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand
     from cryptography.hazmat.primitives.hashes import Hash
     from cryptography.hazmat.primitives.hmac import HMAC
 
 
 class TLS13_HKDF(object):
+    @crypto_validator
     def __init__(self, hash_name="sha256"):
         self.hash = _get_hash(hash_name)
 
+    @crypto_validator
     def extract(self, salt, ikm):
         h = self.hash
         hkdf = HKDF(h, h.digest_size, salt, None, default_backend())
         if ikm is None:
             ikm = b"\x00" * h.digest_size
         return hkdf._extract(ikm)
 
+    @crypto_validator
     def expand(self, prk, info, L):
         h = self.hash
         hkdf = HKDFExpand(h, L, info, default_backend())
         return hkdf.derive(prk)
 
+    @crypto_validator
     def expand_label(self, secret, label, hash_value, length):
         hkdf_label = struct.pack("!H", length)
         hkdf_label += struct.pack("B", 6 + len(label))
         hkdf_label += b"tls13 "
         hkdf_label += label
         hkdf_label += struct.pack("B", len(hash_value))
         hkdf_label += hash_value
         return self.expand(secret, hkdf_label, length)
 
+    @crypto_validator
     def derive_secret(self, secret, label, messages):
         h = Hash(self.hash, backend=default_backend())
         h.update(messages)
         hash_messages = h.finalize()
         hash_len = self.hash.digest_size
         return self.expand_label(secret, label, hash_messages, hash_len)
 
+    @crypto_validator
     def compute_verify_data(self, basekey, handshake_context):
         hash_len = self.hash.digest_size
         finished_key = self.expand_label(basekey, b"finished", b"", hash_len)
 
         h = Hash(self.hash, backend=default_backend())
         h.update(handshake_context)
         hash_value = h.finalize()
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/kx_algs.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/kx_algs.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,22 +6,20 @@
 
 """
 Key Exchange algorithms as listed in appendix C of RFC 4346.
 
 XXX No support yet for PSK (also, no static DH, DSS, SRP or KRB).
 """
 
-from __future__ import absolute_import
 from scapy.layers.tls.keyexchange import (ServerDHParams,
                                           ServerRSAParams,
                                           ClientDiffieHellmanPublic,
                                           ClientECDiffieHellmanPublic,
                                           _tls_server_ecdh_cls_guess,
                                           EncryptedPreMasterSecret)
-import scapy.libs.six as six
 
 
 _tls_kx_algs = {}
 
 
 class _GenericKXMetaclass(type):
     """
@@ -38,15 +36,15 @@
             the_class.anonymous = "_anon" in kx_name
             the_class.no_ske = not ("DHE" in kx_name or "_anon" in kx_name)
             the_class.no_ske &= not the_class.export
             _tls_kx_algs[kx_name[3:]] = the_class
         return the_class
 
 
-class _GenericKX(six.with_metaclass(_GenericKXMetaclass)):
+class _GenericKX(metaclass=_GenericKXMetaclass):
     pass
 
 
 class KX_NULL(_GenericKX):
     descr = "No key exchange"
     server_kx_msg_cls = lambda _, m: None
     client_kx_msg_cls = None
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/md4.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/md4.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/pkcs1.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/pkcs1.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,17 +8,15 @@
 PKCS #1 methods as defined in RFC 3447.
 
 We cannot rely solely on the cryptography library, because the openssl package
 used by the cryptography library may not implement the md5-sha1 hash, as with
 Ubuntu or OSX. This is why we reluctantly keep some legacy crypto here.
 """
 
-from __future__ import absolute_import
 from scapy.compat import bytes_encode, hex_bytes, bytes_hex
-import scapy.libs.six as six
 
 from scapy.config import conf, crypto_validator
 from scapy.error import warning
 if conf.crypto_valid:
     from cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm
     from cryptography.hazmat.backends import default_backend
     from cryptography.hazmat.primitives import hashes
@@ -166,17 +164,15 @@
     def _legacy_verify_md5_sha1(self, M, S):
         k = self._modulusLen // 8
         if len(S) != k:
             warning("invalid signature (len(S) != k)")
             return False
         s = pkcs_os2ip(S)
         n = self._modulus
-        if isinstance(s, int) and six.PY2:
-            s = long(s)  # noqa: F821
-        if (six.PY2 and not isinstance(s, long)) or s > n - 1:  # noqa: F821
+        if s > n - 1:
             warning("Key._rsaep() expects a long between 0 and n-1")
             return None
         m = pow(s, self._pubExp, n)
         EM = pkcs_i2osp(m, k)
         EMPrime = _legacy_pkcs1_v1_5_encode_md5_sha1(M, k)
         if EMPrime is None:
             warning("Key._rsassa_pkcs1_v1_5_verify(): unable to encode.")
@@ -211,15 +207,13 @@
         k = self._modulusLen // 8
         EM = _legacy_pkcs1_v1_5_encode_md5_sha1(M, k)
         if EM is None:
             warning("Key._rsassa_pkcs1_v1_5_sign(): unable to encode")
             return None
         m = pkcs_os2ip(EM)
         n = self._modulus
-        if isinstance(m, int) and six.PY2:
-            m = long(m)  # noqa: F821
-        if (six.PY2 and not isinstance(m, long)) or m > n - 1:  # noqa: F821
+        if m > n - 1:
             warning("Key._rsaep() expects a long between 0 and n-1")
             return None
         privExp = self.key.private_numbers().d
         s = pow(m, privExp, n)
         return pkcs_i2osp(s, k)
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/prf.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/prf.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,14 @@
 # Copyright (C) 2007, 2008, 2009 Arnaud Ebalard
 #               2015, 2016, 2017 Maxence Tury
 
 """
 TLS Pseudorandom Function.
 """
 
-from __future__ import absolute_import
 from scapy.error import warning
 from scapy.utils import strxor
 
 from scapy.layers.tls.crypto.hash import _tls_hash_algs
 from scapy.layers.tls.crypto.h_mac import _tls_hmac_algs
 from scapy.compat import bytes_encode
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/crypto/suites.py` & `scapy-2.6.0rc1/scapy/layers/tls/crypto/suites.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,20 +7,18 @@
 """
 TLS cipher suites.
 
 A comprehensive list of specified cipher suites can be consulted at:
 https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml
 """
 
-from __future__ import absolute_import
 from scapy.layers.tls.crypto.kx_algs import _tls_kx_algs
 from scapy.layers.tls.crypto.hash import _tls_hash_algs
 from scapy.layers.tls.crypto.h_mac import _tls_hmac_algs
 from scapy.layers.tls.crypto.ciphers import _tls_cipher_algs
-import scapy.libs.six as six
 
 
 def get_algs_from_ciphersuite_name(ciphersuite_name):
     """
     Return the 3-tuple made of the Key Exchange Algorithm class, the Cipher
     class and the HMAC class, through the parsing of the ciphersuite name.
     """
@@ -123,15 +121,15 @@
                                                                      bases,
                                                                      dct)
         if cs_name != "_GenericCipherSuite":
             _tls_cipher_suites_cls[cs_val] = the_class
         return the_class
 
 
-class _GenericCipherSuite(six.with_metaclass(_GenericCipherSuiteMetaclass, object)):  # noqa: E501
+class _GenericCipherSuite(metaclass=_GenericCipherSuiteMetaclass):
     def __init__(self, tls_version=0x0303):
         """
         Most of the attributes are fixed and have already been set by the
         metaclass, but we still have to provide tls_version differentiation.
 
         For now, the key_block_len remains the only application if this.
         Indeed for TLS 1.1+, when using a block cipher, there are no implicit
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/extensions.py` & `scapy-2.6.0rc1/scapy/layers/tls/extensions.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,22 +3,34 @@
 # See https://scapy.net/ for more information
 # Copyright (C) 2017 Maxence Tury
 
 """
 TLS handshake extensions.
 """
 
-from __future__ import print_function
 
 import os
 import struct
 
-from scapy.fields import ByteEnumField, ByteField, EnumField, FieldLenField, \
-    FieldListField, IntField, PacketField, PacketListField, ShortEnumField, \
-    ShortField, StrFixedLenField, StrLenField, XStrLenField
+from scapy.fields import (
+    ByteEnumField,
+    ByteField,
+    EnumField,
+    FieldLenField,
+    FieldListField,
+    IntField,
+    MayEnd,
+    PacketField,
+    PacketListField,
+    ShortEnumField,
+    ShortField,
+    StrFixedLenField,
+    StrLenField,
+    XStrLenField,
+)
 from scapy.packet import Packet, Raw, Padding
 from scapy.layers.x509 import X509_Extensions
 from scapy.layers.tls.basefields import _tls_version
 from scapy.layers.tls.keyexchange import (SigAndHashAlgsLenField,
                                           SigAndHashAlgsField, _tls_hash_sig)
 from scapy.layers.tls.session import _GenericTLSSessionInheritance
 from scapy.layers.tls.crypto.groups import _tls_named_groups
@@ -193,26 +205,26 @@
                 return s
         return super(ServerLenField, self).addfield(pkt, s, val)
 
 
 class TLS_Ext_ServerName(TLS_Ext_PrettyPacketList):                 # RFC 4366
     name = "TLS Extension - Server Name"
     fields_desc = [ShortEnumField("type", 0, _tls_ext),
-                   FieldLenField("len", None, length_of="servernames",
-                                 adjust=lambda pkt, x: x + 2),
+                   MayEnd(FieldLenField("len", None, length_of="servernames",
+                                        adjust=lambda pkt, x: x + 2)),
                    ServerLenField("servernameslen", None,
                                   length_of="servernames"),
                    ServerListField("servernames", [], ServerName,
                                    length_from=lambda pkt: pkt.servernameslen)]
 
 
 class TLS_Ext_EncryptedServerName(TLS_Ext_PrettyPacketList):
     name = "TLS Extension - Encrypted Server Name"
     fields_desc = [ShortEnumField("type", 0xffce, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    EnumField("cipher", None, _tls_cipher_suites),
                    ShortEnumField("key_exchange_group", None,
                                   _tls_named_groups),
                    FieldLenField("key_exchange_len", None,
                                  length_of="key_exchange", fmt="H"),
                    XStrLenField("key_exchange", "",
                                 length_from=lambda pkt: pkt.key_exchange_len),
@@ -225,25 +237,25 @@
                    XStrLenField("encrypted_sni", "",
                                 length_from=lambda pkt: pkt.encrypted_sni_len)]
 
 
 class TLS_Ext_MaxFragLen(TLS_Ext_Unknown):                          # RFC 4366
     name = "TLS Extension - Max Fragment Length"
     fields_desc = [ShortEnumField("type", 1, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ByteEnumField("maxfraglen", 4, {1: "2^9",
                                                    2: "2^10",
                                                    3: "2^11",
                                                    4: "2^12"})]
 
 
 class TLS_Ext_ClientCertURL(TLS_Ext_Unknown):                       # RFC 4366
     name = "TLS Extension - Client Certificate URL"
     fields_desc = [ShortEnumField("type", 2, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 _tls_trusted_authority_types = {0: "pre_agreed",
                                 1: "key_sha1_hash",
                                 2: "x509_name",
                                 3: "cert_sha1_hash"}
 
@@ -307,24 +319,24 @@
             cls = _tls_trusted_authority_cls[idtype]
         return cls(m)
 
 
 class TLS_Ext_TrustedCAInd(TLS_Ext_Unknown):                        # RFC 4366
     name = "TLS Extension - Trusted CA Indication"
     fields_desc = [ShortEnumField("type", 3, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("talen", None, length_of="ta"),
                    _TAListField("ta", [], Raw,
                                 length_from=lambda pkt: pkt.talen)]
 
 
 class TLS_Ext_TruncatedHMAC(TLS_Ext_Unknown):                       # RFC 4366
     name = "TLS Extension - Truncated HMAC"
     fields_desc = [ShortEnumField("type", 4, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class ResponderID(Packet):
     name = "Responder ID structure"
     fields_desc = [FieldLenField("respidlen", None, length_of="respid"),
                    StrLenField("respid", "",
                                length_from=lambda pkt: pkt.respidlen)]
@@ -360,64 +372,64 @@
             cls = _cert_status_req_cls[idtype]
         return cls(m)
 
 
 class TLS_Ext_CSR(TLS_Ext_Unknown):                                 # RFC 4366
     name = "TLS Extension - Certificate Status Request"
     fields_desc = [ShortEnumField("type", 5, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ByteEnumField("stype", None, _cert_status_type),
                    _StatusReqField("req", [], Raw,
                                    length_from=lambda pkt: pkt.len - 1)]
 
 
 class TLS_Ext_UserMapping(TLS_Ext_Unknown):                         # RFC 4681
     name = "TLS Extension - User Mapping"
     fields_desc = [ShortEnumField("type", 6, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("umlen", None, fmt="B", length_of="um"),
                    FieldListField("um", [],
                                   ByteField("umtype", 0),
                                   length_from=lambda pkt: pkt.umlen)]
 
 
 class TLS_Ext_ClientAuthz(TLS_Ext_Unknown):                         # RFC 5878
     """ XXX Unsupported """
     name = "TLS Extension - Client Authz"
     fields_desc = [ShortEnumField("type", 7, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ]
 
 
 class TLS_Ext_ServerAuthz(TLS_Ext_Unknown):                         # RFC 5878
     """ XXX Unsupported """
     name = "TLS Extension - Server Authz"
     fields_desc = [ShortEnumField("type", 8, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ]
 
 
 _tls_cert_types = {0: "X.509", 1: "OpenPGP"}
 
 
 class TLS_Ext_ClientCertType(TLS_Ext_Unknown):                      # RFC 5081
     name = "TLS Extension - Certificate Type (client version)"
     fields_desc = [ShortEnumField("type", 9, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("ctypeslen", None, length_of="ctypes"),
                    FieldListField("ctypes", [0, 1],
                                   ByteEnumField("certtypes", None,
                                                 _tls_cert_types),
                                   length_from=lambda pkt: pkt.ctypeslen)]
 
 
 class TLS_Ext_ServerCertType(TLS_Ext_Unknown):                      # RFC 5081
     name = "TLS Extension - Certificate Type (server version)"
     fields_desc = [ShortEnumField("type", 9, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ByteEnumField("ctype", None, _tls_cert_types)]
 
 
 def _TLS_Ext_CertTypeDispatcher(m, *args, **kargs):
     """
     We need to select the correct one on dissection. We use the length for
     that, as 1 for client version would imply an empty list.
@@ -433,15 +445,15 @@
 class TLS_Ext_SupportedGroups(TLS_Ext_Unknown):
     """
     This extension was known as 'Supported Elliptic Curves' before TLS 1.3
     merged both group selection mechanisms for ECDH and FFDH.
     """
     name = "TLS Extension - Supported Groups"
     fields_desc = [ShortEnumField("type", 10, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("groupslen", None, length_of="groups"),
                    FieldListField("groups", [],
                                   ShortEnumField("ng", None,
                                                  _tls_named_groups),
                                   length_from=lambda pkt: pkt.groupslen)]
 
 
@@ -453,38 +465,38 @@
                        1: "ansiX962_compressed_prime",
                        2: "ansiX962_compressed_char2"}
 
 
 class TLS_Ext_SupportedPointFormat(TLS_Ext_Unknown):                # RFC 4492
     name = "TLS Extension - Supported Point Format"
     fields_desc = [ShortEnumField("type", 11, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("ecpllen", None, fmt="B", length_of="ecpl"),
                    FieldListField("ecpl", [0],
                                   ByteEnumField("nc", None,
                                                 _tls_ecpoint_format),
                                   length_from=lambda pkt: pkt.ecpllen)]
 
 
 class TLS_Ext_SignatureAlgorithms(TLS_Ext_Unknown):                 # RFC 5246
     name = "TLS Extension - Signature Algorithms"
     fields_desc = [ShortEnumField("type", 13, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    SigAndHashAlgsLenField("sig_algs_len", None,
                                           length_of="sig_algs"),
                    SigAndHashAlgsField("sig_algs", [],
                                        EnumField("hash_sig", None,
                                                  _tls_hash_sig),
                                        length_from=lambda pkt: pkt.sig_algs_len)]  # noqa: E501
 
 
 class TLS_Ext_Heartbeat(TLS_Ext_Unknown):                           # RFC 6520
     name = "TLS Extension - Heartbeat"
     fields_desc = [ShortEnumField("type", 0x0f, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ByteEnumField("heartbeat_mode", 2,
                                  {1: "peer_allowed_to_send",
                                   2: "peer_not_allowed_to_send"})]
 
 
 class ProtocolName(Packet):
     name = "Protocol Name"
@@ -501,15 +513,15 @@
         res = [p.protocol for p in x]
         return "[%s]" % ", ".join(repr(x) for x in res)
 
 
 class TLS_Ext_ALPN(TLS_Ext_PrettyPacketList):                       # RFC 7301
     name = "TLS Extension - Application Layer Protocol Negotiation"
     fields_desc = [ShortEnumField("type", 0x10, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("protocolslen", None, length_of="protocols"),
                    ProtocolListField("protocols", [], ProtocolName,
                                      length_from=lambda pkt:pkt.protocolslen)]
 
 
 class TLS_Ext_Padding(TLS_Ext_Unknown):                             # RFC 7685
     name = "TLS Extension - Padding"
@@ -518,21 +530,21 @@
                    StrLenField("padding", "",
                                length_from=lambda pkt: pkt.len)]
 
 
 class TLS_Ext_EncryptThenMAC(TLS_Ext_Unknown):                      # RFC 7366
     name = "TLS Extension - Encrypt-then-MAC"
     fields_desc = [ShortEnumField("type", 0x16, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_ExtendedMasterSecret(TLS_Ext_Unknown):                # RFC 7627
     name = "TLS Extension - Extended Master Secret"
     fields_desc = [ShortEnumField("type", 0x17, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_SessionTicket(TLS_Ext_Unknown):                       # RFC 5077
     """
     RFC 5077 updates RFC 4507 according to most implementations, which do not
     use another (useless) 'ticketlen' field after the global 'len' field.
     """
@@ -542,74 +554,74 @@
                    StrLenField("ticket", "",
                                length_from=lambda pkt: pkt.len)]
 
 
 class TLS_Ext_KeyShare(TLS_Ext_Unknown):
     name = "TLS Extension - Key Share (dummy class)"
     fields_desc = [ShortEnumField("type", 0x33, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_PreSharedKey(TLS_Ext_Unknown):
     name = "TLS Extension - Pre Shared Key (dummy class)"
     fields_desc = [ShortEnumField("type", 0x29, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_EarlyDataIndication(TLS_Ext_Unknown):
     name = "TLS Extension - Early Data"
     fields_desc = [ShortEnumField("type", 0x2a, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_EarlyDataIndicationTicket(TLS_Ext_Unknown):
     name = "TLS Extension - Ticket Early Data Info"
     fields_desc = [ShortEnumField("type", 0x2a, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    IntField("max_early_data_size", 0)]
 
 
 _tls_ext_early_data_cls = {1: TLS_Ext_EarlyDataIndication,
                            4: TLS_Ext_EarlyDataIndicationTicket,
                            8: TLS_Ext_EarlyDataIndication}
 
 
 class TLS_Ext_SupportedVersions(TLS_Ext_Unknown):
     name = "TLS Extension - Supported Versions (dummy class)"
     fields_desc = [ShortEnumField("type", 0x2b, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_SupportedVersion_CH(TLS_Ext_Unknown):
     name = "TLS Extension - Supported Versions (for ClientHello)"
     fields_desc = [ShortEnumField("type", 0x2b, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("versionslen", None, fmt='B',
                                  length_of="versions"),
                    FieldListField("versions", [],
                                   ShortEnumField("version", None,
                                                  _tls_version),
                                   length_from=lambda pkt: pkt.versionslen)]
 
 
 class TLS_Ext_SupportedVersion_SH(TLS_Ext_Unknown):
     name = "TLS Extension - Supported Versions (for ServerHello)"
     fields_desc = [ShortEnumField("type", 0x2b, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ShortEnumField("version", None, _tls_version)]
 
 
 _tls_ext_supported_version_cls = {1: TLS_Ext_SupportedVersion_CH,
                                   2: TLS_Ext_SupportedVersion_SH}
 
 
 class TLS_Ext_Cookie(TLS_Ext_Unknown):
     name = "TLS Extension - Cookie"
     fields_desc = [ShortEnumField("type", 0x2c, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("cookielen", None, length_of="cookie"),
                    XStrLenField("cookie", "",
                                 length_from=lambda pkt: pkt.cookielen)]
 
     def build(self):
         fval = self.getfieldval("cookie")
         if fval is None or fval == b"":
@@ -619,27 +631,27 @@
 
 _tls_psk_kx_modes = {0: "psk_ke", 1: "psk_dhe_ke"}
 
 
 class TLS_Ext_PSKKeyExchangeModes(TLS_Ext_Unknown):
     name = "TLS Extension - PSK Key Exchange Modes"
     fields_desc = [ShortEnumField("type", 0x2d, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("kxmodeslen", None, fmt='B',
                                  length_of="kxmodes"),
                    FieldListField("kxmodes", [],
                                   ByteEnumField("kxmode", None,
                                                 _tls_psk_kx_modes),
                                   length_from=lambda pkt: pkt.kxmodeslen)]
 
 
 class TLS_Ext_TicketEarlyDataInfo(TLS_Ext_Unknown):
     name = "TLS Extension - Ticket Early Data Info"
     fields_desc = [ShortEnumField("type", 0x2e, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    IntField("max_early_data_size", 0)]
 
 
 class TLS_Ext_NPN(TLS_Ext_PrettyPacketList):
     """
     Defined in RFC-draft-agl-tls-nextprotoneg-03. Deprecated in favour of ALPN.
     """
@@ -649,43 +661,43 @@
                    ProtocolListField("protocols", [], ProtocolName,
                                      length_from=lambda pkt:pkt.len)]
 
 
 class TLS_Ext_PostHandshakeAuth(TLS_Ext_Unknown):                   # RFC 8446
     name = "TLS Extension - Post Handshake Auth"
     fields_desc = [ShortEnumField("type", 0x31, _tls_ext),
-                   ShortField("len", None)]
+                   MayEnd(ShortField("len", None))]
 
 
 class TLS_Ext_SignatureAlgorithmsCert(TLS_Ext_Unknown):    # RFC 8446
     name = "TLS Extension - Signature Algorithms Cert"
     fields_desc = [ShortEnumField("type", 0x32, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    SigAndHashAlgsLenField("sig_algs_len", None,
                                           length_of="sig_algs"),
                    SigAndHashAlgsField("sig_algs", [],
                                        EnumField("hash_sig", None,
                                                  _tls_hash_sig),
                                        length_from=lambda pkt: pkt.sig_algs_len)]  # noqa: E501
 
 
 class TLS_Ext_RenegotiationInfo(TLS_Ext_Unknown):                   # RFC 5746
     name = "TLS Extension - Renegotiation Indication"
     fields_desc = [ShortEnumField("type", 0xff01, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    FieldLenField("reneg_conn_len", None, fmt='B',
                                  length_of="renegotiated_connection"),
                    StrLenField("renegotiated_connection", "",
                                length_from=lambda pkt: pkt.reneg_conn_len)]
 
 
 class TLS_Ext_RecordSizeLimit(TLS_Ext_Unknown):  # RFC 8449
     name = "TLS Extension - Record Size Limit"
     fields_desc = [ShortEnumField("type", 0x1c, _tls_ext),
-                   ShortField("len", None),
+                   MayEnd(ShortField("len", None)),
                    ShortField("record_size_limit", None)]
 
 
 _tls_ext_cls = {0: TLS_Ext_ServerName,
                 1: TLS_Ext_MaxFragLen,
                 2: TLS_Ext_ClientCertURL,
                 3: TLS_Ext_TrustedCAInd,
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/handshake.py` & `scapy-2.6.0rc1/scapy/layers/tls/handshake.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 """
 TLS handshake fields & logic.
 
 This module covers the handshake TLS subprotocol, except for the key exchange
 mechanisms which are addressed with keyexchange.py.
 """
 
-from __future__ import absolute_import
 import math
 import os
 import struct
 
 from scapy.error import log_runtime, warning
 from scapy.fields import (
     ByteEnumField,
@@ -33,23 +32,23 @@
     StrLenField,
     ThreeBytesField,
     UTCTimeField,
 )
 
 from scapy.compat import hex_bytes, orb, raw
 from scapy.config import conf
-from scapy.libs import six
 from scapy.packet import Packet, Raw, Padding
 from scapy.utils import randstring, repr_hex
 from scapy.layers.x509 import OCSP_Response
 from scapy.layers.tls.cert import Cert
 from scapy.layers.tls.basefields import (_tls_version, _TLSVersionField,
                                          _TLSClientVersionField)
 from scapy.layers.tls.extensions import (_ExtensionsLenField, _ExtensionsField,
                                          _cert_status_type,
+                                         TLS_Ext_PostHandshakeAuth,
                                          TLS_Ext_SupportedVersion_CH,
                                          TLS_Ext_SignatureAlgorithms,
                                          TLS_Ext_SupportedVersion_SH,
                                          TLS_Ext_EarlyDataIndication,
                                          _tls_hello_retry_magic,
                                          TLS_Ext_ExtendedMasterSecret,
                                          TLS_Ext_EncryptThenMAC)
@@ -111,17 +110,23 @@
     def guess_payload_class(self, p):
         return conf.padding_layer
 
     def tls_session_update(self, msg_str):
         """
         Covers both post_build- and post_dissection- context updates.
         """
-
-        self.tls_session.handshake_messages.append(msg_str)
-        self.tls_session.handshake_messages_parsed.append(self)
+        # RFC8446 sect 4.4.1
+        # "Note, however, that subsequent post-handshake authentications do not
+        # include each other, just the messages through the end of the main
+        # handshake."
+        if self.tls_session.post_handshake:
+            self.tls_session.post_handshake_messages.append(msg_str)
+        else:
+            self.tls_session.handshake_messages.append(msg_str)
+            self.tls_session.handshake_messages_parsed.append(self)
 
 
 ###############################################################################
 #   HelloRequest                                                              #
 ###############################################################################
 
 class TLSHelloRequest(_TLSHandshake):
@@ -176,15 +181,15 @@
 
     def __init__(self, name, default, dico, length_from=None, itemfmt="!H"):
         StrLenField.__init__(self, name, default, length_from=length_from)
         self.itemfmt = itemfmt
         self.itemsize = struct.calcsize(itemfmt)
         i2s = self.i2s = {}
         s2i = self.s2i = {}
-        for k in six.iterkeys(dico):
+        for k in dico.keys():
             i2s[k] = dico[k]
             s2i[dico[k]] = k
 
     def any2i_one(self, pkt, x):
         if isinstance(x, (_GenericCipherSuite, _GenericCipherSuiteMetaclass)):
             x = x.val
         if isinstance(x, bytes):
@@ -334,17 +339,18 @@
                         # RFC 8701: GREASE of TLS will send unknown versions
                         # here. We have to ignore them
                         if ver in _tls_version:
                             s.advertised_tls_version = ver
                             break
                     if s.sid:
                         s.middlebox_compatibility = True
-
                 if isinstance(e, TLS_Ext_SignatureAlgorithms):
                     s.advertised_sig_algs = e.sig_algs
+                if isinstance(e, TLS_Ext_PostHandshakeAuth):
+                    s.post_handshake_auth = True
 
 
 class TLS13ClientHello(_TLSHandshake):
     """
     TLS 1.3 ClientHello, with abilities to handle extensions.
 
     The Random structure is 32 random bytes without any GMT time
@@ -461,18 +467,20 @@
         if self.ext:
             for e in self.ext:
                 if isinstance(e, TLS_Ext_SupportedVersion_CH):
                     for ver in sorted(e.versions, reverse=True):
                         # RFC 8701: GREASE of TLS will send unknown versions
                         # here. We have to ignore them
                         if ver in _tls_version:
-                            self.tls_session.advertised_tls_version = ver
+                            s.advertised_tls_version = ver
                             break
                 if isinstance(e, TLS_Ext_SignatureAlgorithms):
                     s.advertised_sig_algs = e.sig_algs
+                if isinstance(e, TLS_Ext_PostHandshakeAuth):
+                    s.post_handshake_auth = True
 
 
 ###############################################################################
 #   ServerHello                                                               #
 ###############################################################################
 
 
@@ -663,15 +671,14 @@
             s.pwcs = writeConnState(ciphersuite=cs_cls,
                                     connection_end=connection_end,
                                     tls_version=s.tls_version)
 
             if not s.middlebox_compatibility:
                 s.triggered_pwcs_commit = True
         elif connection_end == "client":
-
             s.prcs = readConnState(ciphersuite=cs_cls,
                                    connection_end=connection_end,
                                    tls_version=s.tls_version)
             if not s.middlebox_compatibility:
                 s.triggered_prcs_commit = True
 
         if s.tls13_early_secret is None:
@@ -702,14 +709,15 @@
             self.random_bytes = _tls_hello_retry_magic
         return _TLSHandshake.build(self)
 
     def tls_session_update(self, msg_str):
         s = self.tls_session
         s.tls13_retry = True
         s.tls13_client_pubshares = {}
+        # RFC8446 sect 4.4.1
         # If the server responds to a ClientHello with a HelloRetryRequest
         # The value of the first ClientHello is replaced by a message_hash
         if s.client_session_ticket:
             cs_cls = _tls_cipher_suites_cls[s.tls13_ticket_ciphersuite]
             hkdf = TLS13_HKDF(cs_cls.hash_alg.name.lower())
             hash_len = hkdf.hash.digest_size
         else:
@@ -798,15 +806,16 @@
                                         tls_version=s.tls_version)
                 chts = s.tls13_derived_secrets["client_handshake_traffic_secret"]  # noqa: E501
                 s.pwcs.tls13_derive_keys(chts)
                 if not s.middlebox_compatibility:
                     s.wcs = self.tls_session.pwcs
                     s.triggered_pwcs_commit = False
                 else:
-                    s.triggered_prcs_commit = True
+                    s.triggered_pwcs_commit = True
+
 ###############################################################################
 #   Certificate                                                               #
 ###############################################################################
 
 # XXX It might be appropriate to rewrite this mess with basic 3-byte FieldLenField.  # noqa: E501
 
 
@@ -1177,14 +1186,19 @@
                    StrLenField("cert_req_ctxt", "",
                                length_from=lambda pkt: pkt.cert_req_ctxt_len),
                    _ExtensionsLenField("extlen", None, length_of="ext"),
                    _ExtensionsField("ext", None,
                                     length_from=lambda pkt: pkt.msglen -
                                     pkt.cert_req_ctxt_len - 3)]
 
+    def tls_session_update(self, msg_str):
+        super(TLS13CertificateRequest, self).tls_session_update(msg_str)
+        self.tls_session.tls13_cert_req_ctxt = self.cert_req_ctxt
+
+
 ###############################################################################
 #   ServerHelloDone                                                           #
 ###############################################################################
 
 
 class TLSServerHelloDone(_TLSHandshake):
     name = "TLS Handshake - Server Hello Done"
@@ -1199,19 +1213,24 @@
 class TLSCertificateVerify(_TLSHandshake):
     name = "TLS Handshake - Certificate Verify"
     fields_desc = [ByteEnumField("msgtype", 15, _tls_handshake_type),
                    ThreeBytesField("msglen", None),
                    _TLSSignatureField("sig", None,
                                       length_from=lambda pkt: pkt.msglen)]
 
+    # See https://datatracker.ietf.org/doc/html/rfc8446#section-4.4 for how to compute
+    # the signature.
+
     def build(self, *args, **kargs):
         sig = self.getfieldval("sig")
         if sig is None:
             s = self.tls_session
             m = b"".join(s.handshake_messages)
+            if s.post_handshake:
+                m += b"".join(s.post_handshake_messages)
             tls_version = s.tls_version
             if tls_version is None:
                 tls_version = s.advertised_tls_version
             if tls_version >= 0x0304:
                 if s.connection_end == "client":
                     context_string = b"TLS 1.3, client CertificateVerify"
                 elif s.connection_end == "server":
@@ -1224,14 +1243,16 @@
                 # should be TLS 1.3 only
                 self.sig._update_sig(m, s.server_key)
         return _TLSHandshake.build(self, *args, **kargs)
 
     def post_dissection(self, pkt):
         s = self.tls_session
         m = b"".join(s.handshake_messages)
+        if s.post_handshake:
+            m += b"".join(s.post_handshake_messages)
         tls_version = s.tls_version
         if tls_version is None:
             tls_version = s.advertised_tls_version
         if tls_version >= 0x0304:
             if s.connection_end == "client":
                 context_string = b"TLS 1.3, server CertificateVerify"
             elif s.connection_end == "server":
@@ -1327,15 +1348,22 @@
                 self.tls_session.session_hash = hash_object.digest(to_hash)
             else:
                 # Previous TLS version use concatenation of MD5 & SHA1
                 from scapy.layers.tls.crypto.hash import Hash_MD5, Hash_SHA
                 self.tls_session.session_hash = (
                     Hash_MD5().digest(to_hash) + Hash_SHA().digest(to_hash)
                 )
-            self.tls_session.compute_ms_and_derive_keys()
+            if self.tls_session.pre_master_secret:
+                self.tls_session.compute_ms_and_derive_keys()
+
+        if not self.tls_session.master_secret:
+            # There are still no master secret (we're just passive)
+            if self.tls_session.use_nss_master_secret_if_present():
+                # we have a NSS file
+                self.tls_session.compute_ms_and_derive_keys()
 
 
 ###############################################################################
 #   Finished                                                                  #
 ###############################################################################
 
 class _VerifyDataField(StrLenField):
@@ -1356,81 +1384,93 @@
                    _VerifyDataField("vdata", None)]
 
     def build(self, *args, **kargs):
         fval = self.getfieldval("vdata")
         if fval is None:
             s = self.tls_session
             handshake_msg = b"".join(s.handshake_messages)
+            if s.post_handshake:
+                handshake_msg += b"".join(s.post_handshake_messages)
             con_end = s.connection_end
             tls_version = s.tls_version
             if tls_version is None:
                 tls_version = s.advertised_tls_version
             if tls_version < 0x0304:
                 ms = s.master_secret
                 self.vdata = s.wcs.prf.compute_verify_data(con_end, "write",
                                                            handshake_msg, ms)
             else:
-                self.vdata = s.compute_tls13_verify_data(con_end, "write")
+                self.vdata = s.compute_tls13_verify_data(con_end, "write",
+                                                         handshake_msg)
         return _TLSHandshake.build(self, *args, **kargs)
 
     def post_dissection(self, pkt):
         s = self.tls_session
         if not s.frozen:
             handshake_msg = b"".join(s.handshake_messages)
+            if s.post_handshake:
+                handshake_msg += b"".join(s.post_handshake_messages)
             tls_version = s.tls_version
             if tls_version is None:
                 tls_version = s.advertised_tls_version
             if tls_version < 0x0304 and s.master_secret is not None:
                 ms = s.master_secret
                 con_end = s.connection_end
                 verify_data = s.rcs.prf.compute_verify_data(con_end, "read",
                                                             handshake_msg, ms)
                 if self.vdata != verify_data:
                     pkt_info = pkt.firstlayer().summary()
                     log_runtime.info("TLS: invalid Finished received [%s]", pkt_info)  # noqa: E501
             elif tls_version >= 0x0304:
                 con_end = s.connection_end
-                verify_data = s.compute_tls13_verify_data(con_end, "read")
+                verify_data = s.compute_tls13_verify_data(con_end, "read",
+                                                          handshake_msg)
                 if self.vdata != verify_data:
                     pkt_info = pkt.firstlayer().summary()
                     log_runtime.info("TLS: invalid Finished received [%s]", pkt_info)  # noqa: E501
 
     def post_build_tls_session_update(self, msg_str):
         self.tls_session_update(msg_str)
         s = self.tls_session
         tls_version = s.tls_version
         if tls_version is None:
             tls_version = s.advertised_tls_version
-        if tls_version >= 0x0304:
+        if tls_version >= 0x0304 and not s.post_handshake:
             s.pwcs = writeConnState(ciphersuite=type(s.wcs.ciphersuite),
                                     connection_end=s.connection_end,
                                     tls_version=s.tls_version)
             s.triggered_pwcs_commit = True
             if s.connection_end == "server":
                 s.compute_tls13_traffic_secrets()
             elif s.connection_end == "client":
                 s.compute_tls13_traffic_secrets_end()
                 s.compute_tls13_resumption_secret()
+        if s.connection_end == "client":
+            s.post_handshake = True
+            s.post_handshake_messages = []
 
     def post_dissection_tls_session_update(self, msg_str):
         self.tls_session_update(msg_str)
         s = self.tls_session
         tls_version = s.tls_version
         if tls_version is None:
             tls_version = s.advertised_tls_version
-        if tls_version >= 0x0304:
+        if tls_version >= 0x0304 and not s.post_handshake:
             s.prcs = readConnState(ciphersuite=type(s.rcs.ciphersuite),
                                    connection_end=s.connection_end,
                                    tls_version=s.tls_version)
             s.triggered_prcs_commit = True
             if s.connection_end == "client":
                 s.compute_tls13_traffic_secrets()
             elif s.connection_end == "server":
                 s.compute_tls13_traffic_secrets_end()
                 s.compute_tls13_resumption_secret()
+        if s.connection_end == "server":
+            s.post_handshake = True
+            s.post_handshake_messages = []
 
 
 # Additional handshake messages
 
 ###############################################################################
 #   HelloVerifyRequest                                                        #
 ###############################################################################
@@ -1650,15 +1690,14 @@
         if fval == 0:
             # ticket_age_add is a random 32-bit value
             self.ticket_age_add = struct.unpack("!I", os.urandom(4))[0]
 
         return _TLSHandshake.build(self)
 
     def post_dissection_tls_session_update(self, msg_str):
-        self.tls_session_update(msg_str)
         if self.tls_session.connection_end == "client":
             self.tls_session.client_session_ticket = self.ticket
 
 
 ###############################################################################
 #   EndOfEarlyData                                                            #
 ###############################################################################
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/handshake_sslv2.py` & `scapy-2.6.0rc1/scapy/layers/tls/handshake_sslv2.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/keyexchange.py` & `scapy-2.6.0rc1/scapy/layers/tls/keyexchange.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,14 @@
 #               2015, 2016, 2017 Maxence Tury
 #               2019 Romain Perez
 
 """
 TLS key exchange logic.
 """
 
-from __future__ import absolute_import
 import math
 import struct
 
 from scapy.config import conf, crypto_validator
 from scapy.error import warning
 from scapy.fields import ByteEnumField, ByteField, EnumField, FieldLenField, \
     FieldListField, PacketField, ShortEnumField, ShortField, \
@@ -744,15 +743,15 @@
         pubkey = s.client_kx_privkey.public_key()
         y = pubkey.public_numbers().y
         self.dh_Yc = pkcs_i2osp(y, pubkey.key_size // 8)
 
         if s.client_kx_privkey and s.server_kx_pubkey:
             pms = s.client_kx_privkey.exchange(s.server_kx_pubkey)
             s.pre_master_secret = pms.lstrip(b"\x00")
-            if not s.extms or s.session_hash:
+            if not s.extms:
                 # If extms is set (extended master secret), the key will
                 # need the session hash to be computed. This is provided
                 # by the TLSClientKeyExchange. Same in all occurrences
                 s.compute_ms_and_derive_keys()
 
     def post_build(self, pkt, pay):
         if not self.dh_Yc:
@@ -778,15 +777,15 @@
             param_numbers = s.client_kx_ffdh_params.parameter_numbers()
             public_numbers = dh.DHPublicNumbers(y, param_numbers)
             s.client_kx_pubkey = public_numbers.public_key(default_backend())
 
         if s.server_kx_privkey and s.client_kx_pubkey:
             ZZ = s.server_kx_privkey.exchange(s.client_kx_pubkey)
             s.pre_master_secret = ZZ.lstrip(b"\x00")
-            if not s.extms or s.session_hash:
+            if not s.extms:
                 s.compute_ms_and_derive_keys()
 
     def guess_payload_class(self, p):
         return Padding
 
 
 class ClientECDiffieHellmanPublic(_GenericTLSSessionInheritance):
@@ -825,15 +824,15 @@
                             pkcs_i2osp(y, pubkey.key_size // 8))
             if s.client_kx_privkey and s.server_kx_pubkey:
                 pms = s.client_kx_privkey.exchange(ec.ECDH(),
                                                    s.server_kx_pubkey)
 
         if s.client_kx_privkey and s.server_kx_pubkey:
             s.pre_master_secret = pms
-            if not s.extms or s.session_hash:
+            if not s.extms:
                 s.compute_ms_and_derive_keys()
 
     def post_build(self, pkt, pay):
         if not self.ecdh_Yc:
             try:
                 self.fill_missing()
             except ImportError:
@@ -851,15 +850,15 @@
                 s.client_kx_ecdh_params,
                 self.ecdh_Yc
             )
 
         if s.server_kx_privkey and s.client_kx_pubkey:
             ZZ = s.server_kx_privkey.exchange(ec.ECDH(), s.client_kx_pubkey)
             s.pre_master_secret = ZZ
-            if not s.extms or s.session_hash:
+            if not s.extms:
                 s.compute_ms_and_derive_keys()
 
 
 # RSA Encryption (standard & export)
 
 class _UnEncryptedPreMasterSecret(Raw):
     """
@@ -915,15 +914,15 @@
         else:
             # the dispatch_hook is supposed to prevent this case
             pms = b"\x00" * 48
             err = "No server RSA key to decrypt Pre Master Secret. Skipping."
             warning(err)
 
         s.pre_master_secret = pms
-        if not s.extms or s.session_hash:
+        if not s.extms:
             s.compute_ms_and_derive_keys()
 
         return pms
 
     def post_build(self, pkt, pay):
         """
         We encrypt the premaster secret (the 48 bytes) with either the server
@@ -931,15 +930,15 @@
         message. After that step, we add the 2 bytes to provide the length, as
         described in implementation notes at the end of section 7.4.7.1.
         """
         enc = pkt
 
         s = self.tls_session
         s.pre_master_secret = enc
-        if not s.extms or s.session_hash:
+        if not s.extms:
             s.compute_ms_and_derive_keys()
 
         if s.server_tmp_rsa_key is not None:
             enc = s.server_tmp_rsa_key.encrypt(pkt, t="pkcs")
         elif s.server_certs is not None and len(s.server_certs) > 0:
             enc = s.server_certs[0].encrypt(pkt, t="pkcs")
         else:
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/keyexchange_tls13.py` & `scapy-2.6.0rc1/scapy/layers/tls/keyexchange_tls13.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,32 +12,32 @@
 
 from scapy.config import conf, crypto_validator
 from scapy.error import log_runtime
 from scapy.fields import (
     FieldLenField,
     IntField,
     PacketField,
+    PacketLenField,
     PacketListField,
     ShortEnumField,
     ShortField,
     StrFixedLenField,
     StrLenField,
     XStrLenField,
 )
-from scapy.packet import Packet, Padding
+from scapy.packet import Packet
 from scapy.layers.tls.extensions import TLS_Ext_Unknown, _tls_ext
 from scapy.layers.tls.crypto.groups import (
     _tls_named_curves,
     _tls_named_ffdh_groups,
     _tls_named_groups,
     _tls_named_groups_generate,
     _tls_named_groups_import,
     _tls_named_groups_pubbytes,
 )
-import scapy.libs.six as six
 
 if conf.crypto_valid:
     from cryptography.hazmat.primitives.asymmetric import ec
 
 
 class KeyShareEntry(Packet):
     """
@@ -164,17 +164,17 @@
                 log_runtime.info("TLS: overwriting previous server key share [%s]", pkt_info)  # noqa: E501
             group_name = _tls_named_groups[self.server_share.group]
             privshare[group_name] = self.server_share.privkey
 
             if group_name in self.tls_session.tls13_client_pubshares:
                 privkey = self.server_share.privkey
                 pubkey = self.tls_session.tls13_client_pubshares[group_name]
-                if group_name in six.itervalues(_tls_named_ffdh_groups):
+                if group_name in _tls_named_ffdh_groups.values():
                     pms = privkey.exchange(pubkey)
-                elif group_name in six.itervalues(_tls_named_curves):
+                elif group_name in _tls_named_curves.values():
                     if group_name in ["x25519", "x448"]:
                         pms = privkey.exchange(pubkey)
                     else:
                         pms = privkey.exchange(ec.ECDH(), pubkey)
                 self.tls_session.tls13_dhe_secret = pms
         return super(TLS_Ext_KeyShare_SH, self).post_build(pkt, pay)
 
@@ -187,28 +187,28 @@
                 log_runtime.info("TLS: overwriting previous server key share [%s]", pkt_info)  # noqa: E501
             group_name = _tls_named_groups[self.server_share.group]
             pubshare[group_name] = self.server_share.pubkey
 
             if group_name in self.tls_session.tls13_client_privshares:
                 pubkey = self.server_share.pubkey
                 privkey = self.tls_session.tls13_client_privshares[group_name]
-                if group_name in six.itervalues(_tls_named_ffdh_groups):
+                if group_name in _tls_named_ffdh_groups.values():
                     pms = privkey.exchange(pubkey)
-                elif group_name in six.itervalues(_tls_named_curves):
+                elif group_name in _tls_named_curves.values():
                     if group_name in ["x25519", "x448"]:
                         pms = privkey.exchange(pubkey)
                     else:
                         pms = privkey.exchange(ec.ECDH(), pubkey)
                 self.tls_session.tls13_dhe_secret = pms
             elif group_name in self.tls_session.tls13_server_privshare:
                 pubkey = self.tls_session.tls13_client_pubshares[group_name]
                 privkey = self.tls_session.tls13_server_privshare[group_name]
-                if group_name in six.itervalues(_tls_named_ffdh_groups):
+                if group_name in _tls_named_ffdh_groups.values():
                     pms = privkey.exchange(pubkey)
-                elif group_name in six.itervalues(_tls_named_curves):
+                elif group_name in _tls_named_curves.values():
                     if group_name in ["x25519", "x448"]:
                         pms = privkey.exchange(pubkey)
                     else:
                         pms = privkey.exchange(ec.ECDH(), pubkey)
                 self.tls_session.tls13_dhe_secret = pms
         return super(TLS_Ext_KeyShare_SH, self).post_dissection(r)
 
@@ -225,43 +225,44 @@
                    StrFixedLenField("iv", None, 16),
                    FieldLenField("encstatelen", None, length_of="encstate"),
                    StrLenField("encstate", "",
                                length_from=lambda pkt: pkt.encstatelen),
                    StrFixedLenField("mac", None, 32)]
 
 
-class TicketField(PacketField):
-    __slots__ = ["length_from"]
-
-    def __init__(self, name, default, length_from=None, **kargs):
-        self.length_from = length_from
-        PacketField.__init__(self, name, default, Ticket, **kargs)
-
+class TicketField(PacketLenField):
     def m2i(self, pkt, m):
-        tmp_len = self.length_from(pkt)
-        tbd, rem = m[:tmp_len], m[tmp_len:]
-        return self.cls(tbd) / Padding(rem)
+        if len(m) < 64:
+            # Minimum ticket size is 64 bytes
+            return conf.raw_layer(m)
+        return self.cls(m)
 
 
 class PSKIdentity(Packet):
     name = "PSK Identity"
     fields_desc = [FieldLenField("identity_len", None,
                                  length_of="identity"),
-                   TicketField("identity", "",
+                   TicketField("identity", "", Ticket,
                                length_from=lambda pkt: pkt.identity_len),
                    IntField("obfuscated_ticket_age", 0)]
 
+    def default_payload_class(self, payload):
+        return conf.padding_layer
+
 
 class PSKBinderEntry(Packet):
     name = "PSK Binder Entry"
     fields_desc = [FieldLenField("binder_len", None, fmt="B",
                                  length_of="binder"),
                    StrLenField("binder", "",
                                length_from=lambda pkt: pkt.binder_len)]
 
+    def default_payload_class(self, payload):
+        return conf.padding_layer
+
 
 class TLS_Ext_PreSharedKey_CH(TLS_Ext_Unknown):
     # XXX define post_build and post_dissection methods
     name = "TLS Extension - Pre Shared Key (for ClientHello)"
     fields_desc = [ShortEnumField("type", 0x29, _tls_ext),
                    ShortField("len", None),
                    FieldLenField("identities_len", None,
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/record.py` & `scapy-2.6.0rc1/scapy/layers/tls/record.py`

 * *Files 1% similar despite different names*

```diff
@@ -33,26 +33,17 @@
                                          _TLSPadField, _TLSPadLenField,
                                          _TLSLengthField, _tls_type)
 from scapy.layers.tls.crypto.pkcs1 import pkcs_i2osp
 from scapy.layers.tls.crypto.cipher_aead import AEADTagError
 from scapy.layers.tls.crypto.cipher_stream import Cipher_NULL
 from scapy.layers.tls.crypto.common import CipherError
 from scapy.layers.tls.crypto.h_mac import HMACError
-import scapy.libs.six as six
 if conf.crypto_valid_advanced:
     from scapy.layers.tls.crypto.cipher_aead import Cipher_CHACHA20_POLY1305
 
-# Util
-
-
-def _tls_version_check(version, min):
-    """Returns if version >= min, or False if version == None"""
-    if version is None:
-        return False
-    return version >= min
 
 ###############################################################################
 #   TLS Record Protocol                                                       #
 ###############################################################################
 
 
 class _TLSEncryptedContent(Raw, _GenericTLSSessionInheritance):
@@ -152,15 +143,15 @@
                     hasattr(pkt, "type") and pkt.type == 23):
                 return ret, [TLSApplicationData(data=b"")]
             elif hasattr(pkt, "type") and pkt.type == 20:
                 return ret, [TLSChangeCipherSpec()]
             else:
                 return ret, [Raw(load=b"")]
 
-        if False in six.itervalues(pkt.tls_session.rcs.cipher.ready):
+        if False in pkt.tls_session.rcs.cipher.ready.values():
             return ret, _TLSEncryptedContent(remain)
         else:
             while remain:
                 raw_msg = remain
                 p = self.m2i(pkt, remain)
                 if Padding in p:
                     pad = p[Padding]
@@ -213,15 +204,15 @@
         res = b""
         for p in val:
             res += self.i2m(pkt, p)
 
         # Add TLS13ClientHello in case of HelloRetryRequest
         # Add ChangeCipherSpec for middlebox compatibility
         if (isinstance(pkt, _GenericTLSSessionInheritance) and
-                _tls_version_check(pkt.tls_session.tls_version, 0x0304) and
+                pkt.tls_session.tls_version == 0x0304 and
                 not isinstance(pkt.msg[0], TLS13ServerHello) and
                 not isinstance(pkt.msg[0], TLS13ClientHello) and
                 not isinstance(pkt.msg[0], TLSChangeCipherSpec)):
             return s + res
 
         if not pkt.type:
             pkt.type = 0
@@ -333,16 +324,22 @@
                               s.advertised_tls_version == 0x0002) or \
                              (_ssl_looks_like_sslv2(_pkt) and (not s or
                               s.tls_version is None)):
                         from scapy.layers.tls.record_sslv2 import SSLv2
                         return SSLv2
                     # Not SSLv2: continuation
                     return _TLSEncryptedContent
+                if plen >= 5:
+                    # Check minimum length
+                    msglen = struct.unpack('!H', _pkt[3:5])[0] + 5
+                    if plen < msglen:
+                        # This is a fragment
+                        return conf.padding_layer
                 # Check TLS 1.3
-                if s and _tls_version_check(s.tls_version, 0x0304):
+                if s and s.tls_version == 0x0304:
                     _has_cipher = lambda x: (
                         x and not isinstance(x.cipher, Cipher_NULL)
                     )
                     if (_has_cipher(s.rcs) or _has_cipher(s.prcs)) and \
                             byte0 == 0x17:
                         from scapy.layers.tls.record_tls13 import TLS13
                         return TLS13
@@ -572,20 +569,32 @@
     def do_dissect_payload(self, s):
         """
         Try to dissect the following data as a TLS message.
         Note that overloading .guess_payload_class() would not be enough,
         as the TLS session to be used would get lost.
         """
         if s:
+            # Check minimum length
+            if len(s) < 5:
+                p = conf.raw_layer(s, _internal=1, _underlayer=self)
+                self.add_payload(p)
+                return
+            msglen = struct.unpack('!H', s[3:5])[0] + 5
+            if len(s) < msglen:
+                # This is a fragment
+                self.add_payload(conf.padding_layer(s))
+                return
             try:
                 p = TLS(s, _internal=1, _underlayer=self,
                         tls_session=self.tls_session)
             except KeyboardInterrupt:
                 raise
             except Exception:
+                if conf.debug_dissector:
+                    raise
                 p = conf.raw_layer(s, _internal=1, _underlayer=self)
             self.add_payload(p)
 
     # Building methods
 
     def _tls_compress(self, s):
         """
@@ -731,19 +740,19 @@
                 self.tls_session.wcs = self.tls_session.pwcs
                 self.tls_session.pwcs = None
             self.tls_session.triggered_pwcs_commit = False
 
         return hdr + efrag + pay
 
     def mysummary(self):
-        s = super(TLS, self).mysummary()
+        s, n = super(TLS, self).mysummary()
         if self.msg:
             s += " / "
             s += " / ".join(getattr(x, "_name", x.name) for x in self.msg)
-        return s
+        return s, n
 
 ###############################################################################
 #   TLS ChangeCipherSpec                                                      #
 ###############################################################################
 
 
 _tls_changecipherspec_type = {1: "change_cipher_spec"}
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/record_sslv2.py` & `scapy-2.6.0rc1/scapy/layers/tls/record_sslv2.py`

 * *Files 0% similar despite different names*

```diff
@@ -137,15 +137,15 @@
         else:
             cfrag, pad = pfrag[:-padlen], pfrag[-padlen:]
 
         # Verify integrity
         is_mac_ok = self._sslv2_mac_verify(cfrag + pad, mac)
         if not is_mac_ok:
             pkt_info = self.firstlayer().summary()
-            log_runtime.info("TLS: record integrity check failed [%s]", pkt_info)  # noqa: E501
+            log_runtime.info("SSLv2: record integrity check failed [%s]", pkt_info)  # noqa: E501
 
         reconstructed_body = mac + cfrag + pad
         return hdr + reconstructed_body + r
 
     def post_dissect(self, s):
         """
         SSLv2 may force us to commit the write connState here.
@@ -170,15 +170,15 @@
         if s:
             try:
                 p = SSLv2(s, _internal=1, _underlayer=self,
                           tls_session=self.tls_session)
             except KeyboardInterrupt:
                 raise
             except Exception:
-                if conf.debug_dissect:
+                if conf.debug_dissector:
                     raise
                 p = conf.raw_layer(s, _internal=1, _underlayer=self)
             self.add_payload(p)
 
     # Building methods
 
     def _sslv2_mac_add(self, msg):
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/record_tls13.py` & `scapy-2.6.0rc1/scapy/layers/tls/record_tls13.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 ApplicationData submessages. For the Handshake type, see tls_handshake.py.
 
 See the TLS class documentation for more information.
 """
 
 import struct
 
-from scapy.config import conf
 from scapy.error import log_runtime, warning
 from scapy.compat import raw, orb
 from scapy.fields import ByteEnumField, PacketField, XStrField
 from scapy.layers.tls.session import _GenericTLSSessionInheritance
 from scapy.layers.tls.basefields import _TLSVersionField, _tls_version, \
     _TLSMACField, _TLSLengthField, _tls_type
 from scapy.layers.tls.record import _TLSMsgListField, TLS
@@ -121,15 +120,15 @@
                     pkcs_i2osp(len(s), 2))
         try:
             return rcs.cipher.auth_decrypt(add_data, s, read_seq_num)
         except CipherError as e:
             return e.args
         except AEADTagError as e:
             pkt_info = self.firstlayer().summary()
-            log_runtime.info("TLS: record integrity check failed [%s]", pkt_info)  # noqa: E501
+            log_runtime.info("TLS 1.3: record integrity check failed [%s]", pkt_info)  # noqa: E501
             return e.args
 
     def pre_dissect(self, s):
         """
         Decrypt, verify and decompress the message.
         """
         # We commit the pending read state if it has been triggered.
@@ -168,23 +167,15 @@
 
     def do_dissect_payload(self, s):
         """
         Try to dissect the following data as a TLS message.
         Note that overloading .guess_payload_class() would not be enough,
         as the TLS session to be used would get lost.
         """
-        if s:
-            try:
-                p = TLS(s, _internal=1, _underlayer=self,
-                        tls_session=self.tls_session)
-            except KeyboardInterrupt:
-                raise
-            except Exception:
-                p = conf.raw_layer(s, _internal=1, _underlayer=self)
-            self.add_payload(p)
+        return TLS.do_dissect_payload(self, s)
 
     # Building methods
 
     def _tls_auth_encrypt(self, s):
         """
         Return the TLSCiphertext.encrypted_record for AEAD ciphers.
         """
@@ -219,7 +210,14 @@
         if self.tls_session.triggered_pwcs_commit:
             if self.tls_session.pwcs is not None:
                 self.tls_session.wcs = self.tls_session.pwcs
                 self.tls_session.pwcs = None
             self.tls_session.triggered_pwcs_commit = False
 
         return hdr + frag + pay
+
+    def mysummary(self):
+        s, n = super(TLS13, self).mysummary()
+        if self.inner and self.inner.msg:
+            s += " / "
+            s += " / ".join(getattr(x, "_name", x.name) for x in self.inner.msg)
+        return s, n
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/session.py` & `scapy-2.6.0rc1/scapy/layers/tls/session.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,47 +6,48 @@
 #               2019 Romain Perez
 
 """
 TLS session handler.
 """
 
 import binascii
+import collections
 import socket
 import struct
 
 from scapy.config import conf
 from scapy.compat import raw
-import scapy.libs.six as six
 from scapy.error import log_runtime, warning
 from scapy.packet import Packet
 from scapy.pton_ntop import inet_pton
-from scapy.sessions import DefaultSession
+from scapy.sessions import TCPSession
 from scapy.utils import repr_hex, strxor
 from scapy.layers.inet import TCP
 from scapy.layers.tls.crypto.compression import Comp_NULL
 from scapy.layers.tls.crypto.hkdf import TLS13_HKDF
 from scapy.layers.tls.crypto.prf import PRF
 
 # Typing imports
-from scapy.compat import Dict
+from typing import Dict
 
 
 def load_nss_keys(filename):
     # type: (str) -> Dict[str, bytes]
     """
     Parses a NSS Keys log and returns unpacked keys in a dictionary.
     """
-    keys = {}
+    # http://udn.realityripple.com/docs/Mozilla/Projects/NSS/Key_Log_Format
+    keys = collections.defaultdict(dict)
     try:
         fd = open(filename)
         fd.close()
     except FileNotFoundError:
         warning("Cannot open NSS Key Log: %s", filename)
         return {}
-    else:
+    try:
         with open(filename) as fd:
             for line in fd:
                 if line.startswith("#"):
                     continue
                 data = line.strip().split(" ")
                 if len(data) != 3 or data[0] != data[0].upper():
                     warning("Invalid NSS Key Log Entry: %s", line.strip())
@@ -62,20 +63,22 @@
                     secret = binascii.unhexlify(data[2])
                 except binascii.Error:
                     warning("Invalid Secret: %s", data[2])
                     return {}
 
                 # Warn that a duplicated entry was detected. The latest one
                 # will be kept in the resulting dictionary.
-                if data[0] in keys:
+                if client_random in keys[data[0]]:
                     warning("Duplicated entry for %s !", data[0])
 
-                keys[data[0]] = {"ClientRandom": client_random,
-                                 "Secret": secret}
+                keys[data[0]][client_random] = secret
         return keys
+    except UnicodeDecodeError as ex:
+        warning("Cannot read NSS Key Log: %s %s", filename, str(ex))
+        return {}
 
 
 # Note the following import may happen inside connState.__init__()
 # in order to avoid to avoid cyclical dependencies.
 # from scapy.layers.tls.crypto.suites import TLS_NULL_WITH_NULL_NULL
 
 
@@ -365,14 +368,17 @@
         # Network settings
         self.ipsrc = ipsrc
         self.ipdst = ipdst
         self.sport = sport
         self.dport = dport
         self.sid = sid
 
+        # Identify duplicate sessions
+        self.firsttcp = None
+
         # Our TCP socket. None until we send (or receive) a packet.
         self.sock = None
 
         # Connection states
         self.connection_end = connection_end
 
         if wcs is None:
@@ -494,24 +500,29 @@
         # These attributes should only be used with TLS 1.3 connections.
         self.tls13_psk_secret = None
         self.tls13_early_secret = None
         self.tls13_dhe_secret = None
         self.tls13_handshake_secret = None
         self.tls13_master_secret = None
         self.tls13_derived_secrets = {}
-        self.post_handshake_auth = False
+        self.tls13_cert_req_ctxt = False
+        self.post_handshake = False  # whether handshake is done
+        self.post_handshake_auth = False  # whether "Post-Handshake Auth" is used
         self.tls13_ticket_ciphersuite = None
         self.tls13_retry = False
         self.middlebox_compatibility = False
 
         # Handshake messages needed for Finished computation/validation.
         # No record layer headers, no HelloRequests, no ChangeCipherSpecs.
         self.handshake_messages = []
         self.handshake_messages_parsed = []
 
+        # Post-handshake, handshake messages for post-handshake client authentication
+        self.post_handshake_messages = []
+
         # Flag, whether we derive the secret as Extended MS or not
         self.extms = False
         self.session_hash = None
 
         self.encrypt_then_mac = False
 
         # All exchanged TLS packets.
@@ -526,35 +537,50 @@
                 self.wcs.connection_end = val
             if hasattr(self, "prcs") and self.prcs:
                 self.prcs.connection_end = val
             if hasattr(self, "pwcs") and self.pwcs:
                 self.pwcs.connection_end = val
         super(tlsSession, self).__setattr__(name, val)
 
+    # Get infos from underlayer
+
+    def set_underlayer(self, _underlayer):
+        if isinstance(_underlayer, TCP):
+            tcp = _underlayer
+            self.sport = tcp.sport
+            self.dport = tcp.dport
+            try:
+                self.ipsrc = tcp.underlayer.src
+                self.ipdst = tcp.underlayer.dst
+            except AttributeError:
+                pass
+            if self.firsttcp is None:
+                self.firsttcp = tcp.seq
+
     # Mirroring
 
     def mirror(self):
         """
         This function takes a tlsSession object and swaps the IP addresses,
         ports, connection ends and connection states. The triggered_commit are
         also swapped (though it is probably overkill, it is cleaner this way).
 
         It is useful for static analysis of a series of messages from both the
         client and the server. In such a situation, it should be used every
         time the message being read comes from a different side than the one
         read right before, as the reading state becomes the writing state, and
-        vice versa. For instance you could do:
+        vice versa. For instance you could do::
 
-        client_hello = open('client_hello.raw').read()
-        <read other messages>
+            client_hello = open('client_hello.raw').read()
+            <read other messages>
 
-        m1 = TLS(client_hello)
-        m2 = TLS(server_hello, tls_session=m1.tls_session.mirror())
-        m3 = TLS(server_cert, tls_session=m2.tls_session)
-        m4 = TLS(client_keyexchange, tls_session=m3.tls_session.mirror())
+            m1 = TLS(client_hello)
+            m2 = TLS(server_hello, tls_session=m1.tls_session.mirror())
+            m3 = TLS(server_cert, tls_session=m2.tls_session)
+            m4 = TLS(client_keyexchange, tls_session=m3.tls_session.mirror())
         """
 
         self.ipdst, self.ipsrc = self.ipsrc, self.ipdst
         self.dport, self.sport = self.sport, self.dport
 
         self.rcs, self.wcs = self.wcs, self.rcs
         if self.rcs:
@@ -595,20 +621,24 @@
                                                  self.server_random,
                                                  self.extms,
                                                  self.session_hash)
         self.master_secret = ms
         if conf.debug_tls:
             log_runtime.debug("TLS: master secret: %s", repr_hex(ms))
 
-    def compute_ms_and_derive_keys(self):
+    def use_nss_master_secret_if_present(self) -> bool:
         # Load the master secret from an NSS Key dictionary
-        if self.nss_keys and self.nss_keys.get("CLIENT_RANDOM", False) and \
-           self.nss_keys["CLIENT_RANDOM"].get("Secret", False):
-            self.master_secret = self.nss_keys["CLIENT_RANDOM"]["Secret"]
+        if not self.nss_keys or "CLIENT_RANDOM" not in self.nss_keys:
+            return False
+        if self.client_random in self.nss_keys["CLIENT_RANDOM"]:
+            self.master_secret = self.nss_keys["CLIENT_RANDOM"][self.client_random]
+            return True
+        return False
 
+    def compute_ms_and_derive_keys(self):
         if not self.master_secret:
             self.compute_master_secret()
 
         self.prcs.derive_keys(client_random=self.client_random,
                               server_random=self.server_random,
                               master_secret=self.master_secret)
         self.pwcs.derive_keys(client_random=self.client_random,
@@ -775,35 +805,58 @@
     def compute_tls13_traffic_secrets_end(self):
         cts0 = self.tls13_derived_secrets["client_traffic_secrets"][0]
         if self.connection_end == "server":
             self.prcs.tls13_derive_keys(cts0)
         elif self.connection_end == "client":
             self.pwcs.tls13_derive_keys(cts0)
 
-    def compute_tls13_verify_data(self, connection_end, read_or_write):
-        shts = "server_handshake_traffic_secret"
-        chts = "client_handshake_traffic_secret"
+    def compute_tls13_verify_data(self, connection_end, read_or_write,
+                                  handshake_context):
+        # RFC8446 - 4.4
+        # +-----------+-------------------------+-----------------------------+
+        # | Mode      | Handshake Context       | Base Key                    |
+        # +-----------+-------------------------+-----------------------------+
+        # | Server    | ClientHello ... later   | server_handshake_traffic_   |
+        # |           | of EncryptedExtensions/ | secret                      |
+        # |           | CertificateRequest      |                             |
+        # |           |                         |                             |
+        # | Client    | ClientHello ... later   | client_handshake_traffic_   |
+        # |           | of server               | secret                      |
+        # |           | Finished/EndOfEarlyData |                             |
+        # |           |                         |                             |
+        # | Post-     | ClientHello ... client  | client_application_traffic_ |
+        # | Handshake | Finished +              | secret_N                    |
+        # |           | CertificateRequest      |                             |
+        # +-----------+-------------------------+-----------------------------+
+        if self.post_handshake:
+            # RFC8446 - 4.6
+            # TLS also allows other messages to be sent after the main handshake.
+            # These messages use a handshake content type and are encrypted under
+            # the appropriate application traffic key.
+            shts = self.tls13_derived_secrets["server_traffic_secrets"][-1]
+            chts = self.tls13_derived_secrets["client_traffic_secrets"][-1]
+        else:
+            shts = self.tls13_derived_secrets["server_handshake_traffic_secret"]
+            chts = self.tls13_derived_secrets["client_handshake_traffic_secret"]
         if read_or_write == "read":
             hkdf = self.rcs.hkdf
             if connection_end == "client":
-                basekey = self.tls13_derived_secrets[shts]
+                basekey = shts
             elif connection_end == "server":
-                basekey = self.tls13_derived_secrets[chts]
+                basekey = chts
         elif read_or_write == "write":
             hkdf = self.wcs.hkdf
             if connection_end == "client":
-                basekey = self.tls13_derived_secrets[chts]
+                basekey = chts
             elif connection_end == "server":
-                basekey = self.tls13_derived_secrets[shts]
+                basekey = shts
 
         if not hkdf or not basekey:
             warning("Missing arguments for verify_data computation!")
             return None
-        # XXX this join() works in standard cases, but does it in all of them?
-        handshake_context = b"".join(self.handshake_messages)
         return hkdf.compute_verify_data(basekey, handshake_context)
 
     def compute_tls13_resumption_secret(self):
         """
         self.handshake_messages should be ClientHello...ClientFinished.
         """
         if self.connection_end == "server":
@@ -857,15 +910,15 @@
                 self.pwcs.tls13_derive_keys(stsN_1)
 
     # Tests for record building/parsing
 
     def consider_read_padding(self):
         # Return True if padding is needed. Used by TLSPadField.
         return (self.rcs.cipher.type == "block" and
-                not (False in six.itervalues(self.rcs.cipher.ready)))
+                not (False in self.rcs.cipher.ready.values()))
 
     def consider_write_padding(self):
         # Return True if padding is needed. Used by TLSPadField.
         return self.wcs.cipher.type == "block"
 
     def use_explicit_iv(self, version, cipher_type):
         # Return True if an explicit IV is needed. Required for TLS 1.1+
@@ -900,21 +953,28 @@
         if ok:
             if self.sid and other.sid:
                 return self.sid == other.sid
             return True
 
         return False
 
-    def __repr__(self):
+    def repr(self, _underlayer=None):
         sid = repr(self.sid)
         if len(sid) > 12:
             sid = sid[:11] + "..."
+        if _underlayer and _underlayer.dport != self.dport:
+            return "%s:%s > %s:%s" % (self.ipdst, str(self.dport),
+                                      self.ipsrc, str(self.sport))
         return "%s:%s > %s:%s" % (self.ipsrc, str(self.sport),
                                   self.ipdst, str(self.dport))
 
+    def __repr__(self):
+        return self.repr()
+
+
 ###############################################################################
 #   Session singleton                                                         #
 ###############################################################################
 
 
 class _GenericTLSSessionInheritance(Packet):
     """
@@ -943,22 +1003,16 @@
             else:
                 self.tls_session = tls_session
 
         self.rcs_snap_init = self.tls_session.rcs.snapshot()
         self.wcs_snap_init = self.tls_session.wcs.snapshot()
 
         if isinstance(_underlayer, TCP):
-            tcp = _underlayer
-            self.tls_session.sport = tcp.sport
-            self.tls_session.dport = tcp.dport
-            try:
-                self.tls_session.ipsrc = tcp.underlayer.src
-                self.tls_session.ipdst = tcp.underlayer.dst
-            except AttributeError:
-                pass
+            # Get information from _underlayer
+            self.tls_session.set_underlayer(_underlayer)
 
             # Load a NSS Key Log file
             if conf.tls_nss_filename is not None:
                 if conf.tls_nss_keys is None:
                     conf.tls_nss_keys = load_nss_keys(conf.tls_nss_filename)
 
             if conf.tls_session_enable:
@@ -1076,33 +1130,60 @@
         s.frozen = True
         self.__class__(built_packet, tls_session=s).show()
         s.frozen = False
 
         s.rcs = rcs_snap
         s.wcs = wcs_snap
 
-    def mysummary(self):
-        return "TLS %s / %s" % (repr(self.tls_session),
-                                getattr(self, "_name", self.name))
+    def mysummary(self, first=True):
+        from scapy.layers.tls.record import TLS
+        from scapy.layers.tls.record_tls13 import TLS13
+        if (
+            self.underlayer and
+            isinstance(self.underlayer, _GenericTLSSessionInheritance)
+        ):
+            summary = getattr(self, "_name", self.name)
+        else:
+            _underlayer = None
+            if self.underlayer and isinstance(self.underlayer, TCP):
+                _underlayer = self.underlayer
+            summary = "TLS %s / %s" % (
+                self.tls_session.repr(_underlayer=_underlayer),
+                getattr(self, "_name", self.name)
+            )
+        return summary, [TLS, TLS13]
 
     @classmethod
     def tcp_reassemble(cls, data, metadata, session):
-        # Used with TLSSession
+        # Used with TCPSession
         from scapy.layers.tls.record import TLS
         from scapy.layers.tls.record_tls13 import TLS13
         if cls in (TLS, TLS13):
             length = struct.unpack("!H", data[3:5])[0] + 5
-            if len(data) == length:
-                return cls(data)
-            elif len(data) > length:
-                pkt = cls(data)
-                if hasattr(pkt.payload, "tcp_reassemble"):
-                    return pkt.payload.tcp_reassemble(data[length:], metadata, session)
-                else:
-                    return pkt
+            if len(data) >= length:
+                # get the underlayer as it is used to populate tls_session
+                underlayer = metadata["original"][TCP].copy()
+                underlayer.remove_payload()
+                # eventually get the tls_session now for TLS.dispatch_hook
+                tls_session = None
+                if conf.tls_session_enable:
+                    s = tlsSession()
+                    s.set_underlayer(underlayer)
+                    tls_session = conf.tls_sessions.find(s)
+                    if tls_session:
+                        if tls_session.dport != underlayer.dport:
+                            tls_session = tls_session.mirror()
+                        if tls_session.firsttcp == underlayer.seq:
+                            log_runtime.info(
+                                "TLS: session %s is a duplicate of a previous "
+                                "dissection. Discard it" % repr(tls_session)
+                            )
+                            conf.tls_sessions.rem(tls_session, force=True)
+                            tls_session = None
+                return cls(data, _underlayer=underlayer, tls_session=tls_session)
         else:
             return cls(data)
 
 
 ###############################################################################
 #   Multiple TLS sessions                                                     #
 ###############################################################################
@@ -1120,67 +1201,68 @@
 
         h = session.hash()
         if h in self.sessions:
             self.sessions[h].append(session)
         else:
             self.sessions[h] = [session]
 
-    def rem(self, session):
-        s = self.find(session)
-        if s:
-            log_runtime.info("TLS: previous session shall not be overwritten")
-            return
+    def rem(self, session, force=False):
+        if not force:
+            s = self.find(session)
+            if s:
+                log_runtime.info("TLS: previous session shall not be overwritten")
+                return
 
         h = session.hash()
         self.sessions[h].remove(session)
 
     def find(self, session):
         try:
             h = session.hash()
         except Exception:
             return None
         if h in self.sessions:
             for k in self.sessions[h]:
                 if k.eq(session):
-                    if conf.tls_verbose:
+                    if conf.debug_tls:
                         log_runtime.info("TLS: found session matching %s", k)
                     return k
-        if conf.tls_verbose:
+        if conf.debug_tls:
             log_runtime.info("TLS: did not find session matching %s", session)
         return None
 
     def __repr__(self):
         res = [("First endpoint", "Second endpoint", "Session ID")]
-        for li in six.itervalues(self.sessions):
+        for li in self.sessions.values():
             for s in li:
                 src = "%s[%d]" % (s.ipsrc, s.sport)
                 dst = "%s[%d]" % (s.ipdst, s.dport)
                 sid = repr(s.sid)
                 if len(sid) > 12:
                     sid = sid[:11] + "..."
                 res.append((src, dst, sid))
         colwidth = (max(len(y) for y in x) for x in zip(*res))
         fmt = "  ".join(map(lambda x: "%%-%ds" % x, colwidth))
         return "\n".join(map(lambda x: fmt % x, res))
 
 
-class TLSSession(DefaultSession):
+class TLSSession(TCPSession):
     def __init__(self, *args, **kwargs):
+        # XXX this doesn't bring any value.
+        warning(
+            "TLSSession is deprecated and will be removed in a future version. "
+            "Please use TCPSession instead with conf.tls_session_enable=True"
+        )
         server_rsa_key = kwargs.pop("server_rsa_key", None)
         super(TLSSession, self).__init__(*args, **kwargs)
         self._old_conf_status = conf.tls_session_enable
         conf.tls_session_enable = True
         if server_rsa_key:
             conf.tls_sessions.server_rsa_key = server_rsa_key
 
     def toPacketList(self):
         conf.tls_session_enable = self._old_conf_status
         return super(TLSSession, self).toPacketList()
 
 
+# Instantiate the TLS sessions holder
 conf.tls_sessions = _tls_sessions()
-conf.tls_session_enable = False
-conf.tls_verbose = False
-# Filename containing NSS Keys Log
-conf.tls_nss_filename = None
-# Dictionary containing parsed NSS Keys
-conf.tls_nss_keys = None
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tls/tools.py` & `scapy-2.6.0rc1/scapy/layers/tls/tools.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,14 @@
 # Copyright (C) 2007, 2008, 2009 Arnaud Ebalard
 #               2015, 2016, 2017 Maxence Tury
 
 """
 TLS helpers, provided as out-of-context methods.
 """
 
-from __future__ import absolute_import
 import struct
 
 from scapy.compat import orb, chb
 from scapy.error import warning
 from scapy.fields import (ByteEnumField, ShortEnumField,
                           FieldLenField, StrLenField)
 from scapy.packet import Packet
```

### Comparing `scapy-2.5.0rc3/scapy/layers/tuntap.py` & `scapy-2.6.0rc1/scapy/layers/tuntap.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,17 +6,15 @@
 
 """
 Implementation of TUN/TAP interfaces.
 
 These allow Scapy to act as the remote side of a virtual network interface.
 """
 
-from __future__ import absolute_import
 
-import os
 import socket
 import time
 from fcntl import ioctl
 
 from scapy.compat import raw, bytes_encode
 from scapy.config import conf
 from scapy.consts import BIG_ENDIAN, BSD, LINUX
@@ -26,15 +24,14 @@
 from scapy.interfaces import network_name
 from scapy.layers.inet import IP
 from scapy.layers.inet6 import IPv46, IPv6
 from scapy.layers.l2 import Ether
 from scapy.packet import Packet
 from scapy.supersocket import SimpleSocket
 
-import scapy.libs.six as six
 
 # Linux-specific defines (/usr/include/linux/if_tun.h)
 LINUX_TUNSETIFF = 0x400454ca
 LINUX_IFF_TUN = 0x0001
 LINUX_IFF_TAP = 0x0002
 LINUX_IFF_NO_PI = 0x1000
 LINUX_IFNAMSIZ = 16
@@ -206,20 +203,15 @@
 
     def recv_raw(self, x=None):
         if x is None:
             x = self.default_read_size
 
         x += self.mtu_overhead
 
-        if six.PY2:
-            # For some mystical reason, using self.ins.read ignores
-            # buffering=0 on python 2.7 and blocks ?!
-            dat = os.read(self.ins.fileno(), x)
-        else:
-            dat = self.ins.read(x)
+        dat = self.ins.read(x)
         r = self.kernel_packet_class, dat, time.time()
         if self.mtu_overhead > 0 and self.strip_packet_info:
             # Get the packed class of the payload, without triggering a full
             # decode of the payload data.
             cls = r[0](r[1][:self.mtu_overhead]).guess_payload_class(b'')
 
             # Return the payload data only
```

### Comparing `scapy-2.5.0rc3/scapy/layers/vrrp.py` & `scapy-2.6.0rc1/scapy/layers/vrrp.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/vxlan.py` & `scapy-2.6.0rc1/scapy/layers/vxlan.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/layers/x509.py` & `scapy-2.6.0rc1/scapy/layers/x509.py`

 * *Files 4% similar despite different names*

```diff
@@ -21,15 +21,15 @@
     ASN1F_FLAGS, ASN1F_GENERALIZED_TIME, ASN1F_IA5_STRING, ASN1F_INTEGER, \
     ASN1F_ISO646_STRING, ASN1F_NULL, ASN1F_OID, ASN1F_PACKET, \
     ASN1F_PRINTABLE_STRING, ASN1F_SEQUENCE, ASN1F_SEQUENCE_OF, ASN1F_SET_OF, \
     ASN1F_STRING, ASN1F_T61_STRING, ASN1F_UNIVERSAL_STRING, ASN1F_UTC_TIME, \
     ASN1F_UTF8_STRING, ASN1F_badsequence, ASN1F_enum_INTEGER, ASN1F_field, \
     ASN1F_optional
 from scapy.packet import Packet
-from scapy.fields import PacketField
+from scapy.fields import PacketField, MultipleTypeField
 from scapy.volatile import ZuluTime, GeneralizedTime
 from scapy.compat import plain_str
 
 
 class ASN1P_OID(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_OID("oid", "0")
@@ -760,71 +760,33 @@
     ASN1_root = ASN1F_SEQUENCE(
         ASN1F_OID("algorithm", "1.2.840.113549.1.1.11"),
         ASN1F_optional(
             ASN1F_CHOICE("parameters", ASN1_NULL(0),
                          ASN1F_NULL, ECParameters)))
 
 
-class ASN1F_X509_SubjectPublicKeyInfoRSA(ASN1F_SEQUENCE):
-    def __init__(self, **kargs):
-        seq = [ASN1F_PACKET("signatureAlgorithm",
-                            X509_AlgorithmIdentifier(),
-                            X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING_ENCAPS("subjectPublicKey",
-                                       RSAPublicKey(),
-                                       RSAPublicKey)]
-        ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
-
-
-class ASN1F_X509_SubjectPublicKeyInfoECDSA(ASN1F_SEQUENCE):
-    def __init__(self, **kargs):
-        seq = [ASN1F_PACKET("signatureAlgorithm",
-                            X509_AlgorithmIdentifier(),
-                            X509_AlgorithmIdentifier),
-               ASN1F_PACKET("subjectPublicKey", ECDSAPublicKey(),
-                            ECDSAPublicKey)]
-        ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
-
-
 class ASN1F_X509_SubjectPublicKeyInfo(ASN1F_SEQUENCE):
     def __init__(self, **kargs):
         seq = [ASN1F_PACKET("signatureAlgorithm",
                             X509_AlgorithmIdentifier(),
                             X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING("subjectPublicKey", None)]
+               MultipleTypeField(
+                   [
+                       (ASN1F_BIT_STRING_ENCAPS("subjectPublicKey",
+                                                RSAPublicKey(),
+                                                RSAPublicKey),
+                        lambda pkt: "rsa" in pkt.signatureAlgorithm.algorithm.oidname.lower()),  # noqa: E501
+                       (ASN1F_PACKET("subjectPublicKey",
+                                     ECDSAPublicKey(),
+                                     ECDSAPublicKey),
+                        lambda pkt: "ecPublicKey" == pkt.signatureAlgorithm.algorithm.oidname),  # noqa: E501
+                   ],
+                   ASN1F_BIT_STRING("subjectPublicKey", ""))]
         ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
 
-    def m2i(self, pkt, x):
-        c, s = ASN1F_SEQUENCE.m2i(self, pkt, x)
-        keytype = pkt.fields["signatureAlgorithm"].algorithm.oidname
-        if "rsa" in keytype.lower():
-            return ASN1F_X509_SubjectPublicKeyInfoRSA().m2i(pkt, x)
-        elif keytype == "ecPublicKey":
-            return ASN1F_X509_SubjectPublicKeyInfoECDSA().m2i(pkt, x)
-        else:
-            raise Exception("could not parse subjectPublicKeyInfo")
-
-    def dissect(self, pkt, s):
-        c, x = self.m2i(pkt, s)
-        return x
-
-    def build(self, pkt):
-        if "signatureAlgorithm" in pkt.fields:
-            ktype = pkt.fields['signatureAlgorithm'].algorithm.oidname
-        else:
-            ktype = pkt.default_fields["signatureAlgorithm"].algorithm.oidname
-        if "rsa" in ktype.lower():
-            pkt.default_fields["subjectPublicKey"] = RSAPublicKey()
-            return ASN1F_X509_SubjectPublicKeyInfoRSA().build(pkt)
-        elif ktype == "ecPublicKey":
-            pkt.default_fields["subjectPublicKey"] = ECDSAPublicKey()
-            return ASN1F_X509_SubjectPublicKeyInfoECDSA().build(pkt)
-        else:
-            raise Exception("could not build subjectPublicKeyInfo")
-
 
 class X509_SubjectPublicKeyInfo(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_X509_SubjectPublicKeyInfo()
 
 
 #      OpenSSL compatibility wrappers      #
@@ -1000,67 +962,33 @@
         for attrType in sorted(attrsDict):
             if attrType not in _attrName_specials:
                 name_str += "/" + attrType + "="
                 name_str += attrsDict[attrType]
         return name_str
 
 
-class ASN1F_X509_CertECDSA(ASN1F_SEQUENCE):
-    def __init__(self, **kargs):
-        seq = [ASN1F_PACKET("tbsCertificate",
-                            X509_TBSCertificate(),
-                            X509_TBSCertificate),
-               ASN1F_PACKET("signatureAlgorithm",
-                            X509_AlgorithmIdentifier(),
-                            X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING_ENCAPS("signatureValue",
-                                       ECDSASignature(),
-                                       ECDSASignature)]
-        ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
-
-
 class ASN1F_X509_Cert(ASN1F_SEQUENCE):
     def __init__(self, **kargs):
         seq = [ASN1F_PACKET("tbsCertificate",
                             X509_TBSCertificate(),
                             X509_TBSCertificate),
                ASN1F_PACKET("signatureAlgorithm",
                             X509_AlgorithmIdentifier(),
                             X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING("signatureValue",
-                                "defaultsignature" * 2)]
+               MultipleTypeField(
+                   [
+                       (ASN1F_BIT_STRING_ENCAPS("signatureValue",
+                                                ECDSASignature(),
+                                                ECDSASignature),
+                        lambda pkt: "ecdsa" in pkt.signatureAlgorithm.algorithm.oidname.lower()),  # noqa: E501
+                   ],
+                   ASN1F_BIT_STRING("signatureValue",
+                                    "defaultsignature" * 2))]
         ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
 
-    def m2i(self, pkt, x):
-        c, s = ASN1F_SEQUENCE.m2i(self, pkt, x)
-        sigtype = pkt.fields["signatureAlgorithm"].algorithm.oidname
-        if "rsa" in sigtype.lower():
-            return c, s
-        elif "ecdsa" in sigtype.lower():
-            return ASN1F_X509_CertECDSA().m2i(pkt, x)
-        else:
-            raise Exception("could not parse certificate")
-
-    def dissect(self, pkt, s):
-        c, x = self.m2i(pkt, s)
-        return x
-
-    def build(self, pkt):
-        if "signatureAlgorithm" in pkt.fields:
-            sigtype = pkt.fields['signatureAlgorithm'].algorithm.oidname
-        else:
-            sigtype = pkt.default_fields["signatureAlgorithm"].algorithm.oidname  # noqa: E501
-        if "rsa" in sigtype.lower():
-            return ASN1F_SEQUENCE.build(self, pkt)
-        elif "ecdsa" in sigtype.lower():
-            pkt.default_fields["signatureValue"] = ECDSASignature()
-            return ASN1F_X509_CertECDSA().build(pkt)
-        else:
-            raise Exception("could not build certificate")
-
 
 class X509_Cert(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_X509_Cert()
 
 
 #       TBSCertList & CRL       #
@@ -1117,67 +1045,33 @@
         for attrType in sorted(attrsDict):
             if attrType not in _attrName_specials:
                 name_str += "/" + attrType + "="
                 name_str += attrsDict[attrType]
         return name_str
 
 
-class ASN1F_X509_CRLECDSA(ASN1F_SEQUENCE):
-    def __init__(self, **kargs):
-        seq = [ASN1F_PACKET("tbsCertList",
-                            X509_TBSCertList(),
-                            X509_TBSCertList),
-               ASN1F_PACKET("signatureAlgorithm",
-                            X509_AlgorithmIdentifier(),
-                            X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING_ENCAPS("signatureValue",
-                                       ECDSASignature(),
-                                       ECDSASignature)]
-        ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
-
-
 class ASN1F_X509_CRL(ASN1F_SEQUENCE):
     def __init__(self, **kargs):
         seq = [ASN1F_PACKET("tbsCertList",
                             X509_TBSCertList(),
                             X509_TBSCertList),
                ASN1F_PACKET("signatureAlgorithm",
                             X509_AlgorithmIdentifier(),
                             X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING("signatureValue",
-                                "defaultsignature" * 2)]
+               MultipleTypeField(
+                   [
+                       (ASN1F_BIT_STRING_ENCAPS("signatureValue",
+                                                ECDSASignature(),
+                                                ECDSASignature),
+                        lambda pkt: "ecdsa" in pkt.signatureAlgorithm.algorithm.oidname.lower()),  # noqa: E501
+                   ],
+                   ASN1F_BIT_STRING("signatureValue",
+                                    "defaultsignature" * 2))]
         ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
 
-    def m2i(self, pkt, x):
-        c, s = ASN1F_SEQUENCE.m2i(self, pkt, x)
-        sigtype = pkt.fields["signatureAlgorithm"].algorithm.oidname
-        if "rsa" in sigtype.lower():
-            return c, s
-        elif "ecdsa" in sigtype.lower():
-            return ASN1F_X509_CRLECDSA().m2i(pkt, x)
-        else:
-            raise Exception("could not parse certificate")
-
-    def dissect(self, pkt, s):
-        c, x = self.m2i(pkt, s)
-        return x
-
-    def build(self, pkt):
-        if "signatureAlgorithm" in pkt.fields:
-            sigtype = pkt.fields['signatureAlgorithm'].algorithm.oidname
-        else:
-            sigtype = pkt.default_fields["signatureAlgorithm"].algorithm.oidname  # noqa: E501
-        if "rsa" in sigtype.lower():
-            return ASN1F_SEQUENCE.build(self, pkt)
-        elif "ecdsa" in sigtype.lower():
-            pkt.default_fields["signatureValue"] = ECDSASignature()
-            return ASN1F_X509_CRLECDSA().build(pkt)
-        else:
-            raise Exception("could not build certificate")
-
 
 class X509_CRL(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_X509_CRL()
 
 
 #############################
@@ -1204,15 +1098,15 @@
 class OCSP_RevokedInfo(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SEQUENCE(
         ASN1F_GENERALIZED_TIME("revocationTime", ""),
         ASN1F_optional(
             ASN1F_PACKET("revocationReason", None,
                          X509_ExtReasonCode,
-                         explicit_tag=0x80)))
+                         explicit_tag=0xa0)))
 
 
 class OCSP_UnknownInfo(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_NULL("info", 0)
 
 
@@ -1227,15 +1121,15 @@
                                           OCSP_UnknownInfo, implicit_tag=0x82))
 
 
 class OCSP_SingleResponse(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SEQUENCE(
         ASN1F_PACKET("certID", OCSP_CertID(), OCSP_CertID),
-        ASN1F_PACKET("certStatus", OCSP_CertStatus(),
+        ASN1F_PACKET("certStatus", OCSP_CertStatus(certStatus=OCSP_GoodInfo()),
                      OCSP_CertStatus),
         ASN1F_GENERALIZED_TIME("thisUpdate", ""),
         ASN1F_optional(
             ASN1F_GENERALIZED_TIME("nextUpdate", "",
                                    explicit_tag=0xa0)),
         ASN1F_optional(
             ASN1F_SEQUENCE_OF("singleExtensions", None,
@@ -1264,84 +1158,47 @@
 
 class OCSP_ResponseData(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SEQUENCE(
         ASN1F_optional(
             ASN1F_enum_INTEGER("version", 0, {0: "v1"},
                                explicit_tag=0x80)),
-        ASN1F_PACKET("responderID", OCSP_ResponderID(),
+        ASN1F_PACKET("responderID", OCSP_ResponderID(responderID=OCSP_ByName()),
                      OCSP_ResponderID),
         ASN1F_GENERALIZED_TIME("producedAt",
                                str(GeneralizedTime())),
         ASN1F_SEQUENCE_OF("responses", [], OCSP_SingleResponse),
         ASN1F_optional(
             ASN1F_SEQUENCE_OF("responseExtensions", None,
                               X509_Extension,
                               explicit_tag=0xa1)))
 
 
-class ASN1F_OCSP_BasicResponseECDSA(ASN1F_SEQUENCE):
-    def __init__(self, **kargs):
-        seq = [ASN1F_PACKET("tbsResponseData",
-                            OCSP_ResponseData(),
-                            OCSP_ResponseData),
-               ASN1F_PACKET("signatureAlgorithm",
-                            X509_AlgorithmIdentifier(),
-                            X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING_ENCAPS("signature",
-                                       ECDSASignature(),
-                                       ECDSASignature),
-               ASN1F_optional(
-                   ASN1F_SEQUENCE_OF("certs", None, X509_Cert,
-                                     explicit_tag=0xa0))]
-        ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
-
-
 class ASN1F_OCSP_BasicResponse(ASN1F_SEQUENCE):
     def __init__(self, **kargs):
         seq = [ASN1F_PACKET("tbsResponseData",
                             OCSP_ResponseData(),
                             OCSP_ResponseData),
                ASN1F_PACKET("signatureAlgorithm",
                             X509_AlgorithmIdentifier(),
                             X509_AlgorithmIdentifier),
-               ASN1F_BIT_STRING("signature",
-                                "defaultsignature" * 2),
+               MultipleTypeField(
+                   [
+                       (ASN1F_BIT_STRING_ENCAPS("signature",
+                                                ECDSASignature(),
+                                                ECDSASignature),
+                        lambda pkt: "ecdsa" in pkt.signatureAlgorithm.algorithm.oidname.lower()),  # noqa: E501
+                   ],
+                   ASN1F_BIT_STRING("signature",
+                                    "defaultsignature" * 2)),
                ASN1F_optional(
                    ASN1F_SEQUENCE_OF("certs", None, X509_Cert,
                                      explicit_tag=0xa0))]
         ASN1F_SEQUENCE.__init__(self, *seq, **kargs)
 
-    def m2i(self, pkt, x):
-        c, s = ASN1F_SEQUENCE.m2i(self, pkt, x)
-        sigtype = pkt.fields["signatureAlgorithm"].algorithm.oidname
-        if "rsa" in sigtype.lower():
-            return c, s
-        elif "ecdsa" in sigtype.lower():
-            return ASN1F_OCSP_BasicResponseECDSA().m2i(pkt, x)
-        else:
-            raise Exception("could not parse OCSP basic response")
-
-    def dissect(self, pkt, s):
-        c, x = self.m2i(pkt, s)
-        return x
-
-    def build(self, pkt):
-        if "signatureAlgorithm" in pkt.fields:
-            sigtype = pkt.fields['signatureAlgorithm'].algorithm.oidname
-        else:
-            sigtype = pkt.default_fields["signatureAlgorithm"].algorithm.oidname  # noqa: E501
-        if "rsa" in sigtype.lower():
-            return ASN1F_SEQUENCE.build(self, pkt)
-        elif "ecdsa" in sigtype.lower():
-            pkt.default_fields["signatureValue"] = ECDSASignature()
-            return ASN1F_OCSP_BasicResponseECDSA().build(pkt)
-        else:
-            raise Exception("could not build OCSP basic response")
-
 
 class OCSP_ResponseBytes(ASN1_Packet):
     ASN1_codec = ASN1_Codecs.BER
     ASN1_root = ASN1F_SEQUENCE(
         ASN1F_OID("responseType", "1.3.6.1.5.5.7.48.1.1"),
         ASN1F_OCSP_BasicResponse(explicit_tag=0x04))
```

### Comparing `scapy-2.5.0rc3/scapy/layers/zigbee.py` & `scapy-2.6.0rc1/scapy/layers/zigbee.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/libs/matplot.py` & `scapy-2.6.0rc1/scapy/libs/matplot.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/libs/structures.py` & `scapy-2.6.0rc1/scapy/libs/structures.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/libs/test_pyx.py` & `scapy-2.6.0rc1/scapy/libs/test_pyx.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/libs/winpcapy.py` & `scapy-2.6.0rc1/scapy/libs/winpcapy.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Massimo Ciani (2009)
 # Copyright (C) Gabriel Potter
 
 # Modified for scapy's usage - To support Npcap/Monitor mode
 #
-# NOTE: the "winpcap" in the name nonwithstanding, this is for use
+# NOTE: the "winpcap" in the name notwithstanding, this is for use
 # with libpcap on non-Windows platforms, as well as for WinPcap and Npcap.
 
 from ctypes import *
 from ctypes.util import find_library
 import os
 
 from scapy.libs.structures import bpf_program
```

### Comparing `scapy-2.5.0rc3/scapy/main.py` & `scapy-2.6.0rc1/scapy/main.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,51 +3,57 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Main module for interactive startup.
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 
+import builtins
+import pathlib
 import sys
 import os
 import getopt
 import code
 import gzip
 import glob
 import importlib
 import io
+from itertools import zip_longest
 import logging
+import pickle
 import types
 import warnings
 from random import choice
 
 # Never add any global import, in main.py, that would trigger a
 # warning message before the console handlers gets added in interact()
 from scapy.error import (
     log_interactive,
     log_loading,
     Scapy_Exception,
 )
-import scapy.libs.six as six
 from scapy.themes import DefaultTheme, BlackAndWhite, apply_ipython_style
 from scapy.consts import WINDOWS
 
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     List,
     Optional,
     Union,
+    overload,
+)
+from scapy.compat import (
+    Literal,
 )
 
 LAYER_ALIASES = {
-    "tls": "tls.all"
+    "tls": "tls.all",
+    "msrpce": "msrpce.all",
 }
 
 QUOTES = [
     ("Craft packets like it is your last day on earth.", "Lao-Tze"),
     ("Craft packets like I craft my beer.", "Jean De Clerck"),
     ("Craft packets before they craft you.", "Socrate"),
     ("Craft me if you can.", "IPv6 layer"),
@@ -55,50 +61,86 @@
      "the wires and in the waves.", "Jean-Claude Van Damme"),
     ("We are in France, we say Skappee. OK? Merci.", "Sebastien Chabal"),
     ("Wanna support scapy? Star us on GitHub!", "Satoshi Nakamoto"),
     ("What is dead may never die!", "Python 2"),
 ]
 
 
-def _probe_config_file(cf):
-    # type: (str) -> Union[str, None]
-    cf_path = os.path.join(os.path.expanduser("~"), cf)
-    try:
-        os.stat(cf_path)
-    except OSError:
-        return None
-    else:
-        return cf_path
+def _probe_xdg_folder(var, default, *cf):
+    # type: (str, str, *str) -> Optional[pathlib.Path]
+    path = pathlib.Path(os.environ.get(var, default))
+    if not path.exists():
+        # ~ folder doesn't exist. Create according to spec
+        # https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
+        # "If, when attempting to write a file, the destination directory is
+        # non-existent an attempt should be made to create it with permission 0700."
+        path.mkdir(mode=0o700)
+    return path.joinpath(*cf).resolve()
+
+
+def _probe_config_folder(*cf):
+    # type: (str) -> Optional[pathlib.Path]
+    return _probe_xdg_folder(
+        "XDG_CONFIG_HOME",
+        os.path.join(os.path.expanduser("~"), ".config"),
+        *cf
+    )
+
+
+def _probe_cache_folder(*cf):
+    # type: (str) -> Optional[pathlib.Path]
+    return _probe_xdg_folder(
+        "XDG_CACHE_HOME",
+        os.path.join(os.path.expanduser("~"), ".cache"),
+        *cf
+    )
 
 
 def _read_config_file(cf, _globals=globals(), _locals=locals(),
-                      interactive=True):
-    # type: (str, Dict[str, Any], Dict[str, Any], bool) -> None
+                      interactive=True, default=None):
+    # type: (str, Dict[str, Any], Dict[str, Any], bool, Optional[str]) -> None
     """Read a config file: execute a python file while loading scapy, that
     may contain some pre-configured values.
 
     If _globals or _locals are specified, they will be updated with
     the loaded vars.  This allows an external program to use the
     function. Otherwise, vars are only available from inside the scapy
     console.
 
-    params:
-    - _globals: the globals() vars
-    - _locals: the locals() vars
-    - interactive: specified whether or not errors should be printed
+    Parameters:
+
+    :param _globals: the globals() vars
+    :param _locals: the locals() vars
+    :param interactive: specified whether or not errors should be printed
     using the scapy console or raised.
+    :param default: if provided, set a default value for the config file
 
     ex, content of a config.py file:
         'conf.verb = 42\n'
     Manual loading:
         >>> _read_config_file("./config.py"))
         >>> conf.verb
         2
 
     """
+    cf_path = pathlib.Path(cf)
+    if not cf_path.exists():
+        log_loading.debug("Config file [%s] does not exist.", cf)
+        if default is None:
+            return
+        # We have a default ! set it
+        try:
+            cf_path.parent.mkdir(parents=True, exist_ok=True)
+            with cf_path.open("w") as fd:
+                fd.write(default)
+            log_loading.debug("Config file [%s] created with default.", cf)
+        except OSError:
+            log_loading.warning("Config file [%s] could not be created.", cf,
+                                exc_info=True)
+            return
     log_loading.debug("Loading config file [%s]", cf)
     try:
         with open(cf) as cfgf:
             exec(
                 compile(cfgf.read(), cf, 'exec'),
                 _globals, _locals
             )
@@ -115,16 +157,44 @@
 
 def _validate_local(k):
     # type: (str) -> bool
     """Returns whether or not a variable should be imported."""
     return k[0] != "_" and k not in ["range", "map"]
 
 
-DEFAULT_PRESTART_FILE = _probe_config_file(".scapy_prestart.py")
-DEFAULT_STARTUP_FILE = _probe_config_file(".scapy_startup.py")
+# This is ~/.config/scapy
+SCAPY_CONFIG_FOLDER = _probe_config_folder("scapy")
+SCAPY_CACHE_FOLDER = _probe_cache_folder("scapy")
+
+if SCAPY_CONFIG_FOLDER:
+    DEFAULT_PRESTART_FILE: Optional[str] = str(SCAPY_CONFIG_FOLDER / "prestart.py")
+    DEFAULT_STARTUP_FILE: Optional[str] = str(SCAPY_CONFIG_FOLDER / "startup.py")
+else:
+    DEFAULT_PRESTART_FILE = None
+    DEFAULT_STARTUP_FILE = None
+
+# Default scapy prestart.py config file
+
+DEFAULT_PRESTART = """
+# Scapy CLI 'pre-start' config file
+# see https://scapy.readthedocs.io/en/latest/api/scapy.config.html#scapy.config.Conf
+# for all available options
+
+# default interpreter
+conf.interactive_shell = "auto"
+
+# color theme (DefaultTheme, BrightTheme, ColorOnBlackTheme, BlackAndWhite, ...)
+conf.color_theme = DefaultTheme()
+
+# disable INFO: tags related to dependencies missing
+# log_loading.setLevel(logging.WARNING)
+
+# force-use libpcap
+# conf.use_pcap = True
+""".strip()
 
 
 def _usage():
     # type: () -> None
     print(
         "Usage: scapy.py [-s sessionfile] [-c new_startup_file] "
         "[-p new_prestart_file] [-C] [-P] [-H]\n"
@@ -147,26 +217,26 @@
 available globally.
 
     The idea is to load the module using importlib, then copy the
 symbols to the global symbol table.
 
     """
     if globals_dict is None:
-        globals_dict = six.moves.builtins.__dict__
+        globals_dict = builtins.__dict__
     try:
         mod = importlib.import_module(module)
         if '__all__' in mod.__dict__:
             # import listed symbols
             for name in mod.__dict__['__all__']:
                 if symb_list is not None:
                     symb_list.append(name)
                 globals_dict[name] = mod.__dict__[name]
         else:
             # only import non-private symbols
-            for name, sym in six.iteritems(mod.__dict__):
+            for name, sym in mod.__dict__.items():
                 if _validate_local(name):
                     if symb_list is not None:
                         symb_list.append(name)
                     globals_dict[name] = sym
     except Exception:
         log_interactive.error("Loading module %s", module, exc_info=True)
 
@@ -295,22 +365,48 @@
     try:
         from IPython import get_ipython
         get_ipython().user_ns.update(session)
     except Exception:
         pass
 
 
+def _scapy_prestart_builtins():
+    # type: () -> Dict[str, Any]
+    """Load Scapy prestart and return all builtins"""
+    return {
+        k: v
+        for k, v in importlib.import_module(".config", "scapy").__dict__.copy().items()
+        if _validate_local(k)
+    }
+
+
 def _scapy_builtins():
     # type: () -> Dict[str, Any]
     """Load Scapy and return all builtins"""
-    return {k: v
-            for k, v in six.iteritems(
-                importlib.import_module(".all", "scapy").__dict__.copy()
-            )
-            if _validate_local(k)}
+    return {
+        k: v
+        for k, v in importlib.import_module(".all", "scapy").__dict__.copy().items()
+        if _validate_local(k)
+    }
+
+
+def _scapy_exts():
+    # type: () -> Dict[str, Any]
+    """Load Scapy exts and return their builtins"""
+    from scapy.config import conf
+    res = {}
+    for modname, spec in conf.exts.all_specs.items():
+        if spec.default:
+            mod = sys.modules[modname]
+            res.update({
+                k: v
+                for k, v in mod.__dict__.copy().items()
+                if _validate_local(k)
+            })
+    return res
 
 
 def save_session(fname="", session=None, pickleProto=-1):
     # type: (str, Optional[Dict[str, Any]], int) -> None
     """Save current Scapy session to the file specified in the fname arg.
 
     params:
@@ -326,70 +422,74 @@
     log_interactive.info("Saving session into [%s]", fname)
 
     if not session:
         try:
             from IPython import get_ipython
             session = get_ipython().user_ns
         except Exception:
-            session = six.moves.builtins.__dict__["scapy_session"]
+            session = builtins.__dict__["scapy_session"]
 
     if not session:
         log_interactive.error("No session found ?!")
         return
 
     ignore = session.get("_scpybuiltins", [])
-    hard_ignore = ["scapy_session", "In", "Out"]
+    hard_ignore = ["scapy_session", "In", "Out", "open"]
     to_be_saved = session.copy()
 
     for k in list(to_be_saved):
         i = to_be_saved[k]
         if k[0] == "_":
             del to_be_saved[k]
         elif hasattr(i, "__module__") and i.__module__.startswith("IPython"):
             del to_be_saved[k]
         elif isinstance(i, ConfClass):
             del to_be_saved[k]
         elif k in ignore or k in hard_ignore:
             del to_be_saved[k]
-        elif isinstance(i, (type, types.ModuleType)):
+        elif isinstance(i, (type, types.ModuleType, types.FunctionType)):
             if k[0] != "_":
-                log_interactive.warning("[%s] (%s) can't be saved.", k,
-                                        type(to_be_saved[k]))
+                log_interactive.warning("[%s] (%s) can't be saved.", k, type(i))
             del to_be_saved[k]
+        else:
+            try:
+                pickle.dumps(i)
+            except Exception:
+                log_interactive.warning("[%s] (%s) can't be saved.", k, type(i))
 
     try:
         os.rename(fname, fname + ".bak")
     except OSError:
         pass
 
     f = gzip.open(fname, "wb")
-    six.moves.cPickle.dump(to_be_saved, f, pickleProto)
+    pickle.dump(to_be_saved, f, pickleProto)
     f.close()
 
 
 def load_session(fname=None):
     # type: (Optional[Union[str, None]]) -> None
     """Load current Scapy session from the file specified in the fname arg.
     This will erase any existing session.
 
     params:
      - fname: file to load the scapy session from"""
     from scapy.config import conf
     if fname is None:
         fname = conf.session
     try:
-        s = six.moves.cPickle.load(gzip.open(fname, "rb"))
+        s = pickle.load(gzip.open(fname, "rb"))
     except IOError:
         try:
-            s = six.moves.cPickle.load(open(fname, "rb"))
+            s = pickle.load(open(fname, "rb"))
         except IOError:
             # Raise "No such file exception"
             raise
 
-    scapy_session = six.moves.builtins.__dict__["scapy_session"]
+    scapy_session = builtins.__dict__["scapy_session"]
     s.update({k: scapy_session[k] for k in scapy_session["_scpybuiltins"]})
     scapy_session.clear()
     scapy_session.update(s)
     update_ipython_session(scapy_session)
 
     log_loading.info("Loaded session [%s]", fname)
 
@@ -400,42 +500,65 @@
 
     params:
      - fname: file to load the scapy session from"""
     from scapy.config import conf
     if fname is None:
         fname = conf.session
     try:
-        s = six.moves.cPickle.load(gzip.open(fname, "rb"))
+        s = pickle.load(gzip.open(fname, "rb"))
     except IOError:
-        s = six.moves.cPickle.load(open(fname, "rb"))
-    scapy_session = six.moves.builtins.__dict__["scapy_session"]
+        s = pickle.load(open(fname, "rb"))
+    scapy_session = builtins.__dict__["scapy_session"]
     scapy_session.update(s)
     update_ipython_session(scapy_session)
 
 
+@overload
+def init_session(session_name,  # type: Optional[Union[str, None]]
+                 mydict,  # type: Optional[Union[Dict[str, Any], None]]
+                 ret,  # type: Literal[True]
+                 ):
+    # type: (...) -> Dict[str, Any]
+    pass
+
+
+@overload
+def init_session(session_name,  # type: Optional[Union[str, None]]
+                 mydict=None,  # type: Optional[Union[Dict[str, Any], None]]
+                 ret=False,  # type: Literal[False]
+                 ):
+    # type: (...) -> None
+    pass
+
+
 def init_session(session_name,  # type: Optional[Union[str, None]]
                  mydict=None,  # type: Optional[Union[Dict[str, Any], None]]
                  ret=False,  # type: bool
                  ):
-    # type: (...) -> Optional[Dict[str, Any]]
+    # type: (...) -> Union[Dict[str, Any], None]
     from scapy.config import conf
     SESSION = {}  # type: Optional[Dict[str, Any]]
 
+    # Load Scapy
+    scapy_builtins = _scapy_builtins()
+
+    # Load exts
+    scapy_builtins.update(_scapy_exts())
+
     if session_name:
         try:
             os.stat(session_name)
         except OSError:
             log_loading.info("New session [%s]", session_name)
         else:
             try:
                 try:
-                    SESSION = six.moves.cPickle.load(gzip.open(session_name,
-                                                               "rb"))
+                    SESSION = pickle.load(gzip.open(session_name, "rb"))
                 except IOError:
-                    SESSION = six.moves.cPickle.load(open(session_name, "rb"))
+                    SESSION = pickle.load(open(session_name, "rb"))
                 log_loading.info("Using existing session [%s]", session_name)
             except ValueError:
                 msg = "Error opening Python3 pickled session on Python2 [%s]"
                 log_loading.error(msg, session_name)
             except EOFError:
                 log_loading.error("Error opening session [%s]", session_name)
             except AttributeError:
@@ -451,37 +574,34 @@
                 conf.session = session_name
         else:
             conf.session = session_name
             SESSION = {"conf": conf}
     else:
         SESSION = {"conf": conf}
 
-    # Load Scapy
-    scapy_builtins = _scapy_builtins()
-
     SESSION.update(scapy_builtins)
     SESSION["_scpybuiltins"] = scapy_builtins.keys()
-    six.moves.builtins.__dict__["scapy_session"] = SESSION
+    builtins.__dict__["scapy_session"] = SESSION
 
     if mydict is not None:
-        six.moves.builtins.__dict__["scapy_session"].update(mydict)
+        builtins.__dict__["scapy_session"].update(mydict)
         update_ipython_session(mydict)
     if ret:
         return SESSION
     return None
 
 ################
 #     Main     #
 ################
 
 
 def _prepare_quote(quote, author, max_len=78):
     # type: (str, str, int) -> List[str]
     """This function processes a quote and returns a string that is ready
-to be used in the fancy prompt.
+to be used in the fancy banner.
 
     """
     _quote = quote.split(' ')
     max_len -= 6
     lines = []
     cur_line = []  # type: List[str]
 
@@ -497,14 +617,92 @@
     if cur_line:
         lines.append('   | %s' % ' '.join(cur_line))
         cur_line = []
     lines.append('   | %s-- %s' % (" " * (max_len - len(author) - 5), author))
     return lines
 
 
+def get_fancy_banner(mini: Optional[bool] = None) -> str:
+    """
+    Generates the fancy Scapy banner
+
+    :param mini: if set, force a mini banner or not. Otherwise detect
+    """
+    from scapy.config import conf
+    from scapy.utils import get_terminal_width
+    if mini is None:
+        mini_banner = (get_terminal_width() or 84) <= 75
+    else:
+        mini_banner = mini
+
+    the_logo = [
+        "                                      ",
+        "                     aSPY//YASa       ",
+        "             apyyyyCY//////////YCa    ",
+        "            sY//////YSpcs  scpCY//Pp  ",
+        " ayp ayyyyyyySCP//Pp           syY//C ",
+        " AYAsAYYYYYYYY///Ps              cY//S",
+        "         pCCCCY//p          cSSps y//Y",
+        "         SPPPP///a          pP///AC//Y",
+        "              A//A            cyP////C",
+        "              p///Ac            sC///a",
+        "              P////YCpc           A//A",
+        "       scccccp///pSP///p          p//Y",
+        "      sY/////////y  caa           S//P",
+        "       cayCyayP//Ya              pY/Ya",
+        "        sY/PsY////YCc          aC//Yp ",
+        "         sc  sccaCY//PCypaapyCP//YSs  ",
+        "                  spCPY//////YPSps    ",
+        "                       ccaacs         ",
+        "                                      ",
+    ]
+
+    # Used on mini screens
+    the_logo_mini = [
+        "      .SYPACCCSASYY  ",
+        "P /SCS/CCS        ACS",
+        "       /A          AC",
+        "     A/PS       /SPPS",
+        "        YP        (SC",
+        "       SPS/A.      SC",
+        "   Y/PACC          PP",
+        "    PY*AYC        CAA",
+        "         YYCY//SCYP  ",
+    ]
+
+    the_banner = [
+        "",
+        "",
+        "   |",
+        "   | Welcome to Scapy",
+        "   | Version %s" % conf.version,
+        "   |",
+        "   | https://github.com/secdev/scapy",
+        "   |",
+        "   | Have fun!",
+        "   |",
+    ]
+
+    if mini_banner:
+        the_logo = the_logo_mini
+        the_banner = [x[2:] for x in the_banner[3:-1]]
+        the_banner = [""] + the_banner + [""]
+    else:
+        quote, author = choice(QUOTES)
+        the_banner.extend(_prepare_quote(quote, author, max_len=39))
+        the_banner.append("   |")
+    return "\n".join(
+        logo + banner for logo, banner in zip_longest(
+            (conf.color_theme.logo(line) for line in the_logo),
+            (conf.color_theme.success(line) for line in the_banner),
+            fillvalue=""
+        )
+    )
+
+
 def interact(mydict=None, argv=None, mybanner=None, loglevel=logging.INFO):
     # type: (Optional[Any], Optional[Any], Optional[Any], int) -> None
     """
     Starts Scapy's console.
     """
     # We're in interactive mode, let's throw the DeprecationWarnings
     warnings.simplefilter("always")
@@ -526,15 +724,15 @@
 
     try:
         opts = getopt.getopt(argv[1:], "hs:Cc:Pp:d:H")
         for opt, param in opts[0]:
             if opt == "-h":
                 _usage()
             elif opt == "-H":
-                conf.fancy_prompt = False
+                conf.fancy_banner = False
                 conf.verb = 1
                 conf.logLevel = logging.WARNING
             elif opt == "-s":
                 session_name = param
             elif opt == "-c":
                 STARTUP_FILE = param
             elif opt == "-C":
@@ -554,127 +752,172 @@
     except getopt.GetoptError as msg:
         log_loading.error(msg)
         sys.exit(1)
 
     # Reset sys.argv, otherwise IPython thinks it is for him
     sys.argv = sys.argv[:1]
 
+    if PRESTART_FILE:
+        _read_config_file(
+            PRESTART_FILE,
+            interactive=True,
+            _locals=_scapy_prestart_builtins(),
+            default=DEFAULT_PRESTART,
+        )
+
     SESSION = init_session(session_name, mydict=mydict, ret=True)
 
     if STARTUP_FILE:
-        _read_config_file(STARTUP_FILE, interactive=True)
-    if PRESTART_FILE:
-        _read_config_file(PRESTART_FILE, interactive=True)
+        _read_config_file(
+            STARTUP_FILE,
+            interactive=True,
+            _locals=SESSION
+        )
 
-    if not conf.interactive_shell or conf.interactive_shell.lower() in [
-            "ipython", "auto"
-    ]:
-        try:
-            import IPython
-            from IPython import start_ipython
-        except ImportError:
+    if conf.fancy_banner:
+        banner_text = get_fancy_banner()
+    else:
+        banner_text = "Welcome to Scapy (%s)" % conf.version
+    if mybanner is not None:
+        banner_text += "\n"
+        banner_text += mybanner
+
+    # Configure interactive terminal
+
+    if conf.interactive_shell not in [
+            "ipython",
+            "python",
+            "ptpython",
+            "ptipython",
+            "bpython",
+            "auto"]:
+        log_loading.warning("Unknown conf.interactive_shell ! Using 'auto'")
+        conf.interactive_shell = "auto"
+
+    # Auto detect available shells.
+    # Order:
+    # 1. IPython
+    # 2. bpython
+    # 3. ptpython
+
+    _IMPORTS = {
+        "ipython": ["IPython"],
+        "bpython": ["bpython"],
+        "ptpython": ["ptpython"],
+        "ptipython": ["IPython", "ptpython"],
+    }
+
+    if conf.interactive_shell == "auto":
+        # Auto detect
+        for imp in ["IPython", "bpython", "ptpython"]:
+            try:
+                importlib.import_module(imp)
+                conf.interactive_shell = imp.lower()
+                break
+            except ImportError:
+                continue
+        else:
             log_loading.warning(
-                "IPython not available. Using standard Python shell "
-                "instead.\nAutoCompletion, History are disabled."
+                "No alternative Python interpreters found ! "
+                "Using standard Python shell instead."
             )
-            if WINDOWS:
-                log_loading.warning(
-                    "On Windows, colors are also disabled"
-                )
-                conf.color_theme = BlackAndWhite()
-            IPYTHON = False
-        else:
-            IPYTHON = True
-    else:
-        IPYTHON = False
+            conf.interactive_shell = "python"
 
-    if conf.fancy_prompt:
-        from scapy.utils import get_terminal_width
-        mini_banner = (get_terminal_width() or 84) <= 75
+    if conf.interactive_shell in _IMPORTS:
+        # Check import
+        for imp in _IMPORTS[conf.interactive_shell]:
+            try:
+                importlib.import_module(imp)
+            except ImportError:
+                log_loading.warning("%s requested but not found !" % imp)
+                conf.interactive_shell = "python"
 
-        the_logo = [
-            "                                      ",
-            "                     aSPY//YASa       ",
-            "             apyyyyCY//////////YCa    ",
-            "            sY//////YSpcs  scpCY//Pp  ",
-            " ayp ayyyyyyySCP//Pp           syY//C ",
-            " AYAsAYYYYYYYY///Ps              cY//S",
-            "         pCCCCY//p          cSSps y//Y",
-            "         SPPPP///a          pP///AC//Y",
-            "              A//A            cyP////C",
-            "              p///Ac            sC///a",
-            "              P////YCpc           A//A",
-            "       scccccp///pSP///p          p//Y",
-            "      sY/////////y  caa           S//P",
-            "       cayCyayP//Ya              pY/Ya",
-            "        sY/PsY////YCc          aC//Yp ",
-            "         sc  sccaCY//PCypaapyCP//YSs  ",
-            "                  spCPY//////YPSps    ",
-            "                       ccaacs         ",
-            "                                      ",
-        ]
-
-        # Used on mini screens
-        the_logo_mini = [
-            "      .SYPACCCSASYY  ",
-            "P /SCS/CCS        ACS",
-            "       /A          AC",
-            "     A/PS       /SPPS",
-            "        YP        (SC",
-            "       SPS/A.      SC",
-            "   Y/PACC          PP",
-            "    PY*AYC        CAA",
-            "         YYCY//SCYP  ",
-        ]
-
-        the_banner = [
-            "",
-            "",
-            "   |",
-            "   | Welcome to Scapy",
-            "   | Version %s" % conf.version,
-            "   |",
-            "   | https://github.com/secdev/scapy",
-            "   |",
-            "   | Have fun!",
-            "   |",
-        ]
-
-        if mini_banner:
-            the_logo = the_logo_mini
-            the_banner = [x[2:] for x in the_banner[3:-1]]
-            the_banner = [""] + the_banner + [""]
+    # Default shell
+    if conf.interactive_shell == "python":
+        disabled = ["History"]
+        if WINDOWS:
+            disabled.append("Colors")
+            conf.color_theme = BlackAndWhite()
         else:
-            quote, author = choice(QUOTES)
-            the_banner.extend(_prepare_quote(quote, author, max_len=39))
-            the_banner.append("   |")
-        banner_text = "\n".join(
-            logo + banner for logo, banner in six.moves.zip_longest(
-                (conf.color_theme.logo(line) for line in the_logo),
-                (conf.color_theme.success(line) for line in the_banner),
-                fillvalue=""
+            try:
+                # Bad completer.. but better than nothing
+                import rlcompleter
+                import readline
+                readline.set_completer(
+                    rlcompleter.Completer(namespace=SESSION).complete
+                )
+                readline.parse_and_bind('tab: complete')
+            except ImportError:
+                disabled.insert(0, "AutoCompletion")
+        # Display warning when using the default REPL
+        log_loading.info(
+            "Using the default Python shell: %s %s disabled." % (
+                ",".join(disabled),
+                "is" if len(disabled) == 1 else "are"
             )
         )
-    else:
-        banner_text = "Welcome to Scapy (%s)" % conf.version
-    if mybanner is not None:
-        banner_text += "\n"
-        banner_text += mybanner
 
-    if IPYTHON:
-        banner = banner_text + " using IPython %s\n" % IPython.__version__
+    # ptpython configure function
+    def ptpython_configure(repl):
+        # type: (Any) -> None
+        # Hide status bar
+        repl.show_status_bar = False
+        # Complete while typing (versus only when pressing tab)
+        repl.complete_while_typing = False
+        # Enable auto-suggestions
+        repl.enable_auto_suggest = True
+        # Disable exit confirmation
+        repl.confirm_exit = False
+        # Show signature
+        repl.show_signature = True
+        # Apply Scapy color theme: TODO
+        # repl.install_ui_colorscheme("scapy",
+        #                             Style.from_dict(_custom_ui_colorscheme))
+        # repl.use_ui_colorscheme("scapy")
+
+    # Extend banner text
+    if conf.interactive_shell in ["ipython", "ptipython"]:
+        import IPython
+        if conf.interactive_shell == "ptipython":
+            banner = banner_text + " using IPython %s" % IPython.__version__
+            try:
+                from importlib.metadata import version
+                ptpython_version = " " + version('ptpython')
+            except ImportError:
+                ptpython_version = ""
+            banner += " and ptpython%s" % ptpython_version
+        else:
+            banner = banner_text + " using IPython %s" % IPython.__version__
+    elif conf.interactive_shell == "ptpython":
+        try:
+            from importlib.metadata import version
+            ptpython_version = " " + version('ptpython')
+        except ImportError:
+            ptpython_version = ""
+        banner = banner_text + " using ptpython%s" % ptpython_version
+    elif conf.interactive_shell == "bpython":
+        import bpython
+        banner = banner_text + " using bpython %s" % bpython.__version__
+
+    # Start IPython or ptipython
+    if conf.interactive_shell in ["ipython", "ptipython"]:
+        banner += "\n"
+        if conf.interactive_shell == "ptipython":
+            from ptpython.ipython import embed
+        else:
+            from IPython import embed
         try:
             from traitlets.config.loader import Config
         except ImportError:
             log_loading.warning(
                 "traitlets not available. Some Scapy shell features won't be "
                 "available."
             )
             try:
-                start_ipython(
+                embed(
                     display_banner=False,
                     user_ns=SESSION,
                     exec_lines=["print(\"\"\"" + banner + "\"\"\")"]
                 )
             except Exception:
                 code.interact(banner=banner_text, local=SESSION)
         else:
@@ -683,34 +926,66 @@
                 from IPython import get_ipython
                 if not get_ipython():
                     raise ImportError
             except ImportError:
                 # Set "classic" prompt style when launched from
                 # run_scapy(.bat) files Register and apply scapy
                 # color+prompt style
-                apply_ipython_style(shell=cfg.TerminalInteractiveShell)
-                cfg.TerminalInteractiveShell.confirm_exit = False
-                cfg.TerminalInteractiveShell.separate_in = u''
+                apply_ipython_style(shell=cfg.InteractiveShellEmbed)
+                cfg.InteractiveShellEmbed.confirm_exit = False
+                cfg.InteractiveShellEmbed.separate_in = u''
             if int(IPython.__version__[0]) >= 6:
-                cfg.TerminalInteractiveShell.term_title_format = ("Scapy %s" %
-                                                                  conf.version)
+                cfg.InteractiveShellEmbed.term_title_format = ("Scapy %s" %
+                                                               conf.version)
                 # As of IPython 6-7, the jedi completion module is a dumpster
                 # of fire that should be scrapped never to be seen again.
-                cfg.Completer.use_jedi = False
+                # This is why the following defaults to False. Feel free to hurt
+                # yourself (#GH4056) :P
+                cfg.Completer.use_jedi = conf.ipython_use_jedi
             else:
-                cfg.TerminalInteractiveShell.term_title = False
+                cfg.InteractiveShellEmbed.term_title = False
             cfg.HistoryAccessor.hist_file = conf.histfile
             cfg.InteractiveShell.banner1 = banner
             # configuration can thus be specified here.
+            _kwargs = {}
+            if conf.interactive_shell == "ptipython":
+                _kwargs["configure"] = ptpython_configure
             try:
-                start_ipython(config=cfg, user_ns=SESSION)
+                embed(config=cfg, user_ns=SESSION, **_kwargs)
             except (AttributeError, TypeError):
                 code.interact(banner=banner_text, local=SESSION)
-    else:
+    # Start ptpython
+    elif conf.interactive_shell == "ptpython":
+        # ptpython has special, non-default handling of __repr__ which breaks Scapy.
+        # For instance: >>> IP()
+        log_loading.warning("ptpython support is currently partially broken")
+        from ptpython.repl import embed
+        # ptpython has no banner option
+        banner += "\n"
+        print(banner)
+        embed(
+            locals=SESSION,
+            history_filename=conf.histfile,
+            title="Scapy %s" % conf.version,
+            configure=ptpython_configure
+        )
+    # Start bpython
+    elif conf.interactive_shell == "bpython":
+        from bpython.curtsies import main as embed
+        embed(
+            args=["-q", "-i"],
+            locals_=SESSION,
+            banner=banner,
+            welcome_message=""
+        )
+    # Start Python
+    elif conf.interactive_shell == "python":
         code.interact(banner=banner_text, local=SESSION)
+    else:
+        raise ValueError("Invalid conf.interactive_shell")
 
     if conf.session:
         save_session(conf.session, SESSION)
 
 
 if __name__ == "__main__":
     interact()
```

### Comparing `scapy-2.5.0rc3/scapy/modules/krack/__init__.py` & `scapy-2.6.0rc1/scapy/modules/krack/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 ).run()
 
 Then, on the target device, connect to "TEST_KRACK" using "testtest" as the
 passphrase.
 The output logs will indicate if one of the vulnerability have been triggered.
 
 Outputs for vulnerable devices:
-- IV re-use!! Client seems to be vulnerable to handshake 3/4 replay
+- IV reuse!! Client seems to be vulnerable to handshake 3/4 replay
   (CVE-2017-13077)
 - Broadcast packet accepted twice!! (CVE-2017-13080)
 - Client has installed an all zero encryption key (TK)!!
 
 For patched devices:
 - Client is likely not vulnerable to CVE-2017-13080
 """
```

### Comparing `scapy-2.5.0rc3/scapy/modules/krack/automaton.py` & `scapy-2.6.0rc1/scapy/modules/krack/automaton.py`

 * *Files 0% similar despite different names*

```diff
@@ -718,15 +718,15 @@
             (TSC[4] << 32) | (TSC[5] << 40)
         log_runtime.info("Got a packet with IV: %s", hex(iv))
 
         if self.last_iv is None:
             self.last_iv = iv
         else:
             if iv <= self.last_iv:
-                log_runtime.warning("IV re-use!! Client seems to be "
+                log_runtime.warning("IV reuse!! Client seems to be "
                                     "vulnerable to handshake 3/4 replay "
                                     "(CVE-2017-13077)"
                                     )
 
         data_clear = None
 
         # Normal decoding
```

### Comparing `scapy-2.5.0rc3/scapy/modules/krack/crypto.py` & `scapy-2.6.0rc1/scapy/modules/krack/crypto.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,14 @@
 import hmac
 from struct import unpack, pack
 from zlib import crc32
 
 from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
 from cryptography.hazmat.backends import default_backend
 
-import scapy.libs.six as six
 from scapy.compat import orb, chb
 from scapy.layers.dot11 import Dot11TKIP
 from scapy.utils import mac2str
 
 # ARC4
 
 
@@ -154,15 +153,15 @@
     TA: target addr bytes
     TK: temporal key
     """
 
     assert len(TSC) == 6
     assert len(TA) == 6
     assert len(TK) == 16
-    assert all(isinstance(x, six.integer_types) for x in TSC + TA + TK)
+    assert all(isinstance(x, int) for x in TSC + TA + TK)
 
     # Phase 1
     # 802.11i p.54
 
     # Phase 1 - Step 1
     TTAK = []
     TTAK.append(_MK16(TSC[3], TSC[2]))
```

### Comparing `scapy-2.5.0rc3/scapy/modules/nmap.py` & `scapy-2.6.0rc1/scapy/modules/nmap.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,29 +12,36 @@
 
 To get the last published version of this outdated fingerprint
 database, you can fetch it from
 <https://raw.githubusercontent.com/nmap/nmap/9efe1892/nmap-os-fingerprints>.
 
 """
 
-from __future__ import absolute_import
 import os
 import re
 
 from scapy.data import KnowledgeBase
 from scapy.config import conf
 from scapy.arch import WINDOWS
 from scapy.error import warning
 from scapy.layers.inet import IP, TCP, UDP, ICMP, UDPerror, IPerror
 from scapy.packet import NoPayload, Packet
 from scapy.sendrecv import sr
-from scapy.compat import plain_str, raw, Dict, List, Tuple, Optional, cast, Union
+from scapy.compat import plain_str, raw
 from scapy.plist import SndRcvList, PacketList
-import scapy.libs.six as six
 
+# Typing imports
+from typing import (
+    Dict,
+    List,
+    Tuple,
+    Optional,
+    cast,
+    Union,
+)
 
 if WINDOWS:
     conf.nmap_base = os.environ["ProgramFiles"] + "\\nmap\\nmap-os-fingerprints"  # noqa: E501
 else:
     conf.nmap_base = "/usr/share/nmap/nmap-os-fingerprints"
 
 
@@ -137,16 +144,15 @@
             raw(rcv[UDPerror].payload) == raw(snd[UDP].payload)
         ) else "F"
     return res
 
 
 def nmap_match_one_sig(seen, ref):
     # type: (Dict, Dict) -> float
-    cnt = sum(val in ref.get(key, "").split("|")
-              for key, val in six.iteritems(seen))
+    cnt = sum(val in ref.get(key, "").split("|") for key, val in seen.items())
     if cnt == 0 and seen.get("Resp") == "N":
         return 0.7
     return float(cnt) / len(seen)
 
 
 def nmap_sig(target, oport=80, cport=81, ucport=1):
     # type: (str, int, int, int) -> Dict
@@ -194,15 +200,15 @@
 
 def nmap_search(sigs):
     # type: (Dict) -> Tuple[Union[int, float], List]
     guess = 0, []  # type: Tuple[Union[int, float], List]
     conf.nmap_kdb = cast(NmapKnowledgeBase, conf.nmap_kdb)
     for osval, fprint in conf.nmap_kdb.get_base():
         score = 0.0
-        for test, values in six.iteritems(fprint):
+        for test, values in fprint.items():
             if test in sigs:
                 score += nmap_match_one_sig(sigs[test], values)
         score /= len(sigs)
         if score > guess[0]:
             guess = score, [osval]
         elif score == guess[0]:
             guess[1].append(osval)
```

### Comparing `scapy-2.5.0rc3/scapy/modules/p0f.py` & `scapy-2.6.0rc1/scapy/modules/p0f.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,30 +3,27 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Clone of p0f v3 passive OS fingerprinting
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 import re
 import struct
 import random
 
 from scapy.data import KnowledgeBase, select_path
 from scapy.config import conf
 from scapy.compat import raw, orb
 from scapy.packet import NoPayload
 from scapy.layers.inet import IP, TCP, TCPOptions
 from scapy.layers.http import HTTP, HTTPRequest, HTTPResponse
 from scapy.layers.inet6 import IPv6
 from scapy.volatile import RandByte, RandShort, RandString
 from scapy.error import warning
-from scapy.libs.six import integer_types, string_types
 
 _p0fpaths = ["/etc/p0f", "/usr/share/p0f", "/opt/local"]
 conf.p0f_base = select_path(_p0fpaths, "p0f.fp")
 
 MIN_TCP4 = 40  # Min size of IPv4/TCP headers
 MIN_TCP6 = 60  # Min size of IPv6/TCP headers
 MAX_DIST = 35  # Maximum TTL distance for non-fuzzy signature matching
@@ -774,15 +771,15 @@
     if not osgenre and not signature:
         raise ValueError("osgenre or signature is required to impersonate!")
 
     tcp = pkt[TCP]
     tcp_type = tcp.flags & (0x02 | 0x10)  # SYN / SYN+ACK
 
     if signature:
-        if isinstance(signature, string_types):
+        if isinstance(signature, str):
             sig, _ = TCP_Signature.from_raw_sig(signature)
         else:
             raise TypeError("Unsupported signature type")
     else:
         if not p0fdb.get_base():
             sigs = []
         else:
@@ -830,15 +827,15 @@
             pkt.fl = random.randint(1, 2**20 - 1)
         if "ecn" in quirks:
             pkt.tc |= random.randint(0x01, 0x03)
 
     # Take the options already set as "hints" to use in the new packet if we
     # can. we'll use the already-set values if they're valid integers.
     def int_only(val):
-        return val if isinstance(val, integer_types) else None
+        return val if isinstance(val, int) else None
     orig_opts = dict(tcp.options)
     mss_hint = int_only(orig_opts.get("MSS"))
     ws_hint = int_only(orig_opts.get("WScale"))
     ts_hint = [int_only(o) for o in orig_opts.get("Timestamp", (None, None))]
 
     options = []
     for opt in sig.olayout.split(","):
```

### Comparing `scapy-2.5.0rc3/scapy/modules/p0fv2.py` & `scapy-2.6.0rc1/scapy/modules/p0fv2.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,31 +3,28 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Clone of p0f v2 passive OS fingerprinting
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 import time
 import struct
 import os
 import socket
 import random
 
 from scapy.data import KnowledgeBase, select_path
 from scapy.config import conf
 from scapy.compat import raw
 from scapy.layers.inet import IP, TCP, TCPOptions
 from scapy.packet import NoPayload, Packet
 from scapy.error import warning, Scapy_Exception, log_runtime
 from scapy.volatile import RandInt, RandByte, RandNum, RandShort, RandString
 from scapy.sendrecv import sniff
-from scapy.libs import six
 if conf.route is None:
     # unused import, only to initialize conf.route
     import scapy.route  # noqa: F401
 
 _p0fpaths = ["/etc/p0f", "/usr/share/p0f", "/opt/local"]
 
 conf.p0f_base = select_path(_p0fpaths, "p0f.fp")
@@ -405,15 +402,15 @@
     pers = pb[random.randint(0, len(pb) - 1)]
 
     # options (we start with options because of MSS)
     # Take the options already set as "hints" to use in the new packet if we
     # can. MSS, WScale and Timestamp can all be wildcarded in a signature, so
     # we'll use the already-set values if they're valid integers.
     orig_opts = dict(pkt.payload.options)
-    int_only = lambda val: val if isinstance(val, six.integer_types) else None
+    int_only = lambda val: val if isinstance(val, int) else None
     mss_hint = int_only(orig_opts.get('MSS'))
     wscale_hint = int_only(orig_opts.get('WScale'))
     ts_hint = [int_only(o) for o in orig_opts.get('Timestamp', (None, None))]
 
     options = []
     if pers[4] != '.':
         for opt in pers[4].split(','):
```

### Comparing `scapy-2.5.0rc3/scapy/modules/voip.py` & `scapy-2.6.0rc1/scapy/modules/voip.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 VoIP (Voice over IP) related functions
 """
 
-from __future__ import absolute_import
 import subprocess
 ###################
 #   Listen VoIP   #
 ###################
 
 from scapy.sendrecv import sniff
 from scapy.layers.inet import IP, UDP
```

### Comparing `scapy-2.5.0rc3/scapy/packet.py` & `scapy-2.6.0rc1/scapy/packet.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,17 +9,17 @@
 Provides:
  - the default Packet classes
  - binding mechanisms
  - fuzz() method
  - exploration methods: explore() / ls()
 """
 
-from __future__ import absolute_import
-from __future__ import print_function
 from collections import defaultdict
+
+import json
 import re
 import time
 import itertools
 import copy
 import types
 import warnings
 
@@ -27,14 +27,16 @@
     AnyField,
     BitField,
     ConditionalField,
     Emph,
     EnumField,
     Field,
     FlagsField,
+    FlagValue,
+    MayEnd,
     MultiEnumField,
     MultipleTypeField,
     PacketListField,
     RawVal,
     StrField,
 )
 from scapy.config import conf, _version_checker
@@ -43,18 +45,17 @@
     _CanvasDumpExtended
 from scapy.interfaces import _GlobInterfaceType
 from scapy.volatile import RandField, VolatileValue
 from scapy.utils import import_hexcap, tex_escape, colgen, issubtype, \
     pretty_list, EDecimal
 from scapy.error import Scapy_Exception, log_runtime, warning
 from scapy.libs.test_pyx import PYX
-import scapy.libs.six as six
 
 # Typing imports
-from scapy.compat import (
+from typing import (
     Any,
     Callable,
     Dict,
     Iterator,
     List,
     NoReturn,
     Optional,
@@ -62,46 +63,51 @@
     Tuple,
     Type,
     TypeVar,
     Union,
     Sequence,
     cast,
 )
+from scapy.compat import Self
+
 try:
     import pyx
 except ImportError:
     pass
 
 
 _T = TypeVar("_T", Dict[str, Any], Optional[Dict[str, Any]])
 
 
-# six.with_metaclass typing is glitchy
-class Packet(six.with_metaclass(Packet_metaclass,  # type: ignore
-             BasePacket, _CanvasDumpExtended)):
+class Packet(
+    BasePacket,
+    _CanvasDumpExtended,
+    metaclass=Packet_metaclass
+):
     __slots__ = [
         "time", "sent_time", "name",
         "default_fields", "fields", "fieldtype",
         "overload_fields", "overloaded_fields",
         "packetfields",
         "original", "explicit", "raw_packet_cache",
         "raw_packet_cache_fields", "_pkt", "post_transforms",
+        "stop_dissection_after",
         # then payload, underlayer and parent
         "payload", "underlayer", "parent",
         "name",
         # used for sr()
         "_answered",
         # used when sniffing
         "direction", "sniffed_on",
         # handle snaplen Vs real length
         "wirelen",
         "comment"
     ]
     name = None
-    fields_desc = []  # type: Sequence[AnyField]
+    fields_desc = []  # type: List[AnyField]
     deprecated_fields = {}  # type: Dict[str, Tuple[str, str]]
     overload_fields = {}  # type: Dict[Type[Packet], Dict[str, Any]]
     payload_guess = []  # type: List[Tuple[Dict[str, Any], Type[Packet]]]
     show_indent = 1
     show_summary = True
     match_subclass = False
     class_dont_cache = {}  # type: Dict[Type[Packet], bool]
@@ -115,56 +121,68 @@
         # type: (Type[Packet]) -> Packet
         return cls(import_hexcap())
 
     @classmethod
     def upper_bonds(self):
         # type: () -> None
         for fval, upper in self.payload_guess:
-            print("%-20s  %s" % (upper.__name__, ", ".join("%-12s" % ("%s=%r" % i) for i in six.iteritems(fval))))  # noqa: E501
+            print(
+                "%-20s  %s" % (
+                    upper.__name__,
+                    ", ".join("%-12s" % ("%s=%r" % i) for i in fval.items()),
+                )
+            )
 
     @classmethod
     def lower_bonds(self):
         # type: () -> None
-        for lower, fval in six.iteritems(self._overload_fields):
-            print("%-20s  %s" % (lower.__name__, ", ".join("%-12s" % ("%s=%r" % i) for i in six.iteritems(fval))))  # noqa: E501
+        for lower, fval in self._overload_fields.items():
+            print(
+                "%-20s  %s" % (
+                    lower.__name__,
+                    ", ".join("%-12s" % ("%s=%r" % i) for i in fval.items()),
+                )
+            )
 
     def __init__(self,
                  _pkt=b"",  # type: Union[bytes, bytearray]
                  post_transform=None,  # type: Any
                  _internal=0,  # type: int
                  _underlayer=None,  # type: Optional[Packet]
                  _parent=None,  # type: Optional[Packet]
+                 stop_dissection_after=None,  # type: Optional[Type[Packet]]
                  **fields  # type: Any
                  ):
         # type: (...) -> None
         self.time = time.time()  # type: Union[EDecimal, float]
         self.sent_time = None  # type: Union[EDecimal, float, None]
         self.name = (self.__class__.__name__
                      if self._name is None else
                      self._name)
         self.default_fields = {}  # type: Dict[str, Any]
         self.overload_fields = self._overload_fields
         self.overloaded_fields = {}  # type: Dict[str, Any]
         self.fields = {}  # type: Dict[str, Any]
         self.fieldtype = {}  # type: Dict[str, AnyField]
         self.packetfields = []  # type: List[AnyField]
-        self.payload = NoPayload()
+        self.payload = NoPayload()  # type: Packet
         self.init_fields()
         self.underlayer = _underlayer
         self.parent = _parent
         if isinstance(_pkt, bytearray):
             _pkt = bytes(_pkt)
         self.original = _pkt
         self.explicit = 0
         self.raw_packet_cache = None  # type: Optional[bytes]
         self.raw_packet_cache_fields = None  # type: Optional[Dict[str, Any]]  # noqa: E501
         self.wirelen = None  # type: Optional[int]
         self.direction = None  # type: Optional[int]
         self.sniffed_on = None  # type: Optional[_GlobInterfaceType]
         self.comment = None  # type: Optional[bytes]
+        self.stop_dissection_after = stop_dissection_after
         if _pkt:
             self.dissect(_pkt)
             if not _internal:
                 self.dissection_done(self)
         # We use this strange initialization so that the fields
         # are initialized in their declaration order.
         # It is required to always support MultipleTypeField
@@ -389,16 +407,15 @@
     def remove_parent(self, other):
         # type: (Packet) -> None
         """Remove packet parent.
         When packet is an element in PacketListField, parent field would
         point to the list owner packet."""
         self.parent = None
 
-    def copy(self):
-        # type: () -> Packet
+    def copy(self) -> Self:
         """Returns a deep copy of the instance."""
         clone = self.__class__()
         clone.fields = self.copy_fields_dict(self.fields)
         clone.default_fields = self.copy_fields_dict(self.default_fields)
         clone.overloaded_fields = self.overloaded_fields.copy()
         clone.underlayer = self.underlayer
         clone.parent = self.parent
@@ -409,14 +426,16 @@
         )
         clone.wirelen = self.wirelen
         clone.post_transforms = self.post_transforms[:]
         clone.payload = self.payload.copy()
         clone.payload.add_underlayer(clone)
         clone.time = self.time
         clone.comment = self.comment
+        clone.direction = self.direction
+        clone.sniffed_on = self.sniffed_on
         return clone
 
     def _resolve_alias(self, attr):
         # type: (str) -> str
         new_attr, version = self.deprecated_fields[attr]
         warnings.warn(
             "%s has been deprecated in favor of %s since %s !" % (
@@ -519,15 +538,15 @@
         return object.__delattr__(self, attr)
 
     def _superdir(self):
         # type: () -> Set[str]
         """
         Return a list of slots and methods, including those from subclasses.
         """
-        attrs = set()
+        attrs = set()  # type: Set[str]
         cls = self.__class__
         if hasattr(cls, '__all_slots__'):
             attrs.update(cls.__all_slots__)
         for bcls in cls.__mro__:
             if hasattr(bcls, '__dict__'):
                 attrs.update(bcls.__dict__)
         return attrs
@@ -571,29 +590,24 @@
         return "%s%s %s %s%s%s" % (ct.punct("<"),
                                    ct.layer_name(self.__class__.__name__),
                                    s,
                                    ct.punct("|"),
                                    repr(self.payload),
                                    ct.punct(">"))
 
-    if six.PY2:
-        def __str__(self):
-            # type: () -> str
-            return self.build()
-    else:
-        def __str__(self):
-            # type: () -> str
-            return self.summary()
+    def __str__(self):
+        # type: () -> str
+        return self.summary()
 
     def __bytes__(self):
         # type: () -> bytes
         return self.build()
 
     def __div__(self, other):
-        # type: (Any) -> Packet
+        # type: (Any) -> Self
         if isinstance(other, Packet):
             cloneA = self.copy()
             cloneB = other.copy()
             cloneA.add_payload(cloneB)
             return cloneA
         elif isinstance(other, (bytes, str, bytearray, memoryview)):
             return self / conf.raw_layer(load=bytes_encode(other))
@@ -634,22 +648,38 @@
         return self.get_field(fieldname).do_copy(value)
 
     def copy_fields_dict(self, fields):
         # type: (_T) -> _T
         if fields is None:
             return None
         return {fname: self.copy_field_value(fname, fval)
-                for fname, fval in six.iteritems(fields)}
+                for fname, fval in fields.items()}
+
+    def _raw_packet_cache_field_value(self, fld, val, copy=False):
+        # type: (AnyField, Any, bool) -> Optional[Any]
+        """Get a value representative of a mutable field to detect changes"""
+        _cpy = lambda x: fld.do_copy(x) if copy else x  # type: Callable[[Any], Any]
+        if fld.holds_packets:
+            # avoid copying whole packets (perf: #GH3894)
+            if fld.islist:
+                return [
+                    _cpy(x.fields) for x in val
+                ]
+            else:
+                return _cpy(val.fields)
+        elif fld.islist or fld.ismutable:
+            return _cpy(val)
+        return None
 
     def clear_cache(self):
         # type: () -> None
         """Clear the raw packet cache for the field and all its subfields"""
         self.raw_packet_cache = None
-        for fld, fval in six.iteritems(self.fields):
-            fld = self.get_field(fld)
+        for fname, fval in self.fields.items():
+            fld = self.get_field(fname)
             if fld.holds_packets:
                 if isinstance(fval, Packet):
                     fval.clear_cache()
                 elif isinstance(fval, list):
                     for fsubval in fval:
                         fsubval.clear_cache()
         self.payload.clear_cache()
@@ -657,17 +687,19 @@
     def self_build(self):
         # type: () -> bytes
         """
         Create the default layer regarding fields_desc dict
 
         :param field_pos_list:
         """
-        if self.raw_packet_cache is not None:
-            for fname, fval in six.iteritems(self.raw_packet_cache_fields):
-                if self.getfieldval(fname) != fval:
+        if self.raw_packet_cache is not None and \
+                self.raw_packet_cache_fields is not None:
+            for fname, fval in self.raw_packet_cache_fields.items():
+                fld, val = self.getfield_and_val(fname)
+                if self._raw_packet_cache_field_value(fld, val) != fval:
                     self.raw_packet_cache = None
                     self.raw_packet_cache_fields = None
                     self.wirelen = None
                     break
             if self.raw_packet_cache is not None:
                 return self.raw_packet_cache
         p = b""
@@ -977,40 +1009,57 @@
         return s
 
     def do_dissect(self, s):
         # type: (bytes) -> bytes
         _raw = s
         self.raw_packet_cache_fields = {}
         for f in self.fields_desc:
-            if not s:
-                break
             s, fval = f.getfield(self, s)
             # Skip unused ConditionalField
             if isinstance(f, ConditionalField) and fval is None:
                 continue
             # We need to track fields with mutable values to discard
             # .raw_packet_cache when needed.
-            if f.islist or f.holds_packets or f.ismutable:
-                self.raw_packet_cache_fields[f.name] = f.do_copy(fval)
+            if (f.islist or f.holds_packets or f.ismutable) and fval is not None:
+                self.raw_packet_cache_fields[f.name] = \
+                    self._raw_packet_cache_field_value(f, fval, copy=True)
             self.fields[f.name] = fval
+            # Nothing left to dissect
+            if not s and (isinstance(f, MayEnd) or
+                          (fval is not None and isinstance(f, ConditionalField) and
+                           isinstance(f.fld, MayEnd))):
+                break
         self.raw_packet_cache = _raw[:-len(s)] if s else _raw
         self.explicit = 1
         return s
 
     def do_dissect_payload(self, s):
         # type: (bytes) -> None
         """
         Perform the dissection of the layer's payload
 
         :param str s: the raw layer
         """
         if s:
+            if (
+                self.stop_dissection_after and
+                isinstance(self, self.stop_dissection_after)
+            ):
+                # stop dissection here
+                p = conf.raw_layer(s, _internal=1, _underlayer=self)
+                self.add_payload(p)
+                return
             cls = self.guess_payload_class(s)
             try:
-                p = cls(s, _internal=1, _underlayer=self)
+                p = cls(
+                    s,
+                    stop_dissection_after=self.stop_dissection_after,
+                    _internal=1,
+                    _underlayer=self,
+                )
             except KeyboardInterrupt:
                 raise
             except Exception:
                 if conf.debug_dissector:
                     if issubtype(cls, Packet):
                         log_runtime.error("%s dissector failed", cls.__name__)
                     else:
@@ -1044,15 +1093,15 @@
         :param str payload: the layer's payload
         :return: the payload class
         """
         for t in self.aliastypes:
             for fval, cls in t.payload_guess:
                 try:
                     if all(v == self.getfieldval(k)
-                           for k, v in six.iteritems(fval)):
+                           for k, v in fval.items()):
                         return cls  # type: ignore
                 except AttributeError:
                     pass
         return self.default_payload_class(payload)
 
     def default_payload_class(self, payload):
         # type: (bytes) -> Type[Packet]
@@ -1065,15 +1114,15 @@
         """
         return conf.raw_layer
 
     def hide_defaults(self):
         # type: () -> None
         """Removes fields' values that are the same as default values."""
         # use list(): self.fields is modified in the loop
-        for k, v in list(six.iteritems(self.fields)):
+        for k, v in list(self.fields.items()):
             v = self.fields[k]
             if k in self.default_fields:
                 if self.default_fields[k] == v:
                     del self.fields[k]
         self.payload.hide_defaults()
 
     def clone_with(self, payload=None, **kargs):
@@ -1089,14 +1138,16 @@
         pkt.post_transforms = self.post_transforms
         pkt.raw_packet_cache = self.raw_packet_cache
         pkt.raw_packet_cache_fields = self.copy_fields_dict(
             self.raw_packet_cache_fields
         )
         pkt.wirelen = self.wirelen
         pkt.comment = self.comment
+        pkt.sniffed_on = self.sniffed_on
+        pkt.direction = self.direction
         if payload is not None:
             pkt.add_payload(payload)
         return pkt
 
     def __iter__(self):
         # type: () -> Iterator[Packet]
         """Iterates through all sub-packets generated by this Packet."""
@@ -1128,16 +1179,16 @@
                     pkt = self.clone_with(payload=payl, **done2)
                     yield pkt
 
         if self.explicit or self.raw_packet_cache is not None:
             todo = []
             done = self.fields
         else:
-            todo = [k for (k, v) in itertools.chain(six.iteritems(self.default_fields),  # noqa: E501
-                                                    six.iteritems(self.overloaded_fields))  # noqa: E501
+            todo = [k for (k, v) in itertools.chain(self.default_fields.items(),
+                                                    self.overloaded_fields.items())
                     if isinstance(v, VolatileValue)] + list(self.fields)
             done = {}
         return loop(todo, done)
 
     def iterpayloads(self):
         # type: () -> Iterator[Packet]
         """Used to iter through the payloads of a Packet.
@@ -1218,15 +1269,15 @@
         Superseded by "cls in self" syntax.
         """
         if _subclass is None:
             _subclass = self.match_subclass or None
         if _subclass:
             match = issubtype
         else:
-            match = lambda cls1, cls2: bool(cls1 == cls2)
+            match = lambda x, t: bool(x == t)
         if cls is None or match(self.__class__, cls) \
            or cls in [self.__class__.__name__, self._name]:
             return True
         for f in self.packetfields:
             fvalue_gen = self.getfieldval(f.name)
             if fvalue_gen is None:
                 continue
@@ -1251,15 +1302,15 @@
 values.
         """
         if _subclass is None:
             _subclass = self.match_subclass or None
         if _subclass:
             match = issubtype
         else:
-            match = lambda cls1, cls2: bool(cls1 == cls2)
+            match = lambda x, t: bool(x == t)
         # Note:
         # cls can be int, packet, str
         # string_class_name can be packet, str (packet or packet+field)
         # class_name can be packet, str (packet only)
         if isinstance(cls, int):
             nb = cls + 1
             string_class_name = ""  # type: Union[Type[Packet], str]
@@ -1270,15 +1321,15 @@
         if isinstance(string_class_name, str) and "." in string_class_name:
             class_name, fld = string_class_name.split(".", 1)
         else:
             class_name, fld = string_class_name, None
         if not class_name or match(self.__class__, class_name) \
            or class_name in [self.__class__.__name__, self._name]:
             if all(self.getfieldval(fldname) == fldvalue
-                   for fldname, fldvalue in six.iteritems(flt)):
+                   for fldname, fldvalue in flt.items()):
                 if nb == 1:
                     if fld is None:
                         return self
                     else:
                         return self.getfieldval(fld)  # type: ignore
                 else:
                     nb -= 1
@@ -1373,43 +1424,57 @@
         :param str lvl: additional information about the layer lvl
         :param str label_lvl: additional information about the layer fields
         :param first_call: determine if the current function is the first
         :return: return a hierarchical view if dump, else print it
         """
 
         if dump:
-            from scapy.themes import AnsiColorTheme
-            ct = AnsiColorTheme()  # No color for dump output
+            from scapy.themes import ColorTheme, AnsiColorTheme
+            ct: ColorTheme = AnsiColorTheme()  # No color for dump output
         else:
             ct = conf.color_theme
-        s = "%s%s %s %s \n" % (label_lvl,
-                               ct.punct("###["),
-                               ct.layer_name(self.name),
-                               ct.punct("]###"))
-        for f in self.fields_desc:
+        s = "%s%s %s %s\n" % (label_lvl,
+                              ct.punct("###["),
+                              ct.layer_name(self.name),
+                              ct.punct("]###"))
+        fields = self.fields_desc.copy()
+        while fields:
+            f = fields.pop(0)
             if isinstance(f, ConditionalField) and not f._evalcond(self):
                 continue
+            if hasattr(f, "fields"):  # Field has subfields
+                s += "%s  %s =\n" % (
+                    label_lvl + lvl,
+                    ct.depreciate_field_name(f.name),
+                )
+                lvl += " " * indent * self.show_indent
+                for i, fld in enumerate(x for x in f.fields if hasattr(self, x.name)):
+                    fields.insert(i, fld)
+                continue
             if isinstance(f, Emph) or f in conf.emph:
                 ncol = ct.emph_field_name
                 vcol = ct.emph_field_value
             else:
                 ncol = ct.field_name
                 vcol = ct.field_value
+            pad = max(0, 10 - len(f.name)) * " "
             fvalue = self.getfieldval(f.name)
             if isinstance(fvalue, Packet) or (f.islist and f.holds_packets and isinstance(fvalue, list)):  # noqa: E501
-                pad = max(0, 10 - len(f.name)) * " "
-                s += "%s  \\%s%s\\\n" % (label_lvl + lvl, ncol(f.name), pad)
+                s += "%s  %s%s%s%s\n" % (label_lvl + lvl,
+                                         ct.punct("\\"),
+                                         ncol(f.name),
+                                         pad,
+                                         ct.punct("\\"))
                 fvalue_gen = SetGen(
                     fvalue,
                     _iterpacket=0
                 )  # type: SetGen[Packet]
                 for fvalue in fvalue_gen:
                     s += fvalue._show_or_dump(dump=dump, indent=indent, label_lvl=label_lvl + lvl + "   |", first_call=False)  # noqa: E501
             else:
-                pad = max(0, 10 - len(f.name)) * " "
                 begn = "%s  %s%s%s " % (label_lvl + lvl,
                                         ncol(f.name),
                                         pad,
                                         ct.punct("="),)
                 reprval = f.i2repr(self, fvalue)
                 if isinstance(reprval, str):
                     reprval = reprval.replace("\n", "\n" + " " * (len(label_lvl) +  # noqa: E501
@@ -1631,56 +1696,107 @@
         s = raw(self.payload)
         self.payload = cls(s, _internal=1, _underlayer=self)
         pp = self
         while pp.underlayer is not None:
             pp = pp.underlayer
         self.payload.dissection_done(pp)
 
-    def command(self):
-        # type: () -> str
+    def _command(self, json=False):
+        # type: (bool) -> List[Tuple[str, Any]]
         """
-        Returns a string representing the command you have to type to
-        obtain the same packet
+        Internal method used to generate command() and json()
         """
         f = []
-        for fn, fv in six.iteritems(self.fields):
+        iterator: Iterator[Tuple[str, Any]]
+        if json:
+            iterator = ((x.name, self.getfieldval(x.name)) for x in self.fields_desc)
+        else:
+            iterator = iter(self.fields.items())
+        for fn, fv in iterator:
             fld = self.get_field(fn)
-            if isinstance(fv, (list, dict, set)) and len(fv) == 0:
+            if isinstance(fv, (list, dict, set)) and not fv and not fld.default:
                 continue
             if isinstance(fv, Packet):
-                fv = fv.command()
+                if json:
+                    fv = {k: v for (k, v) in fv._command(json=True)}
+                else:
+                    fv = fv.command()
             elif fld.islist and fld.holds_packets and isinstance(fv, list):
-                fv = "[%s]" % ",".join(map(Packet.command, fv))
+                if json:
+                    fv = [
+                        {k: v for (k, v) in x}
+                        for x in map(lambda y: Packet._command(y, json=True), fv)
+                    ]
+                else:
+                    fv = "[%s]" % ",".join(map(Packet.command, fv))
             elif fld.islist and isinstance(fv, list):
-                fv = "[%s]" % ", ".join(
-                    getattr(x, 'command', lambda: repr(x))()
-                    for x in fv
-                )
-            elif isinstance(fld, FlagsField):
+                if json:
+                    fv = [
+                        getattr(x, 'command', lambda: repr(x))()
+                        for x in fv
+                    ]
+                else:
+                    fv = "[%s]" % ",".join(
+                        getattr(x, 'command', lambda: repr(x))()
+                        for x in fv
+                    )
+            elif isinstance(fv, FlagValue):
                 fv = int(fv)
             elif callable(getattr(fv, 'command', None)):
-                fv = fv.command()
+                fv = fv.command(json=json)
             else:
-                fv = repr(fld.i2h(self, fv))
-            f.append("%s=%s" % (fn, fv))
-        c = "%s(%s)" % (self.__class__.__name__, ", ".join(f))
+                if json:
+                    if isinstance(fv, bytes):
+                        fv = fv.decode("utf-8", errors="backslashreplace")
+                    else:
+                        fv = fld.i2h(self, fv)
+                else:
+                    fv = repr(fld.i2h(self, fv))
+            f.append((fn, fv))
+        return f
+
+    def command(self):
+        # type: () -> str
+        """
+        Returns a string representing the command you have to type to
+        obtain the same packet
+        """
+        c = "%s(%s)" % (
+            self.__class__.__name__,
+            ", ".join("%s=%s" % x for x in self._command())
+        )
         pc = self.payload.command()
         if pc:
             c += "/" + pc
         return c
 
+    def json(self):
+        # type: () -> str
+        """
+        Returns a JSON representing the packet.
+
+        Please note that this cannot be used for bijective usage: data loss WILL occur,
+        so it will not make sense to try to rebuild the packet from the output.
+        This must only be used for a grepping/displaying purpose.
+        """
+        dump = json.dumps({k: v for (k, v) in self._command(json=True)})
+        pc = self.payload.json()
+        if pc:
+            dump = dump[:-1] + ", \"payload\": %s}" % pc
+        return dump
+
 
 class NoPayload(Packet):
     def __new__(cls, *args, **kargs):
-        # type: (Type[Packet], *Any, **Any) -> Packet
+        # type: (Type[Packet], *Any, **Any) -> NoPayload
         singl = cls.__dict__.get("__singl__")
         if singl is None:
             cls.__singl__ = singl = Packet.__new__(cls)
             Packet.__init__(singl)
-        return singl
+        return cast(NoPayload, singl)
 
     def __init__(self, *args, **kargs):
         # type: (*Any, **Any) -> None
         pass
 
     def dissection_done(self, pkt):
         # type: (Packet) -> None
@@ -1786,15 +1902,15 @@
         return False
 
     def hashret(self):
         # type: () -> bytes
         return b""
 
     def answers(self, other):
-        # type: (NoPayload) -> bool
+        # type: (Packet) -> bool
         return isinstance(other, (NoPayload, conf.padding_layer))  # noqa: E501
 
     def haslayer(self, cls, _subclass=None):
         # type: (Union[Type[Packet], str], Optional[bool]) -> int
         return 0
 
     def getlayer(self,
@@ -1836,14 +1952,18 @@
         # type: (Optional[Packet]) -> Packet
         return layer or self
 
     def command(self):
         # type: () -> str
         return ""
 
+    def json(self):
+        # type: () -> str
+        return ""
+
     def route(self):
         # type: () -> Tuple[None, None, None]
         return (None, None, None)
 
 
 ####################
 #  packet classes  #
@@ -1853,15 +1973,19 @@
 class Raw(Packet):
     name = "Raw"
     fields_desc = [StrField("load", b"")]
 
     def __init__(self, _pkt=b"", *args, **kwargs):
         # type: (bytes, *Any, **Any) -> None
         if _pkt and not isinstance(_pkt, bytes):
-            _pkt = bytes_encode(_pkt)
+            if isinstance(_pkt, tuple):
+                _pkt, bn = _pkt
+                _pkt = bytes_encode(_pkt), bn
+            else:
+                _pkt = bytes_encode(_pkt)
         super(Raw, self).__init__(_pkt, *args, **kwargs)
 
     def answers(self, other):
         # type: (Packet) -> int
         return 1
 
     def mysummary(self):
@@ -1935,15 +2059,15 @@
     ex:
         >>> bind_top_down(Ether, SNAP, type=0x1234)
         >>> Ether()/SNAP()
         <Ether  type=0x1234 |<SNAP  |>>
     """
     if __fval is not None:
         fval.update(__fval)
-    upper._overload_fields = upper._overload_fields.copy()
+    upper._overload_fields = upper._overload_fields.copy()  # type: ignore
     upper._overload_fields[lower] = fval
 
 
 @conf.commands.register
 def bind_layers(lower,  # type: Type[Packet]
                 upper,  # type: Type[Packet]
                 __fval=None,  # type: Optional[Dict[str, int]]
@@ -1979,15 +2103,15 @@
     """
     if __fval is not None:
         fval.update(__fval)
 
     def do_filter(params, cls):
         # type: (Dict[str, int], Type[Packet]) -> bool
         params_is_invalid = any(
-            k not in params or params[k] != v for k, v in six.iteritems(fval)
+            k not in params or params[k] != v for k, v in fval.items()
         )
         return cls != upper or params_is_invalid
     lower.payload_guess = [x for x in lower.payload_guess if do_filter(*x)]
 
 
 def split_top_down(lower,  # type: Type[Packet]
                    upper,  # type: Type[Packet]
@@ -1998,17 +2122,17 @@
     """This call un-links an association that was made using bind_top_down.
     Have a look at help(bind_top_down)
     """
     if __fval is not None:
         fval.update(__fval)
     if lower in upper._overload_fields:
         ofval = upper._overload_fields[lower]
-        if any(k not in ofval or ofval[k] != v for k, v in six.iteritems(fval)):  # noqa: E501
+        if any(k not in ofval or ofval[k] != v for k, v in fval.items()):
             return
-        upper._overload_fields = upper._overload_fields.copy()
+        upper._overload_fields = upper._overload_fields.copy()  # type: ignore
         del upper._overload_fields[lower]
 
 
 @conf.commands.register
 def split_layers(lower,  # type: Type[Packet]
                  upper,  # type: Type[Packet]
                  __fval=None,  # type: Optional[Any]
@@ -2064,28 +2188,26 @@
         # Only available with prompt_toolkit > 2.0, not released on PyPi yet
         from prompt_toolkit.shortcuts.dialogs import radiolist_dialog, \
             button_dialog
         from prompt_toolkit.formatted_text import HTML
         # Check for prompt_toolkit >= 3.0.0
         call_ptk = lambda x: cast(str, x)  # type: Callable[[Any], str]
         if _version_checker(prompt_toolkit, (3, 0)):
-            call_ptk = lambda x: x.run()  # type: ignore
+            call_ptk = lambda x: x.run()
         # 1 - Ask for layer or contrib
         btn_diag = button_dialog(
-            title=six.text_type("Scapy v%s" % conf.version),
+            title="Scapy v%s" % conf.version,
             text=HTML(
-                six.text_type(
-                    '<style bg="white" fg="red">Chose the type of packets'
-                    ' you want to explore:</style>'
-                )
+                '<style bg="white" fg="red">Chose the type of packets'
+                ' you want to explore:</style>'
             ),
             buttons=[
-                (six.text_type("Layers"), "layers"),
-                (six.text_type("Contribs"), "contribs"),
-                (six.text_type("Cancel"), "cancel")
+                ("Layers", "layers"),
+                ("Contribs", "contribs"),
+                ("Cancel", "cancel")
             ])
         action = call_ptk(btn_diag)
         # 2 - Retrieve list of Packets
         if action == "layers":
             # Get all loaded layers
             lvalues = conf.layers.layers()
             # Restrict to layers-only (not contribs) + packet.py and asn1*.py
@@ -2099,18 +2221,14 @@
             values = [(x['name'], x['description'])
                       for x in cvalues]
             # Remove very specific modules
             values = [x for x in values if "can" not in x[0]]
         else:
             # Escape/Cancel was pressed
             return
-        # Python 2 compat
-        if six.PY2:
-            values = [(six.text_type(x), six.text_type(y))
-                      for x, y in values]
         # Build tree
         if action == "contribs":
             # A tree is a dictionary. Each layer contains a keyword
             # _l which contains the files in the layer, and a _name
             # argument which is its name. The other keys are the subfolders,
             # which are similar dictionaries
             tree = defaultdict(list)  # type: Dict[str, Union[List[Any], Dict[str, Any]]]  # noqa: E501
@@ -2134,15 +2252,15 @@
         # 3 - Ask for the layer/contrib module to explore
         current = tree  # type: Any
         previous = []  # type: List[Dict[str, Union[List[Any], Dict[str, Any]]]]  # noqa: E501
         while True:
             # Generate tests & form
             folders = list(current.keys())
             _radio_values = [
-                ("$" + name, six.text_type('[+] ' + name.capitalize()))
+                ("$" + name, str('[+] ' + name.capitalize()))
                 for name in folders if not name.startswith("_")
             ] + current.get("_l", [])  # type: List[str]
             cur_path = ""
             if previous:
                 cur_path = ".".join(
                     itertools.chain(
                         (x["_name"] for x in previous[1:]),  # type: ignore
@@ -2151,23 +2269,21 @@
                 )
             extra_text = (
                 '\n<style bg="white" fg="green">> scapy.%s</style>'
             ) % (action + ("." + cur_path if cur_path else ""))
             # Show popup
             rd_diag = radiolist_dialog(
                 values=_radio_values,
-                title=six.text_type(
-                    "Scapy v%s" % conf.version
-                ),
+                title="Scapy v%s" % conf.version,
                 text=HTML(
-                    six.text_type((
+                    (
                         '<style bg="white" fg="red">Please select a file'
                         'among the following, to see all layers contained in'
                         ' it:</style>'
-                    ) + extra_text)
+                    ) + extra_text
                 ),
                 cancel_text="Back" if previous else "Cancel"
             )
             result = call_ptk(rd_diag)
             if result is None:
                 # User pressed "Cancel/Back"
                 if previous:  # Back
@@ -2218,15 +2334,15 @@
     try:
         all_layers = conf.layers.ldict[result]
     except KeyError:
         raise Scapy_Exception("Unknown scapy module '%s'" % layer)
     # Print
     print(conf.color_theme.layer_name("Packets contained in %s:" % result))
     rtlst = []  # type: List[Tuple[Union[str, List[str]], ...]]
-    rtlst = [(lay.__name__ or "", lay._name or "") for lay in all_layers]
+    rtlst = [(lay.__name__ or "", cast(str, lay._name) or "") for lay in all_layers]
     print(pretty_list(rtlst, [("Class", "Name")], borders=True))
 
 
 def _pkt_ls(obj,  # type: Union[Packet, Type[Packet]]
             verbose=False,  # type: bool
             ):
     # type: (...) -> List[Tuple[str, Type[AnyField], str, str, List[str]]]  # noqa: E501
@@ -2247,37 +2363,37 @@
         while isinstance(cur_fld, (Emph, ConditionalField)):
             if isinstance(cur_fld, ConditionalField):
                 attrs.append(cur_fld.__class__.__name__[:4])
             cur_fld = cur_fld.fld
         name = cur_fld.name
         default = cur_fld.default
         if verbose and isinstance(cur_fld, EnumField) \
-           and hasattr(cur_fld, "i2s"):
+           and hasattr(cur_fld, "i2s") and cur_fld.i2s:
             if len(cur_fld.i2s or []) < 50:
                 long_attrs.extend(
                     "%s: %d" % (strval, numval)
                     for numval, strval in
-                    sorted(six.iteritems(cur_fld.i2s))
+                    sorted(cur_fld.i2s.items())
                 )
         elif isinstance(cur_fld, MultiEnumField):
-            fld_depend = cur_fld.depends_on(
-                cast(Packet, obj if is_pkt else obj())
-            )
+            if isinstance(obj, Packet):
+                obj_pkt = obj
+            else:
+                obj_pkt = obj()
+            fld_depend = cur_fld.depends_on(obj_pkt)
             attrs.append("Depends on %s" % fld_depend)
             if verbose:
                 cur_i2s = cur_fld.i2s_multi.get(
-                    cur_fld.depends_on(
-                        cast(Packet, obj if is_pkt else obj())
-                    ), {}
+                    cur_fld.depends_on(obj_pkt), {}
                 )
                 if len(cur_i2s) < 50:
                     long_attrs.extend(
                         "%s: %d" % (strval, numval)
                         for numval, strval in
-                        sorted(six.iteritems(cur_i2s))
+                        sorted(cur_i2s.items())
                     )
         elif verbose and isinstance(cur_fld, FlagsField):
             names = cur_fld.names
             long_attrs.append(", ".join(names))
         elif isinstance(cur_fld, MultipleTypeField):
             default = cur_fld.dflt.default
             attrs.append(", ".join(
@@ -2312,24 +2428,22 @@
     # type: (...) -> None
     """List  available layers, or infos on a given layer class or name.
 
     :param obj: Packet / packet name to use
     :param case_sensitive: if obj is a string, is it case sensitive?
     :param verbose:
     """
-    is_string = isinstance(obj, str)
-
-    if obj is None or is_string:
+    if obj is None or isinstance(obj, str):
         tip = False
         if obj is None:
             tip = True
             all_layers = sorted(conf.layers, key=lambda x: x.__name__)
         else:
             pattern = re.compile(
-                cast(str, obj),
+                obj,
                 0 if case_sensitive else re.I
             )
             # We first order by accuracy, then length
             if case_sensitive:
                 sorter = lambda x: (x.__name__.index(obj), len(x.__name__))
             else:
                 obj = obj.lower()
@@ -2345,15 +2459,15 @@
             print("%-10s : %s" % (layer.__name__, layer._name))
         if tip and conf.interactive:
             print("\nTIP: You may use explore() to navigate through all "
                   "layers using a clear GUI")
     else:
         try:
             fields = _pkt_ls(
-                obj,  # type: ignore
+                obj,
                 verbose=verbose
             )
             is_pkt = isinstance(obj, Packet)
             # Print
             for fname, cls, clsne, dflt, long_attrs in fields:
                 clsinfo = cls.__name__ + " " + clsne
                 print("%-10s : %-35s =" % (fname, clsinfo), end=' ')
@@ -2479,29 +2593,32 @@
     return None
 
 
 #############
 #  Fuzzing  #
 #############
 
+_P = TypeVar('_P', bound=Packet)
+
+
 @conf.commands.register
-def fuzz(p,  # type: Packet
+def fuzz(p,  # type: _P
          _inplace=0,  # type: int
          ):
-    # type: (...) -> Packet
+    # type: (...) -> _P
     """
     Transform a layer into a fuzzy layer by replacing some default values
     by random objects.
 
     :param p: the Packet instance to fuzz
     :return: the fuzzed packet.
     """
     if not _inplace:
         p = p.copy()
-    q = p
+    q = cast(Packet, p)
     while not isinstance(q, NoPayload):
         new_default_fields = {}
         multiple_type_fields = []  # type: List[str]
         for f in q.fields_desc:
             if isinstance(f, PacketListField):
                 for r in getattr(q, f.name):
                     fuzz(r, _inplace=1)
@@ -2514,17 +2631,18 @@
                     if rnd is not None:
                         new_default_fields[f.name] = rnd
         # Process packets with MultipleTypeFields
         if multiple_type_fields:
             # freeze the other random values
             new_default_fields = {
                 key: (val._fix() if isinstance(val, VolatileValue) else val)
-                for key, val in six.iteritems(new_default_fields)
+                for key, val in new_default_fields.items()
             }
             q.default_fields.update(new_default_fields)
+            new_default_fields.clear()
             # add the random values of the MultipleTypeFields
             for name in multiple_type_fields:
                 fld = cast(MultipleTypeField, q.get_field(name))
                 rnd = fld._find_fld_pkt(q).randval()
                 if rnd is not None:
                     new_default_fields[name] = rnd
         q.default_fields.update(new_default_fields)
```

### Comparing `scapy-2.5.0rc3/scapy/pipetool.py` & `scapy-2.6.0rc1/scapy/pipetool.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,41 +1,39 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
-from __future__ import print_function
 import os
+import queue
 import subprocess
 import time
-import scapy.libs.six as six
 from threading import Lock, Thread
 
 from scapy.automaton import (
     Message,
     ObjectPipe,
     select_objects,
 )
 from scapy.consts import WINDOWS
 from scapy.error import log_runtime, warning
 from scapy.config import conf
 from scapy.utils import get_temp_file, do_graph
 
-from scapy.compat import (
+from typing import (
     Any,
     Callable,
     Dict,
     Iterable,
     Optional,
     Set,
     Tuple,
     Union,
     Type,
     TypeVar,
-    _Generic_metaclass,
     cast,
 )
 
 
 class PipeEngine(ObjectPipe[str]):
     pipes = {}  # type: Dict[str, Type[Pipe]]
 
@@ -232,15 +230,15 @@
             for ts in p.trigger_sinks:
                 g.append('\t"%i" -> "%i";' % (id(p), id(ts)))
         g.append('}')
         graph = "\n".join(g)
         do_graph(graph, **kargs)
 
 
-class _PipeMeta(_Generic_metaclass):
+class _PipeMeta(type):
     def __new__(cls,
                 name,  # type: str
                 bases,  # type: Tuple[type, ...]
                 dct  # type: Dict[str, Any]
                 ):
         # type: (...) -> Type[Pipe]
         c = cast('Type[Pipe]',
@@ -249,16 +247,15 @@
         return c
 
 
 _S = TypeVar("_S", bound="Sink")
 _TS = TypeVar("_TS", bound="TriggerSink")
 
 
-@six.add_metaclass(_PipeMeta)
-class Pipe:
+class Pipe(metaclass=_PipeMeta):
     def __init__(self, name=None):
         # type: (Optional[str]) -> None
         self.sources = set()  # type: Set['Pipe']
         self.sinks = set()  # type: Set['Sink']
         self.high_sources = set()  # type: Set['Pipe']
         self.high_sinks = set()  # type: Set['Sink']
         self.trigger_sources = set()  # type: Set['Pipe']
@@ -605,15 +602,15 @@
     def send(self, msg):
         # type: (Any) -> int
         self._gen_high_data(msg)
         return 1
 
 
 class PeriodicSource(ThreadGenSource):
-    """Generage messages periodically on low exit:
+    """Generate messages periodically on low exit:
 
     .. code::
 
          +-------+
       >>-|       |->>
          | msg,T |
        >-|  `----|->
@@ -783,15 +780,15 @@
        >-|--'    |->
          +-------+
     """
 
     def __init__(self, name=None):
         # type: (Optional[str]) -> None
         Sink.__init__(self, name=name)
-        self.q = six.moves.queue.Queue()
+        self.q: queue.Queue[Any] = queue.Queue()
 
     def push(self, msg):
         # type: (Any) -> None
         self.q.put(msg)
 
     def high_push(self, msg):
         # type: (Any) -> None
@@ -811,15 +808,15 @@
                         (the default), this method will wait forever. If a
                         non-negative number, this is a number of seconds to
                         wait before giving up (and returning None).
         :type timeout: None, int or float
         """
         try:
             return self.q.get(block=block, timeout=timeout)
-        except six.moves.queue.Empty:
+        except queue.Empty:
             return None
 
 
 class TransformDrain(Drain):
     """Apply a function to messages on low and high entry:
 
     .. code::
```

### Comparing `scapy-2.5.0rc3/scapy/plist.py` & `scapy-2.6.0rc1/scapy/plist.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,52 +4,53 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 PacketList: holds several packets and allows to do operations on them.
 """
 
 
-from __future__ import absolute_import
-from __future__ import print_function
 import os
 from collections import defaultdict
+from typing import NamedTuple
 
-from scapy.compat import lambda_tuple_converter
 from scapy.config import conf
 from scapy.base_classes import (
     BasePacket,
     BasePacketList,
     PacketList_metaclass,
     SetGen,
     _CanvasDumpExtended,
 )
 from scapy.utils import do_graph, hexdump, make_table, make_lined_table, \
     make_tex_table, issubtype
 from functools import reduce
-import scapy.libs.six as six
 
 # typings
-from scapy.compat import (
+from typing import (
     Any,
     Callable,
     DefaultDict,
     Dict,
     Generic,
     Iterator,
     List,
-    NamedTuple,
     Optional,
     Tuple,
     Type,
     TypeVar,
     Union,
     TYPE_CHECKING,
 )
 from scapy.packet import Packet
 
+try:
+    import pyx
+except ImportError:
+    pass
+
 if TYPE_CHECKING:
     from scapy.libs.matplot import Line2D
 
 #############
 #  Results  #
 #############
 
@@ -58,16 +59,15 @@
     "QueryAnswer",
     [("query", Packet), ("answer", Packet)]
 )
 
 _Inner = TypeVar("_Inner", Packet, QueryAnswer)
 
 
-@six.add_metaclass(PacketList_metaclass)
-class _PacketList(Generic[_Inner]):
+class _PacketList(Generic[_Inner], metaclass=PacketList_metaclass):
     __slots__ = ["stats", "res", "listname"]
 
     def __init__(self,
                  res=None,  # type: Optional[Union[_PacketList[_Inner], List[_Inner]]]  # noqa: E501
                  name="PacketList",  # type: str
                  stats=None  # type: Optional[List[Type[Packet]]]
                  ):
@@ -198,20 +198,14 @@
         """prints a summary of each packet
 
         :param prn: function to apply to each packet instead of
                     lambda x:x.summary()
         :param lfilter: truth function to apply to each packet to decide
                         whether it will be displayed
         """
-        # Python 2 backward compatibility
-        if prn is not None:
-            prn = lambda_tuple_converter(prn)
-        if lfilter is not None:
-            lfilter = lambda_tuple_converter(lfilter)
-
         for r in self.res:
             if lfilter is not None:
                 if not lfilter(*r):
                     continue
             if prn is None:
                 print(self._elt2sum(r))
             else:
@@ -225,20 +219,14 @@
         """prints a summary of each packet with the packet's number
 
         :param prn: function to apply to each packet instead of
                     lambda x:x.summary()
         :param lfilter: truth function to apply to each packet to decide
                         whether it will be displayed
         """
-        # Python 2 backward compatibility
-        if prn is not None:
-            prn = lambda_tuple_converter(prn)
-        if lfilter is not None:
-            lfilter = lambda_tuple_converter(lfilter)
-
         for i, res in enumerate(self.res):
             if lfilter is not None:
                 if not lfilter(*res):
                     continue
             print(conf.color_theme.id(i, fmt="%04i"), end=' ')
             if prn is None:
                 print(self._elt2sum(res))
@@ -252,17 +240,14 @@
 
     def filter(self, func):
         # type: (Callable[..., bool]) -> _PacketList[_Inner]
         """Returns a packet list filtered by a truth function. This truth
         function has to take a packet as the only argument and return
         a boolean value.
         """
-        # Python 2 backward compatibility
-        func = lambda_tuple_converter(func)
-
         return self.__class__([x for x in self.res if func(*x)],
                               name="filtered %s" % self.listname)
 
     def make_table(self, *args, **kargs):
         # type: (Any, Any) -> Optional[str]
         """Prints a table using a function that returns for each packet its head column value, head row value and displayed value  # noqa: E501
         ex: p.make_table(lambda x:(x[IP].dst, x[TCP].dport, x[TCP].sprintf("%flags%")) """  # noqa: E501
@@ -294,19 +279,14 @@
         # because it has a heavy dep chain
         from scapy.libs.matplot import (
             plt,
             MATPLOTLIB_INLINED,
             MATPLOTLIB_DEFAULT_PLOT_KARGS
         )
 
-        # Python 2 backward compatibility
-        f = lambda_tuple_converter(f)
-        if lfilter is not None:
-            lfilter = lambda_tuple_converter(lfilter)
-
         # Get the list of packets
         if lfilter is None:
             lst_pkts = [f(*e) for e in self.res]
         else:
             lst_pkts = [f(*e) for e in self.res if lfilter(*e)]
 
         # Mimic the default gnuplot output
@@ -379,19 +359,14 @@
         # because it has a heavy dep chain
         from scapy.libs.matplot import (
             plt,
             MATPLOTLIB_INLINED,
             MATPLOTLIB_DEFAULT_PLOT_KARGS
         )
 
-        # Python 2 backward compatibility
-        f = lambda_tuple_converter(f)
-        if lfilter is not None:
-            lfilter = lambda_tuple_converter(lfilter)
-
         # Get the list of packets
         if lfilter is None:
             lst_pkts = (f(*e) for e in self.res)
         else:
             lst_pkts = (f(*e) for e in self.res if lfilter(*e))
 
         # Apply the function f to the packets
@@ -400,19 +375,19 @@
             d.setdefault(k, []).append(v)
 
         # Mimic the default gnuplot output
         if not kargs:
             kargs = MATPLOTLIB_DEFAULT_PLOT_KARGS
 
         if plot_xy:
-            lines = [plt.plot(*zip(*pl), **dict(kargs, label=k))
-                     for k, pl in six.iteritems(d)]
+            lines = [plt.plot(*list(zip(*pl)), **dict(kargs, label=k))
+                     for k, pl in d.items()]
         else:
             lines = [plt.plot(pl, **dict(kargs, label=k))
-                     for k, pl in six.iteritems(d)]
+                     for k, pl in d.items()]
         plt.legend(loc="center right", bbox_to_anchor=(1.5, 0.5))
 
         # Call show() if matplotlib is not inlined
         if not MATPLOTLIB_INLINED:
             plt.show()
 
         return lines
@@ -508,31 +483,31 @@
                 if 'IPv6' in pkt:
                     return (pkt['IPv6'].src, pkt['IPv6'].dst)
                 if 'ARP' in pkt:
                     return (pkt['ARP'].psrc, pkt['ARP'].pdst)
                 raise TypeError()
             getsrcdst = _getsrcdst
         conv = {}  # type: Dict[Tuple[Any, ...], Any]
-        for p in self.res:
-            p = self._elt2pkt(p)
+        for elt in self.res:
+            p = self._elt2pkt(elt)
             try:
                 c = getsrcdst(p)
             except Exception:
                 # No warning here: it's OK that getsrcdst() raises an
                 # exception, since it might be, for example, a
                 # function that expects a specific layer in each
                 # packet. The try/except approach is faster and
                 # considered more Pythonic than adding tests.
                 continue
             if len(c) == 3:
                 conv.setdefault(c[:2], set()).add(c[2])
             else:
                 conv[c] = conv.get(c, 0) + 1
         gr = 'digraph "conv" {\n'
-        for (s, d), l in six.iteritems(conv):
+        for (s, d), l in conv.items():
             gr += '\t "%s" -> "%s" [label="%s"]\n' % (
                 s, d, ', '.join(str(x) for x in l) if isinstance(l, set) else l
             )
         gr += "}\n"
         return do_graph(gr, **kargs)
 
     def afterglow(self,
@@ -583,17 +558,17 @@
                           ((a, a) for a in x))
             if m == M:
                 m = 0
             if M == 0:
                 M = 1
             return m, M
 
-        mins, maxs = minmax(x for x, _ in six.itervalues(sl))
-        mine, maxe = minmax(x for x, _ in six.itervalues(el))
-        mind, maxd = minmax(six.itervalues(dl))
+        mins, maxs = minmax(x for x, _ in sl.values())
+        mine, maxe = minmax(x for x, _ in el.values())
+        mind, maxd = minmax(dl.values())
 
         gr = 'digraph "afterglow" {\n\tedge [len=2.5];\n'
 
         gr += "# src nodes\n"
         for s in sl:
             n, _ = sl[s]
             n = 1 + float(n - mins) / (maxs - mins)
@@ -617,21 +592,21 @@
             n, lst2 = el[e]
             for d in lst2:
                 gr += ' "evt.%s" -> "dst.%s";\n' % (repr(e), repr(d))
 
         gr += "}"
         return do_graph(gr, **kargs)
 
-    def canvas_dump(self, **kargs):
-        # type: (Any) -> Any  # Using Any since pyx is imported later
-        import pyx
+    def canvas_dump(self, layer_shift=0, rebuild=1):
+        # type: (int, int) -> 'pyx.canvas.canvas'
         d = pyx.document.document()
         len_res = len(self.res)
         for i, res in enumerate(self.res):
-            c = self._elt2pkt(res).canvas_dump(**kargs)
+            c = self._elt2pkt(res).canvas_dump(layer_shift=layer_shift,
+                                               rebuild=rebuild)
             cbb = c.bbox()
             c.text(cbb.left(), cbb.top() + 1, r"\font\cmssfont=cmss12\cmssfont{Frame %i/%i}" % (i, len_res), [pyx.text.size.LARGE])  # noqa: E501
             if conf.verb >= 2:
                 os.write(1, b".")
             d.append(pyx.document.page(c, paperformat=pyx.document.paperformat.A4,  # noqa: E501
                                        margin=1 * pyx.unit.t_cm,
                                        fittosize=1))
```

### Comparing `scapy-2.5.0rc3/scapy/pton_ntop.py` & `scapy-2.6.0rc1/scapy/pton_ntop.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,24 +6,21 @@
 """
 Convert IPv6 addresses between textual representation and binary.
 
 These functions are missing when python is compiled
 without IPv6 support, on Windows for instance.
 """
 
-from __future__ import absolute_import
 import socket
 import re
 import binascii
 from scapy.compat import plain_str, hex_bytes, bytes_encode, bytes_hex
 
-from scapy.compat import (
-    AddressFamily,
-    Union,
-)
+# Typing imports
+from typing import Union
 
 _IP6_ZEROS = re.compile('(?::|^)(0(?::0)+)(?::|$)')
 _INET6_PTON_EXC = socket.error("illegal IP address string passed to inet_pton")
 
 
 def _inet6_pton(addr):
     # type: (str) -> bytes
@@ -80,20 +77,22 @@
 _INET_PTON = {
     socket.AF_INET: socket.inet_aton,
     socket.AF_INET6: _inet6_pton,
 }
 
 
 def inet_pton(af, addr):
-    # type: (AddressFamily, Union[bytes, str]) -> bytes
+    # type: (socket.AddressFamily, Union[bytes, str]) -> bytes
     """Convert an IP address from text representation into binary form."""
     # Will replace Net/Net6 objects
     addr = plain_str(addr)
     # Use inet_pton if available
     try:
+        if not socket.has_ipv6:
+            raise AttributeError
         return socket.inet_pton(af, addr)
     except AttributeError:
         try:
             return _INET_PTON[af](addr)
         except KeyError:
             raise socket.error("Address family not supported by protocol")
 
@@ -128,18 +127,20 @@
 _INET_NTOP = {
     socket.AF_INET: socket.inet_ntoa,
     socket.AF_INET6: _inet6_ntop,
 }
 
 
 def inet_ntop(af, addr):
-    # type: (AddressFamily, bytes) -> str
+    # type: (socket.AddressFamily, bytes) -> str
     """Convert an IP address from binary form into text representation."""
     # Use inet_ntop if available
     addr = bytes_encode(addr)
     try:
+        if not socket.has_ipv6:
+            raise AttributeError
         return socket.inet_ntop(af, addr)
     except AttributeError:
         try:
             return _INET_NTOP[af](addr)
         except KeyError:
             raise ValueError("unknown address family %d" % af)
```

### Comparing `scapy-2.5.0rc3/scapy/route.py` & `scapy-2.6.0rc1/scapy/route.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,23 +4,21 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Routing and handling of network interfaces.
 """
 
 
-from __future__ import absolute_import
-
 from scapy.compat import plain_str
 from scapy.config import conf
 from scapy.error import Scapy_Exception, warning
 from scapy.interfaces import resolve_iface
 from scapy.utils import atol, ltoa, itom, pretty_list
 
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     List,
     Optional,
     Tuple,
     Union,
 )
@@ -30,15 +28,17 @@
 #  Routing/Interfaces stuff  #
 ##############################
 
 class Route:
     def __init__(self):
         # type: () -> None
         self.routes = []  # type: List[Tuple[int, int, str, str, str, int]]
-        self.resync()
+        self.invalidate_cache()
+        if conf.route_autoload:
+            self.resync()
 
     def invalidate_cache(self):
         # type: () -> None
         self.cache = {}  # type: Dict[str, Tuple[str, str, str]]
 
     def resync(self):
         # type: () -> None
@@ -141,16 +141,16 @@
         self.invalidate_cache()
         the_addr, the_msk_b = (addr.split("/") + ["32"])[:2]
         the_msk = itom(int(the_msk_b))
         the_rawaddr = atol(the_addr)
         the_net = the_rawaddr & the_msk
         self.routes.append((the_net, the_msk, '0.0.0.0', iff, the_addr, 1))
 
-    def route(self, dst=None, verbose=conf.verb):
-        # type: (Optional[str], int) -> Tuple[str, str, str]
+    def route(self, dst=None, verbose=conf.verb, _internal=False):
+        # type: (Optional[str], int, bool) -> Tuple[str, str, str]
         """Returns the IPv4 routes to a host.
         parameters:
          - dst: the IPv4 of the destination host
 
         returns: (iface, output_ip, gateway_ip)
          - iface: the interface used to connect to the host
          - output_ip: the outgoing IP that will be used
@@ -191,14 +191,18 @@
                 warning("No route found (no default route?)")
             return conf.loopback_name, "0.0.0.0", "0.0.0.0"
         # Choose the more specific route
         # Sort by greatest netmask and use metrics as a tie-breaker
         paths.sort(key=lambda x: (-x[0], x[1]))
         # Return interface
         ret = paths[0][2]
+        # Check if source is 0.0.0.0. This is a 'via' route with no src.
+        if ret[1] == "0.0.0.0" and not _internal:
+            # Then get the source from route(gw)
+            ret = (ret[0], self.route(ret[2], _internal=True)[1], ret[2])
         self.cache[dst] = ret
         return ret
 
     def get_if_bcast(self, iff):
         # type: (str) -> List[str]
         bcast_list = []
         for net, msk, gw, iface, addr, metric in self.routes:
@@ -213,9 +217,9 @@
         if not bcast_list:
             warning("No broadcast address found for iface %s\n", iff)
         return bcast_list
 
 
 conf.route = Route()
 
-# Load everything, update conf.iface
-conf.ifaces.reload()
+# Update conf.iface
+conf.ifaces.load_confiface()
```

### Comparing `scapy-2.5.0rc3/scapy/route6.py` & `scapy-2.6.0rc1/scapy/route6.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,54 +9,56 @@
 Routing and network interface handling for IPv6.
 """
 
 #############################################################################
 #                        Routing/Interfaces stuff                           #
 #############################################################################
 
-from __future__ import absolute_import
 import socket
 from scapy.config import conf
 from scapy.interfaces import resolve_iface, NetworkInterface
 from scapy.utils6 import in6_ptop, in6_cidr2mask, in6_and, \
     in6_islladdr, in6_ismlladdr, in6_isincluded, in6_isgladdr, \
     in6_isaddr6to4, in6_ismaddr, construct_source_candidate_set, \
     get_source_addr_from_candidate_set
 from scapy.arch import read_routes6, in6_getifaddr
 from scapy.pton_ntop import inet_pton, inet_ntop
 from scapy.error import warning, log_loading
 from scapy.utils import pretty_list
 
-from scapy.compat import (
+from typing import (
     Any,
     Dict,
     List,
     Optional,
     Set,
     Tuple,
     Union,
 )
 
 
 class Route6:
 
     def __init__(self):
         # type: () -> None
-        self.resync()
+        self.routes = []  # type: List[Tuple[str, int, str, str, List[str], int]]  # noqa: E501
+        self.ipv6_ifaces = set()  # type: Set[Union[str, NetworkInterface]]
         self.invalidate_cache()
+        if conf.route6_autoload:
+            self.resync()
 
     def invalidate_cache(self):
         # type: () -> None
         self.cache = {}  # type: Dict[str, Tuple[str, str, str]]
 
     def flush(self):
         # type: () -> None
         self.invalidate_cache()
-        self.ipv6_ifaces = set()  # type: Set[Union[str, NetworkInterface]]
-        self.routes = []  # type: List[Tuple[str, int, str, str, List[str], int]]  # noqa: E501
+        self.routes.clear()
+        self.ipv6_ifaces.clear()
 
     def resync(self):
         # type: () -> None
         # TODO : At the moment, resync will drop existing Teredo routes
         #        if any. Change that ...
         self.invalidate_cache()
         self.routes = read_routes6()
```

### Comparing `scapy-2.5.0rc3/scapy/scapypipes.py` & `scapy-2.6.0rc1/scapy/scapypipes.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,27 +1,26 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
-from __future__ import print_function
+from queue import Queue, Empty
 import socket
 import subprocess
 
-from scapy.libs.six.moves.queue import Queue, Empty
 from scapy.automaton import ObjectPipe
 from scapy.config import conf
 from scapy.compat import raw
 from scapy.interfaces import _GlobInterfaceType
 from scapy.packet import Packet
 from scapy.pipetool import Source, Drain, Sink
 from scapy.utils import ContextManagerSubprocess, PcapReader, PcapWriter
 
 from scapy.supersocket import SuperSocket
-from scapy.compat import (
+from typing import (
     Any,
     Callable,
     List,
     Optional,
     cast,
 )
 
@@ -200,24 +199,25 @@
         If ``None`` (the default), the linktype will be auto-detected on the
         first packet. This field will *not* be updated with the result of this
         auto-detection.
 
         This attribute has no effect after calling :py:meth:`PipeEngine.start`.
     """
 
-    def __init__(self, fname, name=None, linktype=None):
-        # type: (str, Optional[str], Optional[int]) -> None
+    def __init__(self, fname, name=None, linktype=None, **kwargs):
+        # type: (str, Optional[str], Optional[int], **Any) -> None
         Sink.__init__(self, name=name)
         self.fname = fname
         self.f = None  # type: Optional[PcapWriter]
         self.linktype = linktype
+        self.kwargs = kwargs
 
     def start(self):
         # type: () -> None
-        self.f = PcapWriter(self.fname, linktype=self.linktype)
+        self.f = PcapWriter(self.fname, linktype=self.linktype, **self.kwargs)
 
     def stop(self):
         # type: () -> None
         if self.f:
             self.f.flush()
             self.f.close()
 
@@ -378,15 +378,15 @@
 
     def stop(self):
         # type: () -> None
         if self.fd:
             self.fd.close()
 
     def push(self, msg):
-        # type: (Packet) -> None
+        # type: (bytes) -> None
         self.fd.send(msg)
 
     def fileno(self):
         # type: () -> int
         return self.fd.fileno()
 
     def deliver(self):
@@ -414,26 +414,26 @@
     """
     __selectable_force_select__ = True
 
     def __init__(self, addr="", port=0, name=None):
         # type: (str, int, Optional[str]) -> None
         TCPConnectPipe.__init__(self, addr, port, name)
         self.connected = False
-        self.q = Queue()
+        self.q: Queue[Any] = Queue()
 
     def start(self):
         # type: () -> None
         self.connected = False
         self.fd = socket.socket()
         self.fd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         self.fd.bind((self.addr, self.port))
         self.fd.listen(1)
 
     def push(self, msg):
-        # type: (Packet) -> None
+        # type: (bytes) -> None
         if self.connected:
             self.fd.send(msg)
         else:
             self.q.put(msg)
 
     def deliver(self):
         # type: () -> None
@@ -480,15 +480,15 @@
     def start(self):
         # type: () -> None
         self.fd = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
         self.fd.connect((self.addr, self.port))
         self.connected = True
 
     def push(self, msg):
-        # type: (Packet) -> None
+        # type: (bytes) -> None
         self.fd.send(msg)
 
     def deliver(self):
         # type: () -> None
         if not self.connected:
             return
         try:
@@ -520,15 +520,15 @@
 
     def start(self):
         # type: () -> None
         self.fd = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
         self.fd.bind((self.addr, self.port))
 
     def push(self, msg):
-        # type: (Packet) -> None
+        # type: (bytes) -> None
         if self._destination:
             self.fd.sendto(msg, self._destination)
         else:
             self.q.put(msg)
 
     def deliver(self):
         # type: () -> None
@@ -656,15 +656,15 @@
          +------^-------+
     """
 
     def __init__(self, start_state=True, name=None):
         # type: (bool, Optional[Any]) -> None
         Drain.__init__(self, name=name)
         self.opened = start_state
-        self.q = Queue()
+        self.q: Queue[Any] = Queue()
 
     def start(self):
         # type: () -> None
         self.q = Queue()
 
     def push(self, msg):
         # type: (str) -> None
```

### Comparing `scapy-2.5.0rc3/scapy/sendrecv.py` & `scapy-2.6.0rc1/scapy/sendrecv.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,47 +3,47 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Functions to send and receive packets.
 """
 
-from __future__ import absolute_import, print_function
 import itertools
 from threading import Thread, Event
 import os
 import re
+import socket
 import subprocess
 import time
 
 from scapy.compat import plain_str
 from scapy.data import ETH_P_ALL
 from scapy.config import conf
 from scapy.error import warning
 from scapy.interfaces import (
     network_name,
     resolve_iface,
     NetworkInterface,
 )
 from scapy.packet import Packet
+from scapy.pton_ntop import inet_pton
 from scapy.utils import get_temp_file, tcpdump, wrpcap, \
     ContextManagerSubprocess, PcapReader, EDecimal
 from scapy.plist import (
     PacketList,
     QueryAnswer,
     SndRcvList,
 )
 from scapy.error import log_runtime, log_interactive, Scapy_Exception
 from scapy.base_classes import Gen, SetGen
-from scapy.libs import six
 from scapy.sessions import DefaultSession
 from scapy.supersocket import SuperSocket, IterSocket
 
 # Typing imports
-from scapy.compat import (
+from typing import (
     Any,
     Callable,
     Dict,
     Iterator,
     List,
     Optional,
     Tuple,
@@ -89,14 +89,16 @@
         packets will still be sent through pks
     :param prebuild: pre-build the packets before starting to send them.
         Automatically enabled when a generator is passed as the packet
     :param _flood:
     :param threaded: if True, packets will be sent in an individual thread
     :param session: a flow decoder used to handle stream of packets
     :param chainEX: if True, exceptions during send will be forwarded
+    :param stop_filter: Python function applied to each packet to determine if
+        we have to stop the capture after this packet.
     """
 
 
 _GlobSessionType = Union[Type[DefaultSession], DefaultSession]
 
 
 class SndRcvHandler(object):
@@ -123,15 +125,16 @@
                  retry=0,  # type: int
                  multi=False,  # type: bool
                  rcv_pks=None,  # type: Optional[SuperSocket]
                  prebuild=False,  # type: bool
                  _flood=None,  # type: Optional[_FloodGenerator]
                  threaded=False,  # type: bool
                  session=None,  # type: Optional[_GlobSessionType]
-                 chainEX=False  # type: bool
+                 chainEX=False,  # type: bool
+                 stop_filter=None  # type: Optional[Callable[[Packet], bool]]
                  ):
         # type: (...) -> None
         # Instantiate all arguments
         if verbose is None:
             verbose = conf.verb
         if conf.debug_match:
             debug.recv = PacketList([], "Received")
@@ -144,14 +147,15 @@
         self.inter = inter
         self.verbose = verbose
         self.chainCC = chainCC
         self.multi = multi
         self.timeout = timeout
         self.session = session
         self.chainEX = chainEX
+        self.stop_filter = stop_filter
         self._send_done = False
         self.notans = 0
         self.noans = 0
         self._flood = _flood
         # Instantiate packet holders
         if prebuild and not self._flood:
             self.tobesent = list(pkt)  # type: _PacketIterable
@@ -186,19 +190,19 @@
                     self._flood.stop()
                 snd_thread.join()
             else:
                 self._sndrcv_rcv(self._sndrcv_snd)
 
             if multi:
                 remain = [
-                    p for p in itertools.chain(*six.itervalues(self.hsent))
+                    p for p in itertools.chain(*self.hsent.values())
                     if not hasattr(p, '_answered')
                 ]
             else:
-                remain = list(itertools.chain(*six.itervalues(self.hsent)))
+                remain = list(itertools.chain(*self.hsent.values()))
 
             if autostop and len(remain) > 0 and \
                len(remain) != len(self.tobesent):
                 retry = autostop
 
             self.tobesent = remain
             if len(self.tobesent) == 0:
@@ -242,15 +246,16 @@
             for p in self.tobesent:
                 # Populate the dictionary of _sndrcv_rcv
                 # _sndrcv_rcv won't miss the answer of a packet that
                 # has not been sent
                 self.hsent.setdefault(p.hashret(), []).append(p)
                 # Send packet
                 self.pks.send(p)
-                time.sleep(self.inter)
+                if self.inter:
+                    time.sleep(self.inter)
                 i += 1
             if self.verbose:
                 print("Finished sending %i packets." % i)
         except SystemExit:
             pass
         except Exception:
             if self.chainEX:
@@ -289,15 +294,15 @@
                         self.noans += 1
                     else:
                         if not hasattr(sentpkt, '_answered'):
                             self.noans += 1
                         sentpkt._answered = 1
                     break
         if self._send_done and self.noans >= self.notans and not self.multi:
-            if self.sniffer:
+            if self.sniffer and self.sniffer.running:
                 self.sniffer.stop(join=False)
         if not ok:
             if self.verbose > 1:
                 os.write(1, b".")
             self.nbrecv += 1
             if conf.debug_match:
                 debug.recv.append(r)
@@ -310,15 +315,17 @@
             self.sniffer = AsyncSniffer()
             self.sniffer._run(
                 prn=self._process_packet,
                 timeout=self.timeout,
                 store=False,
                 opened_socket=self.rcv_pks,
                 session=self.session,
-                started_callback=callback
+                stop_filter=self.stop_filter,
+                started_callback=callback,
+                chainCC=self.chainCC,
             )
         except KeyboardInterrupt:
             if self.chainCC:
                 raise
 
 
 def sndrcv(*args, **kwargs):
@@ -437,18 +444,18 @@
     :param realtime: check that a packet was sent before sending the next one
     :param return_packets: return the sent packets
     :param socket: the socket to use (default is conf.L3socket(kargs))
     :param iface: the interface to send the packets on
     :param monitor: (not on linux) send in monitor mode
     :returns: None
     """
-    iface = _interface_selection(iface, x)
+    iface, ipv6 = _interface_selection(iface, x)
     return _send(
         x,
-        lambda iface: iface.l3socket(),
+        lambda iface: iface.l3socket(ipv6),
         iface=iface,
         **kargs
     )
 
 
 @conf.commands.register
 def sendp(x,  # type: _PacketIterable
@@ -481,54 +488,58 @@
         iface=iface,
         socket=socket,
         **kargs
     )
 
 
 @conf.commands.register
-def sendpfast(x,  # type: _PacketIterable
-              pps=None,  # type: Optional[float]
-              mbps=None,  # type: Optional[float]
-              realtime=False,  # type: bool
-              loop=None,  # type: Optional[int]
-              file_cache=False,  # type: bool
-              iface=None,  # type: Optional[_GlobInterfaceType]
-              replay_args=None,  # type: Optional[List[str]]
-              parse_results=False,  # type: bool
+def sendpfast(x: _PacketIterable,
+              pps: Optional[float] = None,
+              mbps: Optional[float] = None,
+              realtime: bool = False,
+              count: Optional[int] = None,
+              loop: int = 0,
+              file_cache: bool = False,
+              iface: Optional[_GlobInterfaceType] = None,
+              replay_args: Optional[List[str]] = None,
+              parse_results: bool = False,
               ):
     # type: (...) -> Optional[Dict[str, Any]]
     """Send packets at layer 2 using tcpreplay for performance
 
     :param pps:  packets per second
     :param mbps: MBits per second
     :param realtime: use packet's timestamp, bending time with real-time value
-    :param loop: number of times to process the packet list. 0 implies
-        infinite loop
+    :param loop: send the packet indefinitely (default 0)
+    :param count: number of packets to send (default None=1)
     :param file_cache: cache packets in RAM instead of reading from
         disk at each iteration
     :param iface: output interface
     :param replay_args: List of additional tcpreplay args (List[str])
     :param parse_results: Return a dictionary of information
         outputted by tcpreplay (default=False)
     :returns: stdout, stderr, command used
     """
     if iface is None:
         iface = conf.iface
     argv = [conf.prog.tcpreplay, "--intf1=%s" % network_name(iface)]
     if pps is not None:
-        argv.append("--pps=%i" % pps)
+        argv.append("--pps=%f" % pps)
     elif mbps is not None:
         argv.append("--mbps=%f" % mbps)
     elif realtime is not None:
         argv.append("--multiplier=%f" % realtime)
     else:
         argv.append("--topspeed")
 
-    if loop is not None:
-        argv.append("--loop=%i" % loop)
+    if count:
+        assert not loop, "Can't use loop and count at the same time in sendpfast"
+        argv.append("--loop=%i" % count)
+    elif loop:
+        argv.append("--loop=0")
     if file_cache:
         argv.append("--preload-pcap")
 
     # Check for any additional args we didn't cover.
     if replay_args is not None:
         argv.extend(replay_args)
 
@@ -614,27 +625,34 @@
         log_runtime.error("Error parsing output: %s", parse_exception)
         return {}
 
 
 def _interface_selection(iface,  # type: Optional[_GlobInterfaceType]
                          packet  # type: _PacketIterable
                          ):
-    # type: (...) -> _GlobInterfaceType
+    # type: (...) -> Tuple[NetworkInterface, bool]
     """
     Select the network interface according to the layer 3 destination
     """
-
+    _iff, src, _ = next(packet.__iter__()).route()
+    ipv6 = False
+    if src:
+        try:
+            inet_pton(socket.AF_INET6, src)
+            ipv6 = True
+        except (ValueError, OSError):
+            pass
     if iface is None:
         try:
-            iff = next(packet.__iter__()).route()[0]
+            iff = resolve_iface(_iff or conf.iface)
         except AttributeError:
             iff = None
-        return iff or conf.iface
+        return iff or conf.iface, ipv6
 
-    return iface
+    return resolve_iface(iface), ipv6
 
 
 @conf.commands.register
 def sr(x,  # type: _PacketIterable
        promisc=None,  # type: Optional[bool]
        filter=None,  # type: Optional[str]
        iface=None,  # type: Optional[_GlobInterfaceType]
@@ -642,36 +660,38 @@
        *args,  # type: Any
        **kargs  # type: Any
        ):
     # type: (...) -> Tuple[SndRcvList, PacketList]
     """
     Send and receive packets at layer 3
     """
-    iface = _interface_selection(iface, x)
-    s = conf.L3socket(promisc=promisc, filter=filter,
-                      iface=iface, nofilter=nofilter)
+    iface, ipv6 = _interface_selection(iface, x)
+    s = iface.l3socket(ipv6)(
+        promisc=promisc, filter=filter,
+        iface=iface, nofilter=nofilter,
+    )
     result = sndrcv(s, x, *args, **kargs)
     s.close()
     return result
 
 
 @conf.commands.register
 def sr1(*args, **kargs):
-    # type: (*Packet, **Any) -> Optional[Packet]
+    # type: (*Any, **Any) -> Optional[Packet]
     """
     Send packets at layer 3 and return only the first answer
     """
     ans, _ = sr(*args, **kargs)
     if ans:
         return cast(Packet, ans[0][1])
     return None
 
 
 @conf.commands.register
-def srp(x,  # type: Packet
+def srp(x,  # type: _PacketIterable
         promisc=None,  # type: Optional[bool]
         iface=None,  # type: Optional[_GlobInterfaceType]
         iface_hint=None,  # type: Optional[str]
         filter=None,  # type: Optional[str]
         nofilter=0,  # type: int
         type=ETH_P_ALL,  # type: int
         *args,  # type: Any
@@ -689,15 +709,15 @@
     result = sndrcv(s, x, *args, **kargs)
     s.close()
     return result
 
 
 @conf.commands.register
 def srp1(*args, **kargs):
-    # type: (*Packet, **Any) -> Optional[Packet]
+    # type: (*Any, **Any) -> Optional[Packet]
     """
     Send and receive packets at layer 2 and return only the first answer
     """
     ans, _ = srp(*args, **kargs)
     if len(ans) > 0:
         return cast(Packet, ans[0][1])
     return None
@@ -710,16 +730,16 @@
 
 
 # SEND/RECV LOOP METHODS
 
 
 def __sr_loop(srfunc,  # type: Callable[..., Tuple[SndRcvList, PacketList]]
               pkts,  # type: _PacketIterable
-              prn=lambda x: x[1].summary(),  # type: Callable[[QueryAnswer], Any]  # noqa: E501
-              prnfail=lambda x: x.summary(),  # type: Callable[[Packet], Any]
+              prn=lambda x: x[1].summary(),  # type: Optional[Callable[[QueryAnswer], Any]]  # noqa: E501
+              prnfail=lambda x: x.summary(),  # type: Optional[Callable[[Packet], Any]]
               inter=1,  # type: int
               timeout=None,  # type: Optional[int]
               count=None,  # type: Optional[int]
               verbose=None,  # type: Optional[int]
               store=1,  # type: int
               *args,  # type: Any
               **kargs  # type: Any
@@ -739,43 +759,45 @@
         while True:
             parity ^= 1
             col = [ct.even, ct.odd][parity]
             if count is not None:
                 if count == 0:
                     break
                 count -= 1
-            start = time.time()
+            start = time.monotonic()
             if verbose > 1:
                 print("\rsend...\r", end=' ')
             res = srfunc(pkts, timeout=timeout, verbose=0, chainCC=True, *args, **kargs)  # noqa: E501
             n += len(res[0]) + len(res[1])
             r += len(res[0])
             if verbose > 1 and prn and len(res[0]) > 0:
                 msg = "RECV %i:" % len(res[0])
                 print("\r" + ct.success(msg), end=' ')
-                for p in res[0]:
-                    print(col(prn(p)))
+                for rcv in res[0]:
+                    print(col(prn(rcv)))
                     print(" " * len(msg), end=' ')
             if verbose > 1 and prnfail and len(res[1]) > 0:
                 msg = "fail %i:" % len(res[1])
                 print("\r" + ct.fail(msg), end=' ')
-                for p in res[1]:
-                    print(col(prnfail(p)))
+                for fail in res[1]:
+                    print(col(prnfail(fail)))
                     print(" " * len(msg), end=' ')
             if verbose > 1 and not (prn or prnfail):
-                print("recv:%i  fail:%i" % tuple(map(len, res[:2])))
+                print("recv:%i  fail:%i" % tuple(
+                    map(len, res[:2])  # type: ignore
+                ))
             if verbose == 1:
                 if res[0]:
                     os.write(1, b"*")
                 if res[1]:
                     os.write(1, b".")
             if store:
                 ans += res[0]
                 unans += res[1]
-            end = time.time()
+            end = time.monotonic()
             if end - start < inter:
                 time.sleep(inter + start - end)
     except KeyboardInterrupt:
         pass
 
     if verbose and n > 0:
         print(ct.normal("\nSent %i packets, received %i packets. %3.1f%% hits." % (n, r, 100.0 * r / n)))  # noqa: E501
@@ -883,16 +905,19 @@
 
     :param prn:      function applied to packets received
     :param unique:   only consider packets whose print
     :param nofilter: put 1 to avoid use of BPF filters
     :param filter:   provide a BPF filter
     :param iface:    listen answers only on the given interface
     """
-    iface = resolve_iface(iface or conf.iface)
-    s = iface.l3socket()(promisc=promisc, filter=filter, iface=iface, nofilter=nofilter)  # noqa: E501
+    iface, ipv6 = _interface_selection(iface, x)
+    s = iface.l3socket(ipv6)(
+        promisc=promisc, filter=filter,
+        iface=iface, nofilter=nofilter,
+    )
     r = sndrcvflood(s, x, *args, **kargs)
     s.close()
     return r
 
 
 @conf.commands.register
 def sr1flood(x,  # type: _PacketIterable
@@ -908,16 +933,19 @@
 
     :param prn:      function applied to packets received
     :param verbose:  set verbosity level
     :param nofilter: put 1 to avoid use of BPF filters
     :param filter:   provide a BPF filter
     :param iface:    listen answers only on the given interface
     """
-    iface = resolve_iface(iface or conf.iface)
-    s = iface.l3socket()(promisc=promisc, filter=filter, nofilter=nofilter, iface=iface)  # noqa: E501
+    iface, ipv6 = _interface_selection(iface, x)
+    s = iface.l3socket(ipv6)(
+        promisc=promisc, filter=filter,
+        nofilter=nofilter, iface=iface,
+    )
     ans, _ = sndrcvflood(s, x, *args, **kargs)
     s.close()
     if len(ans) > 0:
         return cast(Packet, ans[0][1])
     return None
 
 
@@ -1003,15 +1031,15 @@
         L2socket: use the provided L2socket (default: use conf.L2listen).
         opened_socket: provide an object (or a list of objects) ready to use
                       .recv() on.
         stop_filter: Python function applied to each packet to determine if
                      we have to stop the capture after this packet.
                      --Ex: stop_filter = lambda x: x.haslayer(TCP)
         iface: interface or list of interfaces (default: None for sniffing
-               on all interfaces).
+               on the default interface).
         monitor: use monitor mode. May not be available on all OS
         started_callback: called as soon as the sniffer starts sniffing
                           (default: None).
 
     The iface, offline and opened_socket parameters can be either an
     element, a list of elements, or a dict object mapping an element to a
     label (see examples below).
@@ -1045,20 +1073,27 @@
         # type: (*Any, **Any) -> None
         # Store keyword arguments
         self.args = args
         self.kwargs = kwargs
         self.running = False
         self.thread = None  # type: Optional[Thread]
         self.results = None  # type: Optional[PacketList]
+        self.exception = None  # type: Optional[Exception]
 
     def _setup_thread(self):
         # type: () -> None
+        def _run_catch(self=self, *args, **kwargs):
+            # type: (Any, *Any, **Any) -> None
+            try:
+                self._run(*args, **kwargs)
+            except Exception as ex:
+                self.exception = ex
         # Prepare sniffing thread
         self.thread = Thread(
-            target=self._run,
+            target=_run_catch,
             args=self.args,
             kwargs=self.kwargs,
             name="AsyncSniffer"
         )
         self.thread.daemon = True
 
     def _run(self,
@@ -1071,83 +1106,81 @@
              L2socket=None,  # type: Optional[Type[SuperSocket]]
              timeout=None,  # type: Optional[int]
              opened_socket=None,  # type: Optional[SuperSocket]
              stop_filter=None,  # type: Optional[Callable[[Packet], bool]]
              iface=None,  # type: Optional[_GlobInterfaceType]
              started_callback=None,  # type: Optional[Callable[[], Any]]
              session=None,  # type: Optional[_GlobSessionType]
-             session_kwargs={},  # type: Dict[str, Any]
+             chainCC=False,  # type: bool
              **karg  # type: Any
              ):
         # type: (...) -> None
         self.running = True
+        self.count = 0
+        lst = []
         # Start main thread
         # instantiate session
         if not isinstance(session, DefaultSession):
             session = session or DefaultSession
-            session = session(prn=prn, store=store,
-                              **session_kwargs)
-        else:
-            session.prn = prn
-            session.store = store
+            session = session()
         # sniff_sockets follows: {socket: label}
         sniff_sockets = {}  # type: Dict[SuperSocket, _GlobInterfaceType]
         if opened_socket is not None:
             if isinstance(opened_socket, list):
                 sniff_sockets.update(
                     (s, "socket%d" % i)
                     for i, s in enumerate(opened_socket)
                 )
             elif isinstance(opened_socket, dict):
                 sniff_sockets.update(
                     (s, label)
-                    for s, label in six.iteritems(opened_socket)
+                    for s, label in opened_socket.items()
                 )
             else:
                 sniff_sockets[opened_socket] = "socket0"
         if offline is not None:
             flt = karg.get('filter')
 
             if isinstance(offline, str):
                 # Single file
                 offline = [offline]
             if isinstance(offline, list) and \
                     all(isinstance(elt, str) for elt in offline):
                 # List of files
-                sniff_sockets.update((PcapReader(
+                sniff_sockets.update((PcapReader(  # type: ignore
                     fname if flt is None else
                     tcpdump(fname,
                             args=["-w", "-"],
                             flt=flt,
                             getfd=True,
                             quiet=quiet)
                 ), fname) for fname in offline)
             elif isinstance(offline, dict):
                 # Dict of files
-                sniff_sockets.update((PcapReader(
+                sniff_sockets.update((PcapReader(  # type: ignore
                     fname if flt is None else
                     tcpdump(fname,
                             args=["-w", "-"],
                             flt=flt,
                             getfd=True,
                             quiet=quiet)
-                ), label) for fname, label in six.iteritems(offline))
+                ), label) for fname, label in offline.items())
             elif isinstance(offline, (Packet, PacketList, list)):
                 # Iterables (list of packets, PacketList..)
                 offline = IterSocket(offline)
                 sniff_sockets[offline if flt is None else PcapReader(
                     tcpdump(offline,
                             args=["-w", "-"],
                             flt=flt,
                             getfd=True,
                             quiet=quiet)
                 )] = offline
             else:
                 # Other (file descriptors...)
-                sniff_sockets[PcapReader(
+                sniff_sockets[PcapReader(  # type: ignore
                     offline if flt is None else
                     tcpdump(offline,
                             args=["-w", "-"],
                             flt=flt,
                             getfd=True,
                             quiet=quiet)
                 )] = offline
@@ -1160,15 +1193,15 @@
                      ifname)
                     for ifname in iface
                 )
             elif isinstance(iface, dict):
                 sniff_sockets.update(
                     (_RL2(ifname)(type=ETH_P_ALL, iface=ifname, **karg),
                      iflabel)
-                    for ifname, iflabel in six.iteritems(iface)
+                    for ifname, iflabel in iface.items()
                 )
             else:
                 iface = iface or conf.iface
                 sniff_sockets[_RL2(iface)(type=ETH_P_ALL, iface=iface,
                                           **karg)] = iface
 
         # Get select information from the sockets
@@ -1181,15 +1214,15 @@
                     "The used select function "
                     "will be the one of the first socket")
 
         close_pipe = None  # type: Optional[ObjectPipe[None]]
         if not nonblocking_socket:
             # select is blocking: Add special control socket
             from scapy.automaton import ObjectPipe
-            close_pipe = ObjectPipe[None]()
+            close_pipe = ObjectPipe[None]("control_socket")
             sniff_sockets[close_pipe] = "control_socket"  # type: ignore
 
             def stop_cb():
                 # type: () -> None
                 if self.running and close_pipe:
                     close_pipe.send(None)
                 self.continue_sniff = False
@@ -1204,29 +1237,49 @@
         try:
             if started_callback:
                 started_callback()
             self.continue_sniff = True
 
             # Start timeout
             if timeout is not None:
-                stoptime = time.time() + timeout
+                stoptime = time.monotonic() + timeout
             remain = None
 
             while sniff_sockets and self.continue_sniff:
                 if timeout is not None:
-                    remain = stoptime - time.time()
+                    remain = stoptime - time.monotonic()
                     if remain <= 0:
                         break
                 sockets = select_func(list(sniff_sockets.keys()), remain)
                 dead_sockets = []
                 for s in sockets:
                     if s is close_pipe:  # type: ignore
                         break
+                    # The session object is passed the socket to call recv() on,
+                    # and may perform additional processing (ip defrag, etc.)
                     try:
-                        p = s.recv()
+                        packets = session.recv(s)
+                        # A session can return multiple objects
+                        for p in packets:
+                            if lfilter and not lfilter(p):
+                                continue
+                            p.sniffed_on = sniff_sockets[s]
+                            # post-processing
+                            self.count += 1
+                            if store:
+                                lst.append(p)
+                            if prn:
+                                result = prn(p)
+                                if result is not None:
+                                    print(result)
+                            # check
+                            if (stop_filter and stop_filter(p)) or \
+                                    (0 < count <= self.count):
+                                self.continue_sniff = False
+                                break
                     except EOFError:
                         # End of stream
                         try:
                             s.close()
                         except Exception:
                             pass
                         dead_sockets.append(s)
@@ -1241,42 +1294,31 @@
                         warning(
                             "Socket %s failed with '%s'." % (s, ex) + msg
                         )
                         dead_sockets.append(s)
                         if conf.debug_dissector >= 2:
                             raise
                         continue
-                    if p is None:
-                        continue
-                    if lfilter and not lfilter(p):
-                        continue
-                    p.sniffed_on = sniff_sockets[s]
-                    # on_packet_received handles the prn/storage
-                    session.on_packet_received(p)
-                    # check
-                    if (stop_filter and stop_filter(p)) or \
-                            (0 < count <= session.count):
-                        self.continue_sniff = False
-                        break
                 # Removed dead sockets
                 for s in dead_sockets:
                     del sniff_sockets[s]
                     if len(sniff_sockets) == 1 and \
                             close_pipe in sniff_sockets:  # type: ignore
                         # Only the close_pipe left
                         del sniff_sockets[close_pipe]  # type: ignore
         except KeyboardInterrupt:
-            pass
+            if chainCC:
+                raise
         self.running = False
         if opened_socket is None:
             for s in sniff_sockets:
                 s.close()
         elif close_pipe:
             close_pipe.close()
-        self.results = session.toPacketList()
+        self.results = PacketList(lst, "Sniffed")
 
     def start(self):
         # type: () -> None
         """Starts AsyncSniffer in async mode"""
         self._setup_thread()
         if self.thread:
             self.thread.start()
@@ -1298,14 +1340,16 @@
         else:
             raise Scapy_Exception("Not running ! (check .running attr)")
 
     def join(self, *args, **kwargs):
         # type: (*Any, **Any) -> None
         if self.thread:
             self.thread.join(*args, **kwargs)
+        if self.exception is not None:
+            raise self.exception
 
 
 @conf.commands.register
 def sniff(*args, **kwargs):
     # type: (*Any, **Any) -> PacketList
     sniffer = AsyncSniffer()
     sniffer._run(*args, **kwargs)
```

### Comparing `scapy-2.5.0rc3/scapy/supersocket.py` & `scapy-2.6.0rc1/scapy/arch/linux/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,553 +1,436 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
-SuperSocket.
+Linux specific functions.
 """
 
-from __future__ import absolute_import
-from select import select, error as select_error
+
+from fcntl import ioctl
+from select import select
+
 import ctypes
-import errno
+import os
 import socket
 import struct
+import subprocess
+import sys
 import time
 
-from scapy.config import conf
-from scapy.consts import DARWIN, WINDOWS
-from scapy.data import MTU, ETH_P_IP, SOL_PACKET, SO_TIMESTAMPNS
 from scapy.compat import raw
-from scapy.error import warning, log_runtime
-from scapy.interfaces import network_name
-import scapy.libs.six as six
-from scapy.packet import Packet
-import scapy.packet
-from scapy.plist import (
-    PacketList,
-    SndRcvList,
-    _PacketIterable,
+from scapy.consts import LINUX
+from scapy.arch.common import (
+    compile_filter,
+)
+from scapy.arch.unix import get_if
+from scapy.config import conf
+from scapy.data import MTU, ETH_P_ALL, SOL_PACKET, SO_ATTACH_FILTER, \
+    SO_TIMESTAMPNS
+from scapy.error import (
+    ScapyInvalidPlatformException,
+    Scapy_Exception,
+    log_runtime,
+    warning,
+)
+from scapy.interfaces import (
+    InterfaceProvider,
+    NetworkInterface,
+    network_name,
+    _GlobInterfaceType,
+)
+from scapy.libs.structures import sock_fprog
+from scapy.packet import Packet, Padding
+from scapy.supersocket import SuperSocket
+
+# re-export
+from scapy.arch.common import get_if_raw_addr  # noqa: F401
+from scapy.arch.unix import read_nameservers, get_if_raw_hwaddr  # noqa: F401
+from scapy.arch.linux.rtnetlink import (  # noqa: F401
+    read_routes,
+    read_routes6,
+    in6_getifaddr,
+    _get_if_list,
 )
-from scapy.utils import PcapReader, tcpdump
 
 # Typing imports
-from scapy.interfaces import _GlobInterfaceType
-from scapy.compat import (
+from typing import (
     Any,
-    Iterator,
-    List,
+    Callable,
+    Dict,
+    NoReturn,
     Optional,
     Tuple,
     Type,
-    cast,
-    _Generic_metaclass
+    Union,
 )
 
+# From sockios.h
+SIOCGIFHWADDR = 0x8927          # Get hardware address
+SIOCGIFADDR = 0x8915          # get PA address
+SIOCGIFNETMASK = 0x891b          # get network PA mask
+SIOCGIFNAME = 0x8910          # get iface name
+SIOCSIFLINK = 0x8911          # set iface channel
+SIOCGIFCONF = 0x8912          # get iface list
+SIOCGIFFLAGS = 0x8913          # get flags
+SIOCSIFFLAGS = 0x8914          # set flags
+SIOCGIFINDEX = 0x8933          # name -> if_index mapping
+SIOCGIFCOUNT = 0x8938          # get number of devices
+SIOCGSTAMP = 0x8906          # get packet timestamp (as a timeval)
+
+# From if.h
+IFF_UP = 0x1               # Interface is up.
+IFF_BROADCAST = 0x2        # Broadcast address valid.
+IFF_DEBUG = 0x4            # Turn on debugging.
+IFF_LOOPBACK = 0x8         # Is a loopback net.
+IFF_POINTOPOINT = 0x10     # Interface is point-to-point link.
+IFF_NOTRAILERS = 0x20      # Avoid use of trailers.
+IFF_RUNNING = 0x40         # Resources allocated.
+IFF_NOARP = 0x80           # No address resolution protocol.
+IFF_PROMISC = 0x100        # Receive all packets.
+
+# From netpacket/packet.h
+PACKET_ADD_MEMBERSHIP = 1
+PACKET_DROP_MEMBERSHIP = 2
+PACKET_RECV_OUTPUT = 3
+PACKET_RX_RING = 5
+PACKET_STATISTICS = 6
+PACKET_MR_MULTICAST = 0
+PACKET_MR_PROMISC = 1
+PACKET_MR_ALLMULTI = 2
+
+# From net/route.h
+RTF_UP = 0x0001  # Route usable
+RTF_REJECT = 0x0200
+
+# From if_packet.h
+PACKET_HOST = 0  # To us
+PACKET_BROADCAST = 1  # To all
+PACKET_MULTICAST = 2  # To group
+PACKET_OTHERHOST = 3  # To someone else
+PACKET_OUTGOING = 4  # Outgoing of any type
+PACKET_LOOPBACK = 5  # MC/BRD frame looped back
+PACKET_USER = 6  # To user space
+PACKET_KERNEL = 7  # To kernel space
+PACKET_AUXDATA = 8
+PACKET_FASTROUTE = 6  # Fastrouted frame
+# Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space
+
+
 # Utils
 
+def attach_filter(sock, bpf_filter, iface):
+    # type: (socket.socket, str, _GlobInterfaceType) -> None
+    """
+    Compile bpf filter and attach it to a socket
+
+    :param sock: the python socket
+    :param bpf_filter: the bpf string filter to compile
+    :param iface: the interface used to compile
+    """
+    bp = compile_filter(bpf_filter, iface)
+    if conf.use_pypy and sys.pypy_version_info <= (7, 3, 2):  # type: ignore
+        # PyPy < 7.3.2 has a broken behavior
+        # https://foss.heptapod.net/pypy/pypy/-/issues/3298
+        bp = struct.pack(  # type: ignore
+            'HL',
+            bp.bf_len, ctypes.addressof(bp.bf_insns.contents)
+        )
+    else:
+        bp = sock_fprog(bp.bf_len, bp.bf_insns)  # type: ignore
+    sock.setsockopt(socket.SOL_SOCKET, SO_ATTACH_FILTER, bp)
 
-class _SuperSocket_metaclass(_Generic_metaclass):
-    desc = None   # type: Optional[str]
 
-    def __repr__(self):
-        # type: () -> str
-        if self.desc is not None:
-            return "<%s: %s>" % (self.__name__, self.desc)
+def set_promisc(s, iff, val=1):
+    # type: (socket.socket, _GlobInterfaceType, int) -> None
+    mreq = struct.pack("IHH8s", get_if_index(iff), PACKET_MR_PROMISC, 0, b"")
+    if val:
+        cmd = PACKET_ADD_MEMBERSHIP
+    else:
+        cmd = PACKET_DROP_MEMBERSHIP
+    s.setsockopt(SOL_PACKET, cmd, mreq)
+
+
+def get_if_index(iff):
+    # type: (_GlobInterfaceType) -> int
+    return int(struct.unpack("I", get_if(iff, SIOCGIFINDEX)[16:20])[0])
+
+
+# Interface provider
+
+
+class LinuxInterfaceProvider(InterfaceProvider):
+    name = "sys"
+
+    def _is_valid(self, dev):
+        # type: (NetworkInterface) -> bool
+        return bool(dev.flags & IFF_UP)
+
+    def load(self):
+        # type: () -> Dict[str, NetworkInterface]
+        data = {}
+        for iface in _get_if_list().values():
+            if_data = iface.copy()
+            if_data.update({
+                "network_name": iface["name"],
+                "description": iface["name"],
+                "ips": [x["address"] for x in iface["ips"]]
+            })
+            data[iface["name"]] = NetworkInterface(self, if_data)
+        return data
+
+
+conf.ifaces.register_provider(LinuxInterfaceProvider)
+
+if os.uname()[4] in ['x86_64', 'aarch64']:
+    def get_last_packet_timestamp(sock):
+        # type: (socket.socket) -> float
+        ts = ioctl(sock, SIOCGSTAMP, "1234567890123456")  # type: ignore
+        s, us = struct.unpack("QQ", ts)  # type: Tuple[int, int]
+        return s + us / 1000000.0
+else:
+    def get_last_packet_timestamp(sock):
+        # type: (socket.socket) -> float
+        ts = ioctl(sock, SIOCGSTAMP, "12345678")  # type: ignore
+        s, us = struct.unpack("II", ts)  # type: Tuple[int, int]
+        return s + us / 1000000.0
+
+
+def _flush_fd(fd):
+    # type: (int) -> None
+    while True:
+        r, w, e = select([fd], [], [], 0)
+        if r:
+            os.read(fd, MTU)
         else:
-            return "<%s>" % self.__name__
+            break
 
 
-# Used to get ancillary data
-PACKET_AUXDATA = 8
-ETH_P_8021Q = 0x8100
-TP_STATUS_VLAN_VALID = 1 << 4
-TP_STATUS_VLAN_TPID_VALID = 1 << 6
-
-
-class tpacket_auxdata(ctypes.Structure):
-    _fields_ = [
-        ("tp_status", ctypes.c_uint),
-        ("tp_len", ctypes.c_uint),
-        ("tp_snaplen", ctypes.c_uint),
-        ("tp_mac", ctypes.c_ushort),
-        ("tp_net", ctypes.c_ushort),
-        ("tp_vlan_tci", ctypes.c_ushort),
-        ("tp_vlan_tpid", ctypes.c_ushort),
-    ]  # type: List[Tuple[str, Any]]
-
-
-# SuperSocket
-
-@six.add_metaclass(_SuperSocket_metaclass)
-class SuperSocket:
-    closed = False  # type: bool
-    nonblocking_socket = False  # type: bool
-    auxdata_available = False   # type: bool
+class L2Socket(SuperSocket):
+    desc = "read/write packets at layer 2 using Linux PF_PACKET sockets"
 
     def __init__(self,
-                 family=socket.AF_INET,  # type: int
-                 type=socket.SOCK_STREAM,  # type: int
-                 proto=0,  # type: int
-                 iface=None,  # type: Optional[_GlobInterfaceType]
-                 **kwargs  # type: Any
+                 iface=None,  # type: Optional[Union[str, NetworkInterface]]
+                 type=ETH_P_ALL,  # type: int
+                 promisc=None,  # type: Optional[Any]
+                 filter=None,  # type: Optional[Any]
+                 nofilter=0,  # type: int
+                 monitor=None,  # type: Optional[Any]
                  ):
         # type: (...) -> None
-        self.ins = socket.socket(family, type, proto)  # type: socket.socket
-        self.outs = self.ins  # type: Optional[socket.socket]
-        self.promisc = conf.sniff_promisc
-        self.iface = iface or conf.iface
-
-    def send(self, x):
-        # type: (Packet) -> int
-        sx = raw(x)
+        self.iface = network_name(iface or conf.iface)
+        self.type = type
+        self.promisc = conf.sniff_promisc if promisc is None else promisc
+        self.ins = socket.socket(
+            socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))
+        self.ins.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)
+        if not nofilter:
+            if conf.except_filter:
+                if filter:
+                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
+                else:
+                    filter = "not (%s)" % conf.except_filter
+            if filter is not None:
+                try:
+                    attach_filter(self.ins, filter, self.iface)
+                except (ImportError, Scapy_Exception) as ex:
+                    raise Scapy_Exception("Cannot set filter: %s" % ex)
+        if self.promisc:
+            set_promisc(self.ins, self.iface)
+        self.ins.bind((self.iface, type))
+        _flush_fd(self.ins.fileno())
+        self.ins.setsockopt(
+            socket.SOL_SOCKET,
+            socket.SO_RCVBUF,
+            conf.bufsize
+        )
+        # Receive Auxiliary Data (VLAN tags)
         try:
-            x.sent_time = time.time()
-        except AttributeError:
-            pass
-
-        if self.outs:
-            return self.outs.send(sx)
+            self.ins.setsockopt(SOL_PACKET, PACKET_AUXDATA, 1)
+            self.ins.setsockopt(socket.SOL_SOCKET, SO_TIMESTAMPNS, 1)
+            self.auxdata_available = True
+        except OSError:
+            # Note: Auxiliary Data is only supported since
+            #       Linux 2.6.21
+            msg = "Your Linux Kernel does not support Auxiliary Data!"
+            log_runtime.info(msg)
+        if not isinstance(self, L2ListenSocket):
+            self.outs = self.ins  # type: socket.socket
+            self.outs.setsockopt(
+                socket.SOL_SOCKET,
+                socket.SO_SNDBUF,
+                conf.bufsize
+            )
         else:
-            return 0
+            self.outs = None  # type: ignore
+        sa_ll = self.ins.getsockname()
+        if sa_ll[3] in conf.l2types:
+            self.LL = conf.l2types.num2layer[sa_ll[3]]
+            self.lvl = 2
+        elif sa_ll[1] in conf.l3types:
+            self.LL = conf.l3types.num2layer[sa_ll[1]]
+            self.lvl = 3
+        else:
+            self.LL = conf.default_l2
+            self.lvl = 2
+            warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using %s", sa_ll[0], sa_ll[1], sa_ll[3], self.LL.name)  # noqa: E501
 
-    if six.PY2 or WINDOWS:
-        def _recv_raw(self, sock, x):
-            # type: (socket.socket, int) -> Tuple[bytes, Any, Optional[float]]
-            """Internal function to receive a Packet"""
-            pkt, sa_ll = sock.recvfrom(x)
-            return pkt, sa_ll, None
-    else:
-        def _recv_raw(self, sock, x):
-            # type: (socket.socket, int) -> Tuple[bytes, Any, Optional[float]]
-            """Internal function to receive a Packet,
-            and process ancillary data.
-            """
-            timestamp = None
-            if not self.auxdata_available:
-                pkt, _, _, sa_ll = sock.recvmsg(x)
-                return pkt, sa_ll, timestamp
-            flags_len = socket.CMSG_LEN(4096)
-            pkt, ancdata, flags, sa_ll = sock.recvmsg(x, flags_len)
-            if not pkt:
-                return pkt, sa_ll, timestamp
-            for cmsg_lvl, cmsg_type, cmsg_data in ancdata:
-                # Check available ancillary data
-                if (cmsg_lvl == SOL_PACKET and cmsg_type == PACKET_AUXDATA):
-                    # Parse AUXDATA
-                    try:
-                        auxdata = tpacket_auxdata.from_buffer_copy(cmsg_data)
-                    except ValueError:
-                        # Note: according to Python documentation, recvmsg()
-                        #       can return a truncated message. A ValueError
-                        #       exception likely indicates that Auxiliary
-                        #       Data is not supported by the Linux kernel.
-                        return pkt, sa_ll, timestamp
-                    if auxdata.tp_vlan_tci != 0 or \
-                            auxdata.tp_status & TP_STATUS_VLAN_VALID:
-                        # Insert VLAN tag
-                        tpid = ETH_P_8021Q
-                        if auxdata.tp_status & TP_STATUS_VLAN_TPID_VALID:
-                            tpid = auxdata.tp_vlan_tpid
-                        tag = struct.pack(
-                            "!HH",
-                            tpid,
-                            auxdata.tp_vlan_tci
-                        )
-                        pkt = pkt[:12] + tag + pkt[12:]
-                elif cmsg_lvl == socket.SOL_SOCKET and \
-                        cmsg_type == SO_TIMESTAMPNS:
-                    length = len(cmsg_data)
-                    if length == 16:  # __kernel_timespec
-                        tmp = struct.unpack("ll", cmsg_data)
-                    elif length == 8:  # timespec
-                        tmp = struct.unpack("ii", cmsg_data)
-                    else:
-                        log_runtime.warning("Unknown timespec format.. ?!")
-                        continue
-                    timestamp = tmp[0] + tmp[1] * 1e-9
-            return pkt, sa_ll, timestamp
+    def close(self):
+        # type: () -> None
+        if self.closed:
+            return
+        try:
+            if self.promisc and getattr(self, "ins", None):
+                set_promisc(self.ins, self.iface, 0)
+        except (AttributeError, OSError):
+            pass
+        SuperSocket.close(self)
 
     def recv_raw(self, x=MTU):
         # type: (int) -> Tuple[Optional[Type[Packet]], Optional[bytes], Optional[float]]  # noqa: E501
-        """Returns a tuple containing (cls, pkt_data, time)"""
-        return conf.raw_layer, self.ins.recv(x), None
+        """Receives a packet, then returns a tuple containing (cls, pkt_data, time)"""  # noqa: E501
+        pkt, sa_ll, ts = self._recv_raw(self.ins, x)
+        if self.outs and sa_ll[2] == socket.PACKET_OUTGOING:
+            return None, None, None
+        if ts is None:
+            ts = get_last_packet_timestamp(self.ins)
+        return self.LL, pkt, ts
 
-    def recv(self, x=MTU):
-        # type: (int) -> Optional[Packet]
-        cls, val, ts = self.recv_raw(x)
-        if not val or not cls:
-            return None
+    def send(self, x):
+        # type: (Packet) -> int
         try:
-            pkt = cls(val)  # type: Packet
-        except KeyboardInterrupt:
+            return SuperSocket.send(self, x)
+        except socket.error as msg:
+            if msg.errno == 22 and len(x) < conf.min_pkt_size:
+                padding = b"\x00" * (conf.min_pkt_size - len(x))
+                if isinstance(x, Packet):
+                    return SuperSocket.send(self, x / Padding(load=padding))
+                else:
+                    return SuperSocket.send(self, raw(x) + padding)
             raise
-        except Exception:
-            if conf.debug_dissector:
-                from scapy.sendrecv import debug
-                debug.crashed_on = (cls, val)
-                raise
-            pkt = conf.raw_layer(val)
-        if ts:
-            pkt.time = ts
-        return pkt
-
-    def fileno(self):
-        # type: () -> int
-        return self.ins.fileno()
 
-    def close(self):
-        # type: () -> None
-        if self.closed:
-            return
-        self.closed = True
-        if getattr(self, "outs", None):
-            if getattr(self, "ins", None) != self.outs:
-                if self.outs and self.outs.fileno() != -1:
-                    self.outs.close()
-        if getattr(self, "ins", None):
-            if self.ins.fileno() != -1:
-                self.ins.close()
-
-    def sr(self, *args, **kargs):
-        # type: (Any, Any) -> Tuple[SndRcvList, PacketList]
-        from scapy import sendrecv
-        ans, unans = sendrecv.sndrcv(self, *args, **kargs)  # type: SndRcvList, PacketList  # noqa: E501
-        return ans, unans
-
-    def sr1(self, *args, **kargs):
-        # type: (Any, Any) -> Optional[Packet]
-        from scapy import sendrecv
-        ans = sendrecv.sndrcv(self, *args, **kargs)[0]  # type: SndRcvList
-        if len(ans) > 0:
-            pkt = ans[0][1]  # type: Packet
-            return pkt
-        else:
-            return None
 
-    def sniff(self, *args, **kargs):
-        # type: (Any, Any) -> PacketList
-        from scapy import sendrecv
-        pkts = sendrecv.sniff(opened_socket=self, *args, **kargs)  # type: PacketList  # noqa: E501
-        return pkts
-
-    def tshark(self, *args, **kargs):
-        # type: (Any, Any) -> None
-        from scapy import sendrecv
-        sendrecv.tshark(opened_socket=self, *args, **kargs)
-
-    # TODO: use 'scapy.ansmachine.AnsweringMachine' when typed
-    def am(self,
-           cls,  # type: Type[Any]
-           *args,  # type: Any
-           **kwargs  # type: Any
-           ):
-        # type: (...) -> Any
-        """
-        Creates an AnsweringMachine associated with this socket.
+class L2ListenSocket(L2Socket):
+    desc = "read packets at layer 2 using Linux PF_PACKET sockets. Also receives the packets going OUT"  # noqa: E501
 
-        :param cls: A subclass of AnsweringMachine to instantiate
-        """
-        return cls(*args, opened_socket=self, socket=self, **kwargs)
+    def send(self, x):
+        # type: (Packet) -> NoReturn
+        raise Scapy_Exception("Can't send anything with L2ListenSocket")
 
-    @staticmethod
-    def select(sockets, remain=conf.recv_poll_rate):
-        # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
-        """This function is called during sendrecv() routine to select
-        the available sockets.
-
-        :param sockets: an array of sockets that need to be selected
-        :returns: an array of sockets that were selected and
-            the function to be called next to get the packets (i.g. recv)
-        """
-        try:
-            inp, _, _ = select(sockets, [], [], remain)
-        except (IOError, select_error) as exc:
-            # select.error has no .errno attribute
-            if not exc.args or exc.args[0] != errno.EINTR:
-                raise
-        return inp
 
-    def __del__(self):
-        # type: () -> None
-        """Close the socket"""
-        self.close()
+class L3PacketSocket(L2Socket):
+    desc = "read/write packets at layer 3 using Linux PF_PACKET sockets"
 
-    def __enter__(self):
-        # type: () -> SuperSocket
-        return self
+    def recv(self, x=MTU, **kwargs):
+        # type: (int, **Any) -> Optional[Packet]
+        pkt = SuperSocket.recv(self, x, **kwargs)
+        if pkt and self.lvl == 2:
+            pkt.payload.time = pkt.time
+            return pkt.payload
+        return pkt
 
-    def __exit__(self, exc_type, exc_value, traceback):
-        # type: (Optional[Type[BaseException]], Optional[BaseException], Optional[Any]) -> None  # noqa: E501
-        """Close the socket"""
-        self.close()
-
-
-if not WINDOWS:
-    class L3RawSocket(SuperSocket):
-        desc = "Layer 3 using Raw sockets (PF_INET/SOCK_RAW)"
-
-        def __init__(self,
-                     type=ETH_P_IP,  # type: int
-                     filter=None,  # type: Optional[str]
-                     iface=None,  # type: Optional[_GlobInterfaceType]
-                     promisc=None,  # type: Optional[bool]
-                     nofilter=0  # type: int
-                     ):
-            # type: (...) -> None
-            self.outs = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)  # noqa: E501
-            self.outs.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1)
-            self.ins = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(type))  # noqa: E501
-            if iface is not None:
-                iface = network_name(iface)
-                self.iface = iface
-                self.ins.bind((iface, type))
-            else:
-                self.iface = "any"
-            if not six.PY2:
-                try:
-                    # Receive Auxiliary Data (VLAN tags)
-                    self.ins.setsockopt(SOL_PACKET, PACKET_AUXDATA, 1)
-                    self.ins.setsockopt(
-                        socket.SOL_SOCKET,
-                        SO_TIMESTAMPNS,
-                        1
-                    )
-                    self.auxdata_available = True
-                except OSError:
-                    # Note: Auxiliary Data is only supported since
-                    #       Linux 2.6.21
-                    msg = "Your Linux Kernel does not support Auxiliary Data!"
-                    log_runtime.info(msg)
-
-        def recv(self, x=MTU):
-            # type: (int) -> Optional[Packet]
-            data, sa_ll, ts = self._recv_raw(self.ins, x)
-            if sa_ll[2] == socket.PACKET_OUTGOING:
-                return None
-            if sa_ll[3] in conf.l2types:
-                cls = conf.l2types.num2layer[sa_ll[3]]  # type: Type[Packet]
-                lvl = 2
-            elif sa_ll[1] in conf.l3types:
-                cls = conf.l3types.num2layer[sa_ll[1]]
-                lvl = 3
+    def send(self, x):
+        # type: (Packet) -> int
+        iff = x.route()[0]
+        if iff is None:
+            iff = network_name(conf.iface)
+        sdto = (iff, self.type)
+        self.outs.bind(sdto)
+        sn = self.outs.getsockname()
+        ll = lambda x: x  # type: Callable[[Packet], Packet]
+        type_x = type(x)
+        if type_x in conf.l3types:
+            sdto = (iff, conf.l3types.layer2num[type_x])
+        if sn[3] in conf.l2types:
+            ll = lambda x: conf.l2types.num2layer[sn[3]]() / x
+        if self.lvl == 3 and type_x != self.LL:
+            warning("Incompatible L3 types detected using %s instead of %s !",
+                    type_x, self.LL)
+            self.LL = type_x
+        sx = raw(ll(x))
+        x.sent_time = time.time()
+        try:
+            return self.outs.sendto(sx, sdto)
+        except socket.error as msg:
+            if msg.errno == 22 and len(sx) < conf.min_pkt_size:
+                return self.outs.send(
+                    sx + b"\x00" * (conf.min_pkt_size - len(sx))
+                )
+            elif conf.auto_fragment and msg.errno == 90:
+                i = 0
+                for p in x.fragment():
+                    i += self.outs.sendto(raw(ll(p)), sdto)
+                return i
             else:
-                cls = conf.default_l2
-                warning("Unable to guess type (interface=%s protocol=%#x family=%i). Using %s", sa_ll[0], sa_ll[1], sa_ll[3], cls.name)  # noqa: E501
-                lvl = 3
-
-            try:
-                pkt = cls(data)
-            except KeyboardInterrupt:
                 raise
-            except Exception:
-                if conf.debug_dissector:
-                    raise
-                pkt = conf.raw_layer(data)
-
-            if lvl == 2:
-                pkt = pkt.payload
-
-            if pkt is not None:
-                if ts is None:
-                    from scapy.arch.linux import get_last_packet_timestamp
-                    ts = get_last_packet_timestamp(self.ins)
-                pkt.time = ts
-            return pkt
-
-        def send(self, x):
-            # type: (Packet) -> int
-            try:
-                sx = raw(x)
-                if self.outs:
-                    x.sent_time = time.time()
-                    return self.outs.sendto(
-                        sx,
-                        (x.dst, 0)
-                    )
-            except AttributeError:
-                raise ValueError(
-                    "Missing 'dst' attribute in the first layer to be "
-                    "sent using a native L3 socket ! (make sure you passed the "
-                    "IP layer)"
-                )
-            except socket.error as msg:
-                log_runtime.error(msg)
-            return 0
-
-
-class SimpleSocket(SuperSocket):
-    desc = "wrapper around a classic socket"
-
-    def __init__(self, sock):
-        # type: (socket.socket) -> None
-        self.ins = sock
-        self.outs = sock
-
-
-class StreamSocket(SimpleSocket):
-    desc = "transforms a stream socket into a layer 2"
-    nonblocking_socket = True
-
-    def __init__(self, sock, basecls=None):
-        # type: (socket.socket, Optional[Type[Packet]]) -> None
-        if basecls is None:
-            basecls = conf.raw_layer
-        SimpleSocket.__init__(self, sock)
-        self.basecls = basecls
-
-    def recv(self, x=MTU):
-        # type: (int) -> Optional[Packet]
-        data = self.ins.recv(x, socket.MSG_PEEK)
-        x = len(data)
-        if x == 0:
-            return None
-        pkt = self.basecls(data)  # type: Packet
-        pad = pkt.getlayer(conf.padding_layer)
-        if pad is not None and pad.underlayer is not None:
-            del pad.underlayer.payload
-        from scapy.packet import NoPayload
-        while pad is not None and not isinstance(pad, NoPayload):
-            x -= len(pad.load)
-            pad = pad.payload
-        self.ins.recv(x)
-        return pkt
 
 
-class SSLStreamSocket(StreamSocket):
-    desc = "similar usage than StreamSocket but specialized for handling SSL-wrapped sockets"  # noqa: E501
+class VEthPair(object):
+    """
+    encapsulates a virtual Ethernet interface pair
+    """
+
+    def __init__(self, iface_name, peer_name):
+        # type: (str, str) -> None
+        if not LINUX:
+            # ToDo: do we need a kernel version check here?
+            raise ScapyInvalidPlatformException(
+                'Virtual Ethernet interface pair only available on Linux'
+            )
 
-    def __init__(self, sock, basecls=None):
-        # type: (socket.socket, Optional[Type[Packet]]) -> None
-        self._buf = b""
-        super(SSLStreamSocket, self).__init__(sock, basecls)
-
-    # 65535, the default value of x is the maximum length of a TLS record
-    def recv(self, x=65535):
-        # type: (int) -> Optional[Packet]
-        pkt = None  # type: Optional[Packet]
-        if self._buf != b"":
-            try:
-                pkt = self.basecls(self._buf)
-            except Exception:
-                # We assume that the exception is generated by a buffer underflow  # noqa: E501
-                pass
-
-        if not pkt:
-            buf = self.ins.recv(x)
-            if len(buf) == 0:
-                raise socket.error((100, "Underlying stream socket tore down"))
-            self._buf += buf
-
-        x = len(self._buf)
-        pkt = self.basecls(self._buf)
-        if pkt is not None:
-            pad = pkt.getlayer(conf.padding_layer)
-
-            if pad is not None and pad.underlayer is not None:
-                del pad.underlayer.payload
-            while pad is not None and not isinstance(pad, scapy.packet.NoPayload):   # noqa: E501
-                x -= len(pad.load)
-                pad = pad.payload
-            self._buf = self._buf[x:]
-        return pkt
+        self.ifaces = [iface_name, peer_name]
 
+    def iface(self):
+        # type: () -> str
+        return self.ifaces[0]
 
-class L2ListenTcpdump(SuperSocket):
-    desc = "read packets at layer 2 using tcpdump"
+    def peer(self):
+        # type: () -> str
+        return self.ifaces[1]
 
-    def __init__(self,
-                 iface=None,  # type: Optional[_GlobInterfaceType]
-                 promisc=None,  # type: Optional[bool]
-                 filter=None,  # type: Optional[str]
-                 nofilter=False,  # type: bool
-                 prog=None,  # type: Optional[str]
-                 *arg,  # type: Any
-                 **karg  # type: Any
-                 ):
-        # type: (...) -> None
-        self.outs = None
-        args = ['-w', '-', '-s', '65535']
-        self.iface = "any"
-        if iface is None and (WINDOWS or DARWIN):
-            self.iface = iface = conf.iface
-        if promisc is None:
-            promisc = conf.sniff_promisc
-        if iface is not None:
-            args.extend(['-i', network_name(iface)])
-        if not promisc:
-            args.append('-p')
-        if not nofilter:
-            if conf.except_filter:
-                if filter:
-                    filter = "(%s) and not (%s)" % (filter, conf.except_filter)
-                else:
-                    filter = "not (%s)" % conf.except_filter
-        if filter is not None:
-            args.append(filter)
-        self.tcpdump_proc = tcpdump(None, prog=prog, args=args, getproc=True)
-        self.reader = PcapReader(self.tcpdump_proc.stdout)
-        self.ins = self.reader  # type: ignore
-
-    def recv(self, x=MTU):
-        # type: (int) -> Optional[Packet]
-        return self.reader.recv(x)
+    def setup(self):
+        # type: () -> None
+        """
+        create veth pair links
+        :raises subprocess.CalledProcessError if operation fails
+        """
+        subprocess.check_call(['ip', 'link', 'add', self.ifaces[0], 'type', 'veth', 'peer', 'name', self.ifaces[1]])  # noqa: E501
 
-    def close(self):
+    def destroy(self):
         # type: () -> None
-        SuperSocket.close(self)
-        self.tcpdump_proc.kill()
+        """
+        remove veth pair links
+        :raises subprocess.CalledProcessError if operation fails
+        """
+        subprocess.check_call(['ip', 'link', 'del', self.ifaces[0]])
 
-    @staticmethod
-    def select(sockets, remain=None):
-        # type: (List[SuperSocket], Optional[float]) -> List[SuperSocket]
-        if (WINDOWS or DARWIN):
-            return sockets
-        return SuperSocket.select(sockets, remain=remain)
-
-
-# More abstract objects
-
-class IterSocket(SuperSocket):
-    desc = "wrapper around an iterable"
-    nonblocking_socket = True
-
-    def __init__(self, obj):
-        # type: (_PacketIterable) -> None
-        if not obj:
-            self.iter = iter([])  # type: Iterator[Packet]
-        elif isinstance(obj, IterSocket):
-            self.iter = obj.iter
-        elif isinstance(obj, SndRcvList):
-            def _iter(obj=cast(SndRcvList, obj)):
-                # type: (SndRcvList) -> Iterator[Packet]
-                for s, r in obj:
-                    if s.sent_time:
-                        s.time = s.sent_time
-                    yield s
-                    yield r
-            self.iter = _iter()
-        elif isinstance(obj, (list, PacketList)):
-            if isinstance(obj[0], bytes):  # type: ignore
-                self.iter = iter(obj)
-            else:
-                self.iter = (y for x in obj for y in x)
-        else:
-            self.iter = obj.__iter__()
+    def up(self):
+        # type: () -> None
+        """
+        set veth pair links up
+        :raises subprocess.CalledProcessError if operation fails
+        """
+        for idx in [0, 1]:
+            subprocess.check_call(["ip", "link", "set", self.ifaces[idx], "up"])  # noqa: E501
 
-    @staticmethod
-    def select(sockets, remain=None):
-        # type: (List[SuperSocket], Any) -> List[SuperSocket]
-        return sockets
+    def down(self):
+        # type: () -> None
+        """
+        set veth pair links down
+        :raises subprocess.CalledProcessError if operation fails
+        """
+        for idx in [0, 1]:
+            subprocess.check_call(["ip", "link", "set", self.ifaces[idx], "down"])  # noqa: E501
 
-    def recv(self, *args):
-        # type: (*Any) -> Optional[Packet]
-        try:
-            pkt = next(self.iter)
-            return pkt.__class__(bytes(pkt))
-        except StopIteration:
-            raise EOFError
+    def __enter__(self):
+        # type: () -> VEthPair
+        self.setup()
+        self.up()
+        conf.ifaces.reload()
+        return self
 
-    def close(self):
-        # type: () -> None
-        pass
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        # type: (Any, Any, Any) -> None
+        self.destroy()
+        conf.ifaces.reload()
```

### Comparing `scapy-2.5.0rc3/scapy/themes.py` & `scapy-2.6.0rc1/scapy/themes.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,46 +7,49 @@
 Color themes for the interactive console.
 """
 
 ##################
 #  Color themes  #
 ##################
 
+import html
 import sys
 
-from scapy.compat import (
+from typing import (
     Any,
-    Callable,
     List,
     Optional,
     Tuple,
+    cast,
 )
+from scapy.compat import Protocol
 
 
 class ColorTable:
     colors = {  # Format: (ansi, pygments)
         # foreground
         "black": ("\033[30m", "#ansiblack"),
         "red": ("\033[31m", "#ansired"),
         "green": ("\033[32m", "#ansigreen"),
         "yellow": ("\033[33m", "#ansiyellow"),
         "blue": ("\033[34m", "#ansiblue"),
         "purple": ("\033[35m", "#ansipurple"),
         "cyan": ("\033[36m", "#ansicyan"),
-        "grey": ("\033[37m", "#ansiwhite"),
+        "white": ("\033[37m", "#ansiwhite"),
+        "grey": ("\033[38;5;246m", "#ansiwhite"),
         "reset": ("\033[39m", "noinherit"),
         # background
         "bg_black": ("\033[40m", "bg:#ansiblack"),
         "bg_red": ("\033[41m", "bg:#ansired"),
         "bg_green": ("\033[42m", "bg:#ansigreen"),
         "bg_yellow": ("\033[43m", "bg:#ansiyellow"),
         "bg_blue": ("\033[44m", "bg:#ansiblue"),
         "bg_purple": ("\033[45m", "bg:#ansipurple"),
         "bg_cyan": ("\033[46m", "bg:#ansicyan"),
-        "bg_grey": ("\033[47m", "bg:#ansiwhite"),
+        "bg_white": ("\033[47m", "bg:#ansiwhite"),
         "bg_reset": ("\033[49m", "noinherit"),
         # specials
         "normal": ("\033[0m", "noinherit"),  # color & brightness
         "bold": ("\033[1m", "bold"),
         "uline": ("\033[4m", "underline"),
         "blink": ("\033[5m", ""),
         "invert": ("\033[7m", ""),
@@ -70,41 +73,79 @@
             x = x.replace(k, " " + v)
         return x.strip()
 
 
 Color = ColorTable()
 
 
+class _ColorFormatterType(Protocol):
+    def __call__(self,
+                 val: Any,
+                 fmt: Optional[str] = None,
+                 fmt2: str = "",
+                 before: str = "",
+                 after: str = "") -> str:
+        pass
+
+
 def create_styler(fmt=None,  # type: Optional[str]
                   before="",  # type: str
                   after="",  # type: str
                   fmt2="%s"  # type: str
                   ):
-    # type: (...) -> Callable[[Any], str]
-    def do_style(val, fmt=fmt, fmt2=fmt2, before=before, after=after):
-        # type: (Any, Optional[str], str, str, str) -> str
+    # type: (...) -> _ColorFormatterType
+    def do_style(val: Any,
+                 fmt: Optional[str] = fmt,
+                 fmt2: str = fmt2,
+                 before: str = before,
+                 after: str = after) -> str:
         if fmt is None:
             sval = str(val)
         else:
             sval = fmt % val
         return fmt2 % (before + sval + after)
     return do_style
 
 
 class ColorTheme:
+    style_normal = ""
+    style_prompt = ""
+    style_punct = ""
+    style_id = ""
+    style_not_printable = ""
+    style_layer_name = ""
+    style_field_name = ""
+    style_field_value = ""
+    style_emph_field_name = ""
+    style_emph_field_value = ""
+    style_depreciate_field_name = ""
+    style_packetlist_name = ""
+    style_packetlist_proto = ""
+    style_packetlist_value = ""
+    style_fail = ""
+    style_success = ""
+    style_odd = ""
+    style_even = ""
+    style_opening = ""
+    style_active = ""
+    style_closed = ""
+    style_left = ""
+    style_right = ""
+    style_logo = ""
+
     def __repr__(self):
         # type: () -> str
         return "<%s>" % self.__class__.__name__
 
     def __reduce__(self):
         # type: () -> Tuple[type, Any, Any]
         return (self.__class__, (), ())
 
     def __getattr__(self, attr):
-        # type: (str) -> Callable[[Any], str]
+        # type: (str) -> _ColorFormatterType
         if attr in ["__getstate__", "__setstate__", "__getinitargs__",
                     "__reduce_ex__"]:
             raise AttributeError()
         return create_styler()
 
     def format(self, string, fmt):
         # type: (str, str) -> str
@@ -115,79 +156,56 @@
 
 class NoTheme(ColorTheme):
     pass
 
 
 class AnsiColorTheme(ColorTheme):
     def __getattr__(self, attr):
-        # type: (str) -> Callable[[Any], str]
+        # type: (str) -> _ColorFormatterType
         if attr.startswith("__"):
             raise AttributeError(attr)
         s = "style_%s" % attr
         if s in self.__class__.__dict__:
             before = getattr(self, s)
             after = self.style_normal
         elif not isinstance(self, BlackAndWhite) and attr in Color.colors:
             before = Color.colors[attr][0]
             after = Color.colors["normal"][0]
         else:
             before = after = ""
 
         return create_styler(before=before, after=after)
 
-    style_normal = ""
-    style_prompt = ""
-    style_punct = ""
-    style_id = ""
-    style_not_printable = ""
-    style_layer_name = ""
-    style_field_name = ""
-    style_field_value = ""
-    style_emph_field_name = ""
-    style_emph_field_value = ""
-    style_packetlist_name = ""
-    style_packetlist_proto = ""
-    style_packetlist_value = ""
-    style_fail = ""
-    style_success = ""
-    style_odd = ""
-    style_even = ""
-    style_opening = ""
-    style_active = ""
-    style_closed = ""
-    style_left = ""
-    style_right = ""
-    style_logo = ""
-
 
 class BlackAndWhite(AnsiColorTheme, NoTheme):
     pass
 
 
 class DefaultTheme(AnsiColorTheme):
     style_normal = Color.normal
     style_prompt = Color.blue + Color.bold
     style_punct = Color.normal
     style_id = Color.blue + Color.bold
-    style_not_printable = Color.grey
+    style_not_printable = Color.white
+    style_depreciate_field_name = Color.grey
     style_layer_name = Color.red + Color.bold
     style_field_name = Color.blue
     style_field_value = Color.purple
     style_emph_field_name = Color.blue + Color.uline + Color.bold
     style_emph_field_value = Color.purple + Color.uline + Color.bold
     style_packetlist_name = Color.red + Color.bold
     style_packetlist_proto = Color.blue
     style_packetlist_value = Color.purple
     style_fail = Color.red + Color.bold
     style_success = Color.blue + Color.bold
     style_even = Color.black + Color.bold
     style_odd = Color.black
     style_opening = Color.yellow
     style_active = Color.black
-    style_closed = Color.grey
+    style_closed = Color.white
     style_left = Color.blue + Color.invert
     style_right = Color.red + Color.invert
     style_logo = Color.green + Color.bold
 
 
 class BrightTheme(AnsiColorTheme):
     style_normal = Color.normal
@@ -247,33 +265,36 @@
     style_emph_field_value = Color.red + Color.bold
     style_packetlist_name = Color.black + Color.bold
     style_packetlist_proto = Color.yellow + Color.bold
     style_packetlist_value = Color.purple + Color.bold
     style_fail = Color.red + Color.bold
     style_success = Color.green
     style_even = Color.black + Color.bold
-    style_odd = Color.grey
+    style_odd = Color.white
     style_opening = Color.yellow
-    style_active = Color.grey + Color.bold
+    style_active = Color.white + Color.bold
     style_closed = Color.black + Color.bold
     style_left = Color.cyan + Color.bold
     style_right = Color.red + Color.bold
     style_logo = Color.green + Color.bold
 
 
 class FormatTheme(ColorTheme):
-    def __getattr__(self, attr):
-        # type: (str) -> Callable[[Any], str]
+    def __getattr__(self, attr: str) -> _ColorFormatterType:
         if attr.startswith("__"):
             raise AttributeError(attr)
         colfmt = self.__class__.__dict__.get("style_%s" % attr, "%s")
         return create_styler(fmt2=colfmt)
 
 
 class LatexTheme(FormatTheme):
+    r"""
+    You can prepend the output from this theme with
+    \tt\obeyspaces\obeylines\tiny\noindent
+    """
     style_prompt = r"\textcolor{blue}{%s}"
     style_not_printable = r"\textcolor{gray}{%s}"
     style_layer_name = r"\textcolor{red}{\bf %s}"
     style_field_name = r"\textcolor{blue}{%s}"
     style_field_value = r"\textcolor{purple}{%s}"
     style_emph_field_name = r"\textcolor{blue}{\underline{%s}}"  # ul
     style_emph_field_value = r"\textcolor{purple}{\underline{%s}}"  # ul
@@ -284,14 +305,22 @@
     style_success = r"\textcolor{blue}{\bf %s}"
     style_left = r"\textcolor{blue}{%s}"
     style_right = r"\textcolor{red}{%s}"
 #    style_even = r"}{\bf "
 #    style_odd = ""
     style_logo = r"\textcolor{green}{\bf %s}"
 
+    def __getattr__(self, attr: str) -> _ColorFormatterType:
+        from scapy.utils import tex_escape
+        styler = super(LatexTheme, self).__getattr__(attr)
+        return cast(
+            _ColorFormatterType,
+            lambda x, *args, **kwargs: styler(tex_escape(x), *args, **kwargs),
+        )
+
 
 class LatexTheme2(FormatTheme):
     style_prompt = r"@`@textcolor@[@blue@]@@[@%s@]@"
     style_not_printable = r"@`@textcolor@[@gray@]@@[@%s@]@"
     style_layer_name = r"@`@textcolor@[@red@]@@[@@`@bfseries@[@@]@%s@]@"
     style_field_name = r"@`@textcolor@[@blue@]@@[@%s@]@"
     style_field_value = r"@`@textcolor@[@purple@]@@[@%s@]@"
@@ -384,16 +413,15 @@
     if isinstance(conf.prompt, Prompts):
         # Set custom prompt style
         shell.prompts_class = conf.prompt
     else:
         if isinstance(conf.color_theme, (FormatTheme, NoTheme)):
             # Formatable
             if isinstance(conf.color_theme, HTMLTheme):
-                from scapy.compat import html_escape
-                prompt = html_escape(conf.prompt)
+                prompt = html.escape(conf.prompt)
             elif isinstance(conf.color_theme, LatexTheme):
                 from scapy.utils import tex_escape
                 prompt = tex_escape(conf.prompt)
             else:
                 prompt = conf.prompt
             prompt = conf.color_theme.prompt(prompt)
         else:
```

### Comparing `scapy-2.5.0rc3/scapy/tools/UTscapy.py` & `scapy-2.6.0rc1/scapy/tools/UTscapy.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,16 +3,15 @@
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
 """
 Unit testing infrastructure for Scapy
 """
 
-from __future__ import print_function
-
+import builtins
 import bz2
 import copy
 import code
 import getopt
 import glob
 import hashlib
 import importlib
@@ -23,31 +22,28 @@
 import sys
 import threading
 import time
 import traceback
 import warnings
 import zlib
 
-from scapy.consts import WINDOWS, DARWIN
-import scapy.libs.six as six
+from scapy.consts import WINDOWS
 from scapy.config import conf
-from scapy.compat import base64_bytes, bytes_hex, plain_str
+from scapy.compat import base64_bytes
 from scapy.themes import DefaultTheme, BlackAndWhite
 from scapy.utils import tex_escape
 
 
 # Check UTF-8 support #
 
 def _utf8_support():
     """
     Check UTF-8 support for the output
     """
     try:
-        if six.PY2:
-            return False
         if WINDOWS:
             return (sys.stdout.encoding == "utf-8")
         return True
     except AttributeError:
         return False
 
 
@@ -65,44 +61,44 @@
 
 class Bunch:
     __init__ = lambda self, **kw: setattr(self, '__dict__', kw)
 
 
 def retry_test(func):
     """Retries the passed function 3 times before failing"""
-    success = False
+    v = None
+    tb = None
     for _ in range(3):
         try:
-            result = func()
+            return func()
         except Exception:
             t, v, tb = sys.exc_info()
             time.sleep(1)
-        else:
-            success = True
-            break
-    if not success:
-        six.reraise(t, v, tb)
-    assert success
-    return result
+
+    if v and tb:
+        raise v.with_traceback(tb)
 
 
 def scapy_path(fname):
     """Resolves a path relative to scapy's root folder"""
     if fname.startswith('/'):
         fname = fname[1:]
     return os.path.abspath(os.path.join(
         os.path.dirname(__file__), '../../', fname
     ))
 
 
 class no_debug_dissector:
     """Context object used to disable conf.debug_dissector"""
+    def __init__(self, reverse=False):
+        self.new_value = reverse
+
     def __enter__(self):
         self.old_dbg = conf.debug_dissector
-        conf.debug_dissector = False
+        conf.debug_dissector = self.new_value
 
     def __exit__(self, exc_type, exc_value, traceback):
         conf.debug_dissector = self.old_dbg
 
 
 #    Import tool    #
 
@@ -174,20 +170,20 @@
 ki1ZgOQDXQ7aIDTdjGRTgnzPML0V1X+tIoSSZmZhrxZbluMWGEkwwky6\n0ObWIM
 cEbX4cawPPBVc6m5UUPbEmBANyjtNvTKE2ri7oOmBVKIMLqQKm+4rlmisu2uGSxW
 zTov5w\nqQDp61FkHk40wzQUKk4YcBlbQT1l8VXeZJYAVFjSJIcC8JykBYZJ1yka
 I4LDm5WP7s2NaRkhhV7A\nFVSD5zA8V/DJzfTk0QHmCT2wRgwPKjP60EqqlDUaST
 /i7kinChIXSAmRgA==\n""")
 
     def get_local_dict(cls):
-        return {x: y.name for (x, y) in six.iteritems(cls.__dict__)
+        return {x: y.name for (x, y) in cls.__dict__.items()
                 if isinstance(y, File)}
     get_local_dict = classmethod(get_local_dict)
 
     def get_URL_dict(cls):
-        return {x: y.URL for (x, y) in six.iteritems(cls.__dict__)
+        return {x: y.URL for (x, y) in cls.__dict__.items()
                 if isinstance(y, File)}
     get_URL_dict = classmethod(get_URL_dict)
 
 
 #    HELPER CLASSES FOR PARAMETRING OUTPUT FORMAT    #
 
 class EnumClass:
@@ -208,15 +204,15 @@
 #    TEST CLASSES    #
 
 class TestClass:
     def __getitem__(self, item):
         return getattr(self, item)
 
     def add_keywords(self, kws):
-        if isinstance(kws, six.string_types):
+        if isinstance(kws, str):
             kws = [kws.lower()]
         for kwd in kws:
             kwd = kwd.lower()
             if kwd.startswith('-'):
                 try:
                     self.keywords.remove(kwd[1:])
                 except KeyError:
@@ -295,19 +291,14 @@
         self.output = ""
         self.num = -1
         self.keywords = set()
         self.crc = None
         self.expand = 1
 
     def prepare(self, theme):
-        if six.PY2:
-            self.test = self.test.decode("utf8", "ignore")
-            self.output = self.output.decode("utf8", "ignore")
-            self.comments = self.comments.decode("utf8", "ignore")
-            self.result = self.result.decode("utf8", "ignore")
         if self.result == "passed":
             self.fresult = theme.success(self.result)
         else:
             self.fresult = theme.fail(self.result)
 
     def __nonzero__(self):
         return self.result == "passed"
@@ -458,26 +449,20 @@
             print("Usage example::")
             for line in t.test.split('\n'):
                 if not line.rstrip().endswith('# no_docs'):
                     print("\t%s" % line)
 
 
 #    COMPUTE CAMPAIGN DIGESTS    #
-if six.PY2:
-    def crc32(x):
-        return "%08X" % (0xffffffff & zlib.crc32(x))
+def crc32(x):
+    return "%08X" % (0xffffffff & zlib.crc32(bytearray(x, "utf8")))
 
-    def sha1(x):
-        return hashlib.sha1(x).hexdigest().upper()
-else:
-    def crc32(x):
-        return "%08X" % (0xffffffff & zlib.crc32(bytearray(x, "utf8")))
 
-    def sha1(x):
-        return hashlib.sha1(x.encode("utf8")).hexdigest().upper()
+def sha1(x):
+    return hashlib.sha1(x.encode("utf8")).hexdigest().upper()
 
 
 def compute_campaign_digests(test_campaign):
     dc = ""
     for ts in test_campaign:
         dts = ""
         for t in ts:
@@ -559,15 +544,15 @@
     finally:
         test.duration = time.time() - start_time
         if test.result == "failed":
             from scapy.sendrecv import debug
             # Add optional debugging data to log
             if debug.crashed_on:
                 cls, val = debug.crashed_on
-                test.output += "\n\nPACKET DISSECTION FAILED ON:\n %s(hex_bytes('%s'))" % (cls.__name__, plain_str(bytes_hex(val)))
+                test.output += "\n\nPACKET DISSECTION FAILED ON:\n %s(bytes.fromhex('%s'))" % (cls.__name__, val.hex())
                 debug.crashed_on = None
         test.prepare(theme)
         if verb > 2:
             print("%(fresult)6s %(crc)s %(duration)06.2fs %(name)s" % test)
         elif verb > 1:
             print("%(fresult)6s %(crc)s %(name)s" % test)
 
@@ -982,14 +967,17 @@
 
 
 def main():
     argv = sys.argv[1:]
     logger = logging.getLogger("scapy")
     logger.addHandler(logging.StreamHandler())
 
+    # Treat SyntaxWarning as errors
+    warnings.filterwarnings("error", category=SyntaxWarning)
+
     import scapy
     print(dash + " UTScapy - Scapy %s - %s" % (
         scapy.__version__, sys.version.split(" ")[0]
     ))
 
     # Parse arguments
 
@@ -1104,19 +1092,14 @@
     if FORMAT in [Format.LIVE, Format.ANSI]:
         theme = DefaultTheme()
     else:
         theme = BlackAndWhite()
 
     # Disable tests if needed
 
-    # Discard Python3 tests when using Python2
-    if six.PY2:
-        KW_KO.append("python3_only")
-        if VERB > 2:
-            print(" " + arrow + " Python 2 mode")
     try:
         if NON_ROOT or os.getuid() != 0:  # Non root
             # Discard root tests
             KW_KO.append("needs_root")
             if VERB > 2:
                 print(" " + arrow + " Non-root mode")
     except AttributeError:
@@ -1125,19 +1108,14 @@
     if conf.use_pcap or WINDOWS:
         KW_KO.append("not_libpcap")
         if VERB > 2:
             print(" " + arrow + " libpcap mode")
 
     KW_KO.append("disabled")
 
-    # Process extras
-    if six.PY2 and DARWIN:
-        # On MacOS 12, Python 2.7 find_library is broken
-        KW_KO.append("libpcap")
-
     if ANNOTATIONS_MODE:
         try:
             from pyannotate_runtime import collect_types
         except ImportError:
             raise ImportError("Please install pyannotate !")
         collect_types.init_types_collection()
         collect_types.start()
@@ -1150,15 +1128,15 @@
         print("[CRITICAL]: Cannot import Scapy: %s" % e)
         traceback.print_exc()
         sys.exit(1)  # Abort the tests
 
     for m in MODULES:
         try:
             mod = import_module(m)
-            six.moves.builtins.__dict__.update(mod.__dict__)
+            builtins.__dict__.update(mod.__dict__)
         except ImportError as e:
             raise getopt.GetoptError("cannot import [%s]: %s" % (m, e))
 
     autorun_func = {
         Format.TEXT: scapy.autorun_get_text_interactive_session,
         Format.ANSI: scapy.autorun_get_ansi_interactive_session,
         Format.HTML: scapy.autorun_get_html_interactive_session,
@@ -1173,15 +1151,15 @@
     glob_output = ""
     glob_result = 0
     glob_title = None
 
     UNIQUE = len(TESTFILES) == 1
 
     # Resolve tags and asterix
-    for prex in six.iterkeys(copy.copy(PREEXEC_DICT)):
+    for prex in copy.copy(PREEXEC_DICT).keys():
         if "*" in prex:
             pycode = PREEXEC_DICT[prex]
             del PREEXEC_DICT[prex]
             for gl in glob.iglob(prex):
                 _pycode = pycode.replace("%name%", os.path.splitext(os.path.split(gl)[1])[0])  # noqa: E501
                 PREEXEC_DICT[gl] = _pycode
 
@@ -1235,15 +1213,15 @@
     # Note: on Python 2, we force-encode to ignore ascii errors
     # on Python 3, we need to detect the type of stream
     if OUTPUTFILE == sys.stdout:
         print(glob_output, file=OUTPUTFILE)
     else:
         with open(OUTPUTFILE, "wb") as f:
             f.write(glob_output.encode("utf8", "ignore")
-                    if 'b' in f.mode or six.PY2 else glob_output)
+                    if 'b' in f.mode else glob_output)
 
     # Print end message
     if VERB > 2:
         if glob_result == 0:
             print(theme.green("UTscapy ended successfully"))
         else:
             print(theme.red("UTscapy ended with error code %s" % glob_result))
```

### Comparing `scapy-2.5.0rc3/scapy/tools/automotive/isotpscanner.py` & `scapy-2.6.0rc1/scapy/tools/automotive/isotpscanner.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,29 +1,33 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Nils Weiss <nils@we155.de>
 # Copyright (C) Alexander Schroeder <alexander1.schroeder@st.othr.de>
 
-from __future__ import print_function
 
 import getopt
 import sys
 import signal
 import re
 import threading
 
 from ast import literal_eval
 
-import scapy.libs.six as six
 from scapy.config import conf
 from scapy.consts import LINUX
-from scapy.compat import Tuple, Optional, Any
 
-if six.PY2 or not LINUX or conf.use_pypy:
+# Typing imports
+from typing import (
+    Tuple,
+    Optional,
+    Any,
+)
+
+if not LINUX or conf.use_pypy:
     conf.contribs['CANSocket'] = {'use-python-can': True}
 
 from scapy.contrib.cansocket import CANSocket, PYTHON_CAN   # noqa: E402
 from scapy.contrib.isotp import isotp_scan  # noqa: E402
 
 
 def usage(is_error):
```

### Comparing `scapy-2.5.0rc3/scapy/tools/automotive/obdscanner.py` & `scapy-2.6.0rc1/scapy/tools/automotive/obdscanner.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,29 +1,27 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Andreas Korb <andreas.korb@e-mundo.de>
 # Copyright (C) Friedrich Feigel <friedrich.feigel@e-mundo.de>
 # Copyright (C) Nils Weiss <nils@we155.de>
 
-from __future__ import print_function
 
 import getopt
 import sys
 import signal
 import re
 import traceback
 
 from ast import literal_eval
 
-import scapy.libs.six as six
 from scapy.config import conf
 from scapy.consts import LINUX
 
-if six.PY2 or not LINUX or conf.use_pypy:
+if not LINUX or conf.use_pypy:
     conf.contribs['CANSocket'] = {'use-python-can': True}
 
 from scapy.contrib.isotp import ISOTPSocket                    # noqa: E402
 from scapy.contrib.cansocket import CANSocket, PYTHON_CAN      # noqa: E402
 from scapy.contrib.automotive.obd.obd import OBD               # noqa: E402
 from scapy.contrib.automotive.obd.scanner import OBD_Scanner, \
     OBD_S01_Enumerator, OBD_S02_Enumerator, OBD_S03_Enumerator, \
```

### Comparing `scapy-2.5.0rc3/scapy/tools/automotive/xcpscanner.py` & `scapy-2.6.0rc1/scapy/tools/automotive/xcpscanner.py`

 * *Files identical despite different names*

### Comparing `scapy-2.5.0rc3/scapy/tools/check_asdis.py` & `scapy-2.6.0rc1/scapy/tools/check_asdis.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # This file is part of Scapy
 # See https://scapy.net/ for more information
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 
-from __future__ import print_function
 import getopt
 
 
 def usage():
     print("""Usage: check_asdis -i <pcap_file> [-o <wrong_packets.pcap>]
     -v   increase verbosity
     -d   hexdiff packets that differ
```

### Comparing `scapy-2.5.0rc3/scapy/tools/generate_ethertypes.py` & `scapy-2.6.0rc1/scapy/tools/generate_ethertypes.py`

 * *Files 27% similar despite different names*

```diff
@@ -7,52 +7,62 @@
 https://github.com/openbsd/src/blob/master/sys/net/ethertypes.h
 
 It allows to have a file with the format of
 http://git.netfilter.org/ebtables/plain/ethertypes
 but up-to-date.
 """
 
+import gzip
 import re
 import urllib.request
 
+from base64 import b85encode
+from scapy.error import log_loading
+
 URL = "https://raw.githubusercontent.com/openbsd/src/master/sys/net/ethertypes.h"  # noqa: E501
 
 with urllib.request.urlopen(URL) as stream:
     DATA = stream.read()
 
-reg = br".*ETHERTYPE_([^\s]+)\s.0x([0-9A-Fa-f]+).*\/\*(.*)\*\/"
-COMPILED = b"""#
+reg = r".*ETHERTYPE_([^\s]+)\s.0x([0-9A-Fa-f]+).*\/\*(.*)\*\/"
+COMPILED = """#
 # Ethernet frame types
 #       This file describes some of the various Ethernet
 #       protocol types that are used on Ethernet networks.
 #
 # This list could be found on:
 #         http://www.iana.org/assignments/ethernet-numbers
 #         http://www.iana.org/assignments/ieee-802-numbers
 #
 # <name>    <hexnumber> <alias1>...<alias35> #Comment
 #
 """
-ALIASES = {
-    b"IP": b"IPv4",
-    b"IPV6": b"IPv6"
-}
+ALIASES = {"IP": "IPv4", "IPV6": "IPv6"}
 
 for line in DATA.split(b"\n"):
-    match = re.match(reg, line)
-    if match:
-        name = match.group(1)
-        name = ALIASES.get(name, name).ljust(16)
-        number = match.group(2).upper()
-        comment = match.group(3).strip()
-        compiled_line = (b"%b%b" + b" " * 25 + b"# %b\n") % (
-            name, number, comment
+    try:
+        match = re.match(reg, line.decode("utf8", errors="backslashreplace"))
+        if match:
+            name = match.group(1)
+            name = ALIASES.get(name, name).ljust(16)
+            number = match.group(2).upper()
+            comment = match.group(3).strip()
+            COMPILED += ("%s%s" + " " * 25 + "# %s\n") % (name, number, comment)
+    except Exception:
+        log_loading.warning(
+            "Couldn't parse one line from [%s] [%r]", URL, line, exc_info=True
         )
-        COMPILED += compiled_line
 
-with open("../libs/ethertypes.py", "rb") as inp:
+# Compress properly
+COMPILED = gzip.compress(COMPILED.encode())
+# Encode in Base85
+COMPILED = b85encode(COMPILED).decode()
+# Split
+COMPILED = "\n".join(COMPILED[i : i + 79] for i in range(0, len(COMPILED), 79)) + "\n"
+
+with open("../libs/ethertypes.py", "r") as inp:
     data = inp.read()
 
-with open("../libs/ethertypes.py", "wb") as out:
-    ini, sep, _ = data.partition(b"DATA = b\"\"\"")
-    COMPILED = ini + sep + b"\n" + COMPILED + b"\"\"\"\n"
+with open("../libs/ethertypes.py", "w") as out:
+    ini, sep, _ = data.partition("DATA = _d(\"\"\"")
+    COMPILED = ini + sep + "\n" + COMPILED + "\"\"\")\n"
     print("Written: %s" % out.write(COMPILED))
```

### Comparing `scapy-2.5.0rc3/scapy/utils.py` & `scapy-2.6.0rc1/scapy/utils.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,6547 +6,7994 @@
 00000050: 3a2f 2f73 6361 7079 2e6e 6574 2f20 666f  ://scapy.net/ fo
 00000060: 7220 6d6f 7265 2069 6e66 6f72 6d61 7469  r more informati
 00000070: 6f6e 0a23 2043 6f70 7972 6967 6874 2028  on.# Copyright (
 00000080: 4329 2050 6869 6c69 7070 6520 4269 6f6e  C) Philippe Bion
 00000090: 6469 203c 7068 696c 4073 6563 6465 762e  di <phil@secdev.
 000000a0: 6f72 673e 0a0a 2222 220a 4765 6e65 7261  org>..""".Genera
 000000b0: 6c20 7574 696c 6974 7920 6675 6e63 7469  l utility functi
-000000c0: 6f6e 732e 0a22 2222 0a0a 6672 6f6d 205f  ons.."""..from _
-000000d0: 5f66 7574 7572 655f 5f20 696d 706f 7274  _future__ import
-000000e0: 2061 6273 6f6c 7574 655f 696d 706f 7274   absolute_import
-000000f0: 0a66 726f 6d20 5f5f 6675 7475 7265 5f5f  .from __future__
-00000100: 2069 6d70 6f72 7420 7072 696e 745f 6675   import print_fu
-00000110: 6e63 7469 6f6e 0a0a 6672 6f6d 2064 6563  nction..from dec
-00000120: 696d 616c 2069 6d70 6f72 7420 4465 6369  imal import Deci
-00000130: 6d61 6c0a 0a69 6d70 6f72 7420 6172 7261  mal..import arra
-00000140: 790a 696d 706f 7274 2063 6f6c 6c65 6374  y.import collect
-00000150: 696f 6e73 0a69 6d70 6f72 7420 6465 6369  ions.import deci
-00000160: 6d61 6c0a 696d 706f 7274 2064 6966 666c  mal.import diffl
-00000170: 6962 0a69 6d70 6f72 7420 677a 6970 0a69  ib.import gzip.i
-00000180: 6d70 6f72 7420 6c6f 6361 6c65 0a69 6d70  mport locale.imp
-00000190: 6f72 7420 6f73 0a69 6d70 6f72 7420 7261  ort os.import ra
-000001a0: 6e64 6f6d 0a69 6d70 6f72 7420 7265 0a69  ndom.import re.i
-000001b0: 6d70 6f72 7420 736f 636b 6574 0a69 6d70  mport socket.imp
-000001c0: 6f72 7420 7374 7275 6374 0a69 6d70 6f72  ort struct.impor
-000001d0: 7420 7375 6270 726f 6365 7373 0a69 6d70  t subprocess.imp
-000001e0: 6f72 7420 7379 730a 696d 706f 7274 2074  ort sys.import t
-000001f0: 656d 7066 696c 650a 696d 706f 7274 2074  empfile.import t
-00000200: 6872 6561 6469 6e67 0a69 6d70 6f72 7420  hreading.import 
-00000210: 7469 6d65 0a69 6d70 6f72 7420 7761 726e  time.import warn
-00000220: 696e 6773 0a0a 696d 706f 7274 2073 6361  ings..import sca
-00000230: 7079 2e6c 6962 732e 7369 7820 6173 2073  py.libs.six as s
-00000240: 6978 0a66 726f 6d20 7363 6170 792e 6c69  ix.from scapy.li
-00000250: 6273 2e73 6978 2e6d 6f76 6573 2069 6d70  bs.six.moves imp
-00000260: 6f72 7420 7261 6e67 652c 2069 6e70 7574  ort range, input
-00000270: 2c20 7a69 705f 6c6f 6e67 6573 740a 0a66  , zip_longest..f
-00000280: 726f 6d20 7363 6170 792e 636f 6e66 6967  rom scapy.config
-00000290: 2069 6d70 6f72 7420 636f 6e66 0a66 726f   import conf.fro
-000002a0: 6d20 7363 6170 792e 636f 6e73 7473 2069  m scapy.consts i
-000002b0: 6d70 6f72 7420 4441 5257 494e 2c20 4f50  mport DARWIN, OP
-000002c0: 454e 4253 442c 2057 494e 444f 5753 0a66  ENBSD, WINDOWS.f
-000002d0: 726f 6d20 7363 6170 792e 6461 7461 2069  rom scapy.data i
-000002e0: 6d70 6f72 7420 4d54 552c 2044 4c54 5f45  mport MTU, DLT_E
-000002f0: 4e31 304d 422c 2044 4c54 5f52 4157 0a66  N10MB, DLT_RAW.f
-00000300: 726f 6d20 7363 6170 792e 636f 6d70 6174  rom scapy.compat
-00000310: 2069 6d70 6f72 7420 6f72 622c 2070 6c61   import orb, pla
-00000320: 696e 5f73 7472 2c20 6368 622c 2062 7974  in_str, chb, byt
-00000330: 6573 5f62 6173 6536 342c 5c0a 2020 2020  es_base64,\.    
-00000340: 6261 7365 3634 5f62 7974 6573 2c20 6865  base64_bytes, he
-00000350: 785f 6279 7465 732c 206c 616d 6264 615f  x_bytes, lambda_
-00000360: 7475 706c 655f 636f 6e76 6572 7465 722c  tuple_converter,
-00000370: 2062 7974 6573 5f65 6e63 6f64 650a 6672   bytes_encode.fr
-00000380: 6f6d 2073 6361 7079 2e65 7272 6f72 2069  om scapy.error i
-00000390: 6d70 6f72 7420 6c6f 675f 7275 6e74 696d  mport log_runtim
-000003a0: 652c 2053 6361 7079 5f45 7863 6570 7469  e, Scapy_Excepti
-000003b0: 6f6e 2c20 7761 726e 696e 670a 6672 6f6d  on, warning.from
-000003c0: 2073 6361 7079 2e70 746f 6e5f 6e74 6f70   scapy.pton_ntop
-000003d0: 2069 6d70 6f72 7420 696e 6574 5f70 746f   import inet_pto
-000003e0: 6e0a 0a23 2054 7970 696e 6720 696d 706f  n..# Typing impo
-000003f0: 7274 730a 6672 6f6d 2073 6361 7079 2e63  rts.from scapy.c
-00000400: 6f6d 7061 7420 696d 706f 7274 2028 0a20  ompat import (. 
-00000410: 2020 2063 6173 742c 0a20 2020 2041 6e79     cast,.    Any
-00000420: 2c0a 2020 2020 416e 7953 7472 2c0a 2020  ,.    AnyStr,.  
-00000430: 2020 4361 6c6c 6162 6c65 2c0a 2020 2020    Callable,.    
-00000440: 4469 6374 2c0a 2020 2020 494f 2c0a 2020  Dict,.    IO,.  
-00000450: 2020 4974 6572 6174 6f72 2c0a 2020 2020    Iterator,.    
-00000460: 4c69 7374 2c0a 2020 2020 4c69 7465 7261  List,.    Litera
-00000470: 6c2c 0a20 2020 204f 7074 696f 6e61 6c2c  l,.    Optional,
-00000480: 0a20 2020 2054 5950 455f 4348 4543 4b49  .    TYPE_CHECKI
-00000490: 4e47 2c0a 2020 2020 5475 706c 652c 0a20  NG,.    Tuple,. 
-000004a0: 2020 2054 7970 652c 0a20 2020 2055 6e69     Type,.    Uni
-000004b0: 6f6e 2c0a 2020 2020 6f76 6572 6c6f 6164  on,.    overload
-000004c0: 2c0a 290a 0a69 6620 5459 5045 5f43 4845  ,.)..if TYPE_CHE
-000004d0: 434b 494e 473a 0a20 2020 2066 726f 6d20  CKING:.    from 
-000004e0: 7363 6170 792e 7061 636b 6574 2069 6d70  scapy.packet imp
-000004f0: 6f72 7420 5061 636b 6574 0a20 2020 2066  ort Packet.    f
-00000500: 726f 6d20 7363 6170 792e 706c 6973 7420  rom scapy.plist 
-00000510: 696d 706f 7274 205f 5061 636b 6574 4974  import _PacketIt
-00000520: 6572 6162 6c65 2c20 5061 636b 6574 4c69  erable, PacketLi
-00000530: 7374 0a20 2020 2066 726f 6d20 7363 6170  st.    from scap
-00000540: 792e 7375 7065 7273 6f63 6b65 7420 696d  y.supersocket im
-00000550: 706f 7274 2053 7570 6572 536f 636b 6574  port SuperSocket
-00000560: 0a20 2020 205f 5375 7065 7253 6f63 6b65  .    _SuperSocke
-00000570: 7420 3d20 5375 7065 7253 6f63 6b65 740a  t = SuperSocket.
-00000580: 656c 7365 3a0a 2020 2020 5f53 7570 6572  else:.    _Super
-00000590: 536f 636b 6574 203d 206f 626a 6563 740a  Socket = object.
-000005a0: 0a5f 4279 7465 5374 7265 616d 203d 2055  ._ByteStream = U
-000005b0: 6e69 6f6e 5b49 4f5b 6279 7465 735d 2c20  nion[IO[bytes], 
-000005c0: 677a 6970 2e47 7a69 7046 696c 655d 0a0a  gzip.GzipFile]..
-000005d0: 2323 2323 2323 2323 2323 230a 2320 2054  ###########.#  T
-000005e0: 6f6f 6c73 2020 230a 2323 2323 2323 2323  ools  #.########
-000005f0: 2323 230a 0a0a 6465 6620 6973 7375 6274  ###...def issubt
-00000600: 7970 6528 782c 2020 2320 7479 7065 3a20  ype(x,  # type: 
-00000610: 416e 790a 2020 2020 2020 2020 2020 2020  Any.            
-00000620: 2020 742c 2020 2320 7479 7065 3a20 556e    t,  # type: Un
-00000630: 696f 6e5b 7479 7065 2c20 7374 725d 0a20  ion[type, str]. 
-00000640: 2020 2020 2020 2020 2020 2020 2029 3a0a               ):.
-00000650: 2020 2020 2320 7479 7065 3a20 282e 2e2e      # type: (...
-00000660: 2920 2d3e 2062 6f6f 6c0a 2020 2020 2222  ) -> bool.    ""
-00000670: 2269 7373 7562 7479 7065 2843 2c20 4229  "issubtype(C, B)
-00000680: 202d 3e20 626f 6f6c 0a0a 2020 2020 5265   -> bool..    Re
-00000690: 7475 726e 2077 6865 7468 6572 2043 2069  turn whether C i
-000006a0: 7320 6120 636c 6173 7320 616e 6420 6966  s a class and if
-000006b0: 2069 7420 6973 2061 2073 7562 636c 6173   it is a subclas
-000006c0: 7320 6f66 2063 6c61 7373 2042 2e0a 2020  s of class B..  
-000006d0: 2020 5768 656e 2075 7369 6e67 2061 2074    When using a t
-000006e0: 7570 6c65 2061 7320 7468 6520 7365 636f  uple as the seco
-000006f0: 6e64 2061 7267 756d 656e 7420 6973 7375  nd argument issu
-00000700: 6274 7970 6528 582c 2028 412c 2042 2c20  btype(X, (A, B, 
-00000710: 2e2e 2e29 292c 0a20 2020 2069 7320 6120  ...)),.    is a 
-00000720: 7368 6f72 7463 7574 2066 6f72 2069 7373  shortcut for iss
-00000730: 7562 7479 7065 2858 2c20 4129 206f 7220  ubtype(X, A) or 
-00000740: 6973 7375 6274 7970 6528 582c 2042 2920  issubtype(X, B) 
-00000750: 6f72 202e 2e2e 2028 6574 632e 292e 0a20  or ... (etc.).. 
-00000760: 2020 2022 2222 0a20 2020 2069 6620 6973     """.    if is
-00000770: 696e 7374 616e 6365 2874 2c20 7374 7229  instance(t, str)
-00000780: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00000790: 2074 2069 6e20 287a 2e5f 5f6e 616d 655f   t in (z.__name_
-000007a0: 5f20 666f 7220 7a20 696e 2078 2e5f 5f62  _ for z in x.__b
-000007b0: 6173 6573 5f5f 290a 2020 2020 6966 2069  ases__).    if i
-000007c0: 7369 6e73 7461 6e63 6528 782c 2074 7970  sinstance(x, typ
-000007d0: 6529 2061 6e64 2069 7373 7562 636c 6173  e) and issubclas
-000007e0: 7328 782c 2074 293a 0a20 2020 2020 2020  s(x, t):.       
-000007f0: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
-00000800: 2072 6574 7572 6e20 4661 6c73 650a 0a0a   return False...
-00000810: 5f44 6563 696d 616c 203d 2055 6e69 6f6e  _Decimal = Union
-00000820: 5b44 6563 696d 616c 2c20 696e 745d 0a0a  [Decimal, int]..
-00000830: 0a63 6c61 7373 2045 4465 6369 6d61 6c28  .class EDecimal(
-00000840: 4465 6369 6d61 6c29 3a0a 2020 2020 2222  Decimal):.    ""
-00000850: 2245 7874 656e 6465 6420 4465 6369 6d61  "Extended Decima
-00000860: 6c0a 0a20 2020 2054 6869 7320 696d 706c  l..    This impl
-00000870: 656d 656e 7473 2061 7269 7468 6d65 7469  ements arithmeti
-00000880: 6320 616e 6420 636f 6d70 6172 6973 6f6e  c and comparison
-00000890: 2077 6974 6820 666c 6f61 7420 666f 720a   with float for.
-000008a0: 2020 2020 6261 636b 7761 7264 2063 6f6d      backward com
-000008b0: 7061 7469 6269 6c69 7479 0a20 2020 2022  patibility.    "
-000008c0: 2222 0a0a 2020 2020 6465 6620 5f5f 6164  ""..    def __ad
-000008d0: 645f 5f28 7365 6c66 2c20 6f74 6865 722c  d__(self, other,
-000008e0: 2063 6f6e 7465 7874 3d4e 6f6e 6529 3a0a   context=None):.
-000008f0: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-00000900: 285f 4465 6369 6d61 6c2c 2041 6e79 2920  (_Decimal, Any) 
-00000910: 2d3e 2045 4465 6369 6d61 6c0a 2020 2020  -> EDecimal.    
-00000920: 2020 2020 7265 7475 726e 2045 4465 6369      return EDeci
-00000930: 6d61 6c28 4465 6369 6d61 6c2e 5f5f 6164  mal(Decimal.__ad
-00000940: 645f 5f28 7365 6c66 2c20 4465 6369 6d61  d__(self, Decima
-00000950: 6c28 6f74 6865 7229 2929 0a0a 2020 2020  l(other)))..    
-00000960: 6465 6620 5f5f 7261 6464 5f5f 2873 656c  def __radd__(sel
-00000970: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-00000980: 2020 2023 2074 7970 653a 2028 5f44 6563     # type: (_Dec
-00000990: 696d 616c 2920 2d3e 2045 4465 6369 6d61  imal) -> EDecima
-000009a0: 6c0a 2020 2020 2020 2020 7265 7475 726e  l.        return
-000009b0: 2045 4465 6369 6d61 6c28 4465 6369 6d61   EDecimal(Decima
-000009c0: 6c2e 5f5f 6164 645f 5f28 7365 6c66 2c20  l.__add__(self, 
-000009d0: 4465 6369 6d61 6c28 6f74 6865 7229 2929  Decimal(other)))
-000009e0: 0a0a 2020 2020 6465 6620 5f5f 7375 625f  ..    def __sub_
-000009f0: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
-00000a00: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-00000a10: 285f 4465 6369 6d61 6c29 202d 3e20 4544  (_Decimal) -> ED
-00000a20: 6563 696d 616c 0a20 2020 2020 2020 2072  ecimal.        r
-00000a30: 6574 7572 6e20 4544 6563 696d 616c 2844  eturn EDecimal(D
-00000a40: 6563 696d 616c 2e5f 5f73 7562 5f5f 2873  ecimal.__sub__(s
-00000a50: 656c 662c 2044 6563 696d 616c 286f 7468  elf, Decimal(oth
-00000a60: 6572 2929 290a 0a20 2020 2064 6566 205f  er)))..    def _
-00000a70: 5f72 7375 625f 5f28 7365 6c66 2c20 6f74  _rsub__(self, ot
-00000a80: 6865 7229 3a0a 2020 2020 2020 2020 2320  her):.        # 
-00000a90: 7479 7065 3a20 285f 4465 6369 6d61 6c29  type: (_Decimal)
-00000aa0: 202d 3e20 4544 6563 696d 616c 0a20 2020   -> EDecimal.   
-00000ab0: 2020 2020 2072 6574 7572 6e20 4544 6563       return EDec
-00000ac0: 696d 616c 2844 6563 696d 616c 2e5f 5f72  imal(Decimal.__r
-00000ad0: 7375 625f 5f28 7365 6c66 2c20 4465 6369  sub__(self, Deci
-00000ae0: 6d61 6c28 6f74 6865 7229 2929 0a0a 2020  mal(other)))..  
-00000af0: 2020 6465 6620 5f5f 6d75 6c5f 5f28 7365    def __mul__(se
-00000b00: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-00000b10: 2020 2020 2320 7479 7065 3a20 285f 4465      # type: (_De
-00000b20: 6369 6d61 6c29 202d 3e20 4544 6563 696d  cimal) -> EDecim
-00000b30: 616c 0a20 2020 2020 2020 2072 6574 7572  al.        retur
-00000b40: 6e20 4544 6563 696d 616c 2844 6563 696d  n EDecimal(Decim
-00000b50: 616c 2e5f 5f6d 756c 5f5f 2873 656c 662c  al.__mul__(self,
-00000b60: 2044 6563 696d 616c 286f 7468 6572 2929   Decimal(other))
-00000b70: 290a 0a20 2020 2064 6566 205f 5f72 6d75  )..    def __rmu
-00000b80: 6c5f 5f28 7365 6c66 2c20 6f74 6865 7229  l__(self, other)
-00000b90: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-00000ba0: 3a20 285f 4465 6369 6d61 6c29 202d 3e20  : (_Decimal) -> 
-00000bb0: 4544 6563 696d 616c 0a20 2020 2020 2020  EDecimal.       
-00000bc0: 2072 6574 7572 6e20 4544 6563 696d 616c   return EDecimal
-00000bd0: 2844 6563 696d 616c 2e5f 5f6d 756c 5f5f  (Decimal.__mul__
-00000be0: 2873 656c 662c 2044 6563 696d 616c 286f  (self, Decimal(o
-00000bf0: 7468 6572 2929 290a 0a20 2020 2064 6566  ther)))..    def
-00000c00: 205f 5f74 7275 6564 6976 5f5f 2873 656c   __truediv__(sel
-00000c10: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-00000c20: 2020 2023 2074 7970 653a 2028 5f44 6563     # type: (_Dec
-00000c30: 696d 616c 2920 2d3e 2045 4465 6369 6d61  imal) -> EDecima
-00000c40: 6c0a 2020 2020 2020 2020 7265 7475 726e  l.        return
-00000c50: 2045 4465 6369 6d61 6c28 4465 6369 6d61   EDecimal(Decima
-00000c60: 6c2e 5f5f 7472 7565 6469 765f 5f28 7365  l.__truediv__(se
-00000c70: 6c66 2c20 4465 6369 6d61 6c28 6f74 6865  lf, Decimal(othe
-00000c80: 7229 2929 0a0a 2020 2020 6465 6620 5f5f  r)))..    def __
-00000c90: 666c 6f6f 7264 6976 5f5f 2873 656c 662c  floordiv__(self,
-00000ca0: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
-00000cb0: 2023 2074 7970 653a 2028 5f44 6563 696d   # type: (_Decim
-00000cc0: 616c 2920 2d3e 2045 4465 6369 6d61 6c0a  al) -> EDecimal.
-00000cd0: 2020 2020 2020 2020 7265 7475 726e 2045          return E
-00000ce0: 4465 6369 6d61 6c28 4465 6369 6d61 6c2e  Decimal(Decimal.
-00000cf0: 5f5f 666c 6f6f 7264 6976 5f5f 2873 656c  __floordiv__(sel
-00000d00: 662c 2044 6563 696d 616c 286f 7468 6572  f, Decimal(other
-00000d10: 2929 290a 0a20 2020 2069 6620 7379 732e  )))..    if sys.
-00000d20: 7665 7273 696f 6e5f 696e 666f 203e 3d20  version_info >= 
-00000d30: 2833 2c29 3a0a 2020 2020 2020 2020 6465  (3,):.        de
-00000d40: 6620 5f5f 6469 766d 6f64 5f5f 2873 656c  f __divmod__(sel
-00000d50: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-00000d60: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-00000d70: 5f44 6563 696d 616c 2920 2d3e 2054 7570  _Decimal) -> Tup
-00000d80: 6c65 5b45 4465 6369 6d61 6c2c 2045 4465  le[EDecimal, EDe
-00000d90: 6369 6d61 6c5d 0a20 2020 2020 2020 2020  cimal].         
-00000da0: 2020 2072 203d 2044 6563 696d 616c 2e5f     r = Decimal._
-00000db0: 5f64 6976 6d6f 645f 5f28 7365 6c66 2c20  _divmod__(self, 
-00000dc0: 4465 6369 6d61 6c28 6f74 6865 7229 290a  Decimal(other)).
-00000dd0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00000de0: 726e 2045 4465 6369 6d61 6c28 725b 305d  rn EDecimal(r[0]
-00000df0: 292c 2045 4465 6369 6d61 6c28 725b 315d  ), EDecimal(r[1]
-00000e00: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
-00000e10: 2020 2020 6465 6620 5f5f 6469 765f 5f28      def __div__(
-00000e20: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00000e30: 2020 2020 2020 2020 2020 2320 7479 7065            # type
-00000e40: 3a20 285f 4465 6369 6d61 6c29 202d 3e20  : (_Decimal) -> 
-00000e50: 4544 6563 696d 616c 0a20 2020 2020 2020  EDecimal.       
-00000e60: 2020 2020 2072 6574 7572 6e20 4544 6563       return EDec
-00000e70: 696d 616c 2844 6563 696d 616c 2e5f 5f64  imal(Decimal.__d
-00000e80: 6976 5f5f 2873 656c 662c 2044 6563 696d  iv__(self, Decim
-00000e90: 616c 286f 7468 6572 2929 290a 0a20 2020  al(other)))..   
-00000ea0: 2020 2020 2064 6566 205f 5f72 6469 765f       def __rdiv_
-00000eb0: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
-00000ec0: 2020 2020 2020 2020 2020 2020 2320 7479              # ty
-00000ed0: 7065 3a20 285f 4465 6369 6d61 6c29 202d  pe: (_Decimal) -
-00000ee0: 3e20 4544 6563 696d 616c 0a20 2020 2020  > EDecimal.     
-00000ef0: 2020 2020 2020 2072 6574 7572 6e20 4544         return ED
-00000f00: 6563 696d 616c 2844 6563 696d 616c 2e5f  ecimal(Decimal._
-00000f10: 5f72 6469 765f 5f28 7365 6c66 2c20 4465  _rdiv__(self, De
-00000f20: 6369 6d61 6c28 6f74 6865 7229 2929 0a0a  cimal(other)))..
-00000f30: 2020 2020 6465 6620 5f5f 6d6f 645f 5f28      def __mod__(
-00000f40: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00000f50: 2020 2020 2020 2320 7479 7065 3a20 285f        # type: (_
-00000f60: 4465 6369 6d61 6c29 202d 3e20 4544 6563  Decimal) -> EDec
-00000f70: 696d 616c 0a20 2020 2020 2020 2072 6574  imal.        ret
-00000f80: 7572 6e20 4544 6563 696d 616c 2844 6563  urn EDecimal(Dec
-00000f90: 696d 616c 2e5f 5f6d 6f64 5f5f 2873 656c  imal.__mod__(sel
-00000fa0: 662c 2044 6563 696d 616c 286f 7468 6572  f, Decimal(other
-00000fb0: 2929 290a 0a20 2020 2064 6566 205f 5f72  )))..    def __r
-00000fc0: 6d6f 645f 5f28 7365 6c66 2c20 6f74 6865  mod__(self, othe
-00000fd0: 7229 3a0a 2020 2020 2020 2020 2320 7479  r):.        # ty
-00000fe0: 7065 3a20 285f 4465 6369 6d61 6c29 202d  pe: (_Decimal) -
-00000ff0: 3e20 4544 6563 696d 616c 0a20 2020 2020  > EDecimal.     
-00001000: 2020 2072 6574 7572 6e20 4544 6563 696d     return EDecim
-00001010: 616c 2844 6563 696d 616c 2e5f 5f72 6d6f  al(Decimal.__rmo
-00001020: 645f 5f28 7365 6c66 2c20 4465 6369 6d61  d__(self, Decima
-00001030: 6c28 6f74 6865 7229 2929 0a0a 2020 2020  l(other)))..    
-00001040: 6465 6620 5f5f 706f 775f 5f28 7365 6c66  def __pow__(self
-00001050: 2c20 6f74 6865 722c 206d 6f64 756c 6f3d  , other, modulo=
-00001060: 4e6f 6e65 293a 0a20 2020 2020 2020 2023  None):.        #
-00001070: 2074 7970 653a 2028 5f44 6563 696d 616c   type: (_Decimal
-00001080: 2c20 4f70 7469 6f6e 616c 5b5f 4465 6369  , Optional[_Deci
-00001090: 6d61 6c5d 2920 2d3e 2045 4465 6369 6d61  mal]) -> EDecima
-000010a0: 6c0a 2020 2020 2020 2020 7265 7475 726e  l.        return
-000010b0: 2045 4465 6369 6d61 6c28 4465 6369 6d61   EDecimal(Decima
-000010c0: 6c2e 5f5f 706f 775f 5f28 7365 6c66 2c20  l.__pow__(self, 
-000010d0: 4465 6369 6d61 6c28 6f74 6865 7229 2c20  Decimal(other), 
-000010e0: 6d6f 6475 6c6f 2929 0a0a 2020 2020 6465  modulo))..    de
-000010f0: 6620 5f5f 6571 5f5f 2873 656c 662c 206f  f __eq__(self, o
-00001100: 7468 6572 293a 0a20 2020 2020 2020 2023  ther):.        #
-00001110: 2074 7970 653a 2028 416e 7929 202d 3e20   type: (Any) -> 
-00001120: 626f 6f6c 0a20 2020 2020 2020 2072 6574  bool.        ret
-00001130: 7572 6e20 7375 7065 7228 4544 6563 696d  urn super(EDecim
-00001140: 616c 2c20 7365 6c66 292e 5f5f 6571 5f5f  al, self).__eq__
-00001150: 286f 7468 6572 2920 6f72 2066 6c6f 6174  (other) or float
-00001160: 2873 656c 6629 203d 3d20 6f74 6865 720a  (self) == other.
-00001170: 0a20 2020 2064 6566 206e 6f72 6d61 6c69  .    def normali
-00001180: 7a65 2873 656c 662c 2070 7265 6369 7369  ze(self, precisi
-00001190: 6f6e 293a 2020 2320 7479 7065 3a20 6967  on):  # type: ig
-000011a0: 6e6f 7265 0a20 2020 2020 2020 2023 2074  nore.        # t
-000011b0: 7970 653a 2028 696e 7429 202d 3e20 4544  ype: (int) -> ED
-000011c0: 6563 696d 616c 0a20 2020 2020 2020 2077  ecimal.        w
-000011d0: 6974 6820 6465 6369 6d61 6c2e 6c6f 6361  ith decimal.loca
-000011e0: 6c63 6f6e 7465 7874 2829 2061 7320 6374  lcontext() as ct
-000011f0: 783a 0a20 2020 2020 2020 2020 2020 2063  x:.            c
-00001200: 7478 2e70 7265 6320 3d20 7072 6563 6973  tx.prec = precis
-00001210: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-00001220: 7265 7475 726e 2045 4465 6369 6d61 6c28  return EDecimal(
-00001230: 7375 7065 7228 4544 6563 696d 616c 2c20  super(EDecimal, 
-00001240: 7365 6c66 292e 6e6f 726d 616c 697a 6528  self).normalize(
-00001250: 6374 7829 290a 0a0a 406f 7665 726c 6f61  ctx))...@overloa
-00001260: 640a 6465 6620 6765 745f 7465 6d70 5f66  d.def get_temp_f
-00001270: 696c 6528 6b65 6570 2c20 6175 746f 6578  ile(keep, autoex
-00001280: 742c 2066 6429 3a0a 2020 2020 2320 7479  t, fd):.    # ty
-00001290: 7065 3a20 2862 6f6f 6c2c 2073 7472 2c20  pe: (bool, str, 
-000012a0: 4c69 7465 7261 6c5b 5472 7565 5d29 202d  Literal[True]) -
-000012b0: 3e20 494f 5b62 7974 6573 5d0a 2020 2020  > IO[bytes].    
-000012c0: 7061 7373 0a0a 0a40 6f76 6572 6c6f 6164  pass...@overload
-000012d0: 0a64 6566 2067 6574 5f74 656d 705f 6669  .def get_temp_fi
-000012e0: 6c65 286b 6565 703d 4661 6c73 652c 2061  le(keep=False, a
-000012f0: 7574 6f65 7874 3d22 222c 2066 643d 4661  utoext="", fd=Fa
-00001300: 6c73 6529 3a20 2023 206e 6f71 613a 2046  lse):  # noqa: F
-00001310: 3831 310a 2020 2020 2320 7479 7065 3a20  811.    # type: 
-00001320: 2862 6f6f 6c2c 2073 7472 2c20 4c69 7465  (bool, str, Lite
-00001330: 7261 6c5b 4661 6c73 655d 2920 2d3e 2073  ral[False]) -> s
-00001340: 7472 0a20 2020 2070 6173 730a 0a0a 6465  tr.    pass...de
-00001350: 6620 6765 745f 7465 6d70 5f66 696c 6528  f get_temp_file(
-00001360: 6b65 6570 3d46 616c 7365 2c20 6175 746f  keep=False, auto
-00001370: 6578 743d 2222 2c20 6664 3d46 616c 7365  ext="", fd=False
-00001380: 293a 2020 2320 6e6f 7161 3a20 4638 3131  ):  # noqa: F811
-00001390: 0a20 2020 2023 2074 7970 653a 2028 626f  .    # type: (bo
-000013a0: 6f6c 2c20 7374 722c 2062 6f6f 6c29 202d  ol, str, bool) -
-000013b0: 3e20 556e 696f 6e5b 494f 5b62 7974 6573  > Union[IO[bytes
-000013c0: 5d2c 2073 7472 5d0a 2020 2020 2222 2243  ], str].    """C
-000013d0: 7265 6174 6573 2061 2074 656d 706f 7261  reates a tempora
-000013e0: 7279 2066 696c 652e 0a0a 2020 2020 3a70  ry file...    :p
-000013f0: 6172 616d 206b 6565 703a 2049 6620 4661  aram keep: If Fa
-00001400: 6c73 652c 2061 7574 6f6d 6174 6963 616c  lse, automatical
-00001410: 6c79 2064 656c 6574 6520 7468 6520 6669  ly delete the fi
-00001420: 6c65 2077 6865 6e20 5363 6170 7920 6578  le when Scapy ex
-00001430: 6974 732e 0a20 2020 203a 7061 7261 6d20  its..    :param 
-00001440: 6175 746f 6578 743a 2053 7566 6669 7820  autoext: Suffix 
-00001450: 746f 2061 6464 2074 6f20 7468 6520 6765  to add to the ge
-00001460: 6e65 7261 7465 6420 6669 6c65 206e 616d  nerated file nam
-00001470: 652e 0a20 2020 203a 7061 7261 6d20 6664  e..    :param fd
-00001480: 3a20 4966 2054 7275 652c 2074 6869 7320  : If True, this 
-00001490: 7265 7475 726e 7320 6120 6669 6c65 2d6c  returns a file-l
-000014a0: 696b 6520 6f62 6a65 6374 2077 6974 6820  ike object with 
-000014b0: 7468 6520 7465 6d70 6f72 6172 790a 2020  the temporary.  
-000014c0: 2020 2020 2020 2020 2020 2020 2066 696c               fil
-000014d0: 6520 6f70 656e 6564 2e20 4966 2046 616c  e opened. If Fal
-000014e0: 7365 2028 6465 6661 756c 7429 2c20 7468  se (default), th
-000014f0: 6973 2072 6574 7572 6e73 2061 2066 696c  is returns a fil
-00001500: 6520 7061 7468 2e0a 2020 2020 2222 220a  e path..    """.
-00001510: 2020 2020 6620 3d20 7465 6d70 6669 6c65      f = tempfile
-00001520: 2e4e 616d 6564 5465 6d70 6f72 6172 7946  .NamedTemporaryF
-00001530: 696c 6528 7072 6566 6978 3d22 7363 6170  ile(prefix="scap
-00001540: 7922 2c20 7375 6666 6978 3d61 7574 6f65  y", suffix=autoe
-00001550: 7874 2c0a 2020 2020 2020 2020 2020 2020  xt,.            
+000000c0: 6f6e 732e 0a22 2222 0a0a 0a66 726f 6d20  ons.."""...from 
+000000d0: 6465 6369 6d61 6c20 696d 706f 7274 2044  decimal import D
+000000e0: 6563 696d 616c 0a66 726f 6d20 696f 2069  ecimal.from io i
+000000f0: 6d70 6f72 7420 5374 7269 6e67 494f 0a66  mport StringIO.f
+00000100: 726f 6d20 6974 6572 746f 6f6c 7320 696d  rom itertools im
+00000110: 706f 7274 207a 6970 5f6c 6f6e 6765 7374  port zip_longest
+00000120: 0a0a 696d 706f 7274 2061 7272 6179 0a69  ..import array.i
+00000130: 6d70 6f72 7420 6172 6770 6172 7365 0a69  mport argparse.i
+00000140: 6d70 6f72 7420 636f 6c6c 6563 7469 6f6e  mport collection
+00000150: 730a 696d 706f 7274 2064 6563 696d 616c  s.import decimal
+00000160: 0a69 6d70 6f72 7420 6469 6666 6c69 620a  .import difflib.
+00000170: 696d 706f 7274 2067 7a69 700a 696d 706f  import gzip.impo
+00000180: 7274 2069 6e73 7065 6374 0a69 6d70 6f72  rt inspect.impor
+00000190: 7420 6c6f 6361 6c65 0a69 6d70 6f72 7420  t locale.import 
+000001a0: 6d61 7468 0a69 6d70 6f72 7420 6f73 0a69  math.import os.i
+000001b0: 6d70 6f72 7420 7069 636b 6c65 0a69 6d70  mport pickle.imp
+000001c0: 6f72 7420 7261 6e64 6f6d 0a69 6d70 6f72  ort random.impor
+000001d0: 7420 7265 0a69 6d70 6f72 7420 7368 7574  t re.import shut
+000001e0: 696c 0a69 6d70 6f72 7420 736f 636b 6574  il.import socket
+000001f0: 0a69 6d70 6f72 7420 7374 7275 6374 0a69  .import struct.i
+00000200: 6d70 6f72 7420 7375 6270 726f 6365 7373  mport subprocess
+00000210: 0a69 6d70 6f72 7420 7379 730a 696d 706f  .import sys.impo
+00000220: 7274 2074 656d 7066 696c 650a 696d 706f  rt tempfile.impo
+00000230: 7274 2074 6872 6561 6469 6e67 0a69 6d70  rt threading.imp
+00000240: 6f72 7420 7469 6d65 0a69 6d70 6f72 7420  ort time.import 
+00000250: 7472 6163 6562 6163 6b0a 696d 706f 7274  traceback.import
+00000260: 2077 6172 6e69 6e67 730a 0a66 726f 6d20   warnings..from 
+00000270: 7363 6170 792e 636f 6e66 6967 2069 6d70  scapy.config imp
+00000280: 6f72 7420 636f 6e66 0a66 726f 6d20 7363  ort conf.from sc
+00000290: 6170 792e 636f 6e73 7473 2069 6d70 6f72  apy.consts impor
+000002a0: 7420 4441 5257 494e 2c20 4f50 454e 4253  t DARWIN, OPENBS
+000002b0: 442c 2057 494e 444f 5753 0a66 726f 6d20  D, WINDOWS.from 
+000002c0: 7363 6170 792e 6461 7461 2069 6d70 6f72  scapy.data impor
+000002d0: 7420 4d54 552c 2044 4c54 5f45 4e31 304d  t MTU, DLT_EN10M
+000002e0: 422c 2044 4c54 5f52 4157 0a66 726f 6d20  B, DLT_RAW.from 
+000002f0: 7363 6170 792e 636f 6d70 6174 2069 6d70  scapy.compat imp
+00000300: 6f72 7420 280a 2020 2020 6f72 622c 0a20  ort (.    orb,. 
+00000310: 2020 2070 6c61 696e 5f73 7472 2c0a 2020     plain_str,.  
+00000320: 2020 6368 622c 0a20 2020 2062 7974 6573    chb,.    bytes
+00000330: 5f62 6173 6536 342c 0a20 2020 2062 6173  _base64,.    bas
+00000340: 6536 345f 6279 7465 732c 0a20 2020 2068  e64_bytes,.    h
+00000350: 6578 5f62 7974 6573 2c0a 2020 2020 6279  ex_bytes,.    by
+00000360: 7465 735f 656e 636f 6465 2c0a 290a 6672  tes_encode,.).fr
+00000370: 6f6d 2073 6361 7079 2e65 7272 6f72 2069  om scapy.error i
+00000380: 6d70 6f72 7420 280a 2020 2020 6c6f 675f  mport (.    log_
+00000390: 696e 7465 7261 6374 6976 652c 0a20 2020  interactive,.   
+000003a0: 206c 6f67 5f72 756e 7469 6d65 2c0a 2020   log_runtime,.  
+000003b0: 2020 5363 6170 795f 4578 6365 7074 696f    Scapy_Exceptio
+000003c0: 6e2c 0a20 2020 2077 6172 6e69 6e67 2c0a  n,.    warning,.
+000003d0: 290a 6672 6f6d 2073 6361 7079 2e70 746f  ).from scapy.pto
+000003e0: 6e5f 6e74 6f70 2069 6d70 6f72 7420 696e  n_ntop import in
+000003f0: 6574 5f70 746f 6e0a 0a23 2054 7970 696e  et_pton..# Typin
+00000400: 6720 696d 706f 7274 730a 6672 6f6d 2074  g imports.from t
+00000410: 7970 696e 6720 696d 706f 7274 2028 0a20  yping import (. 
+00000420: 2020 2063 6173 742c 0a20 2020 2041 6e79     cast,.    Any
+00000430: 2c0a 2020 2020 416e 7953 7472 2c0a 2020  ,.    AnyStr,.  
+00000440: 2020 4361 6c6c 6162 6c65 2c0a 2020 2020    Callable,.    
+00000450: 4469 6374 2c0a 2020 2020 494f 2c0a 2020  Dict,.    IO,.  
+00000460: 2020 4974 6572 6174 6f72 2c0a 2020 2020    Iterator,.    
+00000470: 4c69 7374 2c0a 2020 2020 4f70 7469 6f6e  List,.    Option
+00000480: 616c 2c0a 2020 2020 5459 5045 5f43 4845  al,.    TYPE_CHE
+00000490: 434b 494e 472c 0a20 2020 2054 7570 6c65  CKING,.    Tuple
+000004a0: 2c0a 2020 2020 5479 7065 2c0a 2020 2020  ,.    Type,.    
+000004b0: 556e 696f 6e2c 0a20 2020 206f 7665 726c  Union,.    overl
+000004c0: 6f61 642c 0a29 0a66 726f 6d20 7363 6170  oad,.).from scap
+000004d0: 792e 636f 6d70 6174 2069 6d70 6f72 7420  y.compat import 
+000004e0: 280a 2020 2020 4465 636f 7261 746f 7243  (.    DecoratorC
+000004f0: 616c 6c61 626c 652c 0a20 2020 204c 6974  allable,.    Lit
+00000500: 6572 616c 2c0a 290a 0a69 6620 5459 5045  eral,.)..if TYPE
+00000510: 5f43 4845 434b 494e 473a 0a20 2020 2066  _CHECKING:.    f
+00000520: 726f 6d20 7363 6170 792e 7061 636b 6574  rom scapy.packet
+00000530: 2069 6d70 6f72 7420 5061 636b 6574 0a20   import Packet. 
+00000540: 2020 2066 726f 6d20 7363 6170 792e 706c     from scapy.pl
+00000550: 6973 7420 696d 706f 7274 205f 5061 636b  ist import _Pack
+00000560: 6574 4974 6572 6162 6c65 2c20 5061 636b  etIterable, Pack
+00000570: 6574 4c69 7374 0a20 2020 2066 726f 6d20  etList.    from 
+00000580: 7363 6170 792e 7375 7065 7273 6f63 6b65  scapy.supersocke
+00000590: 7420 696d 706f 7274 2053 7570 6572 536f  t import SuperSo
+000005a0: 636b 6574 0a20 2020 2069 6d70 6f72 7420  cket.    import 
+000005b0: 7072 6f6d 7074 5f74 6f6f 6c6b 6974 0a0a  prompt_toolkit..
+000005c0: 5f42 7974 6553 7472 6561 6d20 3d20 556e  _ByteStream = Un
+000005d0: 696f 6e5b 494f 5b62 7974 6573 5d2c 2067  ion[IO[bytes], g
+000005e0: 7a69 702e 477a 6970 4669 6c65 5d0a 0a23  zip.GzipFile]..#
+000005f0: 2323 2323 2323 2323 2323 0a23 2020 546f  ##########.#  To
+00000600: 6f6c 7320 2023 0a23 2323 2323 2323 2323  ols  #.#########
+00000610: 2323 0a0a 0a64 6566 2069 7373 7562 7479  ##...def issubty
+00000620: 7065 2878 2c20 2023 2074 7970 653a 2041  pe(x,  # type: A
+00000630: 6e79 0a20 2020 2020 2020 2020 2020 2020  ny.             
+00000640: 2074 2c20 2023 2074 7970 653a 2055 6e69   t,  # type: Uni
+00000650: 6f6e 5b74 7970 652c 2073 7472 5d0a 2020  on[type, str].  
+00000660: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
+00000670: 2020 2023 2074 7970 653a 2028 2e2e 2e29     # type: (...)
+00000680: 202d 3e20 626f 6f6c 0a20 2020 2022 2222   -> bool.    """
+00000690: 6973 7375 6274 7970 6528 432c 2042 2920  issubtype(C, B) 
+000006a0: 2d3e 2062 6f6f 6c0a 0a20 2020 2052 6574  -> bool..    Ret
+000006b0: 7572 6e20 7768 6574 6865 7220 4320 6973  urn whether C is
+000006c0: 2061 2063 6c61 7373 2061 6e64 2069 6620   a class and if 
+000006d0: 6974 2069 7320 6120 7375 6263 6c61 7373  it is a subclass
+000006e0: 206f 6620 636c 6173 7320 422e 0a20 2020   of class B..   
+000006f0: 2057 6865 6e20 7573 696e 6720 6120 7475   When using a tu
+00000700: 706c 6520 6173 2074 6865 2073 6563 6f6e  ple as the secon
+00000710: 6420 6172 6775 6d65 6e74 2069 7373 7562  d argument issub
+00000720: 7479 7065 2858 2c20 2841 2c20 422c 202e  type(X, (A, B, .
+00000730: 2e2e 2929 2c0a 2020 2020 6973 2061 2073  ..)),.    is a s
+00000740: 686f 7274 6375 7420 666f 7220 6973 7375  hortcut for issu
+00000750: 6274 7970 6528 582c 2041 2920 6f72 2069  btype(X, A) or i
+00000760: 7373 7562 7479 7065 2858 2c20 4229 206f  ssubtype(X, B) o
+00000770: 7220 2e2e 2e20 2865 7463 2e29 2e0a 2020  r ... (etc.)..  
+00000780: 2020 2222 220a 2020 2020 6966 2069 7369    """.    if isi
+00000790: 6e73 7461 6e63 6528 742c 2073 7472 293a  nstance(t, str):
+000007a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000007b0: 7420 696e 2028 7a2e 5f5f 6e61 6d65 5f5f  t in (z.__name__
+000007c0: 2066 6f72 207a 2069 6e20 782e 5f5f 6261   for z in x.__ba
+000007d0: 7365 735f 5f29 0a20 2020 2069 6620 6973  ses__).    if is
+000007e0: 696e 7374 616e 6365 2878 2c20 7479 7065  instance(x, type
+000007f0: 2920 616e 6420 6973 7375 6263 6c61 7373  ) and issubclass
+00000800: 2878 2c20 7429 3a0a 2020 2020 2020 2020  (x, t):.        
+00000810: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
+00000820: 7265 7475 726e 2046 616c 7365 0a0a 0a5f  return False..._
+00000830: 4465 6369 6d61 6c20 3d20 556e 696f 6e5b  Decimal = Union[
+00000840: 4465 6369 6d61 6c2c 2069 6e74 5d0a 0a0a  Decimal, int]...
+00000850: 636c 6173 7320 4544 6563 696d 616c 2844  class EDecimal(D
+00000860: 6563 696d 616c 293a 0a20 2020 2022 2222  ecimal):.    """
+00000870: 4578 7465 6e64 6564 2044 6563 696d 616c  Extended Decimal
+00000880: 0a0a 2020 2020 5468 6973 2069 6d70 6c65  ..    This imple
+00000890: 6d65 6e74 7320 6172 6974 686d 6574 6963  ments arithmetic
+000008a0: 2061 6e64 2063 6f6d 7061 7269 736f 6e20   and comparison 
+000008b0: 7769 7468 2066 6c6f 6174 2066 6f72 0a20  with float for. 
+000008c0: 2020 2062 6163 6b77 6172 6420 636f 6d70     backward comp
+000008d0: 6174 6962 696c 6974 790a 2020 2020 2222  atibility.    ""
+000008e0: 220a 0a20 2020 2064 6566 205f 5f61 6464  "..    def __add
+000008f0: 5f5f 2873 656c 662c 206f 7468 6572 2c20  __(self, other, 
+00000900: 636f 6e74 6578 743d 4e6f 6e65 293a 0a20  context=None):. 
+00000910: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+00000920: 5f44 6563 696d 616c 2c20 416e 7929 202d  _Decimal, Any) -
+00000930: 3e20 4544 6563 696d 616c 0a20 2020 2020  > EDecimal.     
+00000940: 2020 2072 6574 7572 6e20 4544 6563 696d     return EDecim
+00000950: 616c 2844 6563 696d 616c 2e5f 5f61 6464  al(Decimal.__add
+00000960: 5f5f 2873 656c 662c 2044 6563 696d 616c  __(self, Decimal
+00000970: 286f 7468 6572 2929 290a 0a20 2020 2064  (other)))..    d
+00000980: 6566 205f 5f72 6164 645f 5f28 7365 6c66  ef __radd__(self
+00000990: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+000009a0: 2020 2320 7479 7065 3a20 285f 4465 6369    # type: (_Deci
+000009b0: 6d61 6c29 202d 3e20 4544 6563 696d 616c  mal) -> EDecimal
+000009c0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000009d0: 4544 6563 696d 616c 2844 6563 696d 616c  EDecimal(Decimal
+000009e0: 2e5f 5f61 6464 5f5f 2873 656c 662c 2044  .__add__(self, D
+000009f0: 6563 696d 616c 286f 7468 6572 2929 290a  ecimal(other))).
+00000a00: 0a20 2020 2064 6566 205f 5f73 7562 5f5f  .    def __sub__
+00000a10: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
+00000a20: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+00000a30: 5f44 6563 696d 616c 2920 2d3e 2045 4465  _Decimal) -> EDe
+00000a40: 6369 6d61 6c0a 2020 2020 2020 2020 7265  cimal.        re
+00000a50: 7475 726e 2045 4465 6369 6d61 6c28 4465  turn EDecimal(De
+00000a60: 6369 6d61 6c2e 5f5f 7375 625f 5f28 7365  cimal.__sub__(se
+00000a70: 6c66 2c20 4465 6369 6d61 6c28 6f74 6865  lf, Decimal(othe
+00000a80: 7229 2929 0a0a 2020 2020 6465 6620 5f5f  r)))..    def __
+00000a90: 7273 7562 5f5f 2873 656c 662c 206f 7468  rsub__(self, oth
+00000aa0: 6572 293a 0a20 2020 2020 2020 2023 2074  er):.        # t
+00000ab0: 7970 653a 2028 5f44 6563 696d 616c 2920  ype: (_Decimal) 
+00000ac0: 2d3e 2045 4465 6369 6d61 6c0a 2020 2020  -> EDecimal.    
+00000ad0: 2020 2020 7265 7475 726e 2045 4465 6369      return EDeci
+00000ae0: 6d61 6c28 4465 6369 6d61 6c2e 5f5f 7273  mal(Decimal.__rs
+00000af0: 7562 5f5f 2873 656c 662c 2044 6563 696d  ub__(self, Decim
+00000b00: 616c 286f 7468 6572 2929 290a 0a20 2020  al(other)))..   
+00000b10: 2064 6566 205f 5f6d 756c 5f5f 2873 656c   def __mul__(sel
+00000b20: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
+00000b30: 2020 2023 2074 7970 653a 2028 5f44 6563     # type: (_Dec
+00000b40: 696d 616c 2920 2d3e 2045 4465 6369 6d61  imal) -> EDecima
+00000b50: 6c0a 2020 2020 2020 2020 7265 7475 726e  l.        return
+00000b60: 2045 4465 6369 6d61 6c28 4465 6369 6d61   EDecimal(Decima
+00000b70: 6c2e 5f5f 6d75 6c5f 5f28 7365 6c66 2c20  l.__mul__(self, 
+00000b80: 4465 6369 6d61 6c28 6f74 6865 7229 2929  Decimal(other)))
+00000b90: 0a0a 2020 2020 6465 6620 5f5f 726d 756c  ..    def __rmul
+00000ba0: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
+00000bb0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+00000bc0: 2028 5f44 6563 696d 616c 2920 2d3e 2045   (_Decimal) -> E
+00000bd0: 4465 6369 6d61 6c0a 2020 2020 2020 2020  Decimal.        
+00000be0: 7265 7475 726e 2045 4465 6369 6d61 6c28  return EDecimal(
+00000bf0: 4465 6369 6d61 6c2e 5f5f 6d75 6c5f 5f28  Decimal.__mul__(
+00000c00: 7365 6c66 2c20 4465 6369 6d61 6c28 6f74  self, Decimal(ot
+00000c10: 6865 7229 2929 0a0a 2020 2020 6465 6620  her)))..    def 
+00000c20: 5f5f 7472 7565 6469 765f 5f28 7365 6c66  __truediv__(self
+00000c30: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+00000c40: 2020 2320 7479 7065 3a20 285f 4465 6369    # type: (_Deci
+00000c50: 6d61 6c29 202d 3e20 4544 6563 696d 616c  mal) -> EDecimal
+00000c60: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00000c70: 4544 6563 696d 616c 2844 6563 696d 616c  EDecimal(Decimal
+00000c80: 2e5f 5f74 7275 6564 6976 5f5f 2873 656c  .__truediv__(sel
+00000c90: 662c 2044 6563 696d 616c 286f 7468 6572  f, Decimal(other
+00000ca0: 2929 290a 0a20 2020 2064 6566 205f 5f66  )))..    def __f
+00000cb0: 6c6f 6f72 6469 765f 5f28 7365 6c66 2c20  loordiv__(self, 
+00000cc0: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
+00000cd0: 2320 7479 7065 3a20 285f 4465 6369 6d61  # type: (_Decima
+00000ce0: 6c29 202d 3e20 4544 6563 696d 616c 0a20  l) -> EDecimal. 
+00000cf0: 2020 2020 2020 2072 6574 7572 6e20 4544         return ED
+00000d00: 6563 696d 616c 2844 6563 696d 616c 2e5f  ecimal(Decimal._
+00000d10: 5f66 6c6f 6f72 6469 765f 5f28 7365 6c66  _floordiv__(self
+00000d20: 2c20 4465 6369 6d61 6c28 6f74 6865 7229  , Decimal(other)
+00000d30: 2929 0a0a 2020 2020 6966 2073 7973 2e76  ))..    if sys.v
+00000d40: 6572 7369 6f6e 5f69 6e66 6f20 3e3d 2028  ersion_info >= (
+00000d50: 332c 293a 0a20 2020 2020 2020 2064 6566  3,):.        def
+00000d60: 205f 5f64 6976 6d6f 645f 5f28 7365 6c66   __divmod__(self
+00000d70: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+00000d80: 2020 2020 2020 2320 7479 7065 3a20 285f        # type: (_
+00000d90: 4465 6369 6d61 6c29 202d 3e20 5475 706c  Decimal) -> Tupl
+00000da0: 655b 4544 6563 696d 616c 2c20 4544 6563  e[EDecimal, EDec
+00000db0: 696d 616c 5d0a 2020 2020 2020 2020 2020  imal].          
+00000dc0: 2020 7220 3d20 4465 6369 6d61 6c2e 5f5f    r = Decimal.__
+00000dd0: 6469 766d 6f64 5f5f 2873 656c 662c 2044  divmod__(self, D
+00000de0: 6563 696d 616c 286f 7468 6572 2929 0a20  ecimal(other)). 
+00000df0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00000e00: 6e20 4544 6563 696d 616c 2872 5b30 5d29  n EDecimal(r[0])
+00000e10: 2c20 4544 6563 696d 616c 2872 5b31 5d29  , EDecimal(r[1])
+00000e20: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00000e30: 2020 2064 6566 205f 5f64 6976 5f5f 2873     def __div__(s
+00000e40: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+00000e50: 2020 2020 2020 2020 2023 2074 7970 653a           # type:
+00000e60: 2028 5f44 6563 696d 616c 2920 2d3e 2045   (_Decimal) -> E
+00000e70: 4465 6369 6d61 6c0a 2020 2020 2020 2020  Decimal.        
+00000e80: 2020 2020 7265 7475 726e 2045 4465 6369      return EDeci
+00000e90: 6d61 6c28 4465 6369 6d61 6c2e 5f5f 6469  mal(Decimal.__di
+00000ea0: 765f 5f28 7365 6c66 2c20 4465 6369 6d61  v__(self, Decima
+00000eb0: 6c28 6f74 6865 7229 2929 0a0a 2020 2020  l(other)))..    
+00000ec0: 2020 2020 6465 6620 5f5f 7264 6976 5f5f      def __rdiv__
+00000ed0: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
+00000ee0: 2020 2020 2020 2020 2020 2023 2074 7970             # typ
+00000ef0: 653a 2028 5f44 6563 696d 616c 2920 2d3e  e: (_Decimal) ->
+00000f00: 2045 4465 6369 6d61 6c0a 2020 2020 2020   EDecimal.      
+00000f10: 2020 2020 2020 7265 7475 726e 2045 4465        return EDe
+00000f20: 6369 6d61 6c28 4465 6369 6d61 6c2e 5f5f  cimal(Decimal.__
+00000f30: 7264 6976 5f5f 2873 656c 662c 2044 6563  rdiv__(self, Dec
+00000f40: 696d 616c 286f 7468 6572 2929 290a 0a20  imal(other))).. 
+00000f50: 2020 2064 6566 205f 5f6d 6f64 5f5f 2873     def __mod__(s
+00000f60: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+00000f70: 2020 2020 2023 2074 7970 653a 2028 5f44       # type: (_D
+00000f80: 6563 696d 616c 2920 2d3e 2045 4465 6369  ecimal) -> EDeci
+00000f90: 6d61 6c0a 2020 2020 2020 2020 7265 7475  mal.        retu
+00000fa0: 726e 2045 4465 6369 6d61 6c28 4465 6369  rn EDecimal(Deci
+00000fb0: 6d61 6c2e 5f5f 6d6f 645f 5f28 7365 6c66  mal.__mod__(self
+00000fc0: 2c20 4465 6369 6d61 6c28 6f74 6865 7229  , Decimal(other)
+00000fd0: 2929 0a0a 2020 2020 6465 6620 5f5f 726d  ))..    def __rm
+00000fe0: 6f64 5f5f 2873 656c 662c 206f 7468 6572  od__(self, other
+00000ff0: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+00001000: 653a 2028 5f44 6563 696d 616c 2920 2d3e  e: (_Decimal) ->
+00001010: 2045 4465 6369 6d61 6c0a 2020 2020 2020   EDecimal.      
+00001020: 2020 7265 7475 726e 2045 4465 6369 6d61    return EDecima
+00001030: 6c28 4465 6369 6d61 6c2e 5f5f 726d 6f64  l(Decimal.__rmod
+00001040: 5f5f 2873 656c 662c 2044 6563 696d 616c  __(self, Decimal
+00001050: 286f 7468 6572 2929 290a 0a20 2020 2064  (other)))..    d
+00001060: 6566 205f 5f70 6f77 5f5f 2873 656c 662c  ef __pow__(self,
+00001070: 206f 7468 6572 2c20 6d6f 6475 6c6f 3d4e   other, modulo=N
+00001080: 6f6e 6529 3a0a 2020 2020 2020 2020 2320  one):.        # 
+00001090: 7479 7065 3a20 285f 4465 6369 6d61 6c2c  type: (_Decimal,
+000010a0: 204f 7074 696f 6e61 6c5b 5f44 6563 696d   Optional[_Decim
+000010b0: 616c 5d29 202d 3e20 4544 6563 696d 616c  al]) -> EDecimal
+000010c0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000010d0: 4544 6563 696d 616c 2844 6563 696d 616c  EDecimal(Decimal
+000010e0: 2e5f 5f70 6f77 5f5f 2873 656c 662c 2044  .__pow__(self, D
+000010f0: 6563 696d 616c 286f 7468 6572 292c 206d  ecimal(other), m
+00001100: 6f64 756c 6f29 290a 0a20 2020 2064 6566  odulo))..    def
+00001110: 205f 5f65 715f 5f28 7365 6c66 2c20 6f74   __eq__(self, ot
+00001120: 6865 7229 3a0a 2020 2020 2020 2020 2320  her):.        # 
+00001130: 7479 7065 3a20 2841 6e79 2920 2d3e 2062  type: (Any) -> b
+00001140: 6f6f 6c0a 2020 2020 2020 2020 7265 7475  ool.        retu
+00001150: 726e 2073 7570 6572 2845 4465 6369 6d61  rn super(EDecima
+00001160: 6c2c 2073 656c 6629 2e5f 5f65 715f 5f28  l, self).__eq__(
+00001170: 6f74 6865 7229 206f 7220 666c 6f61 7428  other) or float(
+00001180: 7365 6c66 2920 3d3d 206f 7468 6572 0a0a  self) == other..
+00001190: 2020 2020 6465 6620 6e6f 726d 616c 697a      def normaliz
+000011a0: 6528 7365 6c66 2c20 7072 6563 6973 696f  e(self, precisio
+000011b0: 6e29 3a20 2023 2074 7970 653a 2069 676e  n):  # type: ign
+000011c0: 6f72 650a 2020 2020 2020 2020 2320 7479  ore.        # ty
+000011d0: 7065 3a20 2869 6e74 2920 2d3e 2045 4465  pe: (int) -> EDe
+000011e0: 6369 6d61 6c0a 2020 2020 2020 2020 7769  cimal.        wi
+000011f0: 7468 2064 6563 696d 616c 2e6c 6f63 616c  th decimal.local
+00001200: 636f 6e74 6578 7428 2920 6173 2063 7478  context() as ctx
+00001210: 3a0a 2020 2020 2020 2020 2020 2020 6374  :.            ct
+00001220: 782e 7072 6563 203d 2070 7265 6369 7369  x.prec = precisi
+00001230: 6f6e 0a20 2020 2020 2020 2020 2020 2072  on.            r
+00001240: 6574 7572 6e20 4544 6563 696d 616c 2873  eturn EDecimal(s
+00001250: 7570 6572 2845 4465 6369 6d61 6c2c 2073  uper(EDecimal, s
+00001260: 656c 6629 2e6e 6f72 6d61 6c69 7a65 2863  elf).normalize(c
+00001270: 7478 2929 0a0a 0a40 6f76 6572 6c6f 6164  tx))...@overload
+00001280: 0a64 6566 2067 6574 5f74 656d 705f 6669  .def get_temp_fi
+00001290: 6c65 286b 6565 702c 2061 7574 6f65 7874  le(keep, autoext
+000012a0: 2c20 6664 293a 0a20 2020 2023 2074 7970  , fd):.    # typ
+000012b0: 653a 2028 626f 6f6c 2c20 7374 722c 204c  e: (bool, str, L
+000012c0: 6974 6572 616c 5b54 7275 655d 2920 2d3e  iteral[True]) ->
+000012d0: 2049 4f5b 6279 7465 735d 0a20 2020 2070   IO[bytes].    p
+000012e0: 6173 730a 0a0a 406f 7665 726c 6f61 640a  ass...@overload.
+000012f0: 6465 6620 6765 745f 7465 6d70 5f66 696c  def get_temp_fil
+00001300: 6528 6b65 6570 3d46 616c 7365 2c20 6175  e(keep=False, au
+00001310: 746f 6578 743d 2222 2c20 6664 3d46 616c  toext="", fd=Fal
+00001320: 7365 293a 0a20 2020 2023 2074 7970 653a  se):.    # type:
+00001330: 2028 626f 6f6c 2c20 7374 722c 204c 6974   (bool, str, Lit
+00001340: 6572 616c 5b46 616c 7365 5d29 202d 3e20  eral[False]) -> 
+00001350: 7374 720a 2020 2020 7061 7373 0a0a 0a64  str.    pass...d
+00001360: 6566 2067 6574 5f74 656d 705f 6669 6c65  ef get_temp_file
+00001370: 286b 6565 703d 4661 6c73 652c 2061 7574  (keep=False, aut
+00001380: 6f65 7874 3d22 222c 2066 643d 4661 6c73  oext="", fd=Fals
+00001390: 6529 3a0a 2020 2020 2320 7479 7065 3a20  e):.    # type: 
+000013a0: 2862 6f6f 6c2c 2073 7472 2c20 626f 6f6c  (bool, str, bool
+000013b0: 2920 2d3e 2055 6e69 6f6e 5b49 4f5b 6279  ) -> Union[IO[by
+000013c0: 7465 735d 2c20 7374 725d 0a20 2020 2022  tes], str].    "
+000013d0: 2222 4372 6561 7465 7320 6120 7465 6d70  ""Creates a temp
+000013e0: 6f72 6172 7920 6669 6c65 2e0a 0a20 2020  orary file...   
+000013f0: 203a 7061 7261 6d20 6b65 6570 3a20 4966   :param keep: If
+00001400: 2046 616c 7365 2c20 6175 746f 6d61 7469   False, automati
+00001410: 6361 6c6c 7920 6465 6c65 7465 2074 6865  cally delete the
+00001420: 2066 696c 6520 7768 656e 2053 6361 7079   file when Scapy
+00001430: 2065 7869 7473 2e0a 2020 2020 3a70 6172   exits..    :par
+00001440: 616d 2061 7574 6f65 7874 3a20 5375 6666  am autoext: Suff
+00001450: 6978 2074 6f20 6164 6420 746f 2074 6865  ix to add to the
+00001460: 2067 656e 6572 6174 6564 2066 696c 6520   generated file 
+00001470: 6e61 6d65 2e0a 2020 2020 3a70 6172 616d  name..    :param
+00001480: 2066 643a 2049 6620 5472 7565 2c20 7468   fd: If True, th
+00001490: 6973 2072 6574 7572 6e73 2061 2066 696c  is returns a fil
+000014a0: 652d 6c69 6b65 206f 626a 6563 7420 7769  e-like object wi
+000014b0: 7468 2074 6865 2074 656d 706f 7261 7279  th the temporary
+000014c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000014d0: 6669 6c65 206f 7065 6e65 642e 2049 6620  file opened. If 
+000014e0: 4661 6c73 6520 2864 6566 6175 6c74 292c  False (default),
+000014f0: 2074 6869 7320 7265 7475 726e 7320 6120   this returns a 
+00001500: 6669 6c65 2070 6174 682e 0a20 2020 2022  file path..    "
+00001510: 2222 0a20 2020 2066 203d 2074 656d 7066  "".    f = tempf
+00001520: 696c 652e 4e61 6d65 6454 656d 706f 7261  ile.NamedTempora
+00001530: 7279 4669 6c65 2870 7265 6669 783d 2273  ryFile(prefix="s
+00001540: 6361 7079 222c 2073 7566 6669 783d 6175  capy", suffix=au
+00001550: 746f 6578 742c 0a20 2020 2020 2020 2020  toext,.         
 00001560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001570: 2020 2020 2020 2020 6465 6c65 7465 3d46          delete=F
-00001580: 616c 7365 290a 2020 2020 6966 206e 6f74  alse).    if not
-00001590: 206b 6565 703a 0a20 2020 2020 2020 2063   keep:.        c
-000015a0: 6f6e 662e 7465 6d70 5f66 696c 6573 2e61  onf.temp_files.a
-000015b0: 7070 656e 6428 662e 6e61 6d65 290a 0a20  ppend(f.name).. 
-000015c0: 2020 2069 6620 6664 3a0a 2020 2020 2020     if fd:.      
-000015d0: 2020 7265 7475 726e 2066 0a20 2020 2065    return f.    e
-000015e0: 6c73 653a 0a20 2020 2020 2020 2023 2043  lse:.        # C
-000015f0: 6c6f 7365 2074 6865 2066 696c 6520 736f  lose the file so
-00001600: 2073 6f6d 6574 6869 6e67 2065 6c73 6520   something else 
-00001610: 6361 6e20 7461 6b65 2069 742e 0a20 2020  can take it..   
-00001620: 2020 2020 2066 2e63 6c6f 7365 2829 0a20       f.close(). 
-00001630: 2020 2020 2020 2072 6574 7572 6e20 662e         return f.
-00001640: 6e61 6d65 0a0a 0a64 6566 2067 6574 5f74  name...def get_t
-00001650: 656d 705f 6469 7228 6b65 6570 3d46 616c  emp_dir(keep=Fal
-00001660: 7365 293a 0a20 2020 2023 2074 7970 653a  se):.    # type:
-00001670: 2028 626f 6f6c 2920 2d3e 2073 7472 0a20   (bool) -> str. 
-00001680: 2020 2022 2222 4372 6561 7465 7320 6120     """Creates a 
-00001690: 7465 6d70 6f72 6172 7920 6669 6c65 2c20  temporary file, 
-000016a0: 616e 6420 7265 7475 726e 7320 6974 7320  and returns its 
-000016b0: 6e61 6d65 2e0a 0a20 2020 203a 7061 7261  name...    :para
-000016c0: 6d20 6b65 6570 3a20 4966 2046 616c 7365  m keep: If False
-000016d0: 2028 6465 6661 756c 7429 2c20 7468 6520   (default), the 
-000016e0: 6469 7265 6374 6f72 7920 7769 6c6c 2062  directory will b
-000016f0: 6520 7265 6375 7273 6976 656c 790a 2020  e recursively.  
-00001700: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00001710: 656c 6574 6564 2077 6865 6e20 5363 6170  eleted when Scap
-00001720: 7920 6578 6974 732e 0a20 2020 203a 7265  y exits..    :re
-00001730: 7475 726e 3a20 4120 6675 6c6c 2070 6174  turn: A full pat
-00001740: 6820 746f 2061 2074 656d 706f 7261 7279  h to a temporary
-00001750: 2064 6972 6563 746f 7279 2e0a 2020 2020   directory..    
-00001760: 2222 220a 0a20 2020 2064 6e61 6d65 203d  """..    dname =
-00001770: 2074 656d 7066 696c 652e 6d6b 6474 656d   tempfile.mkdtem
-00001780: 7028 7072 6566 6978 3d22 7363 6170 7922  p(prefix="scapy"
-00001790: 290a 0a20 2020 2069 6620 6e6f 7420 6b65  )..    if not ke
-000017a0: 6570 3a0a 2020 2020 2020 2020 636f 6e66  ep:.        conf
-000017b0: 2e74 656d 705f 6669 6c65 732e 6170 7065  .temp_files.appe
-000017c0: 6e64 2864 6e61 6d65 290a 0a20 2020 2072  nd(dname)..    r
-000017d0: 6574 7572 6e20 646e 616d 650a 0a0a 6465  eturn dname...de
-000017e0: 6620 7361 6e65 2878 2c20 636f 6c6f 723d  f sane(x, color=
-000017f0: 4661 6c73 6529 3a0a 2020 2020 2320 7479  False):.    # ty
-00001800: 7065 3a20 2841 6e79 5374 722c 2062 6f6f  pe: (AnyStr, boo
-00001810: 6c29 202d 3e20 7374 720a 2020 2020 7220  l) -> str.    r 
-00001820: 3d20 2222 0a20 2020 2066 6f72 2069 2069  = "".    for i i
-00001830: 6e20 783a 0a20 2020 2020 2020 206a 203d  n x:.        j =
-00001840: 206f 7262 2869 290a 2020 2020 2020 2020   orb(i).        
-00001850: 6966 2028 6a20 3c20 3332 2920 6f72 2028  if (j < 32) or (
-00001860: 6a20 3e3d 2031 3237 293a 0a20 2020 2020  j >= 127):.     
-00001870: 2020 2020 2020 2069 6620 636f 6c6f 723a         if color:
-00001880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001890: 2072 202b 3d20 636f 6e66 2e63 6f6c 6f72   r += conf.color
-000018a0: 5f74 6865 6d65 2e6e 6f74 5f70 7269 6e74  _theme.not_print
-000018b0: 6162 6c65 2822 2e22 290a 2020 2020 2020  able(".").      
-000018c0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000018d0: 2020 2020 2020 2020 2020 2020 7220 2b3d              r +=
-000018e0: 2022 2e22 0a20 2020 2020 2020 2065 6c73   ".".        els
-000018f0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-00001900: 202b 3d20 6368 7228 6a29 0a20 2020 2072   += chr(j).    r
-00001910: 6574 7572 6e20 720a 0a0a 4063 6f6e 662e  eturn r...@conf.
-00001920: 636f 6d6d 616e 6473 2e72 6567 6973 7465  commands.registe
-00001930: 720a 6465 6620 7265 7374 6172 7428 293a  r.def restart():
-00001940: 0a20 2020 2023 2074 7970 653a 2028 2920  .    # type: () 
-00001950: 2d3e 204e 6f6e 650a 2020 2020 2222 2252  -> None.    """R
-00001960: 6573 7461 7274 7320 7363 6170 7922 2222  estarts scapy"""
-00001970: 0a20 2020 2069 6620 6e6f 7420 636f 6e66  .    if not conf
-00001980: 2e69 6e74 6572 6163 7469 7665 206f 7220  .interactive or 
-00001990: 6e6f 7420 6f73 2e70 6174 682e 6973 6669  not os.path.isfi
-000019a0: 6c65 2873 7973 2e61 7267 765b 305d 293a  le(sys.argv[0]):
-000019b0: 0a20 2020 2020 2020 2072 6169 7365 204f  .        raise O
-000019c0: 5345 7272 6f72 2822 5363 6170 7920 7761  SError("Scapy wa
-000019d0: 7320 6e6f 7420 7374 6172 7465 6420 6672  s not started fr
-000019e0: 6f6d 2063 6f6e 736f 6c65 2229 0a20 2020  om console").   
-000019f0: 2069 6620 5749 4e44 4f57 533a 0a20 2020   if WINDOWS:.   
-00001a00: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00001a10: 2020 2020 2020 7265 735f 636f 6465 203d        res_code =
-00001a20: 2073 7562 7072 6f63 6573 732e 6361 6c6c   subprocess.call
-00001a30: 285b 7379 732e 6578 6563 7574 6162 6c65  ([sys.executable
-00001a40: 5d20 2b20 7379 732e 6172 6776 290a 2020  ] + sys.argv).  
-00001a50: 2020 2020 2020 6578 6365 7074 204b 6579        except Key
-00001a60: 626f 6172 6449 6e74 6572 7275 7074 3a0a  boardInterrupt:.
-00001a70: 2020 2020 2020 2020 2020 2020 7265 735f              res_
-00001a80: 636f 6465 203d 2031 0a20 2020 2020 2020  code = 1.       
-00001a90: 2066 696e 616c 6c79 3a0a 2020 2020 2020   finally:.      
-00001aa0: 2020 2020 2020 6f73 2e5f 6578 6974 2872        os._exit(r
-00001ab0: 6573 5f63 6f64 6529 0a20 2020 206f 732e  es_code).    os.
-00001ac0: 6578 6563 7628 7379 732e 6578 6563 7574  execv(sys.execut
-00001ad0: 6162 6c65 2c20 5b73 7973 2e65 7865 6375  able, [sys.execu
-00001ae0: 7461 626c 655d 202b 2073 7973 2e61 7267  table] + sys.arg
-00001af0: 7629 0a0a 0a64 6566 206c 6865 7828 7829  v)...def lhex(x)
-00001b00: 3a0a 2020 2020 2320 7479 7065 3a20 2841  :.    # type: (A
-00001b10: 6e79 2920 2d3e 2073 7472 0a20 2020 2066  ny) -> str.    f
-00001b20: 726f 6d20 7363 6170 792e 766f 6c61 7469  rom scapy.volati
-00001b30: 6c65 2069 6d70 6f72 7420 566f 6c61 7469  le import Volati
-00001b40: 6c65 5661 6c75 650a 2020 2020 6966 2069  leValue.    if i
-00001b50: 7369 6e73 7461 6e63 6528 782c 2056 6f6c  sinstance(x, Vol
-00001b60: 6174 696c 6556 616c 7565 293a 0a20 2020  atileValue):.   
-00001b70: 2020 2020 2072 6574 7572 6e20 7265 7072       return repr
-00001b80: 2878 290a 2020 2020 6966 2069 7369 6e73  (x).    if isins
-00001b90: 7461 6e63 6528 782c 2073 6978 2e69 6e74  tance(x, six.int
-00001ba0: 6567 6572 5f74 7970 6573 293a 0a20 2020  eger_types):.   
-00001bb0: 2020 2020 2072 6574 7572 6e20 6865 7828       return hex(
-00001bc0: 7829 0a20 2020 2069 6620 6973 696e 7374  x).    if isinst
-00001bd0: 616e 6365 2878 2c20 7475 706c 6529 3a0a  ance(x, tuple):.
-00001be0: 2020 2020 2020 2020 7265 7475 726e 2022          return "
-00001bf0: 2825 7329 2220 2520 222c 2022 2e6a 6f69  (%s)" % ", ".joi
-00001c00: 6e28 6c68 6578 2876 2920 666f 7220 7620  n(lhex(v) for v 
-00001c10: 696e 2078 290a 2020 2020 6966 2069 7369  in x).    if isi
-00001c20: 6e73 7461 6e63 6528 782c 206c 6973 7429  nstance(x, list)
-00001c30: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00001c40: 2022 5b25 735d 2220 2520 222c 2022 2e6a   "[%s]" % ", ".j
-00001c50: 6f69 6e28 6c68 6578 2876 2920 666f 7220  oin(lhex(v) for 
-00001c60: 7620 696e 2078 290a 2020 2020 7265 7475  v in x).    retu
-00001c70: 726e 2073 7472 2878 290a 0a0a 4063 6f6e  rn str(x)...@con
-00001c80: 662e 636f 6d6d 616e 6473 2e72 6567 6973  f.commands.regis
-00001c90: 7465 720a 6465 6620 6865 7864 756d 7028  ter.def hexdump(
-00001ca0: 702c 2064 756d 703d 4661 6c73 6529 3a0a  p, dump=False):.
-00001cb0: 2020 2020 2320 7479 7065 3a20 2855 6e69      # type: (Uni
-00001cc0: 6f6e 5b50 6163 6b65 742c 2041 6e79 5374  on[Packet, AnySt
-00001cd0: 725d 2c20 626f 6f6c 2920 2d3e 204f 7074  r], bool) -> Opt
-00001ce0: 696f 6e61 6c5b 7374 725d 0a20 2020 2022  ional[str].    "
-00001cf0: 2222 4275 696c 6420 6120 7463 7064 756d  ""Build a tcpdum
-00001d00: 7020 6c69 6b65 2068 6578 6164 6563 696d  p like hexadecim
-00001d10: 616c 2076 6965 770a 0a20 2020 203a 7061  al view..    :pa
-00001d20: 7261 6d20 703a 2061 2050 6163 6b65 740a  ram p: a Packet.
-00001d30: 2020 2020 3a70 6172 616d 2064 756d 703a      :param dump:
-00001d40: 2064 6566 696e 6520 6966 2074 6865 2072   define if the r
-00001d50: 6573 756c 7420 6d75 7374 2062 6520 7072  esult must be pr
-00001d60: 696e 7465 6420 6f72 2072 6574 7572 6e65  inted or returne
-00001d70: 6420 696e 2061 2076 6172 6961 626c 650a  d in a variable.
-00001d80: 2020 2020 3a72 6574 7572 6e3a 2061 2053      :return: a S
-00001d90: 7472 696e 6720 6f6e 6c79 2077 6865 6e20  tring only when 
-00001da0: 6475 6d70 3d54 7275 650a 2020 2020 2222  dump=True.    ""
-00001db0: 220a 2020 2020 7320 3d20 2222 0a20 2020  ".    s = "".   
-00001dc0: 2078 203d 2062 7974 6573 5f65 6e63 6f64   x = bytes_encod
-00001dd0: 6528 7029 0a20 2020 2078 5f6c 656e 203d  e(p).    x_len =
-00001de0: 206c 656e 2878 290a 2020 2020 6920 3d20   len(x).    i = 
-00001df0: 300a 2020 2020 7768 696c 6520 6920 3c20  0.    while i < 
-00001e00: 785f 6c65 6e3a 0a20 2020 2020 2020 2073  x_len:.        s
-00001e10: 202b 3d20 2225 3034 7820 2022 2025 2069   += "%04x  " % i
-00001e20: 0a20 2020 2020 2020 2066 6f72 206a 2069  .        for j i
-00001e30: 6e20 7261 6e67 6528 3136 293a 0a20 2020  n range(16):.   
-00001e40: 2020 2020 2020 2020 2069 6620 6920 2b20           if i + 
-00001e50: 6a20 3c20 785f 6c65 6e3a 0a20 2020 2020  j < x_len:.     
-00001e60: 2020 2020 2020 2020 2020 2073 202b 3d20             s += 
-00001e70: 2225 3032 5820 2220 2520 6f72 6228 785b  "%02X " % orb(x[
-00001e80: 6920 2b20 6a5d 290a 2020 2020 2020 2020  i + j]).        
-00001e90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00001ea0: 2020 2020 2020 2020 2020 7320 2b3d 2022            s += "
-00001eb0: 2020 2022 0a20 2020 2020 2020 2073 202b     ".        s +
-00001ec0: 3d20 2220 2573 5c6e 2220 2520 7361 6e65  = " %s\n" % sane
-00001ed0: 2878 5b69 3a69 202b 2031 365d 2c20 636f  (x[i:i + 16], co
-00001ee0: 6c6f 723d 5472 7565 290a 2020 2020 2020  lor=True).      
-00001ef0: 2020 6920 2b3d 2031 360a 2020 2020 2320    i += 16.    # 
-00001f00: 7265 6d6f 7665 2074 7261 696c 696e 6720  remove trailing 
-00001f10: 5c6e 0a20 2020 2073 203d 2073 5b3a 2d31  \n.    s = s[:-1
-00001f20: 5d20 6966 2073 2e65 6e64 7377 6974 6828  ] if s.endswith(
-00001f30: 225c 6e22 2920 656c 7365 2073 0a20 2020  "\n") else s.   
-00001f40: 2069 6620 6475 6d70 3a0a 2020 2020 2020   if dump:.      
-00001f50: 2020 7265 7475 726e 2073 0a20 2020 2065    return s.    e
-00001f60: 6c73 653a 0a20 2020 2020 2020 2070 7269  lse:.        pri
-00001f70: 6e74 2873 290a 2020 2020 2020 2020 7265  nt(s).        re
-00001f80: 7475 726e 204e 6f6e 650a 0a0a 4063 6f6e  turn None...@con
-00001f90: 662e 636f 6d6d 616e 6473 2e72 6567 6973  f.commands.regis
-00001fa0: 7465 720a 6465 6620 6c69 6e65 6865 7864  ter.def linehexd
-00001fb0: 756d 7028 702c 206f 6e6c 7961 7363 3d30  ump(p, onlyasc=0
-00001fc0: 2c20 6f6e 6c79 6865 783d 302c 2064 756d  , onlyhex=0, dum
-00001fd0: 703d 4661 6c73 6529 3a0a 2020 2020 2320  p=False):.    # 
-00001fe0: 7479 7065 3a20 2855 6e69 6f6e 5b50 6163  type: (Union[Pac
-00001ff0: 6b65 742c 2041 6e79 5374 725d 2c20 696e  ket, AnyStr], in
-00002000: 742c 2069 6e74 2c20 626f 6f6c 2920 2d3e  t, int, bool) ->
-00002010: 204f 7074 696f 6e61 6c5b 7374 725d 0a20   Optional[str]. 
-00002020: 2020 2022 2222 4275 696c 6420 616e 2065     """Build an e
-00002030: 7175 6976 616c 656e 7420 7669 6577 206f  quivalent view o
-00002040: 6620 6865 7864 756d 7028 2920 6f6e 2061  f hexdump() on a
-00002050: 2073 696e 676c 6520 6c69 6e65 0a0a 2020   single line..  
-00002060: 2020 4e6f 7465 2074 6861 7420 7365 7474    Note that sett
-00002070: 696e 6720 626f 7468 206f 6e6c 7961 7363  ing both onlyasc
-00002080: 2061 6e64 206f 6e6c 7968 6578 2074 6f20   and onlyhex to 
-00002090: 3120 7265 7375 6c74 7320 696e 2061 2065  1 results in a e
-000020a0: 6d70 7479 206f 7574 7075 740a 0a20 2020  mpty output..   
-000020b0: 203a 7061 7261 6d20 703a 2061 2050 6163   :param p: a Pac
-000020c0: 6b65 740a 2020 2020 3a70 6172 616d 206f  ket.    :param o
-000020d0: 6e6c 7961 7363 3a20 3120 746f 2064 6973  nlyasc: 1 to dis
-000020e0: 706c 6179 206f 6e6c 7920 7468 6520 6173  play only the as
-000020f0: 6369 6920 7669 6577 0a20 2020 203a 7061  cii view.    :pa
-00002100: 7261 6d20 6f6e 6c79 6865 783a 2031 2074  ram onlyhex: 1 t
-00002110: 6f20 6469 7370 6c61 7920 6f6e 6c79 2074  o display only t
-00002120: 6865 2068 6578 6164 6563 696d 616c 2076  he hexadecimal v
-00002130: 6965 770a 2020 2020 3a70 6172 616d 2064  iew.    :param d
-00002140: 756d 703a 2070 7269 6e74 2074 6865 2076  ump: print the v
-00002150: 6965 7720 6966 2046 616c 7365 0a20 2020  iew if False.   
-00002160: 203a 7265 7475 726e 3a20 6120 5374 7269   :return: a Stri
-00002170: 6e67 206f 6e6c 7920 7768 656e 2064 756d  ng only when dum
-00002180: 703d 5472 7565 0a20 2020 2022 2222 0a20  p=True.    """. 
-00002190: 2020 2073 203d 2022 220a 2020 2020 7320     s = "".    s 
-000021a0: 3d20 6865 7873 7472 2870 2c20 6f6e 6c79  = hexstr(p, only
-000021b0: 6173 633d 6f6e 6c79 6173 632c 206f 6e6c  asc=onlyasc, onl
-000021c0: 7968 6578 3d6f 6e6c 7968 6578 2c20 636f  yhex=onlyhex, co
-000021d0: 6c6f 723d 6e6f 7420 6475 6d70 290a 2020  lor=not dump).  
-000021e0: 2020 6966 2064 756d 703a 0a20 2020 2020    if dump:.     
-000021f0: 2020 2072 6574 7572 6e20 730a 2020 2020     return s.    
-00002200: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
-00002210: 696e 7428 7329 0a20 2020 2020 2020 2072  int(s).        r
-00002220: 6574 7572 6e20 4e6f 6e65 0a0a 0a40 636f  eturn None...@co
-00002230: 6e66 2e63 6f6d 6d61 6e64 732e 7265 6769  nf.commands.regi
-00002240: 7374 6572 0a64 6566 2063 6865 7864 756d  ster.def chexdum
-00002250: 7028 702c 2064 756d 703d 4661 6c73 6529  p(p, dump=False)
-00002260: 3a0a 2020 2020 2320 7479 7065 3a20 2855  :.    # type: (U
-00002270: 6e69 6f6e 5b50 6163 6b65 742c 2041 6e79  nion[Packet, Any
-00002280: 5374 725d 2c20 626f 6f6c 2920 2d3e 204f  Str], bool) -> O
-00002290: 7074 696f 6e61 6c5b 7374 725d 0a20 2020  ptional[str].   
-000022a0: 2022 2222 4275 696c 6420 6120 7065 7220   """Build a per 
-000022b0: 6279 7465 2068 6578 6164 6563 696d 616c  byte hexadecimal
-000022c0: 2072 6570 7265 7365 6e74 6174 696f 6e0a   representation.
-000022d0: 0a20 2020 2045 7861 6d70 6c65 3a0a 2020  .    Example:.  
-000022e0: 2020 2020 2020 3e3e 3e20 6368 6578 6475        >>> chexdu
-000022f0: 6d70 2849 5028 2929 0a20 2020 2020 2020  mp(IP()).       
-00002300: 2030 7834 352c 2030 7830 302c 2030 7830   0x45, 0x00, 0x0
-00002310: 302c 2030 7831 342c 2030 7830 302c 2030  0, 0x14, 0x00, 0
-00002320: 7830 312c 2030 7830 302c 2030 7830 302c  x01, 0x00, 0x00,
-00002330: 2030 7834 302c 2030 7830 302c 2030 7837   0x40, 0x00, 0x7
-00002340: 632c 2030 7865 372c 2030 7837 662c 2030  c, 0xe7, 0x7f, 0
-00002350: 7830 302c 2030 7830 302c 2030 7830 312c  x00, 0x00, 0x01,
-00002360: 2030 7837 662c 2030 7830 302c 2030 7830   0x7f, 0x00, 0x0
-00002370: 302c 2030 7830 3120 2023 206e 6f71 613a  0, 0x01  # noqa:
-00002380: 2045 3530 310a 0a20 2020 203a 7061 7261   E501..    :para
-00002390: 6d20 703a 2061 2050 6163 6b65 740a 2020  m p: a Packet.  
-000023a0: 2020 3a70 6172 616d 2064 756d 703a 2070    :param dump: p
-000023b0: 7269 6e74 2074 6865 2076 6965 7720 6966  rint the view if
-000023c0: 2046 616c 7365 0a20 2020 203a 7265 7475   False.    :retu
-000023d0: 726e 3a20 6120 5374 7269 6e67 206f 6e6c  rn: a String onl
-000023e0: 7920 6966 2064 756d 703d 5472 7565 0a20  y if dump=True. 
-000023f0: 2020 2022 2222 0a20 2020 2078 203d 2062     """.    x = b
-00002400: 7974 6573 5f65 6e63 6f64 6528 7029 0a20  ytes_encode(p). 
-00002410: 2020 2073 203d 2022 2c20 222e 6a6f 696e     s = ", ".join
-00002420: 2822 2523 3034 7822 2025 206f 7262 2878  ("%#04x" % orb(x
-00002430: 2920 666f 7220 7820 696e 2078 290a 2020  ) for x in x).  
-00002440: 2020 6966 2064 756d 703a 0a20 2020 2020    if dump:.     
-00002450: 2020 2072 6574 7572 6e20 730a 2020 2020     return s.    
-00002460: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
-00002470: 696e 7428 7329 0a20 2020 2020 2020 2072  int(s).        r
-00002480: 6574 7572 6e20 4e6f 6e65 0a0a 0a40 636f  eturn None...@co
-00002490: 6e66 2e63 6f6d 6d61 6e64 732e 7265 6769  nf.commands.regi
-000024a0: 7374 6572 0a64 6566 2068 6578 7374 7228  ster.def hexstr(
-000024b0: 702c 206f 6e6c 7961 7363 3d30 2c20 6f6e  p, onlyasc=0, on
-000024c0: 6c79 6865 783d 302c 2063 6f6c 6f72 3d46  lyhex=0, color=F
-000024d0: 616c 7365 293a 0a20 2020 2023 2074 7970  alse):.    # typ
-000024e0: 653a 2028 556e 696f 6e5b 5061 636b 6574  e: (Union[Packet
-000024f0: 2c20 416e 7953 7472 5d2c 2069 6e74 2c20  , AnyStr], int, 
-00002500: 696e 742c 2062 6f6f 6c29 202d 3e20 7374  int, bool) -> st
-00002510: 720a 2020 2020 2222 2242 7569 6c64 2061  r.    """Build a
-00002520: 2066 616e 6379 2074 6370 6475 6d70 206c   fancy tcpdump l
-00002530: 696b 6520 6865 7820 6672 6f6d 2062 7974  ike hex from byt
-00002540: 6573 2e22 2222 0a20 2020 2078 203d 2062  es.""".    x = b
-00002550: 7974 6573 5f65 6e63 6f64 6528 7029 0a20  ytes_encode(p). 
-00002560: 2020 2073 203d 205b 5d0a 2020 2020 6966     s = [].    if
-00002570: 206e 6f74 206f 6e6c 7961 7363 3a0a 2020   not onlyasc:.  
-00002580: 2020 2020 2020 732e 6170 7065 6e64 2822        s.append("
-00002590: 2022 2e6a 6f69 6e28 2225 3032 5822 2025   ".join("%02X" %
-000025a0: 206f 7262 2862 2920 666f 7220 6220 696e   orb(b) for b in
-000025b0: 2078 2929 0a20 2020 2069 6620 6e6f 7420   x)).    if not 
-000025c0: 6f6e 6c79 6865 783a 0a20 2020 2020 2020  onlyhex:.       
-000025d0: 2073 2e61 7070 656e 6428 7361 6e65 2878   s.append(sane(x
-000025e0: 2c20 636f 6c6f 723d 636f 6c6f 7229 290a  , color=color)).
-000025f0: 2020 2020 7265 7475 726e 2022 2020 222e      return "  ".
-00002600: 6a6f 696e 2873 290a 0a0a 6465 6620 7265  join(s)...def re
-00002610: 7072 5f68 6578 2873 293a 0a20 2020 2023  pr_hex(s):.    #
-00002620: 2074 7970 653a 2028 6279 7465 7329 202d   type: (bytes) -
-00002630: 3e20 7374 720a 2020 2020 2222 2220 436f  > str.    """ Co
-00002640: 6e76 6572 7420 7072 6f76 6964 6564 2062  nvert provided b
-00002650: 6974 7374 7269 6e67 2074 6f20 6120 7369  itstring to a si
-00002660: 6d70 6c65 2073 7472 696e 6720 6f66 2068  mple string of h
-00002670: 6578 2064 6967 6974 7320 2222 220a 2020  ex digits """.  
-00002680: 2020 7265 7475 726e 2022 222e 6a6f 696e    return "".join
-00002690: 2822 2530 3278 2220 2520 6f72 6228 7829  ("%02x" % orb(x)
-000026a0: 2066 6f72 2078 2069 6e20 7329 0a0a 0a40   for x in s)...@
-000026b0: 636f 6e66 2e63 6f6d 6d61 6e64 732e 7265  conf.commands.re
-000026c0: 6769 7374 6572 0a64 6566 2068 6578 6469  gister.def hexdi
-000026d0: 6666 2861 2c20 622c 2061 7574 6f6a 756e  ff(a, b, autojun
-000026e0: 6b3d 4661 6c73 6529 3a0a 2020 2020 2320  k=False):.    # 
-000026f0: 7479 7065 3a20 2855 6e69 6f6e 5b50 6163  type: (Union[Pac
-00002700: 6b65 742c 2041 6e79 5374 725d 2c20 556e  ket, AnyStr], Un
-00002710: 696f 6e5b 5061 636b 6574 2c20 416e 7953  ion[Packet, AnyS
-00002720: 7472 5d2c 2062 6f6f 6c29 202d 3e20 4e6f  tr], bool) -> No
-00002730: 6e65 0a20 2020 2022 2222 0a20 2020 2053  ne.    """.    S
-00002740: 686f 7720 6469 6666 6572 656e 6365 7320  how differences 
-00002750: 6265 7477 6565 6e20 3220 6269 6e61 7279  between 2 binary
-00002760: 2073 7472 696e 6773 2c20 5061 636b 6574   strings, Packet
-00002770: 732e 2e2e 0a0a 2020 2020 466f 7220 7468  s.....    For th
-00002780: 6520 6175 746f 6a75 6e6b 2070 6172 616d  e autojunk param
-00002790: 6574 6572 2c20 7365 650a 2020 2020 6874  eter, see.    ht
-000027a0: 7470 733a 2f2f 646f 6373 2e70 7974 686f  tps://docs.pytho
-000027b0: 6e2e 6f72 672f 332e 382f 6c69 6272 6172  n.org/3.8/librar
-000027c0: 792f 6469 6666 6c69 622e 6874 6d6c 2364  y/difflib.html#d
-000027d0: 6966 666c 6962 2e53 6571 7565 6e63 654d  ifflib.SequenceM
-000027e0: 6174 6368 6572 0a0a 2020 2020 3a70 6172  atcher..    :par
-000027f0: 616d 2061 3a0a 2020 2020 3a70 6172 616d  am a:.    :param
-00002800: 2062 3a20 5468 6520 6269 6e61 7279 2073   b: The binary s
-00002810: 7472 696e 6773 2c20 7061 636b 6574 732e  trings, packets.
-00002820: 2e2e 2074 6f20 636f 6d70 6172 650a 2020  .. to compare.  
-00002830: 2020 3a70 6172 616d 2061 7574 6f6a 756e    :param autojun
-00002840: 6b3a 2053 6574 7469 6e67 2069 7420 746f  k: Setting it to
-00002850: 2054 7275 6520 7769 6c6c 206c 696b 656c   True will likel
-00002860: 7920 696e 6372 6561 7365 2074 6865 2063  y increase the c
-00002870: 6f6d 7061 7269 736f 6e0a 2020 2020 2020  omparison.      
-00002880: 2020 7370 6565 6420 6120 6c6f 7420 6f6e    speed a lot on
-00002890: 2062 6967 2062 7974 6520 7374 7269 6e67   big byte string
-000028a0: 732c 2062 7574 2077 696c 6c20 7265 6475  s, but will redu
-000028b0: 6365 2061 6363 7572 6163 7920 2877 696c  ce accuracy (wil
-000028c0: 6c20 7465 6e64 0a20 2020 2020 2020 2074  l tend.        t
-000028d0: 6f20 6d69 7373 2069 6e73 6572 7469 6f6e  o miss insertion
-000028e0: 2061 6e64 2073 6565 2072 6570 6c61 6365   and see replace
-000028f0: 6d65 6e74 7320 696e 7374 6561 6420 666f  ments instead fo
-00002900: 7220 696e 7374 616e 6365 292e 0a20 2020  r instance)..   
-00002910: 2022 2222 0a0a 2020 2020 2320 436f 6d70   """..    # Comp
-00002920: 6172 6520 7468 6520 7374 7269 6e67 7320  are the strings 
-00002930: 7573 696e 6720 6469 6666 6c69 620a 0a20  using difflib.. 
-00002940: 2020 2078 6220 3d20 6279 7465 735f 656e     xb = bytes_en
-00002950: 636f 6465 2861 290a 2020 2020 7962 203d  code(a).    yb =
-00002960: 2062 7974 6573 5f65 6e63 6f64 6528 6229   bytes_encode(b)
-00002970: 0a0a 2020 2020 736d 203d 2064 6966 666c  ..    sm = diffl
-00002980: 6962 2e53 6571 7565 6e63 654d 6174 6368  ib.SequenceMatch
-00002990: 6572 2861 3d78 622c 2062 3d79 622c 2061  er(a=xb, b=yb, a
-000029a0: 7574 6f6a 756e 6b3d 6175 746f 6a75 6e6b  utojunk=autojunk
-000029b0: 290a 2020 2020 7861 7272 203d 205b 7862  ).    xarr = [xb
-000029c0: 5b69 3a69 202b 2031 5d20 666f 7220 6920  [i:i + 1] for i 
-000029d0: 696e 2072 616e 6765 286c 656e 2878 6229  in range(len(xb)
-000029e0: 295d 0a20 2020 2079 6172 7220 3d20 5b79  )].    yarr = [y
-000029f0: 625b 693a 6920 2b20 315d 2066 6f72 2069  b[i:i + 1] for i
-00002a00: 2069 6e20 7261 6e67 6528 6c65 6e28 7962   in range(len(yb
-00002a10: 2929 5d0a 0a20 2020 2062 6163 6b74 7261  ))]..    backtra
-00002a20: 636b 7820 3d20 5b5d 0a20 2020 2062 6163  ckx = [].    bac
-00002a30: 6b74 7261 636b 7920 3d20 5b5d 0a20 2020  ktracky = [].   
-00002a40: 2066 6f72 206f 7063 6f64 6520 696e 2073   for opcode in s
-00002a50: 6d2e 6765 745f 6f70 636f 6465 7328 293a  m.get_opcodes():
-00002a60: 0a20 2020 2020 2020 2074 7970 2c20 7830  .        typ, x0
-00002a70: 2c20 7831 2c20 7930 2c20 7931 203d 206f  , x1, y0, y1 = o
-00002a80: 7063 6f64 650a 2020 2020 2020 2020 6966  pcode.        if
-00002a90: 2074 7970 203d 3d20 2764 656c 6574 6527   typ == 'delete'
-00002aa0: 3a0a 2020 2020 2020 2020 2020 2020 6261  :.            ba
-00002ab0: 636b 7472 6163 6b78 202b 3d20 7861 7272  cktrackx += xarr
-00002ac0: 5b78 303a 7831 5d0a 2020 2020 2020 2020  [x0:x1].        
-00002ad0: 2020 2020 6261 636b 7472 6163 6b79 202b      backtracky +
-00002ae0: 3d20 5b62 2727 5d20 2a20 2878 3120 2d20  = [b''] * (x1 - 
-00002af0: 7830 290a 2020 2020 2020 2020 656c 6966  x0).        elif
-00002b00: 2074 7970 203d 3d20 2769 6e73 6572 7427   typ == 'insert'
-00002b10: 3a0a 2020 2020 2020 2020 2020 2020 6261  :.            ba
-00002b20: 636b 7472 6163 6b78 202b 3d20 5b62 2727  cktrackx += [b''
-00002b30: 5d20 2a20 2879 3120 2d20 7930 290a 2020  ] * (y1 - y0).  
-00002b40: 2020 2020 2020 2020 2020 6261 636b 7472            backtr
-00002b50: 6163 6b79 202b 3d20 7961 7272 5b79 303a  acky += yarr[y0:
-00002b60: 7931 5d0a 2020 2020 2020 2020 656c 6966  y1].        elif
-00002b70: 2074 7970 2069 6e20 5b27 6571 7561 6c27   typ in ['equal'
-00002b80: 2c20 2772 6570 6c61 6365 275d 3a0a 2020  , 'replace']:.  
-00002b90: 2020 2020 2020 2020 2020 6261 636b 7472            backtr
-00002ba0: 6163 6b78 202b 3d20 7861 7272 5b78 303a  ackx += xarr[x0:
-00002bb0: 7831 5d0a 2020 2020 2020 2020 2020 2020  x1].            
-00002bc0: 6261 636b 7472 6163 6b79 202b 3d20 7961  backtracky += ya
-00002bd0: 7272 5b79 303a 7931 5d0a 0a20 2020 2069  rr[y0:y1]..    i
-00002be0: 6620 6175 746f 6a75 6e6b 3a0a 2020 2020  f autojunk:.    
-00002bf0: 2020 2020 2320 536f 6d65 206c 696e 6573      # Some lines
-00002c00: 206d 6179 2068 6176 6520 6265 656e 2063   may have been c
-00002c10: 6f6e 7369 6465 7265 6420 6173 206a 756e  onsidered as jun
-00002c20: 6b2e 2043 6865 636b 2074 6865 2073 697a  k. Check the siz
-00002c30: 6573 0a20 2020 2020 2020 206c 6278 203d  es.        lbx =
-00002c40: 206c 656e 2862 6163 6b74 7261 636b 7829   len(backtrackx)
-00002c50: 0a20 2020 2020 2020 206c 6279 203d 206c  .        lby = l
-00002c60: 656e 2862 6163 6b74 7261 636b 7929 0a20  en(backtracky). 
-00002c70: 2020 2020 2020 2062 6163 6b74 7261 636b         backtrack
-00002c80: 7820 2b3d 205b 6227 275d 202a 2028 6d61  x += [b''] * (ma
-00002c90: 7828 6c62 782c 206c 6279 2920 2d20 6c62  x(lbx, lby) - lb
-00002ca0: 7829 0a20 2020 2020 2020 2062 6163 6b74  x).        backt
-00002cb0: 7261 636b 7920 2b3d 205b 6227 275d 202a  racky += [b''] *
-00002cc0: 2028 6d61 7828 6c62 782c 206c 6279 2920   (max(lbx, lby) 
-00002cd0: 2d20 6c62 7929 0a0a 2020 2020 2320 5072  - lby)..    # Pr
-00002ce0: 696e 7420 7468 6520 6469 6666 0a0a 2020  int the diff..  
-00002cf0: 2020 7820 3d20 7920 3d20 6920 3d20 300a    x = y = i = 0.
-00002d00: 2020 2020 636f 6c6f 7269 7a65 203d 207b      colorize = {
-00002d10: 303a 206c 616d 6264 6120 783a 2078 2c0a  0: lambda x: x,.
-00002d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d30: 2d31 3a20 636f 6e66 2e63 6f6c 6f72 5f74  -1: conf.color_t
-00002d40: 6865 6d65 2e6c 6566 742c 0a20 2020 2020  heme.left,.     
-00002d50: 2020 2020 2020 2020 2020 2031 3a20 636f             1: co
-00002d60: 6e66 2e63 6f6c 6f72 5f74 6865 6d65 2e72  nf.color_theme.r
-00002d70: 6967 6874 7d0a 0a20 2020 2064 6f78 203d  ight}..    dox =
-00002d80: 2031 0a20 2020 2064 6f79 203d 2030 0a20   1.    doy = 0. 
-00002d90: 2020 2062 7478 5f6c 656e 203d 206c 656e     btx_len = len
-00002da0: 2862 6163 6b74 7261 636b 7829 0a20 2020  (backtrackx).   
-00002db0: 2077 6869 6c65 2069 203c 2062 7478 5f6c   while i < btx_l
-00002dc0: 656e 3a0a 2020 2020 2020 2020 6c69 6e65  en:.        line
-00002dd0: 7820 3d20 6261 636b 7472 6163 6b78 5b69  x = backtrackx[i
-00002de0: 3a69 202b 2031 365d 0a20 2020 2020 2020  :i + 16].       
-00002df0: 206c 696e 6579 203d 2062 6163 6b74 7261   liney = backtra
-00002e00: 636b 795b 693a 6920 2b20 3136 5d0a 2020  cky[i:i + 16].  
-00002e10: 2020 2020 2020 7878 203d 2073 756d 286c        xx = sum(l
-00002e20: 656e 286b 2920 666f 7220 6b20 696e 206c  en(k) for k in l
-00002e30: 696e 6578 290a 2020 2020 2020 2020 7979  inex).        yy
-00002e40: 203d 2073 756d 286c 656e 286b 2920 666f   = sum(len(k) fo
-00002e50: 7220 6b20 696e 206c 696e 6579 290a 2020  r k in liney).  
-00002e60: 2020 2020 2020 6966 2064 6f78 2061 6e64        if dox and
-00002e70: 206e 6f74 2078 783a 0a20 2020 2020 2020   not xx:.       
-00002e80: 2020 2020 2064 6f78 203d 2030 0a20 2020       dox = 0.   
-00002e90: 2020 2020 2020 2020 2064 6f79 203d 2031           doy = 1
-00002ea0: 0a20 2020 2020 2020 2069 6620 646f 7820  .        if dox 
-00002eb0: 616e 6420 6c69 6e65 7820 3d3d 206c 696e  and linex == lin
-00002ec0: 6579 3a0a 2020 2020 2020 2020 2020 2020  ey:.            
-00002ed0: 646f 7920 3d20 310a 0a20 2020 2020 2020  doy = 1..       
-00002ee0: 2069 6620 646f 783a 0a20 2020 2020 2020   if dox:.       
-00002ef0: 2020 2020 2078 6420 3d20 790a 2020 2020       xd = y.    
-00002f00: 2020 2020 2020 2020 6a20 3d20 300a 2020          j = 0.  
-00002f10: 2020 2020 2020 2020 2020 7768 696c 6520            while 
-00002f20: 6e6f 7420 6c69 6e65 785b 6a5d 3a0a 2020  not linex[j]:.  
-00002f30: 2020 2020 2020 2020 2020 2020 2020 6a20                j 
-00002f40: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
-00002f50: 2020 2020 2078 6420 2d3d 2031 0a20 2020       xd -= 1.   
-00002f60: 2020 2020 2020 2020 2070 7269 6e74 2863           print(c
-00002f70: 6f6c 6f72 697a 655b 646f 7920 2d20 646f  olorize[doy - do
-00002f80: 785d 2822 2530 3478 2220 2520 7864 292c  x]("%04x" % xd),
-00002f90: 2065 6e64 3d27 2027 290a 2020 2020 2020   end=' ').      
-00002fa0: 2020 2020 2020 7820 2b3d 2078 780a 2020        x += xx.  
-00002fb0: 2020 2020 2020 2020 2020 6c69 6e65 203d            line =
-00002fc0: 206c 696e 6578 0a20 2020 2020 2020 2065   linex.        e
-00002fd0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00002fe0: 2070 7269 6e74 2822 2020 2020 222c 2065   print("    ", e
-00002ff0: 6e64 3d27 2027 290a 2020 2020 2020 2020  nd=' ').        
-00003000: 6966 2064 6f79 3a0a 2020 2020 2020 2020  if doy:.        
-00003010: 2020 2020 7964 203d 2079 0a20 2020 2020      yd = y.     
-00003020: 2020 2020 2020 206a 203d 2030 0a20 2020         j = 0.   
-00003030: 2020 2020 2020 2020 2077 6869 6c65 206e           while n
-00003040: 6f74 206c 696e 6579 5b6a 5d3a 0a20 2020  ot liney[j]:.   
-00003050: 2020 2020 2020 2020 2020 2020 206a 202b               j +
-00003060: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
-00003070: 2020 2020 7964 202d 3d20 310a 2020 2020      yd -= 1.    
-00003080: 2020 2020 2020 2020 7072 696e 7428 636f          print(co
-00003090: 6c6f 7269 7a65 5b64 6f79 202d 2064 6f78  lorize[doy - dox
-000030a0: 5d28 2225 3034 7822 2025 2079 6429 2c20  ]("%04x" % yd), 
-000030b0: 656e 643d 2720 2729 0a20 2020 2020 2020  end=' ').       
-000030c0: 2020 2020 2079 202b 3d20 7979 0a20 2020       y += yy.   
-000030d0: 2020 2020 2020 2020 206c 696e 6520 3d20           line = 
-000030e0: 6c69 6e65 790a 2020 2020 2020 2020 656c  liney.        el
-000030f0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00003100: 7072 696e 7428 2220 2020 2022 2c20 656e  print("    ", en
-00003110: 643d 2720 2729 0a0a 2020 2020 2020 2020  d=' ')..        
-00003120: 7072 696e 7428 2220 222c 2065 6e64 3d27  print(" ", end='
-00003130: 2027 290a 0a20 2020 2020 2020 2063 6c20   ')..        cl 
-00003140: 3d20 2222 0a20 2020 2020 2020 2066 6f72  = "".        for
-00003150: 206a 2069 6e20 7261 6e67 6528 3136 293a   j in range(16):
-00003160: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00003170: 6920 2b20 6a20 3c20 6274 785f 6c65 6e3a  i + j < btx_len:
-00003180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003190: 2069 6620 6c69 6e65 5b6a 5d3a 0a20 2020   if line[j]:.   
-000031a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000031b0: 2063 6f6c 203d 2063 6f6c 6f72 697a 655b   col = colorize[
-000031c0: 286c 696e 6578 5b6a 5d20 213d 206c 696e  (linex[j] != lin
-000031d0: 6579 5b6a 5d29 202a 2028 646f 7920 2d20  ey[j]) * (doy - 
-000031e0: 646f 7829 5d0a 2020 2020 2020 2020 2020  dox)].          
-000031f0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-00003200: 636f 6c28 2225 3032 5822 2025 206f 7262  col("%02X" % orb
-00003210: 286c 696e 655b 6a5d 2929 2c20 656e 643d  (line[j])), end=
-00003220: 2720 2729 0a20 2020 2020 2020 2020 2020  ' ').           
-00003230: 2020 2020 2020 2020 2069 6620 6c69 6e65           if line
-00003240: 785b 6a5d 203d 3d20 6c69 6e65 795b 6a5d  x[j] == liney[j]
-00003250: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00003260: 2020 2020 2020 2020 2020 636c 202b 3d20            cl += 
-00003270: 7361 6e65 286c 696e 655b 6a5d 2c20 636f  sane(line[j], co
-00003280: 6c6f 723d 5472 7565 290a 2020 2020 2020  lor=True).      
-00003290: 2020 2020 2020 2020 2020 2020 2020 656c                el
-000032a0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000032b0: 2020 2020 2020 2020 2020 2020 636c 202b              cl +
-000032c0: 3d20 636f 6c28 7361 6e65 286c 696e 655b  = col(sane(line[
-000032d0: 6a5d 2929 0a20 2020 2020 2020 2020 2020  j])).           
-000032e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000032f0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00003300: 7269 6e74 2822 2020 222c 2065 6e64 3d27  rint("  ", end='
-00003310: 2027 290a 2020 2020 2020 2020 2020 2020   ').            
-00003320: 2020 2020 2020 2020 636c 202b 3d20 2220          cl += " 
-00003330: 220a 2020 2020 2020 2020 2020 2020 656c  ".            el
-00003340: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00003350: 2020 2020 7072 696e 7428 2220 2022 2c20      print("  ", 
-00003360: 656e 643d 2720 2729 0a20 2020 2020 2020  end=' ').       
-00003370: 2020 2020 2069 6620 6a20 3d3d 2037 3a0a       if j == 7:.
-00003380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003390: 7072 696e 7428 2222 2c20 656e 643d 2720  print("", end=' 
-000033a0: 2729 0a0a 2020 2020 2020 2020 7072 696e  ')..        prin
-000033b0: 7428 2220 222c 2063 6c29 0a0a 2020 2020  t(" ", cl)..    
-000033c0: 2020 2020 6966 2064 6f79 206f 7220 6e6f      if doy or no
-000033d0: 7420 7979 3a0a 2020 2020 2020 2020 2020  t yy:.          
-000033e0: 2020 646f 7920 3d20 300a 2020 2020 2020    doy = 0.      
-000033f0: 2020 2020 2020 646f 7820 3d20 310a 2020        dox = 1.  
-00003400: 2020 2020 2020 2020 2020 6920 2b3d 2031            i += 1
-00003410: 360a 2020 2020 2020 2020 656c 7365 3a0a  6.        else:.
-00003420: 2020 2020 2020 2020 2020 2020 6966 2079              if y
-00003430: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
-00003440: 2020 2064 6f78 203d 2030 0a20 2020 2020     dox = 0.     
-00003450: 2020 2020 2020 2020 2020 2064 6f79 203d             doy =
-00003460: 2031 0a20 2020 2020 2020 2020 2020 2065   1.            e
-00003470: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00003480: 2020 2020 2069 202b 3d20 3136 0a0a 0a69       i += 16...i
-00003490: 6620 7374 7275 6374 2e70 6163 6b28 2248  f struct.pack("H
-000034a0: 222c 2031 2920 3d3d 2062 225c 7830 305c  ", 1) == b"\x00\
-000034b0: 7830 3122 3a20 2023 2062 6967 2065 6e64  x01":  # big end
-000034c0: 6961 6e0a 2020 2020 6368 6563 6b73 756d  ian.    checksum
-000034d0: 5f65 6e64 6961 6e5f 7472 616e 7366 6f72  _endian_transfor
-000034e0: 6d20 3d20 6c61 6d62 6461 2063 686b 3a20  m = lambda chk: 
-000034f0: 6368 6b20 2023 2074 7970 653a 2043 616c  chk  # type: Cal
-00003500: 6c61 626c 655b 5b69 6e74 5d2c 2069 6e74  lable[[int], int
-00003510: 5d0a 656c 7365 3a0a 2020 2020 6368 6563  ].else:.    chec
-00003520: 6b73 756d 5f65 6e64 6961 6e5f 7472 616e  ksum_endian_tran
-00003530: 7366 6f72 6d20 3d20 6c61 6d62 6461 2063  sform = lambda c
-00003540: 686b 3a20 2828 6368 6b20 3e3e 2038 2920  hk: ((chk >> 8) 
-00003550: 2620 3078 6666 2920 7c20 6368 6b20 3c3c  & 0xff) | chk <<
-00003560: 2038 0a0a 0a64 6566 2063 6865 636b 7375   8...def checksu
-00003570: 6d28 706b 7429 3a0a 2020 2020 2320 7479  m(pkt):.    # ty
-00003580: 7065 3a20 2862 7974 6573 2920 2d3e 2069  pe: (bytes) -> i
-00003590: 6e74 0a20 2020 2069 6620 6c65 6e28 706b  nt.    if len(pk
-000035a0: 7429 2025 2032 203d 3d20 313a 0a20 2020  t) % 2 == 1:.   
-000035b0: 2020 2020 2070 6b74 202b 3d20 6222 5c30       pkt += b"\0
-000035c0: 220a 2020 2020 7320 3d20 7375 6d28 6172  ".    s = sum(ar
-000035d0: 7261 792e 6172 7261 7928 2248 222c 2070  ray.array("H", p
-000035e0: 6b74 2929 0a20 2020 2073 203d 2028 7320  kt)).    s = (s 
-000035f0: 3e3e 2031 3629 202b 2028 7320 2620 3078  >> 16) + (s & 0x
-00003600: 6666 6666 290a 2020 2020 7320 2b3d 2073  ffff).    s += s
-00003610: 203e 3e20 3136 0a20 2020 2073 203d 207e   >> 16.    s = ~
-00003620: 730a 2020 2020 7265 7475 726e 2063 6865  s.    return che
-00003630: 636b 7375 6d5f 656e 6469 616e 5f74 7261  cksum_endian_tra
-00003640: 6e73 666f 726d 2873 2920 2620 3078 6666  nsform(s) & 0xff
-00003650: 6666 0a0a 0a64 6566 205f 666c 6574 6368  ff...def _fletch
-00003660: 6572 3136 2863 6861 7262 7566 293a 0a20  er16(charbuf):. 
-00003670: 2020 2023 2074 7970 653a 2028 6279 7465     # type: (byte
-00003680: 7329 202d 3e20 5475 706c 655b 696e 742c  s) -> Tuple[int,
-00003690: 2069 6e74 5d0a 2020 2020 2320 5468 6973   int].    # This
-000036a0: 2069 7320 6261 7365 6420 6f6e 2074 6865   is based on the
-000036b0: 2047 504c 6564 2043 2069 6d70 6c65 6d65   GPLed C impleme
-000036c0: 6e74 6174 696f 6e20 696e 205a 6562 7261  ntation in Zebra
-000036d0: 203c 6874 7470 3a2f 2f77 7777 2e7a 6562   <http://www.zeb
-000036e0: 7261 2e6f 7267 2f3e 2020 2320 6e6f 7161  ra.org/>  # noqa
-000036f0: 3a20 4535 3031 0a20 2020 2063 3020 3d20  : E501.    c0 = 
-00003700: 6331 203d 2030 0a20 2020 2066 6f72 2063  c1 = 0.    for c
-00003710: 6861 7220 696e 2063 6861 7262 7566 3a0a  har in charbuf:.
-00003720: 2020 2020 2020 2020 6330 202b 3d20 6f72          c0 += or
-00003730: 6228 6368 6172 290a 2020 2020 2020 2020  b(char).        
-00003740: 6331 202b 3d20 6330 0a0a 2020 2020 6330  c1 += c0..    c0
-00003750: 2025 3d20 3235 350a 2020 2020 6331 2025   %= 255.    c1 %
-00003760: 3d20 3235 350a 2020 2020 7265 7475 726e  = 255.    return
-00003770: 2028 6330 2c20 6331 290a 0a0a 4063 6f6e   (c0, c1)...@con
-00003780: 662e 636f 6d6d 616e 6473 2e72 6567 6973  f.commands.regis
-00003790: 7465 720a 6465 6620 666c 6574 6368 6572  ter.def fletcher
-000037a0: 3136 5f63 6865 636b 7375 6d28 6269 6e62  16_checksum(binb
-000037b0: 7566 293a 0a20 2020 2023 2074 7970 653a  uf):.    # type:
-000037c0: 2028 6279 7465 7329 202d 3e20 696e 740a   (bytes) -> int.
-000037d0: 2020 2020 2222 2243 616c 6375 6c61 7465      """Calculate
-000037e0: 7320 466c 6574 6368 6572 2d31 3620 6368  s Fletcher-16 ch
-000037f0: 6563 6b73 756d 206f 6620 7468 6520 6769  ecksum of the gi
-00003800: 7665 6e20 6275 6666 6572 2e0a 0a20 2020  ven buffer...   
-00003810: 2020 2020 4e6f 7465 3a0a 2020 2020 2020      Note:.      
-00003820: 2049 6620 7468 6520 6275 6666 6572 2063   If the buffer c
-00003830: 6f6e 7461 696e 7320 7468 6520 7477 6f20  ontains the two 
-00003840: 6368 6563 6b62 7974 6573 2064 6572 6976  checkbytes deriv
-00003850: 6564 2066 726f 6d20 7468 6520 466c 6574  ed from the Flet
-00003860: 6368 6572 2d31 3620 6368 6563 6b73 756d  cher-16 checksum
-00003870: 2020 2320 6e6f 7161 3a20 4535 3031 0a20    # noqa: E501. 
-00003880: 2020 2020 2020 7468 6520 7265 7375 6c74        the result
-00003890: 206f 6620 7468 6973 2066 756e 6374 696f   of this functio
-000038a0: 6e20 6861 7320 746f 2062 6520 302e 204f  n has to be 0. O
-000038b0: 7468 6572 7769 7365 2074 6865 2062 7566  therwise the buf
-000038c0: 6665 7220 6861 7320 6265 656e 2063 6f72  fer has been cor
-000038d0: 7275 7074 6564 2e20 2023 206e 6f71 613a  rupted.  # noqa:
-000038e0: 2045 3530 310a 2020 2020 2222 220a 2020   E501.    """.  
-000038f0: 2020 2863 302c 2063 3129 203d 205f 666c    (c0, c1) = _fl
-00003900: 6574 6368 6572 3136 2862 696e 6275 6629  etcher16(binbuf)
-00003910: 0a20 2020 2072 6574 7572 6e20 2863 3120  .    return (c1 
-00003920: 3c3c 2038 2920 7c20 6330 0a0a 0a40 636f  << 8) | c0...@co
-00003930: 6e66 2e63 6f6d 6d61 6e64 732e 7265 6769  nf.commands.regi
-00003940: 7374 6572 0a64 6566 2066 6c65 7463 6865  ster.def fletche
-00003950: 7231 365f 6368 6563 6b62 7974 6573 2862  r16_checkbytes(b
-00003960: 696e 6275 662c 206f 6666 7365 7429 3a0a  inbuf, offset):.
-00003970: 2020 2020 2320 7479 7065 3a20 2862 7974      # type: (byt
-00003980: 6573 2c20 696e 7429 202d 3e20 6279 7465  es, int) -> byte
-00003990: 730a 2020 2020 2222 2243 616c 6375 6c61  s.    """Calcula
-000039a0: 7465 7320 7468 6520 466c 6574 6368 6572  tes the Fletcher
-000039b0: 2d31 3620 6368 6563 6b62 7974 6573 2072  -16 checkbytes r
-000039c0: 6574 7572 6e65 6420 6173 2032 2062 7974  eturned as 2 byt
-000039d0: 6520 6269 6e61 7279 2d73 7472 696e 672e  e binary-string.
-000039e0: 0a0a 2020 2020 2020 2049 6e63 6c75 6469  ..       Includi
-000039f0: 6e67 2074 6865 2062 7974 6573 2069 6e74  ng the bytes int
-00003a00: 6f20 7468 6520 6275 6666 6572 2028 6174  o the buffer (at
-00003a10: 2074 6865 2070 6f73 6974 696f 6e20 6d61   the position ma
-00003a20: 726b 6564 2062 7920 6f66 6673 6574 2920  rked by offset) 
-00003a30: 7468 6520 2023 206e 6f71 613a 2045 3530  the  # noqa: E50
-00003a40: 310a 2020 2020 2020 2067 6c6f 6261 6c20  1.       global 
-00003a50: 466c 6574 6368 6572 2d31 3620 6368 6563  Fletcher-16 chec
-00003a60: 6b73 756d 206f 6620 7468 6520 6275 6666  ksum of the buff
-00003a70: 6572 2077 696c 6c20 6265 2030 2e20 5468  er will be 0. Th
-00003a80: 7573 2069 7420 6973 2065 6173 7920 746f  us it is easy to
-00003a90: 2076 6572 6966 7920 2023 206e 6f71 613a   verify  # noqa:
-00003aa0: 2045 3530 310a 2020 2020 2020 2074 6865   E501.       the
-00003ab0: 2069 6e74 6567 7269 7479 206f 6620 7468   integrity of th
-00003ac0: 6520 6275 6666 6572 206f 6e20 7468 6520  e buffer on the 
-00003ad0: 7265 6365 6976 6572 2073 6964 652e 0a0a  receiver side...
-00003ae0: 2020 2020 2020 2046 6f72 2064 6574 6169         For detai
-00003af0: 6c73 206f 6e20 7468 6520 616c 676f 7269  ls on the algori
-00003b00: 7468 6d2c 2073 6565 2052 4643 2032 3332  thm, see RFC 232
-00003b10: 3820 6368 6170 7465 7220 3132 2e31 2e37  8 chapter 12.1.7
-00003b20: 2061 6e64 2052 4643 2039 3035 2041 6e6e   and RFC 905 Ann
-00003b30: 6578 2042 2e20 2023 206e 6f71 613a 2045  ex B.  # noqa: E
-00003b40: 3530 310a 2020 2020 2222 220a 0a20 2020  501.    """..   
-00003b50: 2023 2054 6869 7320 6973 2062 6173 6564   # This is based
-00003b60: 206f 6e20 7468 6520 4750 4c65 6420 4320   on the GPLed C 
-00003b70: 696d 706c 656d 656e 7461 7469 6f6e 2069  implementation i
-00003b80: 6e20 5a65 6272 6120 3c68 7474 703a 2f2f  n Zebra <http://
-00003b90: 7777 772e 7a65 6272 612e 6f72 672f 3e20  www.zebra.org/> 
-00003ba0: 2023 206e 6f71 613a 2045 3530 310a 2020   # noqa: E501.  
-00003bb0: 2020 6966 206c 656e 2862 696e 6275 6629    if len(binbuf)
-00003bc0: 203c 206f 6666 7365 743a 0a20 2020 2020   < offset:.     
-00003bd0: 2020 2072 6169 7365 2045 7863 6570 7469     raise Excepti
-00003be0: 6f6e 2822 5061 636b 6574 2074 6f6f 2073  on("Packet too s
-00003bf0: 686f 7274 2066 6f72 2063 6865 636b 6279  hort for checkby
-00003c00: 7465 7320 2564 2220 2520 6c65 6e28 6269  tes %d" % len(bi
-00003c10: 6e62 7566 2929 0a0a 2020 2020 6269 6e62  nbuf))..    binb
-00003c20: 7566 203d 2062 696e 6275 665b 3a6f 6666  uf = binbuf[:off
-00003c30: 7365 745d 202b 2062 225c 7830 305c 7830  set] + b"\x00\x0
-00003c40: 3022 202b 2062 696e 6275 665b 6f66 6673  0" + binbuf[offs
-00003c50: 6574 202b 2032 3a5d 0a20 2020 2028 6330  et + 2:].    (c0
-00003c60: 2c20 6331 2920 3d20 5f66 6c65 7463 6865  , c1) = _fletche
-00003c70: 7231 3628 6269 6e62 7566 290a 0a20 2020  r16(binbuf)..   
-00003c80: 2078 203d 2028 286c 656e 2862 696e 6275   x = ((len(binbu
-00003c90: 6629 202d 206f 6666 7365 7420 2d20 3129  f) - offset - 1)
-00003ca0: 202a 2063 3020 2d20 6331 2920 2520 3235   * c0 - c1) % 25
-00003cb0: 350a 0a20 2020 2069 6620 2878 203c 3d20  5..    if (x <= 
-00003cc0: 3029 3a0a 2020 2020 2020 2020 7820 2b3d  0):.        x +=
-00003cd0: 2032 3535 0a0a 2020 2020 7920 3d20 3531   255..    y = 51
-00003ce0: 3020 2d20 6330 202d 2078 0a0a 2020 2020  0 - c0 - x..    
-00003cf0: 6966 2028 7920 3e20 3235 3529 3a0a 2020  if (y > 255):.  
-00003d00: 2020 2020 2020 7920 2d3d 2032 3535 0a20        y -= 255. 
-00003d10: 2020 2072 6574 7572 6e20 6368 6228 7829     return chb(x)
-00003d20: 202b 2063 6862 2879 290a 0a0a 6465 6620   + chb(y)...def 
-00003d30: 6d61 6332 7374 7228 6d61 6329 3a0a 2020  mac2str(mac):.  
-00003d40: 2020 2320 7479 7065 3a20 2873 7472 2920    # type: (str) 
-00003d50: 2d3e 2062 7974 6573 0a20 2020 2072 6574  -> bytes.    ret
-00003d60: 7572 6e20 6222 222e 6a6f 696e 2863 6862  urn b"".join(chb
-00003d70: 2869 6e74 2878 2c20 3136 2929 2066 6f72  (int(x, 16)) for
-00003d80: 2078 2069 6e20 706c 6169 6e5f 7374 7228   x in plain_str(
-00003d90: 6d61 6329 2e73 706c 6974 2827 3a27 2929  mac).split(':'))
-00003da0: 0a0a 0a64 6566 2076 616c 6964 5f6d 6163  ...def valid_mac
-00003db0: 286d 6163 293a 0a20 2020 2023 2074 7970  (mac):.    # typ
-00003dc0: 653a 2028 7374 7229 202d 3e20 626f 6f6c  e: (str) -> bool
-00003dd0: 0a20 2020 2074 7279 3a0a 2020 2020 2020  .    try:.      
-00003de0: 2020 7265 7475 726e 206c 656e 286d 6163    return len(mac
-00003df0: 3273 7472 286d 6163 2929 203d 3d20 360a  2str(mac)) == 6.
-00003e00: 2020 2020 6578 6365 7074 2056 616c 7565      except Value
-00003e10: 4572 726f 723a 0a20 2020 2020 2020 2070  Error:.        p
-00003e20: 6173 730a 2020 2020 7265 7475 726e 2046  ass.    return F
-00003e30: 616c 7365 0a0a 0a64 6566 2073 7472 326d  alse...def str2m
-00003e40: 6163 2873 293a 0a20 2020 2023 2074 7970  ac(s):.    # typ
-00003e50: 653a 2028 6279 7465 7329 202d 3e20 7374  e: (bytes) -> st
-00003e60: 720a 2020 2020 6966 2069 7369 6e73 7461  r.    if isinsta
-00003e70: 6e63 6528 732c 2073 7472 293a 0a20 2020  nce(s, str):.   
-00003e80: 2020 2020 2072 6574 7572 6e20 2822 2530       return ("%0
-00003e90: 3278 3a22 202a 206c 656e 2873 2929 5b3a  2x:" * len(s))[:
-00003ea0: 2d31 5d20 2520 7475 706c 6528 6d61 7028  -1] % tuple(map(
-00003eb0: 6f72 642c 2073 2929 0a20 2020 2072 6574  ord, s)).    ret
-00003ec0: 7572 6e20 2822 2530 3278 3a22 202a 206c  urn ("%02x:" * l
-00003ed0: 656e 2873 2929 5b3a 2d31 5d20 2520 7475  en(s))[:-1] % tu
-00003ee0: 706c 6528 7329 0a0a 0a64 6566 2072 616e  ple(s)...def ran
-00003ef0: 6473 7472 696e 6728 6c65 6e67 7468 293a  dstring(length):
-00003f00: 0a20 2020 2023 2074 7970 653a 2028 696e  .    # type: (in
-00003f10: 7429 202d 3e20 6279 7465 730a 2020 2020  t) -> bytes.    
-00003f20: 2222 220a 2020 2020 5265 7475 726e 7320  """.    Returns 
-00003f30: 6120 7261 6e64 6f6d 2073 7472 696e 6720  a random string 
-00003f40: 6f66 206c 656e 6774 6820 286c 656e 6774  of length (lengt
-00003f50: 6820 3e3d 2030 290a 2020 2020 2222 220a  h >= 0).    """.
-00003f60: 2020 2020 7265 7475 726e 2062 2222 2e6a      return b"".j
-00003f70: 6f69 6e28 7374 7275 6374 2e70 6163 6b28  oin(struct.pack(
-00003f80: 2742 272c 2072 616e 646f 6d2e 7261 6e64  'B', random.rand
-00003f90: 696e 7428 302c 2032 3535 2929 0a20 2020  int(0, 255)).   
-00003fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003fb0: 2066 6f72 205f 2069 6e20 7261 6e67 6528   for _ in range(
-00003fc0: 6c65 6e67 7468 2929 0a0a 0a64 6566 207a  length))...def z
-00003fd0: 6572 6f66 7265 655f 7261 6e64 7374 7269  erofree_randstri
-00003fe0: 6e67 286c 656e 6774 6829 3a0a 2020 2020  ng(length):.    
-00003ff0: 2320 7479 7065 3a20 2869 6e74 2920 2d3e  # type: (int) ->
-00004000: 2062 7974 6573 0a20 2020 2022 2222 0a20   bytes.    """. 
-00004010: 2020 2052 6574 7572 6e73 2061 2072 616e     Returns a ran
-00004020: 646f 6d20 7374 7269 6e67 206f 6620 6c65  dom string of le
-00004030: 6e67 7468 2028 6c65 6e67 7468 203e 3d20  ngth (length >= 
-00004040: 3029 2077 6974 686f 7574 207a 6572 6f20  0) without zero 
-00004050: 696e 2069 742e 0a20 2020 2022 2222 0a20  in it..    """. 
-00004060: 2020 2072 6574 7572 6e20 6222 222e 6a6f     return b"".jo
-00004070: 696e 2873 7472 7563 742e 7061 636b 2827  in(struct.pack('
-00004080: 4227 2c20 7261 6e64 6f6d 2e72 616e 6469  B', random.randi
-00004090: 6e74 2831 2c20 3235 3529 290a 2020 2020  nt(1, 255)).    
-000040a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000040b0: 666f 7220 5f20 696e 2072 616e 6765 286c  for _ in range(l
-000040c0: 656e 6774 6829 290a 0a0a 6465 6620 7374  ength))...def st
-000040d0: 7278 6f72 2873 312c 2073 3229 3a0a 2020  rxor(s1, s2):.  
-000040e0: 2020 2320 7479 7065 3a20 2862 7974 6573    # type: (bytes
-000040f0: 2c20 6279 7465 7329 202d 3e20 6279 7465  , bytes) -> byte
-00004100: 730a 2020 2020 2222 220a 2020 2020 5265  s.    """.    Re
-00004110: 7475 726e 7320 7468 6520 6269 6e61 7279  turns the binary
-00004120: 2058 4f52 206f 6620 7468 6520 3220 7072   XOR of the 2 pr
-00004130: 6f76 6964 6564 2073 7472 696e 6773 2073  ovided strings s
-00004140: 3120 616e 6420 7332 2e20 7331 2061 6e64  1 and s2. s1 and
-00004150: 2073 320a 2020 2020 6d75 7374 2062 6520   s2.    must be 
-00004160: 6f66 2073 616d 6520 6c65 6e67 7468 2e0a  of same length..
-00004170: 2020 2020 2222 220a 2020 2020 7265 7475      """.    retu
-00004180: 726e 2062 2222 2e6a 6f69 6e28 6d61 7028  rn b"".join(map(
-00004190: 6c61 6d62 6461 2078 2c20 793a 2063 6862  lambda x, y: chb
-000041a0: 286f 7262 2878 2920 5e20 6f72 6228 7929  (orb(x) ^ orb(y)
-000041b0: 292c 2073 312c 2073 3229 290a 0a0a 6465  ), s1, s2))...de
-000041c0: 6620 7374 7261 6e64 2873 312c 2073 3229  f strand(s1, s2)
-000041d0: 3a0a 2020 2020 2320 7479 7065 3a20 2862  :.    # type: (b
-000041e0: 7974 6573 2c20 6279 7465 7329 202d 3e20  ytes, bytes) -> 
-000041f0: 6279 7465 730a 2020 2020 2222 220a 2020  bytes.    """.  
-00004200: 2020 5265 7475 726e 7320 7468 6520 6269    Returns the bi
-00004210: 6e61 7279 2041 4e44 206f 6620 7468 6520  nary AND of the 
-00004220: 3220 7072 6f76 6964 6564 2073 7472 696e  2 provided strin
-00004230: 6773 2073 3120 616e 6420 7332 2e20 7331  gs s1 and s2. s1
-00004240: 2061 6e64 2073 320a 2020 2020 6d75 7374   and s2.    must
-00004250: 2062 6520 6f66 2073 616d 6520 6c65 6e67   be of same leng
-00004260: 7468 2e0a 2020 2020 2222 220a 2020 2020  th..    """.    
-00004270: 7265 7475 726e 2062 2222 2e6a 6f69 6e28  return b"".join(
-00004280: 6d61 7028 6c61 6d62 6461 2078 2c20 793a  map(lambda x, y:
-00004290: 2063 6862 286f 7262 2878 2920 2620 6f72   chb(orb(x) & or
-000042a0: 6228 7929 292c 2073 312c 2073 3229 290a  b(y)), s1, s2)).
-000042b0: 0a0a 2320 576f 726b 6172 6f75 6e64 2062  ..# Workaround b
-000042c0: 7567 2036 3433 3030 3520 3a20 6874 7470  ug 643005 : http
-000042d0: 733a 2f2f 736f 7572 6365 666f 7267 652e  s://sourceforge.
-000042e0: 6e65 742f 7472 6163 6b65 722f 3f66 756e  net/tracker/?fun
-000042f0: 633d 6465 7461 696c 2661 7469 643d 3130  c=detail&atid=10
-00004300: 3534 3730 2661 6964 3d36 3433 3030 3526  5470&aid=643005&
-00004310: 6772 6f75 705f 6964 3d35 3437 3020 2023  group_id=5470  #
-00004320: 206e 6f71 613a 2045 3530 310a 7472 793a   noqa: E501.try:
-00004330: 0a20 2020 2073 6f63 6b65 742e 696e 6574  .    socket.inet
-00004340: 5f61 746f 6e28 2232 3535 2e32 3535 2e32  _aton("255.255.2
-00004350: 3535 2e32 3535 2229 0a65 7863 6570 7420  55.255").except 
-00004360: 736f 636b 6574 2e65 7272 6f72 3a0a 2020  socket.error:.  
-00004370: 2020 6465 6620 696e 6574 5f61 746f 6e28    def inet_aton(
-00004380: 6970 5f73 7472 696e 6729 3a0a 2020 2020  ip_string):.    
-00004390: 2020 2020 2320 7479 7065 3a20 2873 7472      # type: (str
-000043a0: 2920 2d3e 2062 7974 6573 0a20 2020 2020  ) -> bytes.     
-000043b0: 2020 2069 6620 6970 5f73 7472 696e 6720     if ip_string 
-000043c0: 3d3d 2022 3235 352e 3235 352e 3235 352e  == "255.255.255.
-000043d0: 3235 3522 3a0a 2020 2020 2020 2020 2020  255":.          
-000043e0: 2020 7265 7475 726e 2062 225c 7866 6622    return b"\xff"
-000043f0: 202a 2034 0a20 2020 2020 2020 2065 6c73   * 4.        els
-00004400: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-00004410: 6574 7572 6e20 736f 636b 6574 2e69 6e65  eturn socket.ine
-00004420: 745f 6174 6f6e 2869 705f 7374 7269 6e67  t_aton(ip_string
-00004430: 290a 656c 7365 3a0a 2020 2020 696e 6574  ).else:.    inet
-00004440: 5f61 746f 6e20 3d20 736f 636b 6574 2e69  _aton = socket.i
-00004450: 6e65 745f 6174 6f6e 2020 2320 7479 7065  net_aton  # type
-00004460: 3a20 6967 6e6f 7265 0a0a 696e 6574 5f6e  : ignore..inet_n
-00004470: 746f 6120 3d20 736f 636b 6574 2e69 6e65  toa = socket.ine
-00004480: 745f 6e74 6f61 0a0a 0a64 6566 2061 746f  t_ntoa...def ato
-00004490: 6c28 7829 3a0a 2020 2020 2320 7479 7065  l(x):.    # type
-000044a0: 3a20 2873 7472 2920 2d3e 2069 6e74 0a20  : (str) -> int. 
-000044b0: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-000044c0: 6970 203d 2069 6e65 745f 6174 6f6e 2878  ip = inet_aton(x
-000044d0: 290a 2020 2020 6578 6365 7074 2073 6f63  ).    except soc
-000044e0: 6b65 742e 6572 726f 723a 0a20 2020 2020  ket.error:.     
-000044f0: 2020 2069 7020 3d20 696e 6574 5f61 746f     ip = inet_ato
-00004500: 6e28 736f 636b 6574 2e67 6574 686f 7374  n(socket.gethost
-00004510: 6279 6e61 6d65 2878 2929 0a20 2020 2072  byname(x)).    r
-00004520: 6574 7572 6e20 6361 7374 2869 6e74 2c20  eturn cast(int, 
-00004530: 7374 7275 6374 2e75 6e70 6163 6b28 2221  struct.unpack("!
-00004540: 4922 2c20 6970 295b 305d 290a 0a0a 6465  I", ip)[0])...de
-00004550: 6620 7661 6c69 645f 6970 2861 6464 7229  f valid_ip(addr)
-00004560: 3a0a 2020 2020 2320 7479 7065 3a20 2873  :.    # type: (s
-00004570: 7472 2920 2d3e 2062 6f6f 6c0a 2020 2020  tr) -> bool.    
-00004580: 7472 793a 0a20 2020 2020 2020 2061 6464  try:.        add
-00004590: 7220 3d20 706c 6169 6e5f 7374 7228 6164  r = plain_str(ad
-000045a0: 6472 290a 2020 2020 6578 6365 7074 2055  dr).    except U
-000045b0: 6e69 636f 6465 4465 636f 6465 4572 726f  nicodeDecodeErro
-000045c0: 723a 0a20 2020 2020 2020 2072 6574 7572  r:.        retur
-000045d0: 6e20 4661 6c73 650a 2020 2020 7472 793a  n False.    try:
-000045e0: 0a20 2020 2020 2020 2061 746f 6c28 6164  .        atol(ad
-000045f0: 6472 290a 2020 2020 6578 6365 7074 2028  dr).    except (
-00004600: 4f53 4572 726f 722c 2056 616c 7565 4572  OSError, ValueEr
-00004610: 726f 722c 2073 6f63 6b65 742e 6572 726f  ror, socket.erro
-00004620: 7229 3a0a 2020 2020 2020 2020 7265 7475  r):.        retu
-00004630: 726e 2046 616c 7365 0a20 2020 2072 6574  rn False.    ret
-00004640: 7572 6e20 5472 7565 0a0a 0a64 6566 2076  urn True...def v
-00004650: 616c 6964 5f6e 6574 2861 6464 7229 3a0a  alid_net(addr):.
-00004660: 2020 2020 2320 7479 7065 3a20 2873 7472      # type: (str
-00004670: 2920 2d3e 2062 6f6f 6c0a 2020 2020 7472  ) -> bool.    tr
-00004680: 793a 0a20 2020 2020 2020 2061 6464 7220  y:.        addr 
-00004690: 3d20 706c 6169 6e5f 7374 7228 6164 6472  = plain_str(addr
-000046a0: 290a 2020 2020 6578 6365 7074 2055 6e69  ).    except Uni
-000046b0: 636f 6465 4465 636f 6465 4572 726f 723a  codeDecodeError:
-000046c0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000046d0: 4661 6c73 650a 2020 2020 6966 2027 2f27  False.    if '/'
-000046e0: 2069 6e20 6164 6472 3a0a 2020 2020 2020   in addr:.      
-000046f0: 2020 6970 2c20 6d61 736b 203d 2061 6464    ip, mask = add
-00004700: 722e 7370 6c69 7428 272f 272c 2031 290a  r.split('/', 1).
-00004710: 2020 2020 2020 2020 7265 7475 726e 2076          return v
-00004720: 616c 6964 5f69 7028 6970 2920 616e 6420  alid_ip(ip) and 
-00004730: 6d61 736b 2e69 7364 6967 6974 2829 2061  mask.isdigit() a
-00004740: 6e64 2030 203c 3d20 696e 7428 6d61 736b  nd 0 <= int(mask
-00004750: 2920 3c3d 2033 320a 2020 2020 7265 7475  ) <= 32.    retu
-00004760: 726e 2076 616c 6964 5f69 7028 6164 6472  rn valid_ip(addr
-00004770: 290a 0a0a 6465 6620 7661 6c69 645f 6970  )...def valid_ip
-00004780: 3628 6164 6472 293a 0a20 2020 2023 2074  6(addr):.    # t
-00004790: 7970 653a 2028 7374 7229 202d 3e20 626f  ype: (str) -> bo
-000047a0: 6f6c 0a20 2020 2074 7279 3a0a 2020 2020  ol.    try:.    
-000047b0: 2020 2020 6164 6472 203d 2070 6c61 696e      addr = plain
-000047c0: 5f73 7472 2861 6464 7229 0a20 2020 2065  _str(addr).    e
-000047d0: 7863 6570 7420 556e 6963 6f64 6544 6563  xcept UnicodeDec
-000047e0: 6f64 6545 7272 6f72 3a0a 2020 2020 2020  odeError:.      
-000047f0: 2020 7265 7475 726e 2046 616c 7365 0a20    return False. 
-00004800: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-00004810: 696e 6574 5f70 746f 6e28 736f 636b 6574  inet_pton(socket
-00004820: 2e41 465f 494e 4554 362c 2061 6464 7229  .AF_INET6, addr)
-00004830: 0a20 2020 2065 7863 6570 7420 736f 636b  .    except sock
-00004840: 6574 2e65 7272 6f72 3a0a 2020 2020 2020  et.error:.      
-00004850: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-00004860: 2020 2073 6f63 6b65 742e 6765 7461 6464     socket.getadd
-00004870: 7269 6e66 6f28 6164 6472 2c20 4e6f 6e65  rinfo(addr, None
-00004880: 2c20 736f 636b 6574 2e41 465f 494e 4554  , socket.AF_INET
-00004890: 3629 5b30 5d5b 345d 5b30 5d0a 2020 2020  6)[0][4][0].    
-000048a0: 2020 2020 6578 6365 7074 2073 6f63 6b65      except socke
-000048b0: 742e 6572 726f 723a 0a20 2020 2020 2020  t.error:.       
-000048c0: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
-000048d0: 650a 2020 2020 7265 7475 726e 2054 7275  e.    return Tru
-000048e0: 650a 0a0a 6465 6620 7661 6c69 645f 6e65  e...def valid_ne
-000048f0: 7436 2861 6464 7229 3a0a 2020 2020 2320  t6(addr):.    # 
-00004900: 7479 7065 3a20 2873 7472 2920 2d3e 2062  type: (str) -> b
-00004910: 6f6f 6c0a 2020 2020 7472 793a 0a20 2020  ool.    try:.   
-00004920: 2020 2020 2061 6464 7220 3d20 706c 6169       addr = plai
-00004930: 6e5f 7374 7228 6164 6472 290a 2020 2020  n_str(addr).    
-00004940: 6578 6365 7074 2055 6e69 636f 6465 4465  except UnicodeDe
-00004950: 636f 6465 4572 726f 723a 0a20 2020 2020  codeError:.     
-00004960: 2020 2072 6574 7572 6e20 4661 6c73 650a     return False.
-00004970: 2020 2020 6966 2027 2f27 2069 6e20 6164      if '/' in ad
-00004980: 6472 3a0a 2020 2020 2020 2020 6970 2c20  dr:.        ip, 
-00004990: 6d61 736b 203d 2061 6464 722e 7370 6c69  mask = addr.spli
-000049a0: 7428 272f 272c 2031 290a 2020 2020 2020  t('/', 1).      
-000049b0: 2020 7265 7475 726e 2076 616c 6964 5f69    return valid_i
-000049c0: 7036 2869 7029 2061 6e64 206d 6173 6b2e  p6(ip) and mask.
-000049d0: 6973 6469 6769 7428 2920 616e 6420 3020  isdigit() and 0 
-000049e0: 3c3d 2069 6e74 286d 6173 6b29 203c 3d20  <= int(mask) <= 
-000049f0: 3132 380a 2020 2020 7265 7475 726e 2076  128.    return v
-00004a00: 616c 6964 5f69 7036 2861 6464 7229 0a0a  alid_ip6(addr)..
-00004a10: 0a64 6566 206c 746f 6128 7829 3a0a 2020  .def ltoa(x):.  
-00004a20: 2020 2320 7479 7065 3a20 2869 6e74 2920    # type: (int) 
-00004a30: 2d3e 2073 7472 0a20 2020 2072 6574 7572  -> str.    retur
-00004a40: 6e20 696e 6574 5f6e 746f 6128 7374 7275  n inet_ntoa(stru
-00004a50: 6374 2e70 6163 6b28 2221 4922 2c20 7820  ct.pack("!I", x 
-00004a60: 2620 3078 6666 6666 6666 6666 2929 0a0a  & 0xffffffff))..
-00004a70: 0a64 6566 2069 746f 6d28 7829 3a0a 2020  .def itom(x):.  
-00004a80: 2020 2320 7479 7065 3a20 2869 6e74 2920    # type: (int) 
-00004a90: 2d3e 2069 6e74 0a20 2020 2072 6574 7572  -> int.    retur
-00004aa0: 6e20 2830 7866 6666 6666 6666 6630 3030  n (0xffffffff000
-00004ab0: 3030 3030 3020 3e3e 2078 2920 2620 3078  00000 >> x) & 0x
-00004ac0: 6666 6666 6666 6666 0a0a 0a64 6566 2064  ffffffff...def d
-00004ad0: 6563 6f64 655f 6c6f 6361 6c65 5f73 7472  ecode_locale_str
-00004ae0: 2878 293a 0a20 2020 2023 2074 7970 653a  (x):.    # type:
-00004af0: 2028 6279 7465 7329 202d 3e20 7374 720a   (bytes) -> str.
-00004b00: 2020 2020 2222 220a 2020 2020 4465 636f      """.    Deco
-00004b10: 6465 2062 7974 6573 2069 6e74 6f20 6120  de bytes into a 
-00004b20: 7374 7269 6e67 2075 7369 6e67 2074 6865  string using the
-00004b30: 2073 7973 7465 6d20 6c6f 6361 6c65 2e0a   system locale..
-00004b40: 2020 2020 5573 6566 756c 206f 6e20 5769      Useful on Wi
-00004b50: 6e64 6f77 7320 7768 6572 6520 6974 2063  ndows where it c
-00004b60: 616e 2062 6520 756e 7573 7561 6c20 2865  an be unusual (e
-00004b70: 2e67 2e20 6370 3132 3532 290a 2020 2020  .g. cp1252).    
-00004b80: 2222 220a 2020 2020 7265 7475 726e 2078  """.    return x
-00004b90: 2e64 6563 6f64 6528 656e 636f 6469 6e67  .decode(encoding
-00004ba0: 3d6c 6f63 616c 652e 6765 746c 6f63 616c  =locale.getlocal
-00004bb0: 6528 295b 315d 206f 7220 2275 7466 2d38  e()[1] or "utf-8
-00004bc0: 222c 2065 7272 6f72 733d 2272 6570 6c61  ", errors="repla
-00004bd0: 6365 2229 0a0a 0a63 6c61 7373 2043 6f6e  ce")...class Con
-00004be0: 7465 7874 4d61 6e61 6765 7253 7562 7072  textManagerSubpr
-00004bf0: 6f63 6573 7328 6f62 6a65 6374 293a 0a20  ocess(object):. 
-00004c00: 2020 2022 2222 0a20 2020 2043 6f6e 7465     """.    Conte
-00004c10: 7874 206d 616e 6167 6572 2074 6861 7420  xt manager that 
-00004c20: 6561 7365 7320 6368 6563 6b69 6e67 2066  eases checking f
-00004c30: 6f72 2075 6e6b 6e6f 776e 2063 6f6d 6d61  or unknown comma
-00004c40: 6e64 2c20 7769 7468 6f75 740a 2020 2020  nd, without.    
-00004c50: 6372 6173 6869 6e67 2e0a 0a20 2020 2045  crashing...    E
-00004c60: 7861 6d70 6c65 3a0a 2020 2020 3e3e 3e20  xample:.    >>> 
-00004c70: 7769 7468 2043 6f6e 7465 7874 4d61 6e61  with ContextMana
-00004c80: 6765 7253 7562 7072 6f63 6573 7328 2274  gerSubprocess("t
-00004c90: 6370 6475 6d70 2229 3a0a 2020 2020 3e3e  cpdump"):.    >>
-00004ca0: 3e20 2020 2020 7375 6270 726f 6365 7373  >     subprocess
-00004cb0: 2e50 6f70 656e 285b 2274 6370 6475 6d70  .Popen(["tcpdump
-00004cc0: 222c 2022 2d2d 7665 7273 696f 6e22 5d29  ", "--version"])
-00004cd0: 0a20 2020 2045 5252 4f52 3a20 436f 756c  .    ERROR: Coul
-00004ce0: 6420 6e6f 7420 6578 6563 7574 6520 7463  d not execute tc
-00004cf0: 7064 756d 702c 2069 7320 6974 2069 6e73  pdump, is it ins
-00004d00: 7461 6c6c 6564 3f0a 0a20 2020 2022 2222  talled?..    """
-00004d10: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
-00004d20: 5f5f 2873 656c 662c 2070 726f 672c 2073  __(self, prog, s
-00004d30: 7570 7072 6573 733d 5472 7565 293a 0a20  uppress=True):. 
-00004d40: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-00004d50: 7374 722c 2062 6f6f 6c29 202d 3e20 4e6f  str, bool) -> No
-00004d60: 6e65 0a20 2020 2020 2020 2073 656c 662e  ne.        self.
-00004d70: 7072 6f67 203d 2070 726f 670a 2020 2020  prog = prog.    
-00004d80: 2020 2020 7365 6c66 2e73 7570 7072 6573      self.suppres
-00004d90: 7320 3d20 7375 7070 7265 7373 0a0a 2020  s = suppress..  
-00004da0: 2020 6465 6620 5f5f 656e 7465 725f 5f28    def __enter__(
-00004db0: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
-00004dc0: 2074 7970 653a 2028 2920 2d3e 204e 6f6e   type: () -> Non
-00004dd0: 650a 2020 2020 2020 2020 7061 7373 0a0a  e.        pass..
-00004de0: 2020 2020 6465 6620 5f5f 6578 6974 5f5f      def __exit__
-00004df0: 2873 656c 662c 0a20 2020 2020 2020 2020  (self,.         
-00004e00: 2020 2020 2020 2020 6578 635f 7479 7065          exc_type
-00004e10: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-00004e20: 6e61 6c5b 7479 7065 5d0a 2020 2020 2020  nal[type].      
-00004e30: 2020 2020 2020 2020 2020 2065 7863 5f76             exc_v
-00004e40: 616c 7565 2c20 2023 2074 7970 653a 204f  alue,  # type: O
-00004e50: 7074 696f 6e61 6c5b 4578 6365 7074 696f  ptional[Exceptio
-00004e60: 6e5d 0a20 2020 2020 2020 2020 2020 2020  n].             
-00004e70: 2020 2020 7472 6163 6562 6163 6b2c 2020      traceback,  
-00004e80: 2320 7479 7065 3a20 4f70 7469 6f6e 616c  # type: Optional
-00004e90: 5b41 6e79 5d0a 2020 2020 2020 2020 2020  [Any].          
-00004ea0: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
-00004eb0: 2020 2320 7479 7065 3a20 282e 2e2e 2920    # type: (...) 
-00004ec0: 2d3e 204f 7074 696f 6e61 6c5b 626f 6f6c  -> Optional[bool
-00004ed0: 5d0a 2020 2020 2020 2020 6966 2065 7863  ].        if exc
-00004ee0: 5f76 616c 7565 2069 7320 4e6f 6e65 206f  _value is None o
-00004ef0: 7220 6578 635f 7479 7065 2069 7320 4e6f  r exc_type is No
-00004f00: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00004f10: 7265 7475 726e 204e 6f6e 650a 2020 2020  return None.    
-00004f20: 2020 2020 2320 4572 726f 7265 640a 2020      # Errored.  
-00004f30: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00004f40: 6e63 6528 6578 635f 7661 6c75 652c 2045  nce(exc_value, E
-00004f50: 6e76 6972 6f6e 6d65 6e74 4572 726f 7229  nvironmentError)
-00004f60: 3a0a 2020 2020 2020 2020 2020 2020 6d73  :.            ms
-00004f70: 6720 3d20 2243 6f75 6c64 206e 6f74 2065  g = "Could not e
-00004f80: 7865 6375 7465 2025 732c 2069 7320 6974  xecute %s, is it
-00004f90: 2069 6e73 7461 6c6c 6564 3f22 2025 2073   installed?" % s
-00004fa0: 656c 662e 7072 6f67 0a20 2020 2020 2020  elf.prog.       
-00004fb0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00004fc0: 2020 206d 7367 203d 2022 2573 3a20 6578     msg = "%s: ex
-00004fd0: 6563 7574 696f 6e20 6661 696c 6564 2028  ecution failed (
-00004fe0: 2573 2922 2025 2028 0a20 2020 2020 2020  %s)" % (.       
-00004ff0: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
-00005000: 6f67 2c0a 2020 2020 2020 2020 2020 2020  og,.            
-00005010: 2020 2020 6578 635f 7479 7065 2e5f 5f63      exc_type.__c
-00005020: 6c61 7373 5f5f 2e5f 5f6e 616d 655f 5f0a  lass__.__name__.
-00005030: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00005040: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-00005050: 662e 7375 7070 7265 7373 3a0a 2020 2020  f.suppress:.    
-00005060: 2020 2020 2020 2020 7261 6973 6520 6578          raise ex
-00005070: 635f 7479 7065 286d 7367 290a 2020 2020  c_type(msg).    
-00005080: 2020 2020 6c6f 675f 7275 6e74 696d 652e      log_runtime.
-00005090: 6572 726f 7228 6d73 672c 2065 7863 5f69  error(msg, exc_i
-000050a0: 6e66 6f3d 5472 7565 290a 2020 2020 2020  nfo=True).      
-000050b0: 2020 7265 7475 726e 2054 7275 6520 2023    return True  #
-000050c0: 2053 7570 7072 6573 7320 7468 6520 6578   Suppress the ex
-000050d0: 6365 7074 696f 6e0a 0a0a 636c 6173 7320  ception...class 
-000050e0: 436f 6e74 6578 744d 616e 6167 6572 4361  ContextManagerCa
-000050f0: 7074 7572 654f 7574 7075 7428 6f62 6a65  ptureOutput(obje
-00005100: 6374 293a 0a20 2020 2022 2222 0a20 2020  ct):.    """.   
-00005110: 2043 6f6e 7465 7874 206d 616e 6167 6572   Context manager
-00005120: 2074 6861 7420 696e 7465 7263 6570 7420   that intercept 
-00005130: 7468 6520 636f 6e73 6f6c 6527 7320 6f75  the console's ou
-00005140: 7470 7574 2e0a 0a20 2020 2045 7861 6d70  tput...    Examp
-00005150: 6c65 3a0a 2020 2020 3e3e 3e20 7769 7468  le:.    >>> with
-00005160: 2043 6f6e 7465 7874 4d61 6e61 6765 7243   ContextManagerC
-00005170: 6170 7475 7265 4f75 7470 7574 2829 2061  aptureOutput() a
-00005180: 7320 636d 636f 3a0a 2020 2020 2e2e 2e20  s cmco:.    ... 
-00005190: 2020 2020 7072 696e 7428 2268 6579 2229      print("hey")
-000051a0: 0a20 2020 202e 2e2e 2020 2020 2061 7373  .    ...     ass
-000051b0: 6572 7420 636d 636f 2e67 6574 5f6f 7574  ert cmco.get_out
-000051c0: 7075 7428 2920 3d3d 2022 6865 7922 0a20  put() == "hey". 
-000051d0: 2020 2022 2222 0a0a 2020 2020 6465 6620     """..    def 
-000051e0: 5f5f 696e 6974 5f5f 2873 656c 6629 3a0a  __init__(self):.
-000051f0: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-00005200: 2829 202d 3e20 4e6f 6e65 0a20 2020 2020  () -> None.     
-00005210: 2020 2073 656c 662e 7265 7375 6c74 5f65     self.result_e
-00005220: 7870 6f72 745f 6f62 6a65 6374 203d 2022  xport_object = "
-00005230: 220a 2020 2020 2020 2020 7472 793a 0a20  ".        try:. 
-00005240: 2020 2020 2020 2020 2020 2069 6d70 6f72             impor
-00005250: 7420 6d6f 636b 2020 2320 6e6f 7161 3a20  t mock  # noqa: 
-00005260: 4634 3031 0a20 2020 2020 2020 2065 7863  F401.        exc
-00005270: 6570 7420 4578 6365 7074 696f 6e3a 0a20  ept Exception:. 
-00005280: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00005290: 2049 6d70 6f72 7445 7272 6f72 2822 5468   ImportError("Th
-000052a0: 6520 6d6f 636b 206d 6f64 756c 6520 6e65  e mock module ne
-000052b0: 6564 7320 746f 2062 6520 696e 7374 616c  eds to be instal
-000052c0: 6c65 6420 2122 290a 0a20 2020 2064 6566  led !")..    def
-000052d0: 205f 5f65 6e74 6572 5f5f 2873 656c 6629   __enter__(self)
-000052e0: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-000052f0: 3a20 2829 202d 3e20 436f 6e74 6578 744d  : () -> ContextM
-00005300: 616e 6167 6572 4361 7074 7572 654f 7574  anagerCaptureOut
-00005310: 7075 740a 2020 2020 2020 2020 696d 706f  put.        impo
-00005320: 7274 206d 6f63 6b0a 0a20 2020 2020 2020  rt mock..       
-00005330: 2064 6566 2077 7269 7465 2873 2c20 6465   def write(s, de
-00005340: 636f 7261 746f 723d 7365 6c66 293a 0a20  corator=self):. 
-00005350: 2020 2020 2020 2020 2020 2023 2074 7970             # typ
-00005360: 653a 2028 7374 722c 2043 6f6e 7465 7874  e: (str, Context
-00005370: 4d61 6e61 6765 7243 6170 7475 7265 4f75  ManagerCaptureOu
-00005380: 7470 7574 2920 2d3e 204e 6f6e 650a 2020  tput) -> None.  
-00005390: 2020 2020 2020 2020 2020 6465 636f 7261            decora
-000053a0: 746f 722e 7265 7375 6c74 5f65 7870 6f72  tor.result_expor
-000053b0: 745f 6f62 6a65 6374 202b 3d20 730a 2020  t_object += s.  
-000053c0: 2020 2020 2020 6d6f 636b 5f73 7464 6f75        mock_stdou
-000053d0: 7420 3d20 6d6f 636b 2e4d 6f63 6b28 290a  t = mock.Mock().
-000053e0: 2020 2020 2020 2020 6d6f 636b 5f73 7464          mock_std
-000053f0: 6f75 742e 7772 6974 6520 3d20 7772 6974  out.write = writ
-00005400: 650a 2020 2020 2020 2020 7365 6c66 2e62  e.        self.b
-00005410: 636b 5f73 7464 6f75 7420 3d20 7379 732e  ck_stdout = sys.
-00005420: 7374 646f 7574 0a20 2020 2020 2020 2073  stdout.        s
-00005430: 7973 2e73 7464 6f75 7420 3d20 6d6f 636b  ys.stdout = mock
-00005440: 5f73 7464 6f75 740a 2020 2020 2020 2020  _stdout.        
-00005450: 7265 7475 726e 2073 656c 660a 0a20 2020  return self..   
-00005460: 2064 6566 205f 5f65 7869 745f 5f28 7365   def __exit__(se
-00005470: 6c66 2c20 2a65 7863 293a 0a20 2020 2020  lf, *exc):.     
-00005480: 2020 2023 2074 7970 653a 2028 2a41 6e79     # type: (*Any
-00005490: 2920 2d3e 204c 6974 6572 616c 5b46 616c  ) -> Literal[Fal
-000054a0: 7365 5d0a 2020 2020 2020 2020 7379 732e  se].        sys.
-000054b0: 7374 646f 7574 203d 2073 656c 662e 6263  stdout = self.bc
-000054c0: 6b5f 7374 646f 7574 0a20 2020 2020 2020  k_stdout.       
-000054d0: 2072 6574 7572 6e20 4661 6c73 650a 0a20   return False.. 
-000054e0: 2020 2064 6566 2067 6574 5f6f 7574 7075     def get_outpu
-000054f0: 7428 7365 6c66 2c20 6576 616c 5f62 7974  t(self, eval_byt
-00005500: 6573 3d46 616c 7365 293a 0a20 2020 2020  es=False):.     
-00005510: 2020 2023 2074 7970 653a 2028 626f 6f6c     # type: (bool
-00005520: 2920 2d3e 2073 7472 0a20 2020 2020 2020  ) -> str.       
-00005530: 2069 6620 7365 6c66 2e72 6573 756c 745f   if self.result_
-00005540: 6578 706f 7274 5f6f 626a 6563 742e 7374  export_object.st
-00005550: 6172 7473 7769 7468 2822 6227 2229 2061  artswith("b'") a
-00005560: 6e64 2065 7661 6c5f 6279 7465 733a 0a20  nd eval_bytes:. 
-00005570: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00005580: 6e20 706c 6169 6e5f 7374 7228 6576 616c  n plain_str(eval
-00005590: 2873 656c 662e 7265 7375 6c74 5f65 7870  (self.result_exp
-000055a0: 6f72 745f 6f62 6a65 6374 2929 0a20 2020  ort_object)).   
-000055b0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000055c0: 2e72 6573 756c 745f 6578 706f 7274 5f6f  .result_export_o
-000055d0: 626a 6563 740a 0a0a 6465 6620 646f 5f67  bject...def do_g
-000055e0: 7261 7068 280a 2020 2020 6772 6170 682c  raph(.    graph,
-000055f0: 2020 2320 7479 7065 3a20 7374 720a 2020    # type: str.  
-00005600: 2020 7072 6f67 3d4e 6f6e 652c 2020 2320    prog=None,  # 
-00005610: 7479 7065 3a20 4f70 7469 6f6e 616c 5b73  type: Optional[s
-00005620: 7472 5d0a 2020 2020 666f 726d 6174 3d4e  tr].    format=N
-00005630: 6f6e 652c 2020 2320 7479 7065 3a20 4f70  one,  # type: Op
-00005640: 7469 6f6e 616c 5b73 7472 5d0a 2020 2020  tional[str].    
-00005650: 7461 7267 6574 3d4e 6f6e 652c 2020 2320  target=None,  # 
-00005660: 7479 7065 3a20 4f70 7469 6f6e 616c 5b55  type: Optional[U
-00005670: 6e69 6f6e 5b49 4f5b 6279 7465 735d 2c20  nion[IO[bytes], 
-00005680: 7374 725d 5d0a 2020 2020 7479 7065 3d4e  str]].    type=N
-00005690: 6f6e 652c 2020 2320 7479 7065 3a20 4f70  one,  # type: Op
-000056a0: 7469 6f6e 616c 5b73 7472 5d0a 2020 2020  tional[str].    
-000056b0: 7374 7269 6e67 3d4e 6f6e 652c 2020 2320  string=None,  # 
-000056c0: 7479 7065 3a20 4f70 7469 6f6e 616c 5b62  type: Optional[b
-000056d0: 6f6f 6c5d 0a20 2020 206f 7074 696f 6e73  ool].    options
-000056e0: 3d4e 6f6e 6520 2023 2074 7970 653a 204f  =None  # type: O
-000056f0: 7074 696f 6e61 6c5b 4c69 7374 5b73 7472  ptional[List[str
-00005700: 5d5d 0a29 3a0a 2020 2020 2320 7479 7065  ]].):.    # type
-00005710: 3a20 282e 2e2e 2920 2d3e 204f 7074 696f  : (...) -> Optio
-00005720: 6e61 6c5b 7374 725d 0a20 2020 2022 2222  nal[str].    """
-00005730: 5072 6f63 6573 7365 7320 6772 6170 6820  Processes graph 
-00005740: 6465 7363 7269 7074 696f 6e20 7573 696e  description usin
-00005750: 6720 616e 2065 7874 6572 6e61 6c20 736f  g an external so
-00005760: 6674 7761 7265 2e0a 2020 2020 5468 6973  ftware..    This
-00005770: 206d 6574 686f 6420 6973 2075 7365 6420   method is used 
-00005780: 746f 2063 6f6e 7665 7274 2061 2067 7261  to convert a gra
-00005790: 7068 7669 7a20 666f 726d 6174 2074 6f20  phviz format to 
-000057a0: 616e 2069 6d61 6765 2e0a 0a20 2020 203a  an image...    :
-000057b0: 7061 7261 6d20 6772 6170 683a 2047 7261  param graph: Gra
-000057c0: 7068 5669 7a20 6772 6170 6820 6465 7363  phViz graph desc
-000057d0: 7269 7074 696f 6e0a 2020 2020 3a70 6172  ription.    :par
-000057e0: 616d 2070 726f 673a 2077 6869 6368 2067  am prog: which g
-000057f0: 7261 7068 7669 7a20 7072 6f67 7261 6d20  raphviz program 
-00005800: 746f 2075 7365 0a20 2020 203a 7061 7261  to use.    :para
-00005810: 6d20 666f 726d 6174 3a20 6f75 7470 7574  m format: output
-00005820: 2074 7970 6520 2873 7667 2c20 7073 2c20   type (svg, ps, 
-00005830: 6769 662c 206a 7067 2c20 6574 632e 292c  gif, jpg, etc.),
-00005840: 2070 6173 7365 6420 746f 2064 6f74 2773   passed to dot's
-00005850: 2022 2d54 220a 2020 2020 2020 2020 6f70   "-T".        op
-00005860: 7469 6f6e 0a20 2020 203a 7061 7261 6d20  tion.    :param 
-00005870: 7374 7269 6e67 3a20 6966 206e 6f74 204e  string: if not N
-00005880: 6f6e 652c 2073 696d 706c 7920 7265 7475  one, simply retu
-00005890: 726e 2074 6865 2067 7261 7068 2073 7472  rn the graph str
-000058a0: 696e 670a 2020 2020 3a70 6172 616d 2074  ing.    :param t
-000058b0: 6172 6765 743a 2066 696c 656e 616d 6520  arget: filename 
-000058c0: 6f72 2072 6564 6972 6563 742e 2044 6566  or redirect. Def
-000058d0: 6175 6c74 7320 7069 7065 2074 6f20 496d  aults pipe to Im
-000058e0: 6167 656d 6167 6963 6b27 730a 2020 2020  agemagick's.    
-000058f0: 2020 2020 6469 7370 6c61 7920 7072 6f67      display prog
-00005900: 7261 6d0a 2020 2020 3a70 6172 616d 206f  ram.    :param o
-00005910: 7074 696f 6e73 3a20 6f70 7469 6f6e 7320  ptions: options 
-00005920: 746f 2062 6520 7061 7373 6564 2074 6f20  to be passed to 
-00005930: 7072 6f67 0a20 2020 2022 2222 0a0a 2020  prog.    """..  
-00005940: 2020 6966 2066 6f72 6d61 7420 6973 204e    if format is N
-00005950: 6f6e 653a 0a20 2020 2020 2020 2066 6f72  one:.        for
-00005960: 6d61 7420 3d20 2273 7667 220a 2020 2020  mat = "svg".    
-00005970: 6966 2073 7472 696e 673a 0a20 2020 2020  if string:.     
-00005980: 2020 2072 6574 7572 6e20 6772 6170 680a     return graph.
-00005990: 2020 2020 6966 2074 7970 6520 6973 206e      if type is n
-000059a0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-000059b0: 2077 6172 6e69 6e67 732e 7761 726e 280a   warnings.warn(.
-000059c0: 2020 2020 2020 2020 2020 2020 2274 7970              "typ
-000059d0: 6520 6973 2064 6570 7265 6361 7465 642c  e is deprecated,
-000059e0: 2061 6e64 2077 6173 2072 656e 616d 6564   and was renamed
-000059f0: 2066 6f72 6d61 7422 2c0a 2020 2020 2020   format",.      
-00005a00: 2020 2020 2020 4465 7072 6563 6174 696f        Deprecatio
-00005a10: 6e57 6172 6e69 6e67 0a20 2020 2020 2020  nWarning.       
-00005a20: 2029 0a20 2020 2020 2020 2066 6f72 6d61   ).        forma
-00005a30: 7420 3d20 7479 7065 0a20 2020 2069 6620  t = type.    if 
-00005a40: 7072 6f67 2069 7320 4e6f 6e65 3a0a 2020  prog is None:.  
-00005a50: 2020 2020 2020 7072 6f67 203d 2063 6f6e        prog = con
-00005a60: 662e 7072 6f67 2e64 6f74 0a20 2020 2073  f.prog.dot.    s
-00005a70: 7461 7274 5f76 6965 7765 7220 3d20 4661  tart_viewer = Fa
-00005a80: 6c73 650a 2020 2020 6966 2074 6172 6765  lse.    if targe
-00005a90: 7420 6973 204e 6f6e 653a 0a20 2020 2020  t is None:.     
-00005aa0: 2020 2069 6620 5749 4e44 4f57 533a 0a20     if WINDOWS:. 
-00005ab0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
-00005ac0: 7420 3d20 6765 745f 7465 6d70 5f66 696c  t = get_temp_fil
-00005ad0: 6528 6175 746f 6578 743d 222e 2220 2b20  e(autoext="." + 
-00005ae0: 666f 726d 6174 290a 2020 2020 2020 2020  format).        
-00005af0: 2020 2020 7374 6172 745f 7669 6577 6572      start_viewer
-00005b00: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
-00005b10: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00005b20: 2020 7769 7468 2043 6f6e 7465 7874 4d61    with ContextMa
-00005b30: 6e61 6765 7253 7562 7072 6f63 6573 7328  nagerSubprocess(
-00005b40: 636f 6e66 2e70 726f 672e 6469 7370 6c61  conf.prog.displa
-00005b50: 7929 3a0a 2020 2020 2020 2020 2020 2020  y):.            
-00005b60: 2020 2020 7461 7267 6574 203d 2073 7562      target = sub
-00005b70: 7072 6f63 6573 732e 506f 7065 6e28 5b63  process.Popen([c
-00005b80: 6f6e 662e 7072 6f67 2e64 6973 706c 6179  onf.prog.display
-00005b90: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00001570: 2020 2020 2020 2020 2020 2064 656c 6574             delet
+00001580: 653d 4661 6c73 6529 0a20 2020 2069 6620  e=False).    if 
+00001590: 6e6f 7420 6b65 6570 3a0a 2020 2020 2020  not keep:.      
+000015a0: 2020 636f 6e66 2e74 656d 705f 6669 6c65    conf.temp_file
+000015b0: 732e 6170 7065 6e64 2866 2e6e 616d 6529  s.append(f.name)
+000015c0: 0a0a 2020 2020 6966 2066 643a 0a20 2020  ..    if fd:.   
+000015d0: 2020 2020 2072 6574 7572 6e20 660a 2020       return f.  
+000015e0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000015f0: 2320 436c 6f73 6520 7468 6520 6669 6c65  # Close the file
+00001600: 2073 6f20 736f 6d65 7468 696e 6720 656c   so something el
+00001610: 7365 2063 616e 2074 616b 6520 6974 2e0a  se can take it..
+00001620: 2020 2020 2020 2020 662e 636c 6f73 6528          f.close(
+00001630: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00001640: 2066 2e6e 616d 650a 0a0a 6465 6620 6765   f.name...def ge
+00001650: 745f 7465 6d70 5f64 6972 286b 6565 703d  t_temp_dir(keep=
+00001660: 4661 6c73 6529 3a0a 2020 2020 2320 7479  False):.    # ty
+00001670: 7065 3a20 2862 6f6f 6c29 202d 3e20 7374  pe: (bool) -> st
+00001680: 720a 2020 2020 2222 2243 7265 6174 6573  r.    """Creates
+00001690: 2061 2074 656d 706f 7261 7279 2066 696c   a temporary fil
+000016a0: 652c 2061 6e64 2072 6574 7572 6e73 2069  e, and returns i
+000016b0: 7473 206e 616d 652e 0a0a 2020 2020 3a70  ts name...    :p
+000016c0: 6172 616d 206b 6565 703a 2049 6620 4661  aram keep: If Fa
+000016d0: 6c73 6520 2864 6566 6175 6c74 292c 2074  lse (default), t
+000016e0: 6865 2064 6972 6563 746f 7279 2077 696c  he directory wil
+000016f0: 6c20 6265 2072 6563 7572 7369 7665 6c79  l be recursively
+00001700: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001710: 2020 6465 6c65 7465 6420 7768 656e 2053    deleted when S
+00001720: 6361 7079 2065 7869 7473 2e0a 2020 2020  capy exits..    
+00001730: 3a72 6574 7572 6e3a 2041 2066 756c 6c20  :return: A full 
+00001740: 7061 7468 2074 6f20 6120 7465 6d70 6f72  path to a tempor
+00001750: 6172 7920 6469 7265 6374 6f72 792e 0a20  ary directory.. 
+00001760: 2020 2022 2222 0a0a 2020 2020 646e 616d     """..    dnam
+00001770: 6520 3d20 7465 6d70 6669 6c65 2e6d 6b64  e = tempfile.mkd
+00001780: 7465 6d70 2870 7265 6669 783d 2273 6361  temp(prefix="sca
+00001790: 7079 2229 0a0a 2020 2020 6966 206e 6f74  py")..    if not
+000017a0: 206b 6565 703a 0a20 2020 2020 2020 2063   keep:.        c
+000017b0: 6f6e 662e 7465 6d70 5f66 696c 6573 2e61  onf.temp_files.a
+000017c0: 7070 656e 6428 646e 616d 6529 0a0a 2020  ppend(dname)..  
+000017d0: 2020 7265 7475 726e 2064 6e61 6d65 0a0a    return dname..
+000017e0: 0a64 6566 205f 6372 6561 7465 5f66 6966  .def _create_fif
+000017f0: 6f28 2920 2d3e 2054 7570 6c65 5b73 7472  o() -> Tuple[str
+00001800: 2c20 416e 795d 3a0a 2020 2020 2222 2243  , Any]:.    """C
+00001810: 7265 6174 6573 2061 2074 656d 706f 7261  reates a tempora
+00001820: 7279 2066 6966 6f2e 0a0a 2020 2020 596f  ry fifo...    Yo
+00001830: 7520 6d75 7374 2074 6865 6e20 7573 6520  u must then use 
+00001840: 6f70 656e 5f66 6966 6f28 2920 6f6e 2074  open_fifo() on t
+00001850: 6865 2073 6572 7665 725f 6664 206f 6e63  he server_fd onc
+00001860: 650a 2020 2020 7468 6520 636c 6965 6e74  e.    the client
+00001870: 2069 7320 636f 6e6e 6563 7465 6420 746f   is connected to
+00001880: 2075 7365 2069 742e 0a0a 2020 2020 3a72   use it...    :r
+00001890: 6574 7572 6e73 3a20 2863 6c69 656e 745f  eturns: (client_
+000018a0: 6669 6c65 2c20 7365 7276 6572 5f66 6429  file, server_fd)
+000018b0: 0a20 2020 2022 2222 0a20 2020 2069 6620  .    """.    if 
+000018c0: 5749 4e44 4f57 533a 0a20 2020 2020 2020  WINDOWS:.       
+000018d0: 2066 726f 6d20 7363 6170 792e 6172 6368   from scapy.arch
+000018e0: 2e77 696e 646f 7773 2e73 7472 7563 7475  .windows.structu
+000018f0: 7265 7320 696d 706f 7274 205f 6765 745f  res import _get_
+00001900: 7769 6e5f 6669 666f 0a20 2020 2020 2020  win_fifo.       
+00001910: 2072 6574 7572 6e20 5f67 6574 5f77 696e   return _get_win
+00001920: 5f66 6966 6f28 290a 2020 2020 656c 7365  _fifo().    else
+00001930: 3a0a 2020 2020 2020 2020 6620 3d20 6765  :.        f = ge
+00001940: 745f 7465 6d70 5f66 696c 6528 290a 2020  t_temp_file().  
+00001950: 2020 2020 2020 6f73 2e75 6e6c 696e 6b28        os.unlink(
+00001960: 6629 0a20 2020 2020 2020 206f 732e 6d6b  f).        os.mk
+00001970: 6669 666f 2866 290a 2020 2020 2020 2020  fifo(f).        
+00001980: 7265 7475 726e 2066 2c20 660a 0a0a 6465  return f, f...de
+00001990: 6620 5f6f 7065 6e5f 6669 666f 2866 643a  f _open_fifo(fd:
+000019a0: 2041 6e79 2c20 6d6f 6465 3a20 7374 7220   Any, mode: str 
+000019b0: 3d20 2272 6222 2920 2d3e 2049 4f5b 6279  = "rb") -> IO[by
+000019c0: 7465 735d 3a0a 2020 2020 2222 224f 7065  tes]:.    """Ope
+000019d0: 6e20 7468 6520 7365 7276 6572 5f66 6420  n the server_fd 
+000019e0: 2873 6565 2063 7265 6174 655f 6669 666f  (see create_fifo
+000019f0: 290a 2020 2020 2222 220a 2020 2020 6966  ).    """.    if
+00001a00: 2057 494e 444f 5753 3a0a 2020 2020 2020   WINDOWS:.      
+00001a10: 2020 6672 6f6d 2073 6361 7079 2e61 7263    from scapy.arc
+00001a20: 682e 7769 6e64 6f77 732e 7374 7275 6374  h.windows.struct
+00001a30: 7572 6573 2069 6d70 6f72 7420 5f77 696e  ures import _win
+00001a40: 5f66 6966 6f5f 6f70 656e 0a20 2020 2020  _fifo_open.     
+00001a50: 2020 2072 6574 7572 6e20 5f77 696e 5f66     return _win_f
+00001a60: 6966 6f5f 6f70 656e 2866 6429 0a20 2020  ifo_open(fd).   
+00001a70: 2065 6c73 653a 0a20 2020 2020 2020 2072   else:.        r
+00001a80: 6574 7572 6e20 6f70 656e 2866 642c 206d  eturn open(fd, m
+00001a90: 6f64 6529 0a0a 0a64 6566 2073 616e 6528  ode)...def sane(
+00001aa0: 782c 2063 6f6c 6f72 3d46 616c 7365 293a  x, color=False):
+00001ab0: 0a20 2020 2023 2074 7970 653a 2028 416e  .    # type: (An
+00001ac0: 7953 7472 2c20 626f 6f6c 2920 2d3e 2073  yStr, bool) -> s
+00001ad0: 7472 0a20 2020 2072 203d 2022 220a 2020  tr.    r = "".  
+00001ae0: 2020 666f 7220 6920 696e 2078 3a0a 2020    for i in x:.  
+00001af0: 2020 2020 2020 6a20 3d20 6f72 6228 6929        j = orb(i)
+00001b00: 0a20 2020 2020 2020 2069 6620 286a 203c  .        if (j <
+00001b10: 2033 3229 206f 7220 286a 203e 3d20 3132   32) or (j >= 12
+00001b20: 3729 3a0a 2020 2020 2020 2020 2020 2020  7):.            
+00001b30: 6966 2063 6f6c 6f72 3a0a 2020 2020 2020  if color:.      
+00001b40: 2020 2020 2020 2020 2020 7220 2b3d 2063            r += c
+00001b50: 6f6e 662e 636f 6c6f 725f 7468 656d 652e  onf.color_theme.
+00001b60: 6e6f 745f 7072 696e 7461 626c 6528 222e  not_printable(".
+00001b70: 2229 0a20 2020 2020 2020 2020 2020 2065  ").            e
+00001b80: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00001b90: 2020 2020 2072 202b 3d20 222e 220a 2020       r += ".".  
+00001ba0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00001bb0: 2020 2020 2020 2020 7220 2b3d 2063 6872          r += chr
+00001bc0: 286a 290a 2020 2020 7265 7475 726e 2072  (j).    return r
+00001bd0: 0a0a 0a40 636f 6e66 2e63 6f6d 6d61 6e64  ...@conf.command
+00001be0: 732e 7265 6769 7374 6572 0a64 6566 2072  s.register.def r
+00001bf0: 6573 7461 7274 2829 3a0a 2020 2020 2320  estart():.    # 
+00001c00: 7479 7065 3a20 2829 202d 3e20 4e6f 6e65  type: () -> None
+00001c10: 0a20 2020 2022 2222 5265 7374 6172 7473  .    """Restarts
+00001c20: 2073 6361 7079 2222 220a 2020 2020 6966   scapy""".    if
+00001c30: 206e 6f74 2063 6f6e 662e 696e 7465 7261   not conf.intera
+00001c40: 6374 6976 6520 6f72 206e 6f74 206f 732e  ctive or not os.
+00001c50: 7061 7468 2e69 7366 696c 6528 7379 732e  path.isfile(sys.
+00001c60: 6172 6776 5b30 5d29 3a0a 2020 2020 2020  argv[0]):.      
+00001c70: 2020 7261 6973 6520 4f53 4572 726f 7228    raise OSError(
+00001c80: 2253 6361 7079 2077 6173 206e 6f74 2073  "Scapy was not s
+00001c90: 7461 7274 6564 2066 726f 6d20 636f 6e73  tarted from cons
+00001ca0: 6f6c 6522 290a 2020 2020 6966 2057 494e  ole").    if WIN
+00001cb0: 444f 5753 3a0a 2020 2020 2020 2020 7265  DOWS:.        re
+00001cc0: 735f 636f 6465 203d 2031 0a20 2020 2020  s_code = 1.     
+00001cd0: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00001ce0: 2020 2020 7265 735f 636f 6465 203d 2073      res_code = s
+00001cf0: 7562 7072 6f63 6573 732e 6361 6c6c 285b  ubprocess.call([
+00001d00: 7379 732e 6578 6563 7574 6162 6c65 5d20  sys.executable] 
+00001d10: 2b20 7379 732e 6172 6776 290a 2020 2020  + sys.argv).    
+00001d20: 2020 2020 6669 6e61 6c6c 793a 0a20 2020      finally:.   
+00001d30: 2020 2020 2020 2020 206f 732e 5f65 7869           os._exi
+00001d40: 7428 7265 735f 636f 6465 290a 2020 2020  t(res_code).    
+00001d50: 6f73 2e65 7865 6376 2873 7973 2e65 7865  os.execv(sys.exe
+00001d60: 6375 7461 626c 652c 205b 7379 732e 6578  cutable, [sys.ex
+00001d70: 6563 7574 6162 6c65 5d20 2b20 7379 732e  ecutable] + sys.
+00001d80: 6172 6776 290a 0a0a 6465 6620 6c68 6578  argv)...def lhex
+00001d90: 2878 293a 0a20 2020 2023 2074 7970 653a  (x):.    # type:
+00001da0: 2028 416e 7929 202d 3e20 7374 720a 2020   (Any) -> str.  
+00001db0: 2020 6672 6f6d 2073 6361 7079 2e76 6f6c    from scapy.vol
+00001dc0: 6174 696c 6520 696d 706f 7274 2056 6f6c  atile import Vol
+00001dd0: 6174 696c 6556 616c 7565 0a20 2020 2069  atileValue.    i
+00001de0: 6620 6973 696e 7374 616e 6365 2878 2c20  f isinstance(x, 
+00001df0: 566f 6c61 7469 6c65 5661 6c75 6529 3a0a  VolatileValue):.
+00001e00: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+00001e10: 6570 7228 7829 0a20 2020 2069 6620 6973  epr(x).    if is
+00001e20: 696e 7374 616e 6365 2878 2c20 696e 7429  instance(x, int)
+00001e30: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00001e40: 2068 6578 2878 290a 2020 2020 6966 2069   hex(x).    if i
+00001e50: 7369 6e73 7461 6e63 6528 782c 2074 7570  sinstance(x, tup
+00001e60: 6c65 293a 0a20 2020 2020 2020 2072 6574  le):.        ret
+00001e70: 7572 6e20 2228 2573 2922 2025 2022 2c20  urn "(%s)" % ", 
+00001e80: 222e 6a6f 696e 286c 6865 7828 7629 2066  ".join(lhex(v) f
+00001e90: 6f72 2076 2069 6e20 7829 0a20 2020 2069  or v in x).    i
+00001ea0: 6620 6973 696e 7374 616e 6365 2878 2c20  f isinstance(x, 
+00001eb0: 6c69 7374 293a 0a20 2020 2020 2020 2072  list):.        r
+00001ec0: 6574 7572 6e20 225b 2573 5d22 2025 2022  eturn "[%s]" % "
+00001ed0: 2c20 222e 6a6f 696e 286c 6865 7828 7629  , ".join(lhex(v)
+00001ee0: 2066 6f72 2076 2069 6e20 7829 0a20 2020   for v in x).   
+00001ef0: 2072 6574 7572 6e20 7374 7228 7829 0a0a   return str(x)..
+00001f00: 0a40 636f 6e66 2e63 6f6d 6d61 6e64 732e  .@conf.commands.
+00001f10: 7265 6769 7374 6572 0a64 6566 2068 6578  register.def hex
+00001f20: 6475 6d70 2870 2c20 6475 6d70 3d46 616c  dump(p, dump=Fal
+00001f30: 7365 293a 0a20 2020 2023 2074 7970 653a  se):.    # type:
+00001f40: 2028 556e 696f 6e5b 5061 636b 6574 2c20   (Union[Packet, 
+00001f50: 416e 7953 7472 5d2c 2062 6f6f 6c29 202d  AnyStr], bool) -
+00001f60: 3e20 4f70 7469 6f6e 616c 5b73 7472 5d0a  > Optional[str].
+00001f70: 2020 2020 2222 2242 7569 6c64 2061 2074      """Build a t
+00001f80: 6370 6475 6d70 206c 696b 6520 6865 7861  cpdump like hexa
+00001f90: 6465 6369 6d61 6c20 7669 6577 0a0a 2020  decimal view..  
+00001fa0: 2020 3a70 6172 616d 2070 3a20 6120 5061    :param p: a Pa
+00001fb0: 636b 6574 0a20 2020 203a 7061 7261 6d20  cket.    :param 
+00001fc0: 6475 6d70 3a20 6465 6669 6e65 2069 6620  dump: define if 
+00001fd0: 7468 6520 7265 7375 6c74 206d 7573 7420  the result must 
+00001fe0: 6265 2070 7269 6e74 6564 206f 7220 7265  be printed or re
+00001ff0: 7475 726e 6564 2069 6e20 6120 7661 7269  turned in a vari
+00002000: 6162 6c65 0a20 2020 203a 7265 7475 726e  able.    :return
+00002010: 3a20 6120 5374 7269 6e67 206f 6e6c 7920  : a String only 
+00002020: 7768 656e 2064 756d 703d 5472 7565 0a20  when dump=True. 
+00002030: 2020 2022 2222 0a20 2020 2073 203d 2022     """.    s = "
+00002040: 220a 2020 2020 7820 3d20 6279 7465 735f  ".    x = bytes_
+00002050: 656e 636f 6465 2870 290a 2020 2020 785f  encode(p).    x_
+00002060: 6c65 6e20 3d20 6c65 6e28 7829 0a20 2020  len = len(x).   
+00002070: 2069 203d 2030 0a20 2020 2077 6869 6c65   i = 0.    while
+00002080: 2069 203c 2078 5f6c 656e 3a0a 2020 2020   i < x_len:.    
+00002090: 2020 2020 7320 2b3d 2022 2530 3478 2020      s += "%04x  
+000020a0: 2220 2520 690a 2020 2020 2020 2020 666f  " % i.        fo
+000020b0: 7220 6a20 696e 2072 616e 6765 2831 3629  r j in range(16)
+000020c0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+000020d0: 2069 202b 206a 203c 2078 5f6c 656e 3a0a   i + j < x_len:.
+000020e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000020f0: 7320 2b3d 2022 2530 3258 2022 2025 206f  s += "%02X " % o
+00002100: 7262 2878 5b69 202b 206a 5d29 0a20 2020  rb(x[i + j]).   
+00002110: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00002120: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00002130: 202b 3d20 2220 2020 220a 2020 2020 2020   += "   ".      
+00002140: 2020 7320 2b3d 2022 2025 735c 6e22 2025    s += " %s\n" %
+00002150: 2073 616e 6528 785b 693a 6920 2b20 3136   sane(x[i:i + 16
+00002160: 5d2c 2063 6f6c 6f72 3d54 7275 6529 0a20  ], color=True). 
+00002170: 2020 2020 2020 2069 202b 3d20 3136 0a20         i += 16. 
+00002180: 2020 2023 2072 656d 6f76 6520 7472 6169     # remove trai
+00002190: 6c69 6e67 205c 6e0a 2020 2020 7320 3d20  ling \n.    s = 
+000021a0: 735b 3a2d 315d 2069 6620 732e 656e 6473  s[:-1] if s.ends
+000021b0: 7769 7468 2822 5c6e 2229 2065 6c73 6520  with("\n") else 
+000021c0: 730a 2020 2020 6966 2064 756d 703a 0a20  s.    if dump:. 
+000021d0: 2020 2020 2020 2072 6574 7572 6e20 730a         return s.
+000021e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+000021f0: 2020 7072 696e 7428 7329 0a20 2020 2020    print(s).     
+00002200: 2020 2072 6574 7572 6e20 4e6f 6e65 0a0a     return None..
+00002210: 0a40 636f 6e66 2e63 6f6d 6d61 6e64 732e  .@conf.commands.
+00002220: 7265 6769 7374 6572 0a64 6566 206c 696e  register.def lin
+00002230: 6568 6578 6475 6d70 2870 2c20 6f6e 6c79  ehexdump(p, only
+00002240: 6173 633d 302c 206f 6e6c 7968 6578 3d30  asc=0, onlyhex=0
+00002250: 2c20 6475 6d70 3d46 616c 7365 293a 0a20  , dump=False):. 
+00002260: 2020 2023 2074 7970 653a 2028 556e 696f     # type: (Unio
+00002270: 6e5b 5061 636b 6574 2c20 416e 7953 7472  n[Packet, AnyStr
+00002280: 5d2c 2069 6e74 2c20 696e 742c 2062 6f6f  ], int, int, boo
+00002290: 6c29 202d 3e20 4f70 7469 6f6e 616c 5b73  l) -> Optional[s
+000022a0: 7472 5d0a 2020 2020 2222 2242 7569 6c64  tr].    """Build
+000022b0: 2061 6e20 6571 7569 7661 6c65 6e74 2076   an equivalent v
+000022c0: 6965 7720 6f66 2068 6578 6475 6d70 2829  iew of hexdump()
+000022d0: 206f 6e20 6120 7369 6e67 6c65 206c 696e   on a single lin
+000022e0: 650a 0a20 2020 204e 6f74 6520 7468 6174  e..    Note that
+000022f0: 2073 6574 7469 6e67 2062 6f74 6820 6f6e   setting both on
+00002300: 6c79 6173 6320 616e 6420 6f6e 6c79 6865  lyasc and onlyhe
+00002310: 7820 746f 2031 2072 6573 756c 7473 2069  x to 1 results i
+00002320: 6e20 6120 656d 7074 7920 6f75 7470 7574  n a empty output
+00002330: 0a0a 2020 2020 3a70 6172 616d 2070 3a20  ..    :param p: 
+00002340: 6120 5061 636b 6574 0a20 2020 203a 7061  a Packet.    :pa
+00002350: 7261 6d20 6f6e 6c79 6173 633a 2031 2074  ram onlyasc: 1 t
+00002360: 6f20 6469 7370 6c61 7920 6f6e 6c79 2074  o display only t
+00002370: 6865 2061 7363 6969 2076 6965 770a 2020  he ascii view.  
+00002380: 2020 3a70 6172 616d 206f 6e6c 7968 6578    :param onlyhex
+00002390: 3a20 3120 746f 2064 6973 706c 6179 206f  : 1 to display o
+000023a0: 6e6c 7920 7468 6520 6865 7861 6465 6369  nly the hexadeci
+000023b0: 6d61 6c20 7669 6577 0a20 2020 203a 7061  mal view.    :pa
+000023c0: 7261 6d20 6475 6d70 3a20 7072 696e 7420  ram dump: print 
+000023d0: 7468 6520 7669 6577 2069 6620 4661 6c73  the view if Fals
+000023e0: 650a 2020 2020 3a72 6574 7572 6e3a 2061  e.    :return: a
+000023f0: 2053 7472 696e 6720 6f6e 6c79 2077 6865   String only whe
+00002400: 6e20 6475 6d70 3d54 7275 650a 2020 2020  n dump=True.    
+00002410: 2222 220a 2020 2020 7320 3d20 2222 0a20  """.    s = "". 
+00002420: 2020 2073 203d 2068 6578 7374 7228 702c     s = hexstr(p,
+00002430: 206f 6e6c 7961 7363 3d6f 6e6c 7961 7363   onlyasc=onlyasc
+00002440: 2c20 6f6e 6c79 6865 783d 6f6e 6c79 6865  , onlyhex=onlyhe
+00002450: 782c 2063 6f6c 6f72 3d6e 6f74 2064 756d  x, color=not dum
+00002460: 7029 0a20 2020 2069 6620 6475 6d70 3a0a  p).    if dump:.
+00002470: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00002480: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00002490: 2020 2070 7269 6e74 2873 290a 2020 2020     print(s).    
+000024a0: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
+000024b0: 0a0a 4063 6f6e 662e 636f 6d6d 616e 6473  ..@conf.commands
+000024c0: 2e72 6567 6973 7465 720a 6465 6620 6368  .register.def ch
+000024d0: 6578 6475 6d70 2870 2c20 6475 6d70 3d46  exdump(p, dump=F
+000024e0: 616c 7365 293a 0a20 2020 2023 2074 7970  alse):.    # typ
+000024f0: 653a 2028 556e 696f 6e5b 5061 636b 6574  e: (Union[Packet
+00002500: 2c20 416e 7953 7472 5d2c 2062 6f6f 6c29  , AnyStr], bool)
+00002510: 202d 3e20 4f70 7469 6f6e 616c 5b73 7472   -> Optional[str
+00002520: 5d0a 2020 2020 2222 2242 7569 6c64 2061  ].    """Build a
+00002530: 2070 6572 2062 7974 6520 6865 7861 6465   per byte hexade
+00002540: 6369 6d61 6c20 7265 7072 6573 656e 7461  cimal representa
+00002550: 7469 6f6e 0a0a 2020 2020 4578 616d 706c  tion..    Exampl
+00002560: 653a 0a20 2020 2020 2020 203e 3e3e 2063  e:.        >>> c
+00002570: 6865 7864 756d 7028 4950 2829 290a 2020  hexdump(IP()).  
+00002580: 2020 2020 2020 3078 3435 2c20 3078 3030        0x45, 0x00
+00002590: 2c20 3078 3030 2c20 3078 3134 2c20 3078  , 0x00, 0x14, 0x
+000025a0: 3030 2c20 3078 3031 2c20 3078 3030 2c20  00, 0x01, 0x00, 
+000025b0: 3078 3030 2c20 3078 3430 2c20 3078 3030  0x00, 0x40, 0x00
+000025c0: 2c20 3078 3763 2c20 3078 6537 2c20 3078  , 0x7c, 0xe7, 0x
+000025d0: 3766 2c20 3078 3030 2c20 3078 3030 2c20  7f, 0x00, 0x00, 
+000025e0: 3078 3031 2c20 3078 3766 2c20 3078 3030  0x01, 0x7f, 0x00
+000025f0: 2c20 3078 3030 2c20 3078 3031 2020 2320  , 0x00, 0x01  # 
+00002600: 6e6f 7161 3a20 4535 3031 0a0a 2020 2020  noqa: E501..    
+00002610: 3a70 6172 616d 2070 3a20 6120 5061 636b  :param p: a Pack
+00002620: 6574 0a20 2020 203a 7061 7261 6d20 6475  et.    :param du
+00002630: 6d70 3a20 7072 696e 7420 7468 6520 7669  mp: print the vi
+00002640: 6577 2069 6620 4661 6c73 650a 2020 2020  ew if False.    
+00002650: 3a72 6574 7572 6e3a 2061 2053 7472 696e  :return: a Strin
+00002660: 6720 6f6e 6c79 2069 6620 6475 6d70 3d54  g only if dump=T
+00002670: 7275 650a 2020 2020 2222 220a 2020 2020  rue.    """.    
+00002680: 7820 3d20 6279 7465 735f 656e 636f 6465  x = bytes_encode
+00002690: 2870 290a 2020 2020 7320 3d20 222c 2022  (p).    s = ", "
+000026a0: 2e6a 6f69 6e28 2225 2330 3478 2220 2520  .join("%#04x" % 
+000026b0: 6f72 6228 7829 2066 6f72 2078 2069 6e20  orb(x) for x in 
+000026c0: 7829 0a20 2020 2069 6620 6475 6d70 3a0a  x).    if dump:.
+000026d0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000026e0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+000026f0: 2020 2070 7269 6e74 2873 290a 2020 2020     print(s).    
+00002700: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
+00002710: 0a0a 4063 6f6e 662e 636f 6d6d 616e 6473  ..@conf.commands
+00002720: 2e72 6567 6973 7465 720a 6465 6620 6865  .register.def he
+00002730: 7873 7472 2870 2c20 6f6e 6c79 6173 633d  xstr(p, onlyasc=
+00002740: 302c 206f 6e6c 7968 6578 3d30 2c20 636f  0, onlyhex=0, co
+00002750: 6c6f 723d 4661 6c73 6529 3a0a 2020 2020  lor=False):.    
+00002760: 2320 7479 7065 3a20 2855 6e69 6f6e 5b50  # type: (Union[P
+00002770: 6163 6b65 742c 2041 6e79 5374 725d 2c20  acket, AnyStr], 
+00002780: 696e 742c 2069 6e74 2c20 626f 6f6c 2920  int, int, bool) 
+00002790: 2d3e 2073 7472 0a20 2020 2022 2222 4275  -> str.    """Bu
+000027a0: 696c 6420 6120 6661 6e63 7920 7463 7064  ild a fancy tcpd
+000027b0: 756d 7020 6c69 6b65 2068 6578 2066 726f  ump like hex fro
+000027c0: 6d20 6279 7465 732e 2222 220a 2020 2020  m bytes.""".    
+000027d0: 7820 3d20 6279 7465 735f 656e 636f 6465  x = bytes_encode
+000027e0: 2870 290a 2020 2020 7320 3d20 5b5d 0a20  (p).    s = []. 
+000027f0: 2020 2069 6620 6e6f 7420 6f6e 6c79 6173     if not onlyas
+00002800: 633a 0a20 2020 2020 2020 2073 2e61 7070  c:.        s.app
+00002810: 656e 6428 2220 222e 6a6f 696e 2822 2530  end(" ".join("%0
+00002820: 3258 2220 2520 6f72 6228 6229 2066 6f72  2X" % orb(b) for
+00002830: 2062 2069 6e20 7829 290a 2020 2020 6966   b in x)).    if
+00002840: 206e 6f74 206f 6e6c 7968 6578 3a0a 2020   not onlyhex:.  
+00002850: 2020 2020 2020 732e 6170 7065 6e64 2873        s.append(s
+00002860: 616e 6528 782c 2063 6f6c 6f72 3d63 6f6c  ane(x, color=col
+00002870: 6f72 2929 0a20 2020 2072 6574 7572 6e20  or)).    return 
+00002880: 2220 2022 2e6a 6f69 6e28 7329 0a0a 0a64  "  ".join(s)...d
+00002890: 6566 2072 6570 725f 6865 7828 7329 3a0a  ef repr_hex(s):.
+000028a0: 2020 2020 2320 7479 7065 3a20 2862 7974      # type: (byt
+000028b0: 6573 2920 2d3e 2073 7472 0a20 2020 2022  es) -> str.    "
+000028c0: 2222 2043 6f6e 7665 7274 2070 726f 7669  "" Convert provi
+000028d0: 6465 6420 6269 7473 7472 696e 6720 746f  ded bitstring to
+000028e0: 2061 2073 696d 706c 6520 7374 7269 6e67   a simple string
+000028f0: 206f 6620 6865 7820 6469 6769 7473 2022   of hex digits "
+00002900: 2222 0a20 2020 2072 6574 7572 6e20 2222  "".    return ""
+00002910: 2e6a 6f69 6e28 2225 3032 7822 2025 206f  .join("%02x" % o
+00002920: 7262 2878 2920 666f 7220 7820 696e 2073  rb(x) for x in s
+00002930: 290a 0a0a 4063 6f6e 662e 636f 6d6d 616e  )...@conf.comman
+00002940: 6473 2e72 6567 6973 7465 720a 6465 6620  ds.register.def 
+00002950: 6865 7864 6966 6628 0a20 2020 2061 3a20  hexdiff(.    a: 
+00002960: 556e 696f 6e5b 2750 6163 6b65 7427 2c20  Union['Packet', 
+00002970: 416e 7953 7472 5d2c 0a20 2020 2062 3a20  AnyStr],.    b: 
+00002980: 556e 696f 6e5b 2750 6163 6b65 7427 2c20  Union['Packet', 
+00002990: 416e 7953 7472 5d2c 0a20 2020 2061 6c67  AnyStr],.    alg
+000029a0: 6f3a 204f 7074 696f 6e61 6c5b 7374 725d  o: Optional[str]
+000029b0: 203d 204e 6f6e 652c 0a20 2020 2061 7574   = None,.    aut
+000029c0: 6f6a 756e 6b3a 2062 6f6f 6c20 3d20 4661  ojunk: bool = Fa
+000029d0: 6c73 652c 0a29 202d 3e20 4e6f 6e65 3a0a  lse,.) -> None:.
+000029e0: 2020 2020 2222 220a 2020 2020 5368 6f77      """.    Show
+000029f0: 2064 6966 6665 7265 6e63 6573 2062 6574   differences bet
+00002a00: 7765 656e 2032 2062 696e 6172 7920 7374  ween 2 binary st
+00002a10: 7269 6e67 732c 2050 6163 6b65 7473 2e2e  rings, Packets..
+00002a20: 2e0a 0a20 2020 2041 7661 696c 6162 6c65  ...    Available
+00002a30: 2061 6c67 6f72 6974 686d 733a 0a20 2020   algorithms:.   
+00002a40: 2020 2020 202d 2077 6167 6e65 7266 6973       - wagnerfis
+00002a50: 6368 6572 3a20 5573 6520 7468 6520 5761  cher: Use the Wa
+00002a60: 676e 6572 2061 6e64 2046 6973 6368 6572  gner and Fischer
+00002a70: 2061 6c67 6f72 6974 686d 2074 6f20 636f   algorithm to co
+00002a80: 6d70 7574 6520 7468 650a 2020 2020 2020  mpute the.      
+00002a90: 2020 2020 4c65 7665 6e73 7465 696e 2064      Levenstein d
+00002aa0: 6973 7461 6e63 6520 6265 7477 6565 6e20  istance between 
+00002ab0: 7468 6520 7374 7269 6e67 7320 7468 656e  the strings then
+00002ac0: 2062 6163 6b74 7261 636b 2e0a 2020 2020   backtrack..    
+00002ad0: 2020 2020 2d20 6469 6666 6c69 623a 2055      - difflib: U
+00002ae0: 7365 2074 6865 2064 6966 666c 6962 2e53  se the difflib.S
+00002af0: 6571 7565 6e63 654d 6174 6368 6572 2069  equenceMatcher i
+00002b00: 6d70 6c65 6d65 6e74 6174 696f 6e2e 2054  mplementation. T
+00002b10: 6869 7320 6261 7365 6420 6f6e 2061 0a20  his based on a. 
+00002b20: 2020 2020 2020 2020 206d 6f64 6966 6965           modifie
+00002b30: 6420 7665 7273 696f 6e20 6f66 2074 6865  d version of the
+00002b40: 2052 6174 636c 6966 6620 616e 6420 4f62   Ratcliff and Ob
+00002b50: 6572 7368 656c 7020 616c 676f 7269 7468  ershelp algorith
+00002b60: 6d2e 0a20 2020 2020 2020 2020 2054 6869  m..          Thi
+00002b70: 7320 6973 206d 7563 6820 6661 7374 6572  s is much faster
+00002b80: 2c20 6275 7420 6661 7220 6c65 7373 2061  , but far less a
+00002b90: 6363 7572 6174 652e 0a20 2020 2020 2020  ccurate..       
+00002ba0: 2020 2068 7474 7073 3a2f 2f64 6f63 732e     https://docs.
+00002bb0: 7079 7468 6f6e 2e6f 7267 2f33 2e38 2f6c  python.org/3.8/l
+00002bc0: 6962 7261 7279 2f64 6966 666c 6962 2e68  ibrary/difflib.h
+00002bd0: 746d 6c23 6469 6666 6c69 622e 5365 7175  tml#difflib.Sequ
+00002be0: 656e 6365 4d61 7463 6865 720a 0a20 2020  enceMatcher..   
+00002bf0: 203a 7061 7261 6d20 613a 0a20 2020 203a   :param a:.    :
+00002c00: 7061 7261 6d20 623a 2054 6865 2062 696e  param b: The bin
+00002c10: 6172 7920 7374 7269 6e67 732c 2070 6163  ary strings, pac
+00002c20: 6b65 7473 2e2e 2e20 746f 2063 6f6d 7061  kets... to compa
+00002c30: 7265 0a20 2020 203a 7061 7261 6d20 616c  re.    :param al
+00002c40: 676f 3a20 466f 7263 6520 7468 6520 616c  go: Force the al
+00002c50: 676f 2074 6f20 6265 2027 7761 676e 6572  go to be 'wagner
+00002c60: 6669 7363 6865 7227 206f 7220 2764 6966  fischer' or 'dif
+00002c70: 666c 6962 272e 0a20 2020 2020 2020 2020  flib'..         
+00002c80: 2020 2020 2020 2020 4279 2064 6566 6175          By defau
+00002c90: 6c74 2c20 7468 6973 2069 7320 6368 6f73  lt, this is chos
+00002ca0: 656e 2064 6570 656e 6469 6e67 206f 6e20  en depending on 
+00002cb0: 7468 6520 636f 6d70 6c65 7869 7479 2c20  the complexity, 
+00002cc0: 6f70 7469 6d69 7374 6963 616c 6c79 0a20  optimistically. 
+00002cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ce0: 7072 6566 6572 7269 6e67 2077 6167 6e65  preferring wagne
+00002cf0: 7266 6973 6368 6572 2075 6e6c 6573 7320  rfischer unless 
+00002d00: 7265 616c 6c79 206e 6563 6573 7361 7279  really necessary
+00002d10: 2e0a 2020 2020 3a70 6172 616d 2061 7574  ..    :param aut
+00002d20: 6f6a 756e 6b3a 2028 6469 6666 6c69 6220  ojunk: (difflib 
+00002d30: 6f6e 6c79 2920 5365 6520 6469 6666 6c69  only) See diffli
+00002d40: 6220 646f 6375 6d65 6e74 6174 696f 6e2e  b documentation.
+00002d50: 0a20 2020 2022 2222 0a20 2020 2078 6220  .    """.    xb 
+00002d60: 3d20 6279 7465 735f 656e 636f 6465 2861  = bytes_encode(a
+00002d70: 290a 2020 2020 7962 203d 2062 7974 6573  ).    yb = bytes
+00002d80: 5f65 6e63 6f64 6528 6229 0a0a 2020 2020  _encode(b)..    
+00002d90: 6966 2061 6c67 6f20 6973 204e 6f6e 653a  if algo is None:
+00002da0: 0a20 2020 2020 2020 2023 2043 686f 6f73  .        # Choos
+00002db0: 6520 7468 6520 6265 7374 2061 6c67 6f72  e the best algor
+00002dc0: 6974 686d 0a20 2020 2020 2020 2063 6f6d  ithm.        com
+00002dd0: 706c 6578 6974 7920 3d20 6c65 6e28 7862  plexity = len(xb
+00002de0: 2920 2a20 6c65 6e28 7962 290a 2020 2020  ) * len(yb).    
+00002df0: 2020 2020 6966 2063 6f6d 706c 6578 6974      if complexit
+00002e00: 7920 3c20 3165 373a 0a20 2020 2020 2020  y < 1e7:.       
+00002e10: 2020 2020 2023 2043 6f6d 7061 7269 6e67       # Comparing
+00002e20: 2074 776f 2028 6e6f 6e2d 6a75 6d62 6f73   two (non-jumbos
+00002e30: 2920 4574 6865 726e 6574 2070 6163 6b65  ) Ethernet packe
+00002e40: 7473 2069 7320 7e32 6536 2077 6869 6368  ts is ~2e6 which
+00002e50: 2069 7320 6d61 6e61 6765 6162 6c65 2e0a   is manageable..
+00002e60: 2020 2020 2020 2020 2020 2020 2320 416e              # An
+00002e70: 7974 6869 6e67 206d 7563 6820 6c61 7267  ything much larg
+00002e80: 6572 2074 6861 6e20 7468 6973 2073 686f  er than this sho
+00002e90: 756c 646e 2774 2062 6520 6174 7465 6d70  uldn't be attemp
+00002ea0: 7465 6420 6279 2064 6566 6175 6c74 2e0a  ted by default..
+00002eb0: 2020 2020 2020 2020 2020 2020 616c 676f              algo
+00002ec0: 203d 2022 7761 676e 6572 6669 7363 6865   = "wagnerfische
+00002ed0: 7222 0a20 2020 2020 2020 2020 2020 2069  r".            i
+00002ee0: 6620 636f 6d70 6c65 7869 7479 203e 2031  f complexity > 1
+00002ef0: 6536 3a0a 2020 2020 2020 2020 2020 2020  e6:.            
+00002f00: 2020 2020 6c6f 675f 696e 7465 7261 6374      log_interact
+00002f10: 6976 652e 696e 666f 280a 2020 2020 2020  ive.info(.      
+00002f20: 2020 2020 2020 2020 2020 2020 2020 2243                "C
+00002f30: 6f6d 706c 6578 6974 7920 6973 2061 2062  omplexity is a b
+00002f40: 6974 2068 6967 682e 2068 6578 6469 6666  it high. hexdiff
+00002f50: 2077 696c 6c20 7461 6b65 2061 2066 6577   will take a few
+00002f60: 2073 6563 6f6e 6473 2e22 0a20 2020 2020   seconds.".     
+00002f70: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00002f80: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00002f90: 2020 2020 2020 2061 6c67 6f20 3d20 2264         algo = "d
+00002fa0: 6966 666c 6962 220a 0a20 2020 2062 6163  ifflib"..    bac
+00002fb0: 6b74 7261 636b 7820 3d20 5b5d 0a20 2020  ktrackx = [].   
+00002fc0: 2062 6163 6b74 7261 636b 7920 3d20 5b5d   backtracky = []
+00002fd0: 0a0a 2020 2020 6966 2061 6c67 6f20 3d3d  ..    if algo ==
+00002fe0: 2022 7761 676e 6572 6669 7363 6865 7222   "wagnerfischer"
+00002ff0: 3a0a 2020 2020 2020 2020 7862 203d 2078  :.        xb = x
+00003000: 625b 3a3a 2d31 5d0a 2020 2020 2020 2020  b[::-1].        
+00003010: 7962 203d 2079 625b 3a3a 2d31 5d0a 0a20  yb = yb[::-1].. 
+00003020: 2020 2020 2020 2023 2063 6f73 7473 2066         # costs f
+00003030: 6f72 2074 6865 2033 206f 7065 7261 7469  or the 3 operati
+00003040: 6f6e 730a 2020 2020 2020 2020 494e 5345  ons.        INSE
+00003050: 5254 203d 2031 0a20 2020 2020 2020 2044  RT = 1.        D
+00003060: 454c 4554 4520 3d20 310a 2020 2020 2020  ELETE = 1.      
+00003070: 2020 5355 4253 5420 3d20 310a 0a20 2020    SUBST = 1..   
+00003080: 2020 2020 2023 2054 7970 6963 616c 6c79       # Typically
+00003090: 2c20 645b 692c 6a5d 2077 696c 6c20 686f  , d[i,j] will ho
+000030a0: 6c64 2074 6865 2064 6973 7461 6e63 6520  ld the distance 
+000030b0: 6265 7477 6565 6e0a 2020 2020 2020 2020  between.        
+000030c0: 2320 7468 6520 6669 7273 7420 6920 6368  # the first i ch
+000030d0: 6172 6163 7465 7273 206f 6620 7862 2061  aracters of xb a
+000030e0: 6e64 2074 6865 2066 6972 7374 206a 2063  nd the first j c
+000030f0: 6861 7261 6374 6572 7320 6f66 2079 622e  haracters of yb.
+00003100: 0a20 2020 2020 2020 2023 2057 6520 6368  .        # We ch
+00003110: 616e 6765 2074 6865 2057 6167 6e65 7220  ange the Wagner 
+00003120: 4669 7363 6865 7220 746f 2061 6c73 6f20  Fischer to also 
+00003130: 7374 6f72 6520 706f 696e 7465 7273 2074  store pointers t
+00003140: 6f20 616c 6c0a 2020 2020 2020 2020 2320  o all.        # 
+00003150: 7468 6520 696e 7465 726d 6564 6961 7465  the intermediate
+00003160: 2073 7465 7073 2074 616b 656e 2077 6869   steps taken whi
+00003170: 6c65 2063 616c 6375 6c61 7469 6e67 2074  le calculating t
+00003180: 6865 204c 6576 656e 7374 6569 6e20 6469  he Levenstein di
+00003190: 7374 616e 6365 2e0a 2020 2020 2020 2020  stance..        
+000031a0: 6420 3d20 7b28 2d31 2c20 2d31 293a 2028  d = {(-1, -1): (
+000031b0: 302c 2028 2d31 2c20 2d31 2929 7d0a 2020  0, (-1, -1))}.  
+000031c0: 2020 2020 2020 666f 7220 6a20 696e 2072        for j in r
+000031d0: 616e 6765 286c 656e 2879 6229 293a 0a20  ange(len(yb)):. 
+000031e0: 2020 2020 2020 2020 2020 2064 5b2d 312c             d[-1,
+000031f0: 206a 5d20 3d20 286a 202b 2031 2920 2a20   j] = (j + 1) * 
+00003200: 494e 5345 5254 2c20 282d 312c 206a 202d  INSERT, (-1, j -
+00003210: 2031 290a 2020 2020 2020 2020 666f 7220   1).        for 
+00003220: 6920 696e 2072 616e 6765 286c 656e 2878  i in range(len(x
+00003230: 6229 293a 0a20 2020 2020 2020 2020 2020  b)):.           
+00003240: 2064 5b69 2c20 2d31 5d20 3d20 2869 202b   d[i, -1] = (i +
+00003250: 2031 2920 2a20 494e 5345 5254 202b 2031   1) * INSERT + 1
+00003260: 2c20 2869 202d 2031 2c20 2d31 290a 0a20  , (i - 1, -1).. 
+00003270: 2020 2020 2020 2023 2043 6f6d 7075 7465         # Compute
+00003280: 2074 6865 204c 6576 656e 7374 6569 6e20   the Levenstein 
+00003290: 6469 7374 616e 6365 2062 6574 7765 656e  distance between
+000032a0: 2074 6865 2074 776f 2073 7472 696e 6773   the two strings
+000032b0: 2c20 6275 740a 2020 2020 2020 2020 2320  , but.        # 
+000032c0: 7374 6f72 6520 616c 6c20 7468 6520 7374  store all the st
+000032d0: 6570 7320 746f 2062 6520 6162 6c65 2074  eps to be able t
+000032e0: 6f20 6261 636b 7472 6163 6b20 6174 2074  o backtrack at t
+000032f0: 6865 2065 6e64 2e0a 2020 2020 2020 2020  he end..        
+00003300: 666f 7220 6a20 696e 2072 616e 6765 286c  for j in range(l
+00003310: 656e 2879 6229 293a 0a20 2020 2020 2020  en(yb)):.       
+00003320: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
+00003330: 6e67 6528 6c65 6e28 7862 2929 3a0a 2020  nge(len(xb)):.  
+00003340: 2020 2020 2020 2020 2020 2020 2020 645b                d[
+00003350: 692c 206a 5d20 3d20 6d69 6e28 0a20 2020  i, j] = min(.   
+00003360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003370: 2028 645b 6920 2d20 312c 206a 202d 2031   (d[i - 1, j - 1
+00003380: 5d5b 305d 202b 2053 5542 5354 202a 2028  ][0] + SUBST * (
+00003390: 7862 5b69 5d20 213d 2079 625b 6a5d 292c  xb[i] != yb[j]),
+000033a0: 2028 6920 2d20 312c 206a 202d 2031 2929   (i - 1, j - 1))
+000033b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000033c0: 2020 2020 2020 2864 5b69 202d 2031 2c20        (d[i - 1, 
+000033d0: 6a5d 5b30 5d20 2b20 4445 4c45 5445 2c20  j][0] + DELETE, 
+000033e0: 2869 202d 2031 2c20 6a29 292c 0a20 2020  (i - 1, j)),.   
+000033f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003400: 2028 645b 692c 206a 202d 2031 5d5b 305d   (d[i, j - 1][0]
+00003410: 202b 2049 4e53 4552 542c 2028 692c 206a   + INSERT, (i, j
+00003420: 202d 2031 2929 2c0a 2020 2020 2020 2020   - 1)),.        
+00003430: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+00003440: 2020 2023 2049 7465 7261 7465 2074 6872     # Iterate thr
+00003450: 6f75 6768 2074 6865 2073 7465 7073 2062  ough the steps b
+00003460: 6163 6b77 6172 6473 2074 6f20 6372 6561  ackwards to crea
+00003470: 7465 2074 6865 2064 6966 660a 2020 2020  te the diff.    
+00003480: 2020 2020 6920 3d20 6c65 6e28 7862 2920      i = len(xb) 
+00003490: 2d20 310a 2020 2020 2020 2020 6a20 3d20  - 1.        j = 
+000034a0: 6c65 6e28 7962 2920 2d20 310a 2020 2020  len(yb) - 1.    
+000034b0: 2020 2020 7768 696c 6520 6e6f 7420 2869      while not (i
+000034c0: 203d 3d20 6a20 3d3d 202d 3129 3a0a 2020   == j == -1):.  
+000034d0: 2020 2020 2020 2020 2020 6932 2c20 6a32            i2, j2
+000034e0: 203d 2064 5b69 2c20 6a5d 5b31 5d0a 2020   = d[i, j][1].  
+000034f0: 2020 2020 2020 2020 2020 6261 636b 7472            backtr
+00003500: 6163 6b78 2e61 7070 656e 6428 7862 5b69  ackx.append(xb[i
+00003510: 3220 2b20 313a 6920 2b20 315d 290a 2020  2 + 1:i + 1]).  
+00003520: 2020 2020 2020 2020 2020 6261 636b 7472            backtr
+00003530: 6163 6b79 2e61 7070 656e 6428 7962 5b6a  acky.append(yb[j
+00003540: 3220 2b20 313a 6a20 2b20 315d 290a 2020  2 + 1:j + 1]).  
+00003550: 2020 2020 2020 2020 2020 692c 206a 203d            i, j =
+00003560: 2069 322c 206a 320a 2020 2020 656c 6966   i2, j2.    elif
+00003570: 2061 6c67 6f20 3d3d 2022 6469 6666 6c69   algo == "diffli
+00003580: 6222 3a0a 2020 2020 2020 2020 736d 203d  b":.        sm =
+00003590: 2064 6966 666c 6962 2e53 6571 7565 6e63   difflib.Sequenc
+000035a0: 654d 6174 6368 6572 2861 3d78 622c 2062  eMatcher(a=xb, b
+000035b0: 3d79 622c 2061 7574 6f6a 756e 6b3d 6175  =yb, autojunk=au
+000035c0: 746f 6a75 6e6b 290a 2020 2020 2020 2020  tojunk).        
+000035d0: 7861 7272 203d 205b 7862 5b69 3a69 202b  xarr = [xb[i:i +
+000035e0: 2031 5d20 666f 7220 6920 696e 2072 616e   1] for i in ran
+000035f0: 6765 286c 656e 2878 6229 295d 0a20 2020  ge(len(xb))].   
+00003600: 2020 2020 2079 6172 7220 3d20 5b79 625b       yarr = [yb[
+00003610: 693a 6920 2b20 315d 2066 6f72 2069 2069  i:i + 1] for i i
+00003620: 6e20 7261 6e67 6528 6c65 6e28 7962 2929  n range(len(yb))
+00003630: 5d0a 2020 2020 2020 2020 2320 4974 6572  ].        # Iter
+00003640: 6174 6520 7468 726f 7567 6820 6f70 636f  ate through opco
+00003650: 6465 7320 746f 2062 7569 6c64 2074 6865  des to build the
+00003660: 2062 6163 6b74 7261 636b 0a20 2020 2020   backtrack.     
+00003670: 2020 2066 6f72 206f 7063 6f64 6520 696e     for opcode in
+00003680: 2073 6d2e 6765 745f 6f70 636f 6465 7328   sm.get_opcodes(
+00003690: 293a 0a20 2020 2020 2020 2020 2020 2074  ):.            t
+000036a0: 7970 2c20 7830 2c20 7831 2c20 7930 2c20  yp, x0, x1, y0, 
+000036b0: 7931 203d 206f 7063 6f64 650a 2020 2020  y1 = opcode.    
+000036c0: 2020 2020 2020 2020 6966 2074 7970 203d          if typ =
+000036d0: 3d20 2764 656c 6574 6527 3a0a 2020 2020  = 'delete':.    
+000036e0: 2020 2020 2020 2020 2020 2020 6261 636b              back
+000036f0: 7472 6163 6b78 202b 3d20 7861 7272 5b78  trackx += xarr[x
+00003700: 303a 7831 5d0a 2020 2020 2020 2020 2020  0:x1].          
+00003710: 2020 2020 2020 6261 636b 7472 6163 6b79        backtracky
+00003720: 202b 3d20 5b62 2727 5d20 2a20 2878 3120   += [b''] * (x1 
+00003730: 2d20 7830 290a 2020 2020 2020 2020 2020  - x0).          
+00003740: 2020 656c 6966 2074 7970 203d 3d20 2769    elif typ == 'i
+00003750: 6e73 6572 7427 3a0a 2020 2020 2020 2020  nsert':.        
+00003760: 2020 2020 2020 2020 6261 636b 7472 6163          backtrac
+00003770: 6b78 202b 3d20 5b62 2727 5d20 2a20 2879  kx += [b''] * (y
+00003780: 3120 2d20 7930 290a 2020 2020 2020 2020  1 - y0).        
+00003790: 2020 2020 2020 2020 6261 636b 7472 6163          backtrac
+000037a0: 6b79 202b 3d20 7961 7272 5b79 303a 7931  ky += yarr[y0:y1
+000037b0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
+000037c0: 6966 2074 7970 2069 6e20 5b27 6571 7561  if typ in ['equa
+000037d0: 6c27 2c20 2772 6570 6c61 6365 275d 3a0a  l', 'replace']:.
+000037e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000037f0: 6261 636b 7472 6163 6b78 202b 3d20 7861  backtrackx += xa
+00003800: 7272 5b78 303a 7831 5d0a 2020 2020 2020  rr[x0:x1].      
+00003810: 2020 2020 2020 2020 2020 6261 636b 7472            backtr
+00003820: 6163 6b79 202b 3d20 7961 7272 5b79 303a  acky += yarr[y0:
+00003830: 7931 5d0a 2020 2020 2020 2020 2320 536f  y1].        # So
+00003840: 6d65 206c 696e 6573 206d 6179 2068 6176  me lines may hav
+00003850: 6520 6265 656e 2063 6f6e 7369 6465 7265  e been considere
+00003860: 6420 6173 206a 756e 6b2e 2043 6865 636b  d as junk. Check
+00003870: 2074 6865 2073 697a 6573 0a20 2020 2020   the sizes.     
+00003880: 2020 2069 6620 6175 746f 6a75 6e6b 3a0a     if autojunk:.
+00003890: 2020 2020 2020 2020 2020 2020 6c62 7820              lbx 
+000038a0: 3d20 6c65 6e28 6261 636b 7472 6163 6b78  = len(backtrackx
+000038b0: 290a 2020 2020 2020 2020 2020 2020 6c62  ).            lb
+000038c0: 7920 3d20 6c65 6e28 6261 636b 7472 6163  y = len(backtrac
+000038d0: 6b79 290a 2020 2020 2020 2020 2020 2020  ky).            
+000038e0: 6261 636b 7472 6163 6b78 202b 3d20 5b62  backtrackx += [b
+000038f0: 2727 5d20 2a20 286d 6178 286c 6278 2c20  ''] * (max(lbx, 
+00003900: 6c62 7929 202d 206c 6278 290a 2020 2020  lby) - lbx).    
+00003910: 2020 2020 2020 2020 6261 636b 7472 6163          backtrac
+00003920: 6b79 202b 3d20 5b62 2727 5d20 2a20 286d  ky += [b''] * (m
+00003930: 6178 286c 6278 2c20 6c62 7929 202d 206c  ax(lbx, lby) - l
+00003940: 6279 290a 2020 2020 656c 7365 3a0a 2020  by).    else:.  
+00003950: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00003960: 6545 7272 6f72 2822 556e 6b6e 6f77 6e20  eError("Unknown 
+00003970: 616c 676f 7269 7468 6d20 2725 7327 2220  algorithm '%s'" 
+00003980: 2520 616c 676f 290a 0a20 2020 2023 2050  % algo)..    # P
+00003990: 7269 6e74 2074 6865 2064 6966 660a 0a20  rint the diff.. 
+000039a0: 2020 2078 203d 2079 203d 2069 203d 2030     x = y = i = 0
+000039b0: 0a20 2020 2063 6f6c 6f72 697a 653a 2044  .    colorize: D
+000039c0: 6963 745b 696e 742c 2043 616c 6c61 626c  ict[int, Callabl
+000039d0: 655b 5b73 7472 5d2c 2073 7472 5d5d 203d  e[[str], str]] =
+000039e0: 207b 0a20 2020 2020 2020 2030 3a20 6c61   {.        0: la
+000039f0: 6d62 6461 2078 3a20 782c 0a20 2020 2020  mbda x: x,.     
+00003a00: 2020 202d 313a 2063 6f6e 662e 636f 6c6f     -1: conf.colo
+00003a10: 725f 7468 656d 652e 6c65 6674 2c0a 2020  r_theme.left,.  
+00003a20: 2020 2020 2020 313a 2063 6f6e 662e 636f        1: conf.co
+00003a30: 6c6f 725f 7468 656d 652e 7269 6768 740a  lor_theme.right.
+00003a40: 2020 2020 7d0a 0a20 2020 2064 6f78 203d      }..    dox =
+00003a50: 2031 0a20 2020 2064 6f79 203d 2030 0a20   1.    doy = 0. 
+00003a60: 2020 2062 7478 5f6c 656e 203d 206c 656e     btx_len = len
+00003a70: 2862 6163 6b74 7261 636b 7829 0a20 2020  (backtrackx).   
+00003a80: 2077 6869 6c65 2069 203c 2062 7478 5f6c   while i < btx_l
+00003a90: 656e 3a0a 2020 2020 2020 2020 6c69 6e65  en:.        line
+00003aa0: 7820 3d20 6261 636b 7472 6163 6b78 5b69  x = backtrackx[i
+00003ab0: 3a69 202b 2031 365d 0a20 2020 2020 2020  :i + 16].       
+00003ac0: 206c 696e 6579 203d 2062 6163 6b74 7261   liney = backtra
+00003ad0: 636b 795b 693a 6920 2b20 3136 5d0a 2020  cky[i:i + 16].  
+00003ae0: 2020 2020 2020 7878 203d 2073 756d 286c        xx = sum(l
+00003af0: 656e 286b 2920 666f 7220 6b20 696e 206c  en(k) for k in l
+00003b00: 696e 6578 290a 2020 2020 2020 2020 7979  inex).        yy
+00003b10: 203d 2073 756d 286c 656e 286b 2920 666f   = sum(len(k) fo
+00003b20: 7220 6b20 696e 206c 696e 6579 290a 2020  r k in liney).  
+00003b30: 2020 2020 2020 6966 2064 6f78 2061 6e64        if dox and
+00003b40: 206e 6f74 2078 783a 0a20 2020 2020 2020   not xx:.       
+00003b50: 2020 2020 2064 6f78 203d 2030 0a20 2020       dox = 0.   
+00003b60: 2020 2020 2020 2020 2064 6f79 203d 2031           doy = 1
+00003b70: 0a20 2020 2020 2020 2069 6620 646f 7820  .        if dox 
+00003b80: 616e 6420 6c69 6e65 7820 3d3d 206c 696e  and linex == lin
+00003b90: 6579 3a0a 2020 2020 2020 2020 2020 2020  ey:.            
+00003ba0: 646f 7920 3d20 310a 0a20 2020 2020 2020  doy = 1..       
+00003bb0: 2069 6620 646f 783a 0a20 2020 2020 2020   if dox:.       
+00003bc0: 2020 2020 2078 6420 3d20 790a 2020 2020       xd = y.    
+00003bd0: 2020 2020 2020 2020 6a20 3d20 300a 2020          j = 0.  
+00003be0: 2020 2020 2020 2020 2020 7768 696c 6520            while 
+00003bf0: 6e6f 7420 6c69 6e65 785b 6a5d 3a0a 2020  not linex[j]:.  
+00003c00: 2020 2020 2020 2020 2020 2020 2020 6a20                j 
+00003c10: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+00003c20: 2020 2020 2078 6420 2d3d 2031 0a20 2020       xd -= 1.   
+00003c30: 2020 2020 2020 2020 2070 7269 6e74 2863           print(c
+00003c40: 6f6c 6f72 697a 655b 646f 7920 2d20 646f  olorize[doy - do
+00003c50: 785d 2822 2530 3478 2220 2520 7864 292c  x]("%04x" % xd),
+00003c60: 2065 6e64 3d27 2027 290a 2020 2020 2020   end=' ').      
+00003c70: 2020 2020 2020 7820 2b3d 2078 780a 2020        x += xx.  
+00003c80: 2020 2020 2020 2020 2020 6c69 6e65 203d            line =
+00003c90: 206c 696e 6578 0a20 2020 2020 2020 2065   linex.        e
+00003ca0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00003cb0: 2070 7269 6e74 2822 2020 2020 222c 2065   print("    ", e
+00003cc0: 6e64 3d27 2027 290a 2020 2020 2020 2020  nd=' ').        
+00003cd0: 6966 2064 6f79 3a0a 2020 2020 2020 2020  if doy:.        
+00003ce0: 2020 2020 7964 203d 2079 0a20 2020 2020      yd = y.     
+00003cf0: 2020 2020 2020 206a 203d 2030 0a20 2020         j = 0.   
+00003d00: 2020 2020 2020 2020 2077 6869 6c65 206e           while n
+00003d10: 6f74 206c 696e 6579 5b6a 5d3a 0a20 2020  ot liney[j]:.   
+00003d20: 2020 2020 2020 2020 2020 2020 206a 202b               j +
+00003d30: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
+00003d40: 2020 2020 7964 202d 3d20 310a 2020 2020      yd -= 1.    
+00003d50: 2020 2020 2020 2020 7072 696e 7428 636f          print(co
+00003d60: 6c6f 7269 7a65 5b64 6f79 202d 2064 6f78  lorize[doy - dox
+00003d70: 5d28 2225 3034 7822 2025 2079 6429 2c20  ]("%04x" % yd), 
+00003d80: 656e 643d 2720 2729 0a20 2020 2020 2020  end=' ').       
+00003d90: 2020 2020 2079 202b 3d20 7979 0a20 2020       y += yy.   
+00003da0: 2020 2020 2020 2020 206c 696e 6520 3d20           line = 
+00003db0: 6c69 6e65 790a 2020 2020 2020 2020 656c  liney.        el
+00003dc0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00003dd0: 7072 696e 7428 2220 2020 2022 2c20 656e  print("    ", en
+00003de0: 643d 2720 2729 0a0a 2020 2020 2020 2020  d=' ')..        
+00003df0: 7072 696e 7428 2220 222c 2065 6e64 3d27  print(" ", end='
+00003e00: 2027 290a 0a20 2020 2020 2020 2063 6c20   ')..        cl 
+00003e10: 3d20 2222 0a20 2020 2020 2020 2066 6f72  = "".        for
+00003e20: 206a 2069 6e20 7261 6e67 6528 3136 293a   j in range(16):
+00003e30: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00003e40: 6920 2b20 6a20 3c20 6d69 6e28 6c65 6e28  i + j < min(len(
+00003e50: 6261 636b 7472 6163 6b78 292c 206c 656e  backtrackx), len
+00003e60: 2862 6163 6b74 7261 636b 7929 293a 0a20  (backtracky)):. 
+00003e70: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00003e80: 6620 6c69 6e65 5b6a 5d3a 0a20 2020 2020  f line[j]:.     
+00003e90: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00003ea0: 6f6c 203d 2063 6f6c 6f72 697a 655b 286c  ol = colorize[(l
+00003eb0: 696e 6578 5b6a 5d20 213d 206c 696e 6579  inex[j] != liney
+00003ec0: 5b6a 5d29 202a 2028 646f 7920 2d20 646f  [j]) * (doy - do
+00003ed0: 7829 5d0a 2020 2020 2020 2020 2020 2020  x)].            
+00003ee0: 2020 2020 2020 2020 7072 696e 7428 636f          print(co
+00003ef0: 6c28 2225 3032 5822 2025 206f 7262 286c  l("%02X" % orb(l
+00003f00: 696e 655b 6a5d 2929 2c20 656e 643d 2720  ine[j])), end=' 
+00003f10: 2729 0a20 2020 2020 2020 2020 2020 2020  ').             
+00003f20: 2020 2020 2020 2069 6620 6c69 6e65 785b         if linex[
+00003f30: 6a5d 203d 3d20 6c69 6e65 795b 6a5d 3a0a  j] == liney[j]:.
+00003f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003f50: 2020 2020 2020 2020 636c 202b 3d20 7361          cl += sa
+00003f60: 6e65 286c 696e 655b 6a5d 2c20 636f 6c6f  ne(line[j], colo
+00003f70: 723d 5472 7565 290a 2020 2020 2020 2020  r=True).        
+00003f80: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00003f90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00003fa0: 2020 2020 2020 2020 2020 636c 202b 3d20            cl += 
+00003fb0: 636f 6c28 7361 6e65 286c 696e 655b 6a5d  col(sane(line[j]
+00003fc0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00003fd0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00003fe0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+00003ff0: 6e74 2822 2020 222c 2065 6e64 3d27 2027  nt("  ", end=' '
+00004000: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00004010: 2020 2020 2020 636c 202b 3d20 2220 220a        cl += " ".
+00004020: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00004030: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00004040: 2020 7072 696e 7428 2220 2022 2c20 656e    print("  ", en
+00004050: 643d 2720 2729 0a20 2020 2020 2020 2020  d=' ').         
+00004060: 2020 2069 6620 6a20 3d3d 2037 3a0a 2020     if j == 7:.  
+00004070: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00004080: 696e 7428 2222 2c20 656e 643d 2720 2729  int("", end=' ')
+00004090: 0a0a 2020 2020 2020 2020 7072 696e 7428  ..        print(
+000040a0: 2220 222c 2063 6c29 0a0a 2020 2020 2020  " ", cl)..      
+000040b0: 2020 6966 2064 6f79 206f 7220 6e6f 7420    if doy or not 
+000040c0: 7979 3a0a 2020 2020 2020 2020 2020 2020  yy:.            
+000040d0: 646f 7920 3d20 300a 2020 2020 2020 2020  doy = 0.        
+000040e0: 2020 2020 646f 7820 3d20 310a 2020 2020      dox = 1.    
+000040f0: 2020 2020 2020 2020 6920 2b3d 2031 360a          i += 16.
+00004100: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004110: 2020 2020 2020 2020 2020 6966 2079 793a            if yy:
+00004120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004130: 2064 6f78 203d 2030 0a20 2020 2020 2020   dox = 0.       
+00004140: 2020 2020 2020 2020 2064 6f79 203d 2031           doy = 1
+00004150: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+00004160: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00004170: 2020 2069 202b 3d20 3136 0a0a 0a69 6620     i += 16...if 
+00004180: 7374 7275 6374 2e70 6163 6b28 2248 222c  struct.pack("H",
+00004190: 2031 2920 3d3d 2062 225c 7830 305c 7830   1) == b"\x00\x0
+000041a0: 3122 3a20 2023 2062 6967 2065 6e64 6961  1":  # big endia
+000041b0: 6e0a 2020 2020 6368 6563 6b73 756d 5f65  n.    checksum_e
+000041c0: 6e64 6961 6e5f 7472 616e 7366 6f72 6d20  ndian_transform 
+000041d0: 3d20 6c61 6d62 6461 2063 686b 3a20 6368  = lambda chk: ch
+000041e0: 6b20 2023 2074 7970 653a 2043 616c 6c61  k  # type: Calla
+000041f0: 626c 655b 5b69 6e74 5d2c 2069 6e74 5d0a  ble[[int], int].
+00004200: 656c 7365 3a0a 2020 2020 6368 6563 6b73  else:.    checks
+00004210: 756d 5f65 6e64 6961 6e5f 7472 616e 7366  um_endian_transf
+00004220: 6f72 6d20 3d20 6c61 6d62 6461 2063 686b  orm = lambda chk
+00004230: 3a20 2828 6368 6b20 3e3e 2038 2920 2620  : ((chk >> 8) & 
+00004240: 3078 6666 2920 7c20 6368 6b20 3c3c 2038  0xff) | chk << 8
+00004250: 0a0a 0a64 6566 2063 6865 636b 7375 6d28  ...def checksum(
+00004260: 706b 7429 3a0a 2020 2020 2320 7479 7065  pkt):.    # type
+00004270: 3a20 2862 7974 6573 2920 2d3e 2069 6e74  : (bytes) -> int
+00004280: 0a20 2020 2069 6620 6c65 6e28 706b 7429  .    if len(pkt)
+00004290: 2025 2032 203d 3d20 313a 0a20 2020 2020   % 2 == 1:.     
+000042a0: 2020 2070 6b74 202b 3d20 6222 5c30 220a     pkt += b"\0".
+000042b0: 2020 2020 7320 3d20 7375 6d28 6172 7261      s = sum(arra
+000042c0: 792e 6172 7261 7928 2248 222c 2070 6b74  y.array("H", pkt
+000042d0: 2929 0a20 2020 2073 203d 2028 7320 3e3e  )).    s = (s >>
+000042e0: 2031 3629 202b 2028 7320 2620 3078 6666   16) + (s & 0xff
+000042f0: 6666 290a 2020 2020 7320 2b3d 2073 203e  ff).    s += s >
+00004300: 3e20 3136 0a20 2020 2073 203d 207e 730a  > 16.    s = ~s.
+00004310: 2020 2020 7265 7475 726e 2063 6865 636b      return check
+00004320: 7375 6d5f 656e 6469 616e 5f74 7261 6e73  sum_endian_trans
+00004330: 666f 726d 2873 2920 2620 3078 6666 6666  form(s) & 0xffff
+00004340: 0a0a 0a64 6566 205f 666c 6574 6368 6572  ...def _fletcher
+00004350: 3136 2863 6861 7262 7566 293a 0a20 2020  16(charbuf):.   
+00004360: 2023 2074 7970 653a 2028 6279 7465 7329   # type: (bytes)
+00004370: 202d 3e20 5475 706c 655b 696e 742c 2069   -> Tuple[int, i
+00004380: 6e74 5d0a 2020 2020 2320 5468 6973 2069  nt].    # This i
+00004390: 7320 6261 7365 6420 6f6e 2074 6865 2047  s based on the G
+000043a0: 504c 6564 2043 2069 6d70 6c65 6d65 6e74  PLed C implement
+000043b0: 6174 696f 6e20 696e 205a 6562 7261 203c  ation in Zebra <
+000043c0: 6874 7470 3a2f 2f77 7777 2e7a 6562 7261  http://www.zebra
+000043d0: 2e6f 7267 2f3e 2020 2320 6e6f 7161 3a20  .org/>  # noqa: 
+000043e0: 4535 3031 0a20 2020 2063 3020 3d20 6331  E501.    c0 = c1
+000043f0: 203d 2030 0a20 2020 2066 6f72 2063 6861   = 0.    for cha
+00004400: 7220 696e 2063 6861 7262 7566 3a0a 2020  r in charbuf:.  
+00004410: 2020 2020 2020 6330 202b 3d20 6368 6172        c0 += char
+00004420: 0a20 2020 2020 2020 2063 3120 2b3d 2063  .        c1 += c
+00004430: 300a 0a20 2020 2063 3020 253d 2032 3535  0..    c0 %= 255
+00004440: 0a20 2020 2063 3120 253d 2032 3535 0a20  .    c1 %= 255. 
+00004450: 2020 2072 6574 7572 6e20 2863 302c 2063     return (c0, c
+00004460: 3129 0a0a 0a40 636f 6e66 2e63 6f6d 6d61  1)...@conf.comma
+00004470: 6e64 732e 7265 6769 7374 6572 0a64 6566  nds.register.def
+00004480: 2066 6c65 7463 6865 7231 365f 6368 6563   fletcher16_chec
+00004490: 6b73 756d 2862 696e 6275 6629 3a0a 2020  ksum(binbuf):.  
+000044a0: 2020 2320 7479 7065 3a20 2862 7974 6573    # type: (bytes
+000044b0: 2920 2d3e 2069 6e74 0a20 2020 2022 2222  ) -> int.    """
+000044c0: 4361 6c63 756c 6174 6573 2046 6c65 7463  Calculates Fletc
+000044d0: 6865 722d 3136 2063 6865 636b 7375 6d20  her-16 checksum 
+000044e0: 6f66 2074 6865 2067 6976 656e 2062 7566  of the given buf
+000044f0: 6665 722e 0a0a 2020 2020 2020 204e 6f74  fer...       Not
+00004500: 653a 0a20 2020 2020 2020 4966 2074 6865  e:.       If the
+00004510: 2062 7566 6665 7220 636f 6e74 6169 6e73   buffer contains
+00004520: 2074 6865 2074 776f 2063 6865 636b 6279   the two checkby
+00004530: 7465 7320 6465 7269 7665 6420 6672 6f6d  tes derived from
+00004540: 2074 6865 2046 6c65 7463 6865 722d 3136   the Fletcher-16
+00004550: 2063 6865 636b 7375 6d20 2023 206e 6f71   checksum  # noq
+00004560: 613a 2045 3530 310a 2020 2020 2020 2074  a: E501.       t
+00004570: 6865 2072 6573 756c 7420 6f66 2074 6869  he result of thi
+00004580: 7320 6675 6e63 7469 6f6e 2068 6173 2074  s function has t
+00004590: 6f20 6265 2030 2e20 4f74 6865 7277 6973  o be 0. Otherwis
+000045a0: 6520 7468 6520 6275 6666 6572 2068 6173  e the buffer has
+000045b0: 2062 6565 6e20 636f 7272 7570 7465 642e   been corrupted.
+000045c0: 2020 2320 6e6f 7161 3a20 4535 3031 0a20    # noqa: E501. 
+000045d0: 2020 2022 2222 0a20 2020 2028 6330 2c20     """.    (c0, 
+000045e0: 6331 2920 3d20 5f66 6c65 7463 6865 7231  c1) = _fletcher1
+000045f0: 3628 6269 6e62 7566 290a 2020 2020 7265  6(binbuf).    re
+00004600: 7475 726e 2028 6331 203c 3c20 3829 207c  turn (c1 << 8) |
+00004610: 2063 300a 0a0a 4063 6f6e 662e 636f 6d6d   c0...@conf.comm
+00004620: 616e 6473 2e72 6567 6973 7465 720a 6465  ands.register.de
+00004630: 6620 666c 6574 6368 6572 3136 5f63 6865  f fletcher16_che
+00004640: 636b 6279 7465 7328 6269 6e62 7566 2c20  ckbytes(binbuf, 
+00004650: 6f66 6673 6574 293a 0a20 2020 2023 2074  offset):.    # t
+00004660: 7970 653a 2028 6279 7465 732c 2069 6e74  ype: (bytes, int
+00004670: 2920 2d3e 2062 7974 6573 0a20 2020 2022  ) -> bytes.    "
+00004680: 2222 4361 6c63 756c 6174 6573 2074 6865  ""Calculates the
+00004690: 2046 6c65 7463 6865 722d 3136 2063 6865   Fletcher-16 che
+000046a0: 636b 6279 7465 7320 7265 7475 726e 6564  ckbytes returned
+000046b0: 2061 7320 3220 6279 7465 2062 696e 6172   as 2 byte binar
+000046c0: 792d 7374 7269 6e67 2e0a 0a20 2020 2020  y-string...     
+000046d0: 2020 496e 636c 7564 696e 6720 7468 6520    Including the 
+000046e0: 6279 7465 7320 696e 746f 2074 6865 2062  bytes into the b
+000046f0: 7566 6665 7220 2861 7420 7468 6520 706f  uffer (at the po
+00004700: 7369 7469 6f6e 206d 6172 6b65 6420 6279  sition marked by
+00004710: 206f 6666 7365 7429 2074 6865 2020 2320   offset) the  # 
+00004720: 6e6f 7161 3a20 4535 3031 0a20 2020 2020  noqa: E501.     
+00004730: 2020 676c 6f62 616c 2046 6c65 7463 6865    global Fletche
+00004740: 722d 3136 2063 6865 636b 7375 6d20 6f66  r-16 checksum of
+00004750: 2074 6865 2062 7566 6665 7220 7769 6c6c   the buffer will
+00004760: 2062 6520 302e 2054 6875 7320 6974 2069   be 0. Thus it i
+00004770: 7320 6561 7379 2074 6f20 7665 7269 6679  s easy to verify
+00004780: 2020 2320 6e6f 7161 3a20 4535 3031 0a20    # noqa: E501. 
+00004790: 2020 2020 2020 7468 6520 696e 7465 6772        the integr
+000047a0: 6974 7920 6f66 2074 6865 2062 7566 6665  ity of the buffe
+000047b0: 7220 6f6e 2074 6865 2072 6563 6569 7665  r on the receive
+000047c0: 7220 7369 6465 2e0a 0a20 2020 2020 2020  r side...       
+000047d0: 466f 7220 6465 7461 696c 7320 6f6e 2074  For details on t
+000047e0: 6865 2061 6c67 6f72 6974 686d 2c20 7365  he algorithm, se
+000047f0: 6520 5246 4320 3233 3238 2063 6861 7074  e RFC 2328 chapt
+00004800: 6572 2031 322e 312e 3720 616e 6420 5246  er 12.1.7 and RF
+00004810: 4320 3930 3520 416e 6e65 7820 422e 2020  C 905 Annex B.  
+00004820: 2320 6e6f 7161 3a20 4535 3031 0a20 2020  # noqa: E501.   
+00004830: 2022 2222 0a0a 2020 2020 2320 5468 6973   """..    # This
+00004840: 2069 7320 6261 7365 6420 6f6e 2074 6865   is based on the
+00004850: 2047 504c 6564 2043 2069 6d70 6c65 6d65   GPLed C impleme
+00004860: 6e74 6174 696f 6e20 696e 205a 6562 7261  ntation in Zebra
+00004870: 203c 6874 7470 3a2f 2f77 7777 2e7a 6562   <http://www.zeb
+00004880: 7261 2e6f 7267 2f3e 2020 2320 6e6f 7161  ra.org/>  # noqa
+00004890: 3a20 4535 3031 0a20 2020 2069 6620 6c65  : E501.    if le
+000048a0: 6e28 6269 6e62 7566 2920 3c20 6f66 6673  n(binbuf) < offs
+000048b0: 6574 3a0a 2020 2020 2020 2020 7261 6973  et:.        rais
+000048c0: 6520 4578 6365 7074 696f 6e28 2250 6163  e Exception("Pac
+000048d0: 6b65 7420 746f 6f20 7368 6f72 7420 666f  ket too short fo
+000048e0: 7220 6368 6563 6b62 7974 6573 2025 6422  r checkbytes %d"
+000048f0: 2025 206c 656e 2862 696e 6275 6629 290a   % len(binbuf)).
+00004900: 0a20 2020 2062 696e 6275 6620 3d20 6269  .    binbuf = bi
+00004910: 6e62 7566 5b3a 6f66 6673 6574 5d20 2b20  nbuf[:offset] + 
+00004920: 6222 5c78 3030 5c78 3030 2220 2b20 6269  b"\x00\x00" + bi
+00004930: 6e62 7566 5b6f 6666 7365 7420 2b20 323a  nbuf[offset + 2:
+00004940: 5d0a 2020 2020 2863 302c 2063 3129 203d  ].    (c0, c1) =
+00004950: 205f 666c 6574 6368 6572 3136 2862 696e   _fletcher16(bin
+00004960: 6275 6629 0a0a 2020 2020 7820 3d20 2828  buf)..    x = ((
+00004970: 6c65 6e28 6269 6e62 7566 2920 2d20 6f66  len(binbuf) - of
+00004980: 6673 6574 202d 2031 2920 2a20 6330 202d  fset - 1) * c0 -
+00004990: 2063 3129 2025 2032 3535 0a0a 2020 2020   c1) % 255..    
+000049a0: 6966 2028 7820 3c3d 2030 293a 0a20 2020  if (x <= 0):.   
+000049b0: 2020 2020 2078 202b 3d20 3235 350a 0a20       x += 255.. 
+000049c0: 2020 2079 203d 2035 3130 202d 2063 3020     y = 510 - c0 
+000049d0: 2d20 780a 0a20 2020 2069 6620 2879 203e  - x..    if (y >
+000049e0: 2032 3535 293a 0a20 2020 2020 2020 2079   255):.        y
+000049f0: 202d 3d20 3235 350a 2020 2020 7265 7475   -= 255.    retu
+00004a00: 726e 2063 6862 2878 2920 2b20 6368 6228  rn chb(x) + chb(
+00004a10: 7929 0a0a 0a64 6566 206d 6163 3273 7472  y)...def mac2str
+00004a20: 286d 6163 293a 0a20 2020 2023 2074 7970  (mac):.    # typ
+00004a30: 653a 2028 7374 7229 202d 3e20 6279 7465  e: (str) -> byte
+00004a40: 730a 2020 2020 7265 7475 726e 2062 2222  s.    return b""
+00004a50: 2e6a 6f69 6e28 6368 6228 696e 7428 782c  .join(chb(int(x,
+00004a60: 2031 3629 2920 666f 7220 7820 696e 2070   16)) for x in p
+00004a70: 6c61 696e 5f73 7472 286d 6163 292e 7370  lain_str(mac).sp
+00004a80: 6c69 7428 273a 2729 290a 0a0a 6465 6620  lit(':'))...def 
+00004a90: 7661 6c69 645f 6d61 6328 6d61 6329 3a0a  valid_mac(mac):.
+00004aa0: 2020 2020 2320 7479 7065 3a20 2873 7472      # type: (str
+00004ab0: 2920 2d3e 2062 6f6f 6c0a 2020 2020 7472  ) -> bool.    tr
+00004ac0: 793a 0a20 2020 2020 2020 2072 6574 7572  y:.        retur
+00004ad0: 6e20 6c65 6e28 6d61 6332 7374 7228 6d61  n len(mac2str(ma
+00004ae0: 6329 2920 3d3d 2036 0a20 2020 2065 7863  c)) == 6.    exc
+00004af0: 6570 7420 5661 6c75 6545 7272 6f72 3a0a  ept ValueError:.
+00004b00: 2020 2020 2020 2020 7061 7373 0a20 2020          pass.   
+00004b10: 2072 6574 7572 6e20 4661 6c73 650a 0a0a   return False...
+00004b20: 6465 6620 7374 7232 6d61 6328 7329 3a0a  def str2mac(s):.
+00004b30: 2020 2020 2320 7479 7065 3a20 2862 7974      # type: (byt
+00004b40: 6573 2920 2d3e 2073 7472 0a20 2020 2069  es) -> str.    i
+00004b50: 6620 6973 696e 7374 616e 6365 2873 2c20  f isinstance(s, 
+00004b60: 7374 7229 3a0a 2020 2020 2020 2020 7265  str):.        re
+00004b70: 7475 726e 2028 2225 3032 783a 2220 2a20  turn ("%02x:" * 
+00004b80: 6c65 6e28 7329 295b 3a2d 315d 2025 2074  len(s))[:-1] % t
+00004b90: 7570 6c65 286d 6170 286f 7264 2c20 7329  uple(map(ord, s)
+00004ba0: 290a 2020 2020 7265 7475 726e 2028 2225  ).    return ("%
+00004bb0: 3032 783a 2220 2a20 6c65 6e28 7329 295b  02x:" * len(s))[
+00004bc0: 3a2d 315d 2025 2074 7570 6c65 2873 290a  :-1] % tuple(s).
+00004bd0: 0a0a 6465 6620 7261 6e64 7374 7269 6e67  ..def randstring
+00004be0: 286c 656e 6774 6829 3a0a 2020 2020 2320  (length):.    # 
+00004bf0: 7479 7065 3a20 2869 6e74 2920 2d3e 2062  type: (int) -> b
+00004c00: 7974 6573 0a20 2020 2022 2222 0a20 2020  ytes.    """.   
+00004c10: 2052 6574 7572 6e73 2061 2072 616e 646f   Returns a rando
+00004c20: 6d20 7374 7269 6e67 206f 6620 6c65 6e67  m string of leng
+00004c30: 7468 2028 6c65 6e67 7468 203e 3d20 3029  th (length >= 0)
+00004c40: 0a20 2020 2022 2222 0a20 2020 2072 6574  .    """.    ret
+00004c50: 7572 6e20 6222 222e 6a6f 696e 2873 7472  urn b"".join(str
+00004c60: 7563 742e 7061 636b 2827 4227 2c20 7261  uct.pack('B', ra
+00004c70: 6e64 6f6d 2e72 616e 6469 6e74 2830 2c20  ndom.randint(0, 
+00004c80: 3235 3529 290a 2020 2020 2020 2020 2020  255)).          
+00004c90: 2020 2020 2020 2020 2020 666f 7220 5f20            for _ 
+00004ca0: 696e 2072 616e 6765 286c 656e 6774 6829  in range(length)
+00004cb0: 290a 0a0a 6465 6620 7a65 726f 6672 6565  )...def zerofree
+00004cc0: 5f72 616e 6473 7472 696e 6728 6c65 6e67  _randstring(leng
+00004cd0: 7468 293a 0a20 2020 2023 2074 7970 653a  th):.    # type:
+00004ce0: 2028 696e 7429 202d 3e20 6279 7465 730a   (int) -> bytes.
+00004cf0: 2020 2020 2222 220a 2020 2020 5265 7475      """.    Retu
+00004d00: 726e 7320 6120 7261 6e64 6f6d 2073 7472  rns a random str
+00004d10: 696e 6720 6f66 206c 656e 6774 6820 286c  ing of length (l
+00004d20: 656e 6774 6820 3e3d 2030 2920 7769 7468  ength >= 0) with
+00004d30: 6f75 7420 7a65 726f 2069 6e20 6974 2e0a  out zero in it..
+00004d40: 2020 2020 2222 220a 2020 2020 7265 7475      """.    retu
+00004d50: 726e 2062 2222 2e6a 6f69 6e28 7374 7275  rn b"".join(stru
+00004d60: 6374 2e70 6163 6b28 2742 272c 2072 616e  ct.pack('B', ran
+00004d70: 646f 6d2e 7261 6e64 696e 7428 312c 2032  dom.randint(1, 2
+00004d80: 3535 2929 0a20 2020 2020 2020 2020 2020  55)).           
+00004d90: 2020 2020 2020 2020 2066 6f72 205f 2069           for _ i
+00004da0: 6e20 7261 6e67 6528 6c65 6e67 7468 2929  n range(length))
+00004db0: 0a0a 0a64 6566 2073 7472 786f 7228 7331  ...def strxor(s1
+00004dc0: 2c20 7332 293a 0a20 2020 2023 2074 7970  , s2):.    # typ
+00004dd0: 653a 2028 6279 7465 732c 2062 7974 6573  e: (bytes, bytes
+00004de0: 2920 2d3e 2062 7974 6573 0a20 2020 2022  ) -> bytes.    "
+00004df0: 2222 0a20 2020 2052 6574 7572 6e73 2074  "".    Returns t
+00004e00: 6865 2062 696e 6172 7920 584f 5220 6f66  he binary XOR of
+00004e10: 2074 6865 2032 2070 726f 7669 6465 6420   the 2 provided 
+00004e20: 7374 7269 6e67 7320 7331 2061 6e64 2073  strings s1 and s
+00004e30: 322e 2073 3120 616e 6420 7332 0a20 2020  2. s1 and s2.   
+00004e40: 206d 7573 7420 6265 206f 6620 7361 6d65   must be of same
+00004e50: 206c 656e 6774 682e 0a20 2020 2022 2222   length..    """
+00004e60: 0a20 2020 2072 6574 7572 6e20 6222 222e  .    return b"".
+00004e70: 6a6f 696e 286d 6170 286c 616d 6264 6120  join(map(lambda 
+00004e80: 782c 2079 3a20 6368 6228 6f72 6228 7829  x, y: chb(orb(x)
+00004e90: 205e 206f 7262 2879 2929 2c20 7331 2c20   ^ orb(y)), s1, 
+00004ea0: 7332 2929 0a0a 0a64 6566 2073 7472 616e  s2))...def stran
+00004eb0: 6428 7331 2c20 7332 293a 0a20 2020 2023  d(s1, s2):.    #
+00004ec0: 2074 7970 653a 2028 6279 7465 732c 2062   type: (bytes, b
+00004ed0: 7974 6573 2920 2d3e 2062 7974 6573 0a20  ytes) -> bytes. 
+00004ee0: 2020 2022 2222 0a20 2020 2052 6574 7572     """.    Retur
+00004ef0: 6e73 2074 6865 2062 696e 6172 7920 414e  ns the binary AN
+00004f00: 4420 6f66 2074 6865 2032 2070 726f 7669  D of the 2 provi
+00004f10: 6465 6420 7374 7269 6e67 7320 7331 2061  ded strings s1 a
+00004f20: 6e64 2073 322e 2073 3120 616e 6420 7332  nd s2. s1 and s2
+00004f30: 0a20 2020 206d 7573 7420 6265 206f 6620  .    must be of 
+00004f40: 7361 6d65 206c 656e 6774 682e 0a20 2020  same length..   
+00004f50: 2022 2222 0a20 2020 2072 6574 7572 6e20   """.    return 
+00004f60: 6222 222e 6a6f 696e 286d 6170 286c 616d  b"".join(map(lam
+00004f70: 6264 6120 782c 2079 3a20 6368 6228 6f72  bda x, y: chb(or
+00004f80: 6228 7829 2026 206f 7262 2879 2929 2c20  b(x) & orb(y)), 
+00004f90: 7331 2c20 7332 2929 0a0a 0a64 6566 2073  s1, s2))...def s
+00004fa0: 7472 726f 7428 7331 2c20 636f 756e 742c  trrot(s1, count,
+00004fb0: 2072 6967 6874 3d54 7275 6529 3a0a 2020   right=True):.  
+00004fc0: 2020 2320 7479 7065 3a20 2862 7974 6573    # type: (bytes
+00004fd0: 2c20 696e 742c 2062 6f6f 6c29 202d 3e20  , int, bool) -> 
+00004fe0: 6279 7465 730a 2020 2020 2222 220a 2020  bytes.    """.  
+00004ff0: 2020 526f 7461 7465 2074 6865 2062 696e    Rotate the bin
+00005000: 6172 7920 6279 2027 636f 756e 7427 2062  ary by 'count' b
+00005010: 7974 6573 0a20 2020 2022 2222 0a20 2020  ytes.    """.   
+00005020: 206f 6666 203d 2063 6f75 6e74 2025 206c   off = count % l
+00005030: 656e 2873 3129 0a20 2020 2069 6620 7269  en(s1).    if ri
+00005040: 6768 743a 0a20 2020 2020 2020 2072 6574  ght:.        ret
+00005050: 7572 6e20 7331 5b2d 6f66 663a 5d20 2b20  urn s1[-off:] + 
+00005060: 7331 5b3a 2d6f 6666 5d0a 2020 2020 656c  s1[:-off].    el
+00005070: 7365 3a0a 2020 2020 2020 2020 7265 7475  se:.        retu
+00005080: 726e 2073 315b 6f66 663a 5d20 2b20 7331  rn s1[off:] + s1
+00005090: 5b3a 6f66 665d 0a0a 0a23 2057 6f72 6b61  [:off]...# Worka
+000050a0: 726f 756e 6420 6275 6720 3634 3330 3035  round bug 643005
+000050b0: 203a 2068 7474 7073 3a2f 2f73 6f75 7263   : https://sourc
+000050c0: 6566 6f72 6765 2e6e 6574 2f74 7261 636b  eforge.net/track
+000050d0: 6572 2f3f 6675 6e63 3d64 6574 6169 6c26  er/?func=detail&
+000050e0: 6174 6964 3d31 3035 3437 3026 6169 643d  atid=105470&aid=
+000050f0: 3634 3330 3035 2667 726f 7570 5f69 643d  643005&group_id=
+00005100: 3534 3730 2020 2320 6e6f 7161 3a20 4535  5470  # noqa: E5
+00005110: 3031 0a74 7279 3a0a 2020 2020 736f 636b  01.try:.    sock
+00005120: 6574 2e69 6e65 745f 6174 6f6e 2822 3235  et.inet_aton("25
+00005130: 352e 3235 352e 3235 352e 3235 3522 290a  5.255.255.255").
+00005140: 6578 6365 7074 2073 6f63 6b65 742e 6572  except socket.er
+00005150: 726f 723a 0a20 2020 2064 6566 2069 6e65  ror:.    def ine
+00005160: 745f 6174 6f6e 2869 705f 7374 7269 6e67  t_aton(ip_string
+00005170: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+00005180: 653a 2028 7374 7229 202d 3e20 6279 7465  e: (str) -> byte
+00005190: 730a 2020 2020 2020 2020 6966 2069 705f  s.        if ip_
+000051a0: 7374 7269 6e67 203d 3d20 2232 3535 2e32  string == "255.2
+000051b0: 3535 2e32 3535 2e32 3535 223a 0a20 2020  55.255.255":.   
+000051c0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000051d0: 6222 5c78 6666 2220 2a20 340a 2020 2020  b"\xff" * 4.    
+000051e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+000051f0: 2020 2020 2020 7265 7475 726e 2073 6f63        return soc
+00005200: 6b65 742e 696e 6574 5f61 746f 6e28 6970  ket.inet_aton(ip
+00005210: 5f73 7472 696e 6729 0a65 6c73 653a 0a20  _string).else:. 
+00005220: 2020 2069 6e65 745f 6174 6f6e 203d 2073     inet_aton = s
+00005230: 6f63 6b65 742e 696e 6574 5f61 746f 6e20  ocket.inet_aton 
+00005240: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
+00005250: 0a69 6e65 745f 6e74 6f61 203d 2073 6f63  .inet_ntoa = soc
+00005260: 6b65 742e 696e 6574 5f6e 746f 610a 0a0a  ket.inet_ntoa...
+00005270: 6465 6620 6174 6f6c 2878 293a 0a20 2020  def atol(x):.   
+00005280: 2023 2074 7970 653a 2028 7374 7229 202d   # type: (str) -
+00005290: 3e20 696e 740a 2020 2020 7472 793a 0a20  > int.    try:. 
+000052a0: 2020 2020 2020 2069 7020 3d20 696e 6574         ip = inet
+000052b0: 5f61 746f 6e28 7829 0a20 2020 2065 7863  _aton(x).    exc
+000052c0: 6570 7420 736f 636b 6574 2e65 7272 6f72  ept socket.error
+000052d0: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+000052e0: 5661 6c75 6545 7272 6f72 2822 4261 6420  ValueError("Bad 
+000052f0: 4950 2066 6f72 6d61 743a 2025 7322 2025  IP format: %s" %
+00005300: 2078 290a 2020 2020 7265 7475 726e 2063   x).    return c
+00005310: 6173 7428 696e 742c 2073 7472 7563 742e  ast(int, struct.
+00005320: 756e 7061 636b 2822 2149 222c 2069 7029  unpack("!I", ip)
+00005330: 5b30 5d29 0a0a 0a64 6566 2076 616c 6964  [0])...def valid
+00005340: 5f69 7028 6164 6472 293a 0a20 2020 2023  _ip(addr):.    #
+00005350: 2074 7970 653a 2028 7374 7229 202d 3e20   type: (str) -> 
+00005360: 626f 6f6c 0a20 2020 2074 7279 3a0a 2020  bool.    try:.  
+00005370: 2020 2020 2020 6164 6472 203d 2070 6c61        addr = pla
+00005380: 696e 5f73 7472 2861 6464 7229 0a20 2020  in_str(addr).   
+00005390: 2065 7863 6570 7420 556e 6963 6f64 6544   except UnicodeD
+000053a0: 6563 6f64 6545 7272 6f72 3a0a 2020 2020  ecodeError:.    
+000053b0: 2020 2020 7265 7475 726e 2046 616c 7365      return False
+000053c0: 0a20 2020 2074 7279 3a0a 2020 2020 2020  .    try:.      
+000053d0: 2020 6174 6f6c 2861 6464 7229 0a20 2020    atol(addr).   
+000053e0: 2065 7863 6570 7420 284f 5345 7272 6f72   except (OSError
+000053f0: 2c20 5661 6c75 6545 7272 6f72 2c20 736f  , ValueError, so
+00005400: 636b 6574 2e65 7272 6f72 293a 0a20 2020  cket.error):.   
+00005410: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
+00005420: 650a 2020 2020 7265 7475 726e 2054 7275  e.    return Tru
+00005430: 650a 0a0a 6465 6620 7661 6c69 645f 6e65  e...def valid_ne
+00005440: 7428 6164 6472 293a 0a20 2020 2023 2074  t(addr):.    # t
+00005450: 7970 653a 2028 7374 7229 202d 3e20 626f  ype: (str) -> bo
+00005460: 6f6c 0a20 2020 2074 7279 3a0a 2020 2020  ol.    try:.    
+00005470: 2020 2020 6164 6472 203d 2070 6c61 696e      addr = plain
+00005480: 5f73 7472 2861 6464 7229 0a20 2020 2065  _str(addr).    e
+00005490: 7863 6570 7420 556e 6963 6f64 6544 6563  xcept UnicodeDec
+000054a0: 6f64 6545 7272 6f72 3a0a 2020 2020 2020  odeError:.      
+000054b0: 2020 7265 7475 726e 2046 616c 7365 0a20    return False. 
+000054c0: 2020 2069 6620 272f 2720 696e 2061 6464     if '/' in add
+000054d0: 723a 0a20 2020 2020 2020 2069 702c 206d  r:.        ip, m
+000054e0: 6173 6b20 3d20 6164 6472 2e73 706c 6974  ask = addr.split
+000054f0: 2827 2f27 2c20 3129 0a20 2020 2020 2020  ('/', 1).       
+00005500: 2072 6574 7572 6e20 7661 6c69 645f 6970   return valid_ip
+00005510: 2869 7029 2061 6e64 206d 6173 6b2e 6973  (ip) and mask.is
+00005520: 6469 6769 7428 2920 616e 6420 3020 3c3d  digit() and 0 <=
+00005530: 2069 6e74 286d 6173 6b29 203c 3d20 3332   int(mask) <= 32
+00005540: 0a20 2020 2072 6574 7572 6e20 7661 6c69  .    return vali
+00005550: 645f 6970 2861 6464 7229 0a0a 0a64 6566  d_ip(addr)...def
+00005560: 2076 616c 6964 5f69 7036 2861 6464 7229   valid_ip6(addr)
+00005570: 3a0a 2020 2020 2320 7479 7065 3a20 2873  :.    # type: (s
+00005580: 7472 2920 2d3e 2062 6f6f 6c0a 2020 2020  tr) -> bool.    
+00005590: 7472 793a 0a20 2020 2020 2020 2061 6464  try:.        add
+000055a0: 7220 3d20 706c 6169 6e5f 7374 7228 6164  r = plain_str(ad
+000055b0: 6472 290a 2020 2020 6578 6365 7074 2055  dr).    except U
+000055c0: 6e69 636f 6465 4465 636f 6465 4572 726f  nicodeDecodeErro
+000055d0: 723a 0a20 2020 2020 2020 2072 6574 7572  r:.        retur
+000055e0: 6e20 4661 6c73 650a 2020 2020 7472 793a  n False.    try:
+000055f0: 0a20 2020 2020 2020 2069 6e65 745f 7074  .        inet_pt
+00005600: 6f6e 2873 6f63 6b65 742e 4146 5f49 4e45  on(socket.AF_INE
+00005610: 5436 2c20 6164 6472 290a 2020 2020 6578  T6, addr).    ex
+00005620: 6365 7074 2073 6f63 6b65 742e 6572 726f  cept socket.erro
+00005630: 723a 0a20 2020 2020 2020 2072 6574 7572  r:.        retur
+00005640: 6e20 4661 6c73 650a 2020 2020 7265 7475  n False.    retu
+00005650: 726e 2054 7275 650a 0a0a 6465 6620 7661  rn True...def va
+00005660: 6c69 645f 6e65 7436 2861 6464 7229 3a0a  lid_net6(addr):.
+00005670: 2020 2020 2320 7479 7065 3a20 2873 7472      # type: (str
+00005680: 2920 2d3e 2062 6f6f 6c0a 2020 2020 7472  ) -> bool.    tr
+00005690: 793a 0a20 2020 2020 2020 2061 6464 7220  y:.        addr 
+000056a0: 3d20 706c 6169 6e5f 7374 7228 6164 6472  = plain_str(addr
+000056b0: 290a 2020 2020 6578 6365 7074 2055 6e69  ).    except Uni
+000056c0: 636f 6465 4465 636f 6465 4572 726f 723a  codeDecodeError:
+000056d0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000056e0: 4661 6c73 650a 2020 2020 6966 2027 2f27  False.    if '/'
+000056f0: 2069 6e20 6164 6472 3a0a 2020 2020 2020   in addr:.      
+00005700: 2020 6970 2c20 6d61 736b 203d 2061 6464    ip, mask = add
+00005710: 722e 7370 6c69 7428 272f 272c 2031 290a  r.split('/', 1).
+00005720: 2020 2020 2020 2020 7265 7475 726e 2076          return v
+00005730: 616c 6964 5f69 7036 2869 7029 2061 6e64  alid_ip6(ip) and
+00005740: 206d 6173 6b2e 6973 6469 6769 7428 2920   mask.isdigit() 
+00005750: 616e 6420 3020 3c3d 2069 6e74 286d 6173  and 0 <= int(mas
+00005760: 6b29 203c 3d20 3132 380a 2020 2020 7265  k) <= 128.    re
+00005770: 7475 726e 2076 616c 6964 5f69 7036 2861  turn valid_ip6(a
+00005780: 6464 7229 0a0a 0a64 6566 206c 746f 6128  ddr)...def ltoa(
+00005790: 7829 3a0a 2020 2020 2320 7479 7065 3a20  x):.    # type: 
+000057a0: 2869 6e74 2920 2d3e 2073 7472 0a20 2020  (int) -> str.   
+000057b0: 2072 6574 7572 6e20 696e 6574 5f6e 746f   return inet_nto
+000057c0: 6128 7374 7275 6374 2e70 6163 6b28 2221  a(struct.pack("!
+000057d0: 4922 2c20 7820 2620 3078 6666 6666 6666  I", x & 0xffffff
+000057e0: 6666 2929 0a0a 0a64 6566 2069 746f 6d28  ff))...def itom(
+000057f0: 7829 3a0a 2020 2020 2320 7479 7065 3a20  x):.    # type: 
+00005800: 2869 6e74 2920 2d3e 2069 6e74 0a20 2020  (int) -> int.   
+00005810: 2072 6574 7572 6e20 2830 7866 6666 6666   return (0xfffff
+00005820: 6666 6630 3030 3030 3030 3020 3e3e 2078  fff00000000 >> x
+00005830: 2920 2620 3078 6666 6666 6666 6666 0a0a  ) & 0xffffffff..
+00005840: 0a64 6566 2064 6563 6f64 655f 6c6f 6361  .def decode_loca
+00005850: 6c65 5f73 7472 2878 293a 0a20 2020 2023  le_str(x):.    #
+00005860: 2074 7970 653a 2028 6279 7465 7329 202d   type: (bytes) -
+00005870: 3e20 7374 720a 2020 2020 2222 220a 2020  > str.    """.  
+00005880: 2020 4465 636f 6465 2062 7974 6573 2069    Decode bytes i
+00005890: 6e74 6f20 6120 7374 7269 6e67 2075 7369  nto a string usi
+000058a0: 6e67 2074 6865 2073 7973 7465 6d20 6c6f  ng the system lo
+000058b0: 6361 6c65 2e0a 2020 2020 5573 6566 756c  cale..    Useful
+000058c0: 206f 6e20 5769 6e64 6f77 7320 7768 6572   on Windows wher
+000058d0: 6520 6974 2063 616e 2062 6520 756e 7573  e it can be unus
+000058e0: 7561 6c20 2865 2e67 2e20 6370 3132 3532  ual (e.g. cp1252
+000058f0: 290a 2020 2020 2222 220a 2020 2020 7265  ).    """.    re
+00005900: 7475 726e 2078 2e64 6563 6f64 6528 656e  turn x.decode(en
+00005910: 636f 6469 6e67 3d6c 6f63 616c 652e 6765  coding=locale.ge
+00005920: 746c 6f63 616c 6528 295b 315d 206f 7220  tlocale()[1] or 
+00005930: 2275 7466 2d38 222c 2065 7272 6f72 733d  "utf-8", errors=
+00005940: 2272 6570 6c61 6365 2229 0a0a 0a63 6c61  "replace")...cla
+00005950: 7373 2043 6f6e 7465 7874 4d61 6e61 6765  ss ContextManage
+00005960: 7253 7562 7072 6f63 6573 7328 6f62 6a65  rSubprocess(obje
+00005970: 6374 293a 0a20 2020 2022 2222 0a20 2020  ct):.    """.   
+00005980: 2043 6f6e 7465 7874 206d 616e 6167 6572   Context manager
+00005990: 2074 6861 7420 6561 7365 7320 6368 6563   that eases chec
+000059a0: 6b69 6e67 2066 6f72 2075 6e6b 6e6f 776e  king for unknown
+000059b0: 2063 6f6d 6d61 6e64 2c20 7769 7468 6f75   command, withou
+000059c0: 740a 2020 2020 6372 6173 6869 6e67 2e0a  t.    crashing..
+000059d0: 0a20 2020 2045 7861 6d70 6c65 3a0a 2020  .    Example:.  
+000059e0: 2020 3e3e 3e20 7769 7468 2043 6f6e 7465    >>> with Conte
+000059f0: 7874 4d61 6e61 6765 7253 7562 7072 6f63  xtManagerSubproc
+00005a00: 6573 7328 2274 6370 6475 6d70 2229 3a0a  ess("tcpdump"):.
+00005a10: 2020 2020 3e3e 3e20 2020 2020 7375 6270      >>>     subp
+00005a20: 726f 6365 7373 2e50 6f70 656e 285b 2274  rocess.Popen(["t
+00005a30: 6370 6475 6d70 222c 2022 2d2d 7665 7273  cpdump", "--vers
+00005a40: 696f 6e22 5d29 0a20 2020 2045 5252 4f52  ion"]).    ERROR
+00005a50: 3a20 436f 756c 6420 6e6f 7420 6578 6563  : Could not exec
+00005a60: 7574 6520 7463 7064 756d 702c 2069 7320  ute tcpdump, is 
+00005a70: 6974 2069 6e73 7461 6c6c 6564 3f0a 0a20  it installed?.. 
+00005a80: 2020 2022 2222 0a0a 2020 2020 6465 6620     """..    def 
+00005a90: 5f5f 696e 6974 5f5f 2873 656c 662c 2070  __init__(self, p
+00005aa0: 726f 672c 2073 7570 7072 6573 733d 5472  rog, suppress=Tr
+00005ab0: 7565 293a 0a20 2020 2020 2020 2023 2074  ue):.        # t
+00005ac0: 7970 653a 2028 7374 722c 2062 6f6f 6c29  ype: (str, bool)
+00005ad0: 202d 3e20 4e6f 6e65 0a20 2020 2020 2020   -> None.       
+00005ae0: 2073 656c 662e 7072 6f67 203d 2070 726f   self.prog = pro
+00005af0: 670a 2020 2020 2020 2020 7365 6c66 2e73  g.        self.s
+00005b00: 7570 7072 6573 7320 3d20 7375 7070 7265  uppress = suppre
+00005b10: 7373 0a0a 2020 2020 6465 6620 5f5f 656e  ss..    def __en
+00005b20: 7465 725f 5f28 7365 6c66 293a 0a20 2020  ter__(self):.   
+00005b30: 2020 2020 2023 2074 7970 653a 2028 2920       # type: () 
+00005b40: 2d3e 204e 6f6e 650a 2020 2020 2020 2020  -> None.        
+00005b50: 7061 7373 0a0a 2020 2020 6465 6620 5f5f  pass..    def __
+00005b60: 6578 6974 5f5f 2873 656c 662c 0a20 2020  exit__(self,.   
+00005b70: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+00005b80: 635f 7479 7065 2c20 2023 2074 7970 653a  c_type,  # type:
+00005b90: 204f 7074 696f 6e61 6c5b 7479 7065 5d0a   Optional[type].
 00005ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005bb0: 2020 2020 2020 2020 2020 2020 2073 7464               std
-00005bc0: 696e 3d73 7562 7072 6f63 6573 732e 5049  in=subprocess.PI
-00005bd0: 5045 292e 7374 6469 6e0a 2020 2020 6966  PE).stdin.    if
-00005be0: 2066 6f72 6d61 7420 6973 206e 6f74 204e   format is not N
-00005bf0: 6f6e 653a 0a20 2020 2020 2020 2066 6f72  one:.        for
-00005c00: 6d61 7420 3d20 222d 5425 7322 2025 2066  mat = "-T%s" % f
-00005c10: 6f72 6d61 740a 2020 2020 6966 2069 7369  ormat.    if isi
-00005c20: 6e73 7461 6e63 6528 7461 7267 6574 2c20  nstance(target, 
-00005c30: 7374 7229 3a0a 2020 2020 2020 2020 6966  str):.        if
-00005c40: 2074 6172 6765 742e 7374 6172 7473 7769   target.startswi
-00005c50: 7468 2827 7c27 293a 0a20 2020 2020 2020  th('|'):.       
-00005c60: 2020 2020 2074 6172 6765 7420 3d20 7375       target = su
-00005c70: 6270 726f 6365 7373 2e50 6f70 656e 2874  bprocess.Popen(t
-00005c80: 6172 6765 745b 313a 5d2e 6c73 7472 6970  arget[1:].lstrip
-00005c90: 2829 2c20 7368 656c 6c3d 5472 7565 2c0a  (), shell=True,.
-00005ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005cc0: 2020 2020 2020 7374 6469 6e3d 7375 6270        stdin=subp
-00005cd0: 726f 6365 7373 2e50 4950 4529 2e73 7464  rocess.PIPE).std
-00005ce0: 696e 0a20 2020 2020 2020 2065 6c69 6620  in.        elif 
-00005cf0: 7461 7267 6574 2e73 7461 7274 7377 6974  target.startswit
-00005d00: 6828 273e 2729 3a0a 2020 2020 2020 2020  h('>'):.        
-00005d10: 2020 2020 7461 7267 6574 203d 206f 7065      target = ope
-00005d20: 6e28 7461 7267 6574 5b31 3a5d 2e6c 7374  n(target[1:].lst
-00005d30: 7269 7028 292c 2022 7762 2229 0a20 2020  rip(), "wb").   
-00005d40: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00005d50: 2020 2020 2020 2074 6172 6765 7420 3d20         target = 
-00005d60: 6f70 656e 286f 732e 7061 7468 2e61 6273  open(os.path.abs
-00005d70: 7061 7468 2874 6172 6765 7429 2c20 2277  path(target), "w
-00005d80: 6222 290a 2020 2020 7461 7267 6574 203d  b").    target =
-00005d90: 2063 6173 7428 494f 5b62 7974 6573 5d2c   cast(IO[bytes],
-00005da0: 2074 6172 6765 7429 0a20 2020 2070 726f   target).    pro
-00005db0: 6320 3d20 7375 6270 726f 6365 7373 2e50  c = subprocess.P
-00005dc0: 6f70 656e 280a 2020 2020 2020 2020 225c  open(.        "\
-00005dd0: 2225 735c 2220 2573 2025 7322 2025 2028  "%s\" %s %s" % (
-00005de0: 7072 6f67 2c20 6f70 7469 6f6e 7320 6f72  prog, options or
-00005df0: 2022 222c 2066 6f72 6d61 7420 6f72 2022   "", format or "
-00005e00: 2229 2c0a 2020 2020 2020 2020 7368 656c  "),.        shel
-00005e10: 6c3d 5472 7565 2c20 7374 6469 6e3d 7375  l=True, stdin=su
-00005e20: 6270 726f 6365 7373 2e50 4950 452c 2073  bprocess.PIPE, s
-00005e30: 7464 6f75 743d 7461 7267 6574 2c0a 2020  tdout=target,.  
-00005e40: 2020 2020 2020 7374 6465 7272 3d73 7562        stderr=sub
-00005e50: 7072 6f63 6573 732e 5049 5045 0a20 2020  process.PIPE.   
-00005e60: 2029 0a20 2020 205f 2c20 7374 6465 7272   ).    _, stderr
-00005e70: 203d 2070 726f 632e 636f 6d6d 756e 6963   = proc.communic
-00005e80: 6174 6528 6279 7465 735f 656e 636f 6465  ate(bytes_encode
-00005e90: 2867 7261 7068 2929 0a20 2020 2069 6620  (graph)).    if 
-00005ea0: 7072 6f63 2e72 6574 7572 6e63 6f64 6520  proc.returncode 
-00005eb0: 213d 2030 3a0a 2020 2020 2020 2020 7261  != 0:.        ra
-00005ec0: 6973 6520 4f53 4572 726f 7228 0a20 2020  ise OSError(.   
-00005ed0: 2020 2020 2020 2020 2022 4772 6170 6856           "GraphV
-00005ee0: 697a 2063 616c 6c20 6661 696c 6564 2028  iz call failed (
-00005ef0: 6973 2069 7420 696e 7374 616c 6c65 643f  is it installed?
-00005f00: 293a 5c6e 2220 2b0a 2020 2020 2020 2020  ):\n" +.        
-00005f10: 2020 2020 706c 6169 6e5f 7374 7228 7374      plain_str(st
-00005f20: 6465 7272 290a 2020 2020 2020 2020 290a  derr).        ).
-00005f30: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-00005f40: 2074 6172 6765 742e 636c 6f73 6528 290a   target.close().
-00005f50: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
-00005f60: 7469 6f6e 3a0a 2020 2020 2020 2020 7061  tion:.        pa
-00005f70: 7373 0a20 2020 2069 6620 7374 6172 745f  ss.    if start_
-00005f80: 7669 6577 6572 3a0a 2020 2020 2020 2020  viewer:.        
-00005f90: 2320 576f 726b 6172 6f75 6e64 2066 6f72  # Workaround for
-00005fa0: 2066 696c 6520 6e6f 7420 666f 756e 6420   file not found 
-00005fb0: 6572 726f 723a 2057 6520 7761 6974 2075  error: We wait u
-00005fc0: 6e74 696c 2074 656d 7066 696c 6520 6973  ntil tempfile is
-00005fd0: 2077 7269 7474 656e 2e20 2023 206e 6f71   written.  # noq
-00005fe0: 613a 2045 3530 310a 2020 2020 2020 2020  a: E501.        
-00005ff0: 7761 6974 696e 675f 7374 6172 7420 3d20  waiting_start = 
-00006000: 7469 6d65 2e74 696d 6528 290a 2020 2020  time.time().    
-00006010: 2020 2020 7768 696c 6520 6e6f 7420 6f73      while not os
-00006020: 2e70 6174 682e 6578 6973 7473 2874 6172  .path.exists(tar
-00006030: 6765 742e 6e61 6d65 293a 0a20 2020 2020  get.name):.     
-00006040: 2020 2020 2020 2074 696d 652e 736c 6565         time.slee
-00006050: 7028 302e 3129 0a20 2020 2020 2020 2020  p(0.1).         
-00006060: 2020 2069 6620 7469 6d65 2e74 696d 6528     if time.time(
-00006070: 2920 2d20 7761 6974 696e 675f 7374 6172  ) - waiting_star
-00006080: 7420 3e20 333a 0a20 2020 2020 2020 2020  t > 3:.         
-00006090: 2020 2020 2020 2077 6172 6e69 6e67 2822         warning("
-000060a0: 5465 6d70 6f72 6172 7920 6669 6c65 2027  Temporary file '
-000060b0: 2573 2720 636f 756c 6420 6e6f 7420 6265  %s' could not be
-000060c0: 2077 7269 7474 656e 2e20 4772 6170 6869   written. Graphi
-000060d0: 6320 7769 6c6c 206e 6f74 2062 6520 6469  c will not be di
-000060e0: 7370 6c61 7965 642e 222c 2074 656d 7066  splayed.", tempf
-000060f0: 696c 6529 2020 2320 6e6f 7161 3a20 4535  ile)  # noqa: E5
-00006100: 3031 0a20 2020 2020 2020 2020 2020 2020  01.             
-00006110: 2020 2062 7265 616b 0a20 2020 2020 2020     break.       
-00006120: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00006130: 2020 2069 6620 5749 4e44 4f57 5320 616e     if WINDOWS an
-00006140: 6420 636f 6e66 2e70 726f 672e 6469 7370  d conf.prog.disp
-00006150: 6c61 7920 3d3d 2063 6f6e 662e 7072 6f67  lay == conf.prog
-00006160: 2e5f 6465 6661 756c 743a 0a20 2020 2020  ._default:.     
-00006170: 2020 2020 2020 2020 2020 206f 732e 7374             os.st
-00006180: 6172 7466 696c 6528 7461 7267 6574 2e6e  artfile(target.n
-00006190: 616d 6529 0a20 2020 2020 2020 2020 2020  ame).           
-000061a0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-000061b0: 2020 2020 2020 2077 6974 6820 436f 6e74         with Cont
-000061c0: 6578 744d 616e 6167 6572 5375 6270 726f  extManagerSubpro
-000061d0: 6365 7373 2863 6f6e 662e 7072 6f67 2e64  cess(conf.prog.d
-000061e0: 6973 706c 6179 293a 0a20 2020 2020 2020  isplay):.       
-000061f0: 2020 2020 2020 2020 2020 2020 2073 7562               sub
-00006200: 7072 6f63 6573 732e 506f 7065 6e28 5b63  process.Popen([c
-00006210: 6f6e 662e 7072 6f67 2e64 6973 706c 6179  onf.prog.display
-00006220: 2c20 7461 7267 6574 2e6e 616d 655d 290a  , target.name]).
-00006230: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
-00006240: 0a0a 5f54 4558 5f54 5220 3d20 7b0a 2020  .._TEX_TR = {.  
-00006250: 2020 227b 223a 2022 7b5c 5c74 745c 5c63    "{": "{\\tt\\c
-00006260: 6861 7231 3233 7d22 2c0a 2020 2020 227d  har123}",.    "}
-00006270: 223a 2022 7b5c 5c74 745c 5c63 6861 7231  ": "{\\tt\\char1
-00006280: 3235 7d22 2c0a 2020 2020 225c 5c22 3a20  25}",.    "\\": 
-00006290: 227b 5c5c 7474 5c5c 6368 6172 3932 7d22  "{\\tt\\char92}"
-000062a0: 2c0a 2020 2020 225e 223a 2022 5c5c 5e7b  ,.    "^": "\\^{
-000062b0: 7d22 2c0a 2020 2020 2224 223a 2022 5c5c  }",.    "$": "\\
-000062c0: 2422 2c0a 2020 2020 2223 223a 2022 5c5c  $",.    "#": "\\
-000062d0: 2322 2c0a 2020 2020 225f 223a 2022 5c5c  #",.    "_": "\\
-000062e0: 5f22 2c0a 2020 2020 2226 223a 2022 5c5c  _",.    "&": "\\
-000062f0: 2622 2c0a 2020 2020 2225 223a 2022 5c5c  &",.    "%": "\\
-00006300: 2522 2c0a 2020 2020 227c 223a 2022 7b5c  %",.    "|": "{\
-00006310: 5c74 745c 5c63 6861 7231 3234 7d22 2c0a  \tt\\char124}",.
-00006320: 2020 2020 227e 223a 2022 7b5c 5c74 745c      "~": "{\\tt\
-00006330: 5c63 6861 7231 3236 7d22 2c0a 2020 2020  \char126}",.    
-00006340: 223c 223a 2022 7b5c 5c74 745c 5c63 6861  "<": "{\\tt\\cha
-00006350: 7236 307d 222c 0a20 2020 2022 3e22 3a20  r60}",.    ">": 
-00006360: 227b 5c5c 7474 5c5c 6368 6172 3632 7d22  "{\\tt\\char62}"
-00006370: 2c0a 7d0a 0a0a 6465 6620 7465 785f 6573  ,.}...def tex_es
-00006380: 6361 7065 2878 293a 0a20 2020 2023 2074  cape(x):.    # t
-00006390: 7970 653a 2028 7374 7229 202d 3e20 7374  ype: (str) -> st
-000063a0: 720a 2020 2020 7320 3d20 2222 0a20 2020  r.    s = "".   
-000063b0: 2066 6f72 2063 2069 6e20 783a 0a20 2020   for c in x:.   
-000063c0: 2020 2020 2073 202b 3d20 5f54 4558 5f54       s += _TEX_T
-000063d0: 522e 6765 7428 632c 2063 290a 2020 2020  R.get(c, c).    
-000063e0: 7265 7475 726e 2073 0a0a 0a64 6566 2063  return s...def c
-000063f0: 6f6c 6765 6e28 2a6c 7374 636f 6c2c 2020  olgen(*lstcol,  
-00006400: 2320 7479 7065 3a20 416e 790a 2020 2020  # type: Any.    
-00006410: 2020 2020 2020 202a 2a6b 6172 6773 2020         **kargs  
-00006420: 2320 7479 7065 3a20 416e 790a 2020 2020  # type: Any.    
-00006430: 2020 2020 2020 2029 3a0a 2020 2020 2320         ):.    # 
-00006440: 7479 7065 3a20 282e 2e2e 2920 2d3e 2049  type: (...) -> I
-00006450: 7465 7261 746f 725b 416e 795d 0a20 2020  terator[Any].   
-00006460: 2022 2222 5265 7475 726e 7320 6120 6765   """Returns a ge
-00006470: 6e65 7261 746f 7220 7468 6174 206d 6978  nerator that mix
-00006480: 6573 2070 726f 7669 6465 6420 7175 616e  es provided quan
-00006490: 7469 7469 6573 2066 6f72 6576 6572 0a20  tities forever. 
-000064a0: 2020 2074 7261 6e73 3a20 6120 6675 6e63     trans: a func
-000064b0: 7469 6f6e 2074 6f20 636f 6e76 6572 7420  tion to convert 
-000064c0: 7468 6520 7468 7265 6520 6172 6775 6d65  the three argume
-000064d0: 6e74 7320 696e 746f 2061 2063 6f6c 6f72  nts into a color
-000064e0: 2e20 6c61 6d62 6461 2078 2c79 2c7a 3a28  . lambda x,y,z:(
-000064f0: 782c 792c 7a29 2062 7920 6465 6661 756c  x,y,z) by defaul
-00006500: 7422 2222 2020 2320 6e6f 7161 3a20 4535  t"""  # noqa: E5
-00006510: 3031 0a20 2020 2069 6620 6c65 6e28 6c73  01.    if len(ls
-00006520: 7463 6f6c 2920 3c20 323a 0a20 2020 2020  tcol) < 2:.     
-00006530: 2020 206c 7374 636f 6c20 2a3d 2032 0a20     lstcol *= 2. 
-00006540: 2020 2074 7261 6e73 203d 206b 6172 6773     trans = kargs
-00006550: 2e67 6574 2822 7472 616e 7322 2c20 6c61  .get("trans", la
-00006560: 6d62 6461 2078 2c20 792c 207a 3a20 2878  mbda x, y, z: (x
-00006570: 2c20 792c 207a 2929 0a20 2020 2077 6869  , y, z)).    whi
-00006580: 6c65 2054 7275 653a 0a20 2020 2020 2020  le True:.       
-00006590: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-000065a0: 6c65 6e28 6c73 7463 6f6c 2929 3a0a 2020  len(lstcol)):.  
-000065b0: 2020 2020 2020 2020 2020 666f 7220 6a20            for j 
-000065c0: 696e 2072 616e 6765 286c 656e 286c 7374  in range(len(lst
-000065d0: 636f 6c29 293a 0a20 2020 2020 2020 2020  col)):.         
-000065e0: 2020 2020 2020 2066 6f72 206b 2069 6e20         for k in 
-000065f0: 7261 6e67 6528 6c65 6e28 6c73 7463 6f6c  range(len(lstcol
-00006600: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
-00006610: 2020 2020 2020 2020 6966 2069 2021 3d20          if i != 
-00006620: 6a20 6f72 206a 2021 3d20 6b20 6f72 206b  j or j != k or k
-00006630: 2021 3d20 693a 0a20 2020 2020 2020 2020   != i:.         
-00006640: 2020 2020 2020 2020 2020 2020 2020 2079                 y
-00006650: 6965 6c64 2074 7261 6e73 286c 7374 636f  ield trans(lstco
-00006660: 6c5b 2869 202b 206a 2920 2520 6c65 6e28  l[(i + j) % len(
-00006670: 6c73 7463 6f6c 295d 2c20 6c73 7463 6f6c  lstcol)], lstcol
-00006680: 5b28 6a20 2b20 6b29 2025 206c 656e 286c  [(j + k) % len(l
-00006690: 7374 636f 6c29 5d2c 206c 7374 636f 6c5b  stcol)], lstcol[
-000066a0: 286b 202b 2069 2920 2520 6c65 6e28 6c73  (k + i) % len(ls
-000066b0: 7463 6f6c 295d 2920 2023 206e 6f71 613a  tcol)])  # noqa:
-000066c0: 2045 3530 310a 0a0a 6465 6620 696e 6372   E501...def incr
-000066d0: 656d 656e 7461 6c5f 6c61 6265 6c28 6c61  emental_label(la
-000066e0: 6265 6c3d 2274 6167 2530 3569 222c 2073  bel="tag%05i", s
-000066f0: 7461 7274 3d30 293a 0a20 2020 2023 2074  tart=0):.    # t
-00006700: 7970 653a 2028 7374 722c 2069 6e74 2920  ype: (str, int) 
-00006710: 2d3e 2049 7465 7261 746f 725b 7374 725d  -> Iterator[str]
-00006720: 0a20 2020 2077 6869 6c65 2054 7275 653a  .    while True:
-00006730: 0a20 2020 2020 2020 2079 6965 6c64 206c  .        yield l
-00006740: 6162 656c 2025 2073 7461 7274 0a20 2020  abel % start.   
-00006750: 2020 2020 2073 7461 7274 202b 3d20 310a       start += 1.
-00006760: 0a0a 6465 6620 6269 6e72 6570 7228 7661  ..def binrepr(va
-00006770: 6c29 3a0a 2020 2020 2320 7479 7065 3a20  l):.    # type: 
-00006780: 2869 6e74 2920 2d3e 2073 7472 0a20 2020  (int) -> str.   
-00006790: 2072 6574 7572 6e20 6269 6e28 7661 6c29   return bin(val)
-000067a0: 5b32 3a5d 0a0a 0a64 6566 206c 6f6e 675f  [2:]...def long_
-000067b0: 636f 6e76 6572 7465 7228 7329 3a0a 2020  converter(s):.  
-000067c0: 2020 2320 7479 7065 3a20 2873 7472 2920    # type: (str) 
-000067d0: 2d3e 2069 6e74 0a20 2020 2072 6574 7572  -> int.    retur
-000067e0: 6e20 696e 7428 732e 7265 706c 6163 6528  n int(s.replace(
-000067f0: 275c 6e27 2c20 2727 292e 7265 706c 6163  '\n', '').replac
-00006800: 6528 2720 272c 2027 2729 2c20 3136 290a  e(' ', ''), 16).
-00006810: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
-00006820: 2323 2323 2323 2323 2323 0a23 2020 2020  ##########.#    
-00006830: 456e 756d 206d 616e 6167 656d 656e 7420  Enum management 
-00006840: 2020 2023 0a23 2323 2323 2323 2323 2323     #.###########
-00006850: 2323 2323 2323 2323 2323 2323 2323 0a0a  ##############..
-00006860: 0a63 6c61 7373 2045 6e75 6d45 6c65 6d65  .class EnumEleme
-00006870: 6e74 3a0a 2020 2020 6465 6620 5f5f 696e  nt:.    def __in
-00006880: 6974 5f5f 2873 656c 662c 206b 6579 2c20  it__(self, key, 
-00006890: 7661 6c75 6529 3a0a 2020 2020 2020 2020  value):.        
-000068a0: 2320 7479 7065 3a20 2873 7472 2c20 696e  # type: (str, in
-000068b0: 7429 202d 3e20 4e6f 6e65 0a20 2020 2020  t) -> None.     
-000068c0: 2020 2073 656c 662e 5f6b 6579 203d 206b     self._key = k
-000068d0: 6579 0a20 2020 2020 2020 2073 656c 662e  ey.        self.
-000068e0: 5f76 616c 7565 203d 2076 616c 7565 0a0a  _value = value..
-000068f0: 2020 2020 6465 6620 5f5f 7265 7072 5f5f      def __repr__
-00006900: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00006910: 2320 7479 7065 3a20 2829 202d 3e20 7374  # type: () -> st
-00006920: 720a 2020 2020 2020 2020 7265 7475 726e  r.        return
-00006930: 2022 3c25 7320 2573 5b25 725d 3e22 2025   "<%s %s[%r]>" %
-00006940: 2028 7365 6c66 2e5f 5f64 6963 745f 5f2e   (self.__dict__.
-00006950: 6765 7428 225f 6e61 6d65 222c 2073 656c  get("_name", sel
-00006960: 662e 5f5f 636c 6173 735f 5f2e 5f5f 6e61  f.__class__.__na
-00006970: 6d65 5f5f 292c 2073 656c 662e 5f6b 6579  me__), self._key
-00006980: 2c20 7365 6c66 2e5f 7661 6c75 6529 2020  , self._value)  
-00006990: 2320 6e6f 7161 3a20 4535 3031 0a0a 2020  # noqa: E501..  
-000069a0: 2020 6465 6620 5f5f 6765 7461 7474 725f    def __getattr_
-000069b0: 5f28 7365 6c66 2c20 6174 7472 293a 0a20  _(self, attr):. 
-000069c0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-000069d0: 7374 7229 202d 3e20 416e 790a 2020 2020  str) -> Any.    
-000069e0: 2020 2020 7265 7475 726e 2067 6574 6174      return getat
-000069f0: 7472 2873 656c 662e 5f76 616c 7565 2c20  tr(self._value, 
-00006a00: 6174 7472 290a 0a20 2020 2064 6566 205f  attr)..    def _
-00006a10: 5f73 7472 5f5f 2873 656c 6629 3a0a 2020  _str__(self):.  
-00006a20: 2020 2020 2020 2320 7479 7065 3a20 2829        # type: ()
-00006a30: 202d 3e20 7374 720a 2020 2020 2020 2020   -> str.        
-00006a40: 7265 7475 726e 2073 656c 662e 5f6b 6579  return self._key
-00006a50: 0a0a 2020 2020 6465 6620 5f5f 6279 7465  ..    def __byte
-00006a60: 735f 5f28 7365 6c66 293a 0a20 2020 2020  s__(self):.     
-00006a70: 2020 2023 2074 7970 653a 2028 2920 2d3e     # type: () ->
-00006a80: 2062 7974 6573 0a20 2020 2020 2020 2072   bytes.        r
-00006a90: 6574 7572 6e20 6279 7465 735f 656e 636f  eturn bytes_enco
-00006aa0: 6465 2873 656c 662e 5f5f 7374 725f 5f28  de(self.__str__(
-00006ab0: 2929 0a0a 2020 2020 6465 6620 5f5f 6861  ))..    def __ha
-00006ac0: 7368 5f5f 2873 656c 6629 3a0a 2020 2020  sh__(self):.    
-00006ad0: 2020 2020 2320 7479 7065 3a20 2829 202d      # type: () -
-00006ae0: 3e20 696e 740a 2020 2020 2020 2020 7265  > int.        re
-00006af0: 7475 726e 2073 656c 662e 5f76 616c 7565  turn self._value
-00006b00: 0a0a 2020 2020 6465 6620 5f5f 696e 745f  ..    def __int_
-00006b10: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
-00006b20: 2023 2074 7970 653a 2028 2920 2d3e 2069   # type: () -> i
-00006b30: 6e74 0a20 2020 2020 2020 2072 6574 7572  nt.        retur
-00006b40: 6e20 696e 7428 7365 6c66 2e5f 7661 6c75  n int(self._valu
-00006b50: 6529 0a0a 2020 2020 6465 6620 5f5f 6571  e)..    def __eq
-00006b60: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
-00006b70: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-00006b80: 2028 416e 7929 202d 3e20 626f 6f6c 0a20   (Any) -> bool. 
-00006b90: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00006ba0: 6c66 2e5f 7661 6c75 6520 3d3d 2069 6e74  lf._value == int
-00006bb0: 286f 7468 6572 290a 0a20 2020 2064 6566  (other)..    def
-00006bc0: 205f 5f6e 6571 5f5f 2873 656c 662c 206f   __neq__(self, o
-00006bd0: 7468 6572 293a 0a20 2020 2020 2020 2023  ther):.        #
-00006be0: 2074 7970 653a 2028 416e 7929 202d 3e20   type: (Any) -> 
-00006bf0: 626f 6f6c 0a20 2020 2020 2020 2072 6574  bool.        ret
-00006c00: 7572 6e20 6e6f 7420 7365 6c66 2e5f 5f65  urn not self.__e
-00006c10: 715f 5f28 6f74 6865 7229 0a0a 0a63 6c61  q__(other)...cla
-00006c20: 7373 2045 6e75 6d5f 6d65 7461 636c 6173  ss Enum_metaclas
-00006c30: 7328 7479 7065 293a 0a20 2020 2065 6c65  s(type):.    ele
-00006c40: 6d65 6e74 5f63 6c61 7373 203d 2045 6e75  ment_class = Enu
-00006c50: 6d45 6c65 6d65 6e74 0a0a 2020 2020 6465  mElement..    de
-00006c60: 6620 5f5f 6e65 775f 5f28 636c 732c 206e  f __new__(cls, n
-00006c70: 616d 652c 2062 6173 6573 2c20 6463 7429  ame, bases, dct)
-00006c80: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-00006c90: 3a20 2841 6e79 2c20 7374 722c 2041 6e79  : (Any, str, Any
-00006ca0: 2c20 4469 6374 5b73 7472 2c20 416e 795d  , Dict[str, Any]
-00006cb0: 2920 2d3e 2041 6e79 0a20 2020 2020 2020  ) -> Any.       
-00006cc0: 2072 6469 6374 203d 207b 7d0a 2020 2020   rdict = {}.    
-00006cd0: 2020 2020 666f 7220 6b2c 2076 2069 6e20      for k, v in 
-00006ce0: 7369 782e 6974 6572 6974 656d 7328 6463  six.iteritems(dc
-00006cf0: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-00006d00: 6966 2069 7369 6e73 7461 6e63 6528 762c  if isinstance(v,
-00006d10: 2069 6e74 293a 0a20 2020 2020 2020 2020   int):.         
-00006d20: 2020 2020 2020 2076 203d 2063 6c73 2e65         v = cls.e
-00006d30: 6c65 6d65 6e74 5f63 6c61 7373 286b 2c20  lement_class(k, 
-00006d40: 7629 0a20 2020 2020 2020 2020 2020 2020  v).             
-00006d50: 2020 2064 6374 5b6b 5d20 3d20 760a 2020     dct[k] = v.  
-00006d60: 2020 2020 2020 2020 2020 2020 2020 7264                rd
-00006d70: 6963 745b 765d 203d 206b 0a20 2020 2020  ict[v] = k.     
-00006d80: 2020 2064 6374 5b22 5f5f 7264 6963 745f     dct["__rdict_
-00006d90: 5f22 5d20 3d20 7264 6963 740a 2020 2020  _"] = rdict.    
-00006da0: 2020 2020 7265 7475 726e 2073 7570 6572      return super
-00006db0: 2845 6e75 6d5f 6d65 7461 636c 6173 732c  (Enum_metaclass,
-00006dc0: 2063 6c73 292e 5f5f 6e65 775f 5f28 636c   cls).__new__(cl
-00006dd0: 732c 206e 616d 652c 2062 6173 6573 2c20  s, name, bases, 
-00006de0: 6463 7429 0a0a 2020 2020 6465 6620 5f5f  dct)..    def __
-00006df0: 6765 7469 7465 6d5f 5f28 7365 6c66 2c20  getitem__(self, 
-00006e00: 6174 7472 293a 0a20 2020 2020 2020 2023  attr):.        #
-00006e10: 2074 7970 653a 2028 696e 7429 202d 3e20   type: (int) -> 
-00006e20: 416e 790a 2020 2020 2020 2020 7265 7475  Any.        retu
-00006e30: 726e 2073 656c 662e 5f5f 7264 6963 745f  rn self.__rdict_
-00006e40: 5f5b 6174 7472 5d20 2023 2074 7970 653a  _[attr]  # type:
-00006e50: 2069 676e 6f72 650a 0a20 2020 2064 6566   ignore..    def
-00006e60: 205f 5f63 6f6e 7461 696e 735f 5f28 7365   __contains__(se
-00006e70: 6c66 2c20 7661 6c29 3a0a 2020 2020 2020  lf, val):.      
-00006e80: 2020 2320 7479 7065 3a20 2869 6e74 2920    # type: (int) 
-00006e90: 2d3e 2062 6f6f 6c0a 2020 2020 2020 2020  -> bool.        
-00006ea0: 7265 7475 726e 2076 616c 2069 6e20 7365  return val in se
-00006eb0: 6c66 2e5f 5f72 6469 6374 5f5f 2020 2320  lf.__rdict__  # 
-00006ec0: 7479 7065 3a20 6967 6e6f 7265 0a0a 2020  type: ignore..  
-00006ed0: 2020 6465 6620 6765 7428 7365 6c66 2c20    def get(self, 
-00006ee0: 6174 7472 2c20 7661 6c3d 4e6f 6e65 293a  attr, val=None):
-00006ef0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-00006f00: 2028 7374 722c 204f 7074 696f 6e61 6c5b   (str, Optional[
-00006f10: 416e 795d 2920 2d3e 2041 6e79 0a20 2020  Any]) -> Any.   
-00006f20: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00006f30: 2e5f 5f72 6469 6374 5f5f 2e67 6574 2861  .__rdict__.get(a
-00006f40: 7474 722c 2076 616c 2920 2023 2074 7970  ttr, val)  # typ
-00006f50: 653a 2069 676e 6f72 650a 0a20 2020 2064  e: ignore..    d
-00006f60: 6566 205f 5f72 6570 725f 5f28 7365 6c66  ef __repr__(self
-00006f70: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
-00006f80: 653a 2028 2920 2d3e 2073 7472 0a20 2020  e: () -> str.   
-00006f90: 2020 2020 2072 6574 7572 6e20 223c 2573       return "<%s
-00006fa0: 3e22 2025 2073 656c 662e 5f5f 6469 6374  >" % self.__dict
-00006fb0: 5f5f 2e67 6574 2822 6e61 6d65 222c 2073  __.get("name", s
-00006fc0: 656c 662e 5f5f 6e61 6d65 5f5f 290a 0a0a  elf.__name__)...
-00006fd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006fe0: 2323 230a 2320 204f 626a 6563 7420 7361  ###.#  Object sa
-00006ff0: 7669 6e67 2020 230a 2323 2323 2323 2323  ving  #.########
-00007000: 2323 2323 2323 2323 2323 230a 0a0a 6465  ###########...de
-00007010: 6620 6578 706f 7274 5f6f 626a 6563 7428  f export_object(
-00007020: 6f62 6a29 3a0a 2020 2020 2320 7479 7065  obj):.    # type
-00007030: 3a20 2841 6e79 2920 2d3e 204e 6f6e 650a  : (Any) -> None.
-00007040: 2020 2020 696d 706f 7274 207a 6c69 620a      import zlib.
-00007050: 2020 2020 7072 696e 7428 6279 7465 735f      print(bytes_
-00007060: 6261 7365 3634 287a 6c69 622e 636f 6d70  base64(zlib.comp
-00007070: 7265 7373 2873 6978 2e6d 6f76 6573 2e63  ress(six.moves.c
-00007080: 5069 636b 6c65 2e64 756d 7073 286f 626a  Pickle.dumps(obj
-00007090: 2c20 3229 2c20 3929 2929 0a0a 0a64 6566  , 2), 9)))...def
-000070a0: 2069 6d70 6f72 745f 6f62 6a65 6374 286f   import_object(o
-000070b0: 626a 3d4e 6f6e 6529 3a0a 2020 2020 2320  bj=None):.    # 
-000070c0: 7479 7065 3a20 284f 7074 696f 6e61 6c5b  type: (Optional[
-000070d0: 7374 725d 2920 2d3e 2041 6e79 0a20 2020  str]) -> Any.   
-000070e0: 2069 6d70 6f72 7420 7a6c 6962 0a20 2020   import zlib.   
-000070f0: 2069 6620 6f62 6a20 6973 204e 6f6e 653a   if obj is None:
-00007100: 0a20 2020 2020 2020 206f 626a 203d 2073  .        obj = s
-00007110: 7973 2e73 7464 696e 2e72 6561 6428 290a  ys.stdin.read().
-00007120: 2020 2020 7265 7475 726e 2073 6978 2e6d      return six.m
-00007130: 6f76 6573 2e63 5069 636b 6c65 2e6c 6f61  oves.cPickle.loa
-00007140: 6473 287a 6c69 622e 6465 636f 6d70 7265  ds(zlib.decompre
-00007150: 7373 2862 6173 6536 345f 6279 7465 7328  ss(base64_bytes(
-00007160: 6f62 6a2e 7374 7269 7028 2929 2929 2020  obj.strip())))  
-00007170: 2320 6e6f 7161 3a20 4535 3031 0a0a 0a64  # noqa: E501...d
-00007180: 6566 2073 6176 655f 6f62 6a65 6374 2866  ef save_object(f
-00007190: 6e61 6d65 2c20 6f62 6a29 3a0a 2020 2020  name, obj):.    
-000071a0: 2320 7479 7065 3a20 2873 7472 2c20 416e  # type: (str, An
-000071b0: 7929 202d 3e20 4e6f 6e65 0a20 2020 2022  y) -> None.    "
-000071c0: 2222 5069 636b 6c65 2061 2050 7974 686f  ""Pickle a Pytho
-000071d0: 6e20 6f62 6a65 6374 2222 220a 0a20 2020  n object"""..   
-000071e0: 2066 6420 3d20 677a 6970 2e6f 7065 6e28   fd = gzip.open(
-000071f0: 666e 616d 652c 2022 7762 2229 0a20 2020  fname, "wb").   
-00007200: 2073 6978 2e6d 6f76 6573 2e63 5069 636b   six.moves.cPick
-00007210: 6c65 2e64 756d 7028 6f62 6a2c 2066 6429  le.dump(obj, fd)
-00007220: 0a20 2020 2066 642e 636c 6f73 6528 290a  .    fd.close().
-00007230: 0a0a 6465 6620 6c6f 6164 5f6f 626a 6563  ..def load_objec
-00007240: 7428 666e 616d 6529 3a0a 2020 2020 2320  t(fname):.    # 
-00007250: 7479 7065 3a20 2873 7472 2920 2d3e 2041  type: (str) -> A
-00007260: 6e79 0a20 2020 2022 2222 756e 7069 636b  ny.    """unpick
-00007270: 6c65 2061 2050 7974 686f 6e20 6f62 6a65  le a Python obje
-00007280: 6374 2222 220a 2020 2020 7265 7475 726e  ct""".    return
-00007290: 2073 6978 2e6d 6f76 6573 2e63 5069 636b   six.moves.cPick
-000072a0: 6c65 2e6c 6f61 6428 677a 6970 2e6f 7065  le.load(gzip.ope
-000072b0: 6e28 666e 616d 652c 2022 7262 2229 290a  n(fname, "rb")).
-000072c0: 0a0a 4063 6f6e 662e 636f 6d6d 616e 6473  ..@conf.commands
-000072d0: 2e72 6567 6973 7465 720a 6465 6620 636f  .register.def co
-000072e0: 7272 7570 745f 6279 7465 7328 6461 7461  rrupt_bytes(data
-000072f0: 2c20 703d 302e 3031 2c20 6e3d 4e6f 6e65  , p=0.01, n=None
-00007300: 293a 0a20 2020 2023 2074 7970 653a 2028  ):.    # type: (
-00007310: 7374 722c 2066 6c6f 6174 2c20 4f70 7469  str, float, Opti
-00007320: 6f6e 616c 5b69 6e74 5d29 202d 3e20 6279  onal[int]) -> by
-00007330: 7465 730a 2020 2020 2222 220a 2020 2020  tes.    """.    
-00007340: 436f 7272 7570 7420 6120 6769 7665 6e20  Corrupt a given 
-00007350: 7065 7263 656e 7461 6765 2028 6174 206c  percentage (at l
-00007360: 6561 7374 206f 6e65 2062 7974 6529 206f  east one byte) o
-00007370: 7220 6e75 6d62 6572 206f 6620 6279 7465  r number of byte
-00007380: 730a 2020 2020 6672 6f6d 2061 2073 7472  s.    from a str
-00007390: 696e 670a 2020 2020 2222 220a 2020 2020  ing.    """.    
-000073a0: 7320 3d20 6172 7261 792e 6172 7261 7928  s = array.array(
-000073b0: 2242 222c 2062 7974 6573 5f65 6e63 6f64  "B", bytes_encod
-000073c0: 6528 6461 7461 2929 0a20 2020 2073 5f6c  e(data)).    s_l
-000073d0: 656e 203d 206c 656e 2873 290a 2020 2020  en = len(s).    
-000073e0: 6966 206e 2069 7320 4e6f 6e65 3a0a 2020  if n is None:.  
-000073f0: 2020 2020 2020 6e20 3d20 6d61 7828 312c        n = max(1,
-00007400: 2069 6e74 2873 5f6c 656e 202a 2070 2929   int(s_len * p))
-00007410: 0a20 2020 2066 6f72 2069 2069 6e20 7261  .    for i in ra
-00007420: 6e64 6f6d 2e73 616d 706c 6528 7261 6e67  ndom.sample(rang
-00007430: 6528 735f 6c65 6e29 2c20 6e29 3a0a 2020  e(s_len), n):.  
-00007440: 2020 2020 2020 735b 695d 203d 2028 735b        s[i] = (s[
-00007450: 695d 202b 2072 616e 646f 6d2e 7261 6e64  i] + random.rand
-00007460: 696e 7428 312c 2032 3535 2929 2025 2032  int(1, 255)) % 2
-00007470: 3536 0a20 2020 2072 6574 7572 6e20 732e  56.    return s.
-00007480: 746f 7374 7269 6e67 2829 2069 6620 7369  tostring() if si
-00007490: 782e 5059 3220 656c 7365 2073 2e74 6f62  x.PY2 else s.tob
-000074a0: 7974 6573 2829 2020 2320 7479 7065 3a20  ytes()  # type: 
-000074b0: 6967 6e6f 7265 0a0a 0a40 636f 6e66 2e63  ignore...@conf.c
-000074c0: 6f6d 6d61 6e64 732e 7265 6769 7374 6572  ommands.register
-000074d0: 0a64 6566 2063 6f72 7275 7074 5f62 6974  .def corrupt_bit
-000074e0: 7328 6461 7461 2c20 703d 302e 3031 2c20  s(data, p=0.01, 
-000074f0: 6e3d 4e6f 6e65 293a 0a20 2020 2023 2074  n=None):.    # t
-00007500: 7970 653a 2028 7374 722c 2066 6c6f 6174  ype: (str, float
-00007510: 2c20 4f70 7469 6f6e 616c 5b69 6e74 5d29  , Optional[int])
-00007520: 202d 3e20 6279 7465 730a 2020 2020 2222   -> bytes.    ""
-00007530: 220a 2020 2020 466c 6970 2061 2067 6976  ".    Flip a giv
-00007540: 656e 2070 6572 6365 6e74 6167 6520 2861  en percentage (a
-00007550: 7420 6c65 6173 7420 6f6e 6520 6269 7429  t least one bit)
-00007560: 206f 7220 6e75 6d62 6572 206f 6620 6269   or number of bi
-00007570: 7473 0a20 2020 2066 726f 6d20 6120 7374  ts.    from a st
-00007580: 7269 6e67 0a20 2020 2022 2222 0a20 2020  ring.    """.   
-00007590: 2073 203d 2061 7272 6179 2e61 7272 6179   s = array.array
-000075a0: 2822 4222 2c20 6279 7465 735f 656e 636f  ("B", bytes_enco
-000075b0: 6465 2864 6174 6129 290a 2020 2020 735f  de(data)).    s_
-000075c0: 6c65 6e20 3d20 6c65 6e28 7329 202a 2038  len = len(s) * 8
-000075d0: 0a20 2020 2069 6620 6e20 6973 204e 6f6e  .    if n is Non
-000075e0: 653a 0a20 2020 2020 2020 206e 203d 206d  e:.        n = m
-000075f0: 6178 2831 2c20 696e 7428 735f 6c65 6e20  ax(1, int(s_len 
-00007600: 2a20 7029 290a 2020 2020 666f 7220 6920  * p)).    for i 
-00007610: 696e 2072 616e 646f 6d2e 7361 6d70 6c65  in random.sample
-00007620: 2872 616e 6765 2873 5f6c 656e 292c 206e  (range(s_len), n
-00007630: 293a 0a20 2020 2020 2020 2073 5b69 202f  ):.        s[i /
-00007640: 2f20 385d 205e 3d20 3120 3c3c 2028 6920  / 8] ^= 1 << (i 
-00007650: 2520 3829 0a20 2020 2072 6574 7572 6e20  % 8).    return 
-00007660: 732e 746f 7374 7269 6e67 2829 2069 6620  s.tostring() if 
-00007670: 7369 782e 5059 3220 656c 7365 2073 2e74  six.PY2 else s.t
-00007680: 6f62 7974 6573 2829 2020 2320 7479 7065  obytes()  # type
-00007690: 3a20 6967 6e6f 7265 0a0a 0a23 2323 2323  : ignore...#####
-000076a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000076b0: 2323 2323 2323 2323 0a23 2020 7063 6170  ########.#  pcap
-000076c0: 2063 6170 7475 7265 2066 696c 6520 7374   capture file st
-000076d0: 7566 6620 2023 0a23 2323 2323 2323 2323  uff  #.#########
-000076e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000076f0: 2323 2323 0a0a 4063 6f6e 662e 636f 6d6d  ####..@conf.comm
-00007700: 616e 6473 2e72 6567 6973 7465 720a 6465  ands.register.de
-00007710: 6620 7772 7063 6170 2866 696c 656e 616d  f wrpcap(filenam
-00007720: 652c 2020 2320 7479 7065 3a20 556e 696f  e,  # type: Unio
-00007730: 6e5b 494f 5b62 7974 6573 5d2c 2073 7472  n[IO[bytes], str
-00007740: 5d0a 2020 2020 2020 2020 2020 2070 6b74  ].           pkt
-00007750: 2c20 2023 2074 7970 653a 205f 5061 636b  ,  # type: _Pack
-00007760: 6574 4974 6572 6162 6c65 0a20 2020 2020  etIterable.     
-00007770: 2020 2020 2020 2a61 7267 732c 2020 2320        *args,  # 
-00007780: 7479 7065 3a20 416e 790a 2020 2020 2020  type: Any.      
-00007790: 2020 2020 202a 2a6b 6172 6773 2020 2320       **kargs  # 
-000077a0: 7479 7065 3a20 416e 790a 2020 2020 2020  type: Any.      
-000077b0: 2020 2020 2029 3a0a 2020 2020 2320 7479       ):.    # ty
-000077c0: 7065 3a20 282e 2e2e 2920 2d3e 204e 6f6e  pe: (...) -> Non
-000077d0: 650a 2020 2020 2222 2257 7269 7465 2061  e.    """Write a
-000077e0: 206c 6973 7420 6f66 2070 6163 6b65 7473   list of packets
-000077f0: 2074 6f20 6120 7063 6170 2066 696c 650a   to a pcap file.
-00007800: 0a20 2020 203a 7061 7261 6d20 6669 6c65  .    :param file
-00007810: 6e61 6d65 3a20 7468 6520 6e61 6d65 206f  name: the name o
-00007820: 6620 7468 6520 6669 6c65 2074 6f20 7772  f the file to wr
-00007830: 6974 6520 7061 636b 6574 7320 746f 2c20  ite packets to, 
-00007840: 6f72 2061 6e20 6f70 656e 2c0a 2020 2020  or an open,.    
-00007850: 2020 2020 7772 6974 6162 6c65 2066 696c      writable fil
-00007860: 652d 6c69 6b65 206f 626a 6563 742e 2054  e-like object. T
-00007870: 6865 2066 696c 6520 6465 7363 7269 7074  he file descript
-00007880: 6f72 2077 696c 6c20 6265 0a20 2020 2020  or will be.     
-00007890: 2020 2063 6c6f 7365 6420 6174 2074 6865     closed at the
-000078a0: 2065 6e64 206f 6620 7468 6520 6361 6c6c   end of the call
-000078b0: 2c20 736f 2064 6f20 6e6f 7420 7573 6520  , so do not use 
-000078c0: 616e 206f 626a 6563 7420 796f 750a 2020  an object you.  
-000078d0: 2020 2020 2020 646f 206e 6f74 2077 616e        do not wan
-000078e0: 7420 746f 2063 6c6f 7365 2028 652e 672e  t to close (e.g.
-000078f0: 2c20 7275 6e6e 696e 6720 7772 7063 6170  , running wrpcap
-00007900: 2873 7973 2e73 7464 6f75 742c 205b 5d29  (sys.stdout, [])
-00007910: 0a20 2020 2020 2020 2069 6e20 696e 7465  .        in inte
-00007920: 7261 6374 6976 6520 6d6f 6465 2077 696c  ractive mode wil
-00007930: 6c20 6372 6173 6820 5363 6170 7929 2e0a  l crash Scapy)..
-00007940: 2020 2020 3a70 6172 616d 2067 7a3a 2073      :param gz: s
-00007950: 6574 2074 6f20 3120 746f 2073 6176 6520  et to 1 to save 
-00007960: 6120 677a 6970 7065 6420 6361 7074 7572  a gzipped captur
-00007970: 650a 2020 2020 3a70 6172 616d 206c 696e  e.    :param lin
-00007980: 6b74 7970 653a 2066 6f72 6365 206c 696e  ktype: force lin
-00007990: 6b74 7970 6520 7661 6c75 650a 2020 2020  ktype value.    
-000079a0: 3a70 6172 616d 2065 6e64 6961 6e6e 6573  :param endiannes
-000079b0: 733a 2022 3c22 206f 7220 223e 222c 2066  s: "<" or ">", f
-000079c0: 6f72 6365 2065 6e64 6961 6e6e 6573 730a  orce endianness.
-000079d0: 2020 2020 3a70 6172 616d 2073 796e 633a      :param sync:
-000079e0: 2064 6f20 6e6f 7420 6275 6666 6572 697a   do not bufferiz
-000079f0: 6520 7772 6974 6573 2074 6f20 7468 6520  e writes to the 
-00007a00: 6361 7074 7572 6520 6669 6c65 0a20 2020  capture file.   
-00007a10: 2022 2222 0a20 2020 2077 6974 6820 5063   """.    with Pc
-00007a20: 6170 5772 6974 6572 2866 696c 656e 616d  apWriter(filenam
-00007a30: 652c 202a 6172 6773 2c20 2a2a 6b61 7267  e, *args, **karg
-00007a40: 7329 2061 7320 6664 6573 633a 0a20 2020  s) as fdesc:.   
-00007a50: 2020 2020 2066 6465 7363 2e77 7269 7465       fdesc.write
-00007a60: 2870 6b74 290a 0a0a 4063 6f6e 662e 636f  (pkt)...@conf.co
-00007a70: 6d6d 616e 6473 2e72 6567 6973 7465 720a  mmands.register.
-00007a80: 6465 6620 7772 7063 6170 6e67 2866 696c  def wrpcapng(fil
-00007a90: 656e 616d 652c 2020 2320 7479 7065 3a20  ename,  # type: 
-00007aa0: 7374 720a 2020 2020 2020 2020 2020 2020  str.            
-00007ab0: 2070 6b74 2c20 2023 2074 7970 653a 205f   pkt,  # type: _
-00007ac0: 5061 636b 6574 4974 6572 6162 6c65 0a20  PacketIterable. 
-00007ad0: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
-00007ae0: 2020 2023 2074 7970 653a 2028 2e2e 2e29     # type: (...)
-00007af0: 202d 3e20 4e6f 6e65 0a20 2020 2022 2222   -> None.    """
-00007b00: 5772 6974 6520 6120 6c69 7374 206f 6620  Write a list of 
-00007b10: 7061 636b 6574 7320 746f 2061 2070 6361  packets to a pca
-00007b20: 706e 6720 6669 6c65 0a0a 2020 2020 3a70  png file..    :p
-00007b30: 6172 616d 2066 696c 656e 616d 653a 2074  aram filename: t
-00007b40: 6865 206e 616d 6520 6f66 2074 6865 2066  he name of the f
-00007b50: 696c 6520 746f 2077 7269 7465 2070 6163  ile to write pac
-00007b60: 6b65 7473 2074 6f2c 206f 7220 616e 206f  kets to, or an o
-00007b70: 7065 6e2c 0a20 2020 2020 2020 2077 7269  pen,.        wri
-00007b80: 7461 626c 6520 6669 6c65 2d6c 696b 6520  table file-like 
-00007b90: 6f62 6a65 6374 2e20 5468 6520 6669 6c65  object. The file
-00007ba0: 2064 6573 6372 6970 746f 7220 7769 6c6c   descriptor will
-00007bb0: 2062 650a 2020 2020 2020 2020 636c 6f73   be.        clos
-00007bc0: 6564 2061 7420 7468 6520 656e 6420 6f66  ed at the end of
-00007bd0: 2074 6865 2063 616c 6c2c 2073 6f20 646f   the call, so do
-00007be0: 206e 6f74 2075 7365 2061 6e20 6f62 6a65   not use an obje
-00007bf0: 6374 2079 6f75 0a20 2020 2020 2020 2064  ct you.        d
-00007c00: 6f20 6e6f 7420 7761 6e74 2074 6f20 636c  o not want to cl
-00007c10: 6f73 6520 2865 2e67 2e2c 2072 756e 6e69  ose (e.g., runni
-00007c20: 6e67 2077 7270 6361 706e 6728 7379 732e  ng wrpcapng(sys.
-00007c30: 7374 646f 7574 2c20 5b5d 290a 2020 2020  stdout, []).    
-00007c40: 2020 2020 696e 2069 6e74 6572 6163 7469      in interacti
-00007c50: 7665 206d 6f64 6520 7769 6c6c 2063 7261  ve mode will cra
-00007c60: 7368 2053 6361 7079 292e 0a20 2020 203a  sh Scapy)..    :
-00007c70: 7061 7261 6d20 706b 743a 2070 6163 6b65  param pkt: packe
-00007c80: 7473 2074 6f20 7772 6974 650a 2020 2020  ts to write.    
-00007c90: 2222 220a 2020 2020 7769 7468 2050 6361  """.    with Pca
-00007ca0: 704e 6757 7269 7465 7228 6669 6c65 6e61  pNgWriter(filena
-00007cb0: 6d65 2920 6173 2066 6465 7363 3a0a 2020  me) as fdesc:.  
-00007cc0: 2020 2020 2020 6664 6573 632e 7772 6974        fdesc.writ
-00007cd0: 6528 706b 7429 0a0a 0a40 636f 6e66 2e63  e(pkt)...@conf.c
-00007ce0: 6f6d 6d61 6e64 732e 7265 6769 7374 6572  ommands.register
-00007cf0: 0a64 6566 2072 6470 6361 7028 6669 6c65  .def rdpcap(file
-00007d00: 6e61 6d65 2c20 636f 756e 743d 2d31 293a  name, count=-1):
-00007d10: 0a20 2020 2023 2074 7970 653a 2028 556e  .    # type: (Un
-00007d20: 696f 6e5b 494f 5b62 7974 6573 5d2c 2073  ion[IO[bytes], s
-00007d30: 7472 5d2c 2069 6e74 2920 2d3e 2050 6163  tr], int) -> Pac
-00007d40: 6b65 744c 6973 740a 2020 2020 2222 2252  ketList.    """R
-00007d50: 6561 6420 6120 7063 6170 206f 7220 7063  ead a pcap or pc
-00007d60: 6170 6e67 2066 696c 6520 616e 6420 7265  apng file and re
-00007d70: 7475 726e 2061 2070 6163 6b65 7420 6c69  turn a packet li
-00007d80: 7374 0a0a 2020 2020 3a70 6172 616d 2063  st..    :param c
-00007d90: 6f75 6e74 3a20 7265 6164 206f 6e6c 7920  ount: read only 
-00007da0: 3c63 6f75 6e74 3e20 7061 636b 6574 730a  <count> packets.
-00007db0: 2020 2020 2222 220a 2020 2020 2320 5261      """.    # Ra
-00007dc0: 6e74 3a20 4f75 7220 636f 6d70 6c69 6361  nt: Our complica
-00007dd0: 7465 6420 7573 6520 6f66 206d 6574 6163  ted use of metac
-00007de0: 6c61 7373 6573 2061 6e64 2065 7370 6563  lasses and espec
-00007df0: 6961 6c6c 7920 7468 650a 2020 2020 2320  ially the.    # 
-00007e00: 5f5f 6361 6c6c 5f5f 2066 756e 6374 696f  __call__ functio
-00007e10: 6e20 6973 2c20 6f66 2063 6f75 7273 652c  n is, of course,
-00007e20: 206e 6f74 2073 7570 706f 7274 6564 2062   not supported b
-00007e30: 7920 4d79 5079 2e0a 2020 2020 2320 4f6e  y MyPy..    # On
-00007e40: 6520 6461 7920 7765 2073 686f 756c 6420  e day we should 
-00007e50: 7369 6d70 6c69 6679 2074 6869 7320 6d65  simplify this me
-00007e60: 7373 2061 6e64 2075 7365 2061 206d 7563  ss and use a muc
-00007e70: 6820 7369 6d70 6c65 720a 2020 2020 2320  h simpler.    # 
-00007e80: 6c61 796f 7574 2074 6861 7420 7769 6c6c  layout that will
-00007e90: 2061 6374 7561 6c6c 7920 6265 2073 7570   actually be sup
-00007ea0: 706f 7274 6564 2061 6e64 2070 726f 7065  ported and prope
-00007eb0: 726c 7920 6469 7373 6563 7465 642e 0a20  rly dissected.. 
-00007ec0: 2020 2077 6974 6820 5063 6170 5265 6164     with PcapRead
-00007ed0: 6572 2866 696c 656e 616d 6529 2061 7320  er(filename) as 
-00007ee0: 6664 6573 633a 2020 2320 7479 7065 3a20  fdesc:  # type: 
-00007ef0: 6967 6e6f 7265 0a20 2020 2020 2020 2072  ignore.        r
-00007f00: 6574 7572 6e20 6664 6573 632e 7265 6164  eturn fdesc.read
-00007f10: 5f61 6c6c 2863 6f75 6e74 3d63 6f75 6e74  _all(count=count
-00007f20: 290a 0a0a 2320 4e4f 5445 3a20 5479 7065  )...# NOTE: Type
-00007f30: 2068 696e 7469 6e67 0a23 204d 7970 7920   hinting.# Mypy 
-00007f40: 646f 6573 6e27 7420 756e 6465 7273 7461  doesn't understa
-00007f50: 6e64 2074 6865 2066 6f6c 6c6f 7769 6e67  nd the following
-00007f60: 206d 6574 6163 6c61 7373 2c20 616e 6420   metaclass, and 
-00007f70: 7468 696e 6b73 2065 6163 680a 2320 636f  thinks each.# co
-00007f80: 6e73 7472 7563 746f 7220 2850 6361 7052  nstructor (PcapR
-00007f90: 6561 6465 722e 2e2e 2920 6e65 6564 7320  eader...) needs 
-00007fa0: 3320 6172 6775 6d65 6e74 7320 6561 6368  3 arguments each
-00007fb0: 2e20 546f 2061 766f 6964 2074 6869 732c  . To avoid this,
-00007fc0: 0a23 2077 6520 6164 6420 6120 6661 6b65  .# we add a fake
-00007fd0: 2028 3d4e 6f6e 6529 2074 6f20 7468 6520   (=None) to the 
-00007fe0: 6c61 7374 2032 2061 7267 756d 656e 7473  last 2 arguments
-00007ff0: 2074 6865 6e20 666f 7263 6520 7468 6520   then force the 
-00008000: 7661 6c75 650a 2320 746f 206e 6f74 2062  value.# to not b
-00008010: 6520 4e6f 6e65 2069 6e20 7468 6520 7369  e None in the si
-00008020: 676e 6174 7572 6520 616e 6420 7061 636b  gnature and pack
-00008030: 2074 6865 2077 686f 6c65 2074 6869 6e67   the whole thing
-00008040: 2069 6e20 616e 2069 676e 6f72 652e 0a23   in an ignore..#
-00008050: 2054 6869 7320 616c 6c6f 7773 2074 6f20   This allows to 
-00008060: 6e6f 7420 6861 7665 2023 2074 7970 653a  not have # type:
-00008070: 2069 676e 6f72 6520 6576 6572 7920 7469   ignore every ti
-00008080: 6d65 2077 6520 6361 6c6c 2074 686f 7365  me we call those
-00008090: 0a23 2063 6f6e 7374 7275 6374 6f72 732e  .# constructors.
-000080a0: 0a0a 636c 6173 7320 5063 6170 5265 6164  ..class PcapRead
-000080b0: 6572 5f6d 6574 6163 6c61 7373 2874 7970  er_metaclass(typ
-000080c0: 6529 3a0a 2020 2020 2222 224d 6574 6163  e):.    """Metac
-000080d0: 6c61 7373 2066 6f72 2028 5261 7729 5063  lass for (Raw)Pc
-000080e0: 6170 284e 6729 5265 6164 6572 7322 2222  ap(Ng)Readers"""
-000080f0: 0a0a 2020 2020 6465 6620 5f5f 6e65 775f  ..    def __new_
-00008100: 5f28 636c 732c 206e 616d 652c 2062 6173  _(cls, name, bas
-00008110: 6573 2c20 6463 7429 3a0a 2020 2020 2020  es, dct):.      
-00008120: 2020 2320 7479 7065 3a20 2841 6e79 2c20    # type: (Any, 
-00008130: 7374 722c 2041 6e79 2c20 4469 6374 5b73  str, Any, Dict[s
-00008140: 7472 2c20 416e 795d 2920 2d3e 2041 6e79  tr, Any]) -> Any
-00008150: 0a20 2020 2020 2020 2022 2222 5468 6520  .        """The 
-00008160: 6061 6c74 6572 6e61 7469 7665 6020 636c  `alternative` cl
-00008170: 6173 7320 6174 7472 6962 7574 6520 6973  ass attribute is
-00008180: 2064 6563 6c61 7265 6420 696e 2074 6865   declared in the
-00008190: 2050 6361 704e 670a 2020 2020 2020 2020   PcapNg.        
-000081a0: 7661 7269 616e 742c 2061 6e64 2073 6574  variant, and set
-000081b0: 2068 6572 6520 746f 2074 6865 2050 6361   here to the Pca
-000081c0: 7020 7661 7269 616e 742e 0a0a 2020 2020  p variant...    
-000081d0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-000081e0: 6e65 7763 6c73 203d 2073 7570 6572 2850  newcls = super(P
-000081f0: 6361 7052 6561 6465 725f 6d65 7461 636c  capReader_metacl
-00008200: 6173 732c 2063 6c73 292e 5f5f 6e65 775f  ass, cls).__new_
-00008210: 5f28 0a20 2020 2020 2020 2020 2020 2063  _(.            c
-00008220: 6c73 2c20 6e61 6d65 2c20 6261 7365 732c  ls, name, bases,
-00008230: 2064 6374 0a20 2020 2020 2020 2029 0a20   dct.        ). 
-00008240: 2020 2020 2020 2069 6620 2761 6c74 6572         if 'alter
-00008250: 6e61 7469 7665 2720 696e 2064 6374 3a0a  native' in dct:.
-00008260: 2020 2020 2020 2020 2020 2020 6463 745b              dct[
-00008270: 2761 6c74 6572 6e61 7469 7665 275d 2e61  'alternative'].a
-00008280: 6c74 6572 6e61 7469 7665 203d 206e 6577  lternative = new
-00008290: 636c 730a 2020 2020 2020 2020 7265 7475  cls.        retu
-000082a0: 726e 206e 6577 636c 730a 0a20 2020 2064  rn newcls..    d
-000082b0: 6566 205f 5f63 616c 6c5f 5f28 636c 732c  ef __call__(cls,
-000082c0: 2066 696c 656e 616d 6529 3a20 2023 2074   filename):  # t
-000082d0: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
-000082e0: 2020 2020 2320 7479 7065 3a20 2855 6e69      # type: (Uni
-000082f0: 6f6e 5b49 4f5b 6279 7465 735d 2c20 7374  on[IO[bytes], st
-00008300: 725d 2920 2d3e 2041 6e79 0a20 2020 2020  r]) -> Any.     
-00008310: 2020 2022 2222 4372 6561 7465 7320 6120     """Creates a 
-00008320: 636c 7320 696e 7374 616e 6365 2c20 7573  cls instance, us
-00008330: 6520 7468 6520 6061 6c74 6572 6e61 7469  e the `alternati
-00008340: 7665 6020 6966 2074 6861 740a 2020 2020  ve` if that.    
-00008350: 2020 2020 6661 696c 732e 0a0a 2020 2020      fails...    
-00008360: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00008370: 6920 3d20 636c 732e 5f5f 6e65 775f 5f28  i = cls.__new__(
-00008380: 636c 732c 2063 6c73 2e5f 5f6e 616d 655f  cls, cls.__name_
-00008390: 5f2c 2063 6c73 2e5f 5f62 6173 6573 5f5f  _, cls.__bases__
-000083a0: 2c20 636c 732e 5f5f 6469 6374 5f5f 290a  , cls.__dict__).
-000083b0: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
-000083c0: 2c20 6664 6573 632c 206d 6167 6963 203d  , fdesc, magic =
-000083d0: 2063 6c73 2e6f 7065 6e28 6669 6c65 6e61   cls.open(filena
-000083e0: 6d65 290a 2020 2020 2020 2020 6966 206e  me).        if n
-000083f0: 6f74 206d 6167 6963 3a0a 2020 2020 2020  ot magic:.      
-00008400: 2020 2020 2020 7261 6973 6520 5363 6170        raise Scap
-00008410: 795f 4578 6365 7074 696f 6e28 0a20 2020  y_Exception(.   
-00008420: 2020 2020 2020 2020 2020 2020 2022 4e6f               "No
-00008430: 2064 6174 6120 636f 756c 6420 6265 2072   data could be r
-00008440: 6561 6421 220a 2020 2020 2020 2020 2020  ead!".          
-00008450: 2020 290a 2020 2020 2020 2020 7472 793a    ).        try:
-00008460: 0a20 2020 2020 2020 2020 2020 2069 2e5f  .            i._
-00008470: 5f69 6e69 745f 5f28 6669 6c65 6e61 6d65  _init__(filename
-00008480: 2c20 6664 6573 632c 206d 6167 6963 290a  , fdesc, magic).
-00008490: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000084a0: 726e 2069 0a20 2020 2020 2020 2065 7863  rn i.        exc
-000084b0: 6570 7420 2853 6361 7079 5f45 7863 6570  ept (Scapy_Excep
-000084c0: 7469 6f6e 2c20 454f 4645 7272 6f72 293a  tion, EOFError):
-000084d0: 0a20 2020 2020 2020 2020 2020 2070 6173  .            pas
-000084e0: 730a 0a20 2020 2020 2020 2069 6620 2261  s..        if "a
-000084f0: 6c74 6572 6e61 7469 7665 2220 696e 2063  lternative" in c
-00008500: 6c73 2e5f 5f64 6963 745f 5f3a 0a20 2020  ls.__dict__:.   
-00008510: 2020 2020 2020 2020 2063 6c73 203d 2063           cls = c
-00008520: 6c73 2e5f 5f64 6963 745f 5f5b 2261 6c74  ls.__dict__["alt
-00008530: 6572 6e61 7469 7665 225d 0a20 2020 2020  ernative"].     
-00008540: 2020 2020 2020 2069 203d 2063 6c73 2e5f         i = cls._
-00008550: 5f6e 6577 5f5f 2863 6c73 2c20 636c 732e  _new__(cls, cls.
-00008560: 5f5f 6e61 6d65 5f5f 2c20 636c 732e 5f5f  __name__, cls.__
-00008570: 6261 7365 735f 5f2c 2063 6c73 2e5f 5f64  bases__, cls.__d
-00008580: 6963 745f 5f29 0a20 2020 2020 2020 2020  ict__).         
-00008590: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-000085a0: 2020 2020 2020 2020 692e 5f5f 696e 6974          i.__init
-000085b0: 5f5f 2866 696c 656e 616d 652c 2066 6465  __(filename, fde
-000085c0: 7363 2c20 6d61 6769 6329 0a20 2020 2020  sc, magic).     
-000085d0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000085e0: 6e20 690a 2020 2020 2020 2020 2020 2020  n i.            
-000085f0: 6578 6365 7074 2028 5363 6170 795f 4578  except (Scapy_Ex
-00008600: 6365 7074 696f 6e2c 2045 4f46 4572 726f  ception, EOFErro
-00008610: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-00008620: 2020 2020 7061 7373 0a0a 2020 2020 2020      pass..      
-00008630: 2020 7261 6973 6520 5363 6170 795f 4578    raise Scapy_Ex
-00008640: 6365 7074 696f 6e28 224e 6f74 2061 2073  ception("Not a s
-00008650: 7570 706f 7274 6564 2063 6170 7475 7265  upported capture
-00008660: 2066 696c 6522 290a 0a20 2020 2040 7374   file")..    @st
-00008670: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
-00008680: 6566 206f 7065 6e28 666e 616d 6520 2023  ef open(fname  #
-00008690: 2074 7970 653a 2055 6e69 6f6e 5b49 4f5b   type: Union[IO[
-000086a0: 6279 7465 735d 2c20 7374 725d 0a20 2020  bytes], str].   
-000086b0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-000086c0: 2020 2020 2023 2074 7970 653a 2028 2e2e       # type: (..
-000086d0: 2e29 202d 3e20 5475 706c 655b 7374 722c  .) -> Tuple[str,
-000086e0: 205f 4279 7465 5374 7265 616d 2c20 6279   _ByteStream, by
-000086f0: 7465 735d 0a20 2020 2020 2020 2022 2222  tes].        """
-00008700: 4f70 656e 2028 6966 206e 6563 6573 7361  Open (if necessa
-00008710: 7279 2920 6669 6c65 6e61 6d65 2c20 616e  ry) filename, an
-00008720: 6420 7265 6164 2074 6865 206d 6167 6963  d read the magic
-00008730: 2e22 2222 0a20 2020 2020 2020 2069 6620  .""".        if 
-00008740: 6973 696e 7374 616e 6365 2866 6e61 6d65  isinstance(fname
-00008750: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-00008760: 2020 2020 6669 6c65 6e61 6d65 203d 2066      filename = f
-00008770: 6e61 6d65 0a20 2020 2020 2020 2020 2020  name.           
-00008780: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
-00008790: 2020 2020 2020 6664 6573 6320 3d20 677a        fdesc = gz
-000087a0: 6970 2e6f 7065 6e28 6669 6c65 6e61 6d65  ip.open(filename
-000087b0: 2c20 2272 6222 2920 2023 2074 7970 653a  , "rb")  # type:
-000087c0: 205f 4279 7465 5374 7265 616d 0a20 2020   _ByteStream.   
-000087d0: 2020 2020 2020 2020 2020 2020 206d 6167               mag
-000087e0: 6963 203d 2066 6465 7363 2e72 6561 6428  ic = fdesc.read(
-000087f0: 3429 0a20 2020 2020 2020 2020 2020 2065  4).            e
-00008800: 7863 6570 7420 494f 4572 726f 723a 0a20  xcept IOError:. 
-00008810: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00008820: 6465 7363 203d 206f 7065 6e28 6669 6c65  desc = open(file
-00008830: 6e61 6d65 2c20 2272 6222 290a 2020 2020  name, "rb").    
-00008840: 2020 2020 2020 2020 2020 2020 6d61 6769              magi
-00008850: 6320 3d20 6664 6573 632e 7265 6164 2834  c = fdesc.read(4
-00008860: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-00008870: 2020 2020 2020 2020 2020 2020 6664 6573              fdes
-00008880: 6320 3d20 666e 616d 650a 2020 2020 2020  c = fname.      
-00008890: 2020 2020 2020 6669 6c65 6e61 6d65 203d        filename =
-000088a0: 2067 6574 6174 7472 2866 6465 7363 2c20   getattr(fdesc, 
-000088b0: 226e 616d 6522 2c20 224e 6f20 6e61 6d65  "name", "No name
-000088c0: 2229 0a20 2020 2020 2020 2020 2020 206d  ").            m
-000088d0: 6167 6963 203d 2066 6465 7363 2e72 6561  agic = fdesc.rea
-000088e0: 6428 3429 0a20 2020 2020 2020 2072 6574  d(4).        ret
-000088f0: 7572 6e20 6669 6c65 6e61 6d65 2c20 6664  urn filename, fd
-00008900: 6573 632c 206d 6167 6963 0a0a 0a40 7369  esc, magic...@si
-00008910: 782e 6164 645f 6d65 7461 636c 6173 7328  x.add_metaclass(
-00008920: 5063 6170 5265 6164 6572 5f6d 6574 6163  PcapReader_metac
-00008930: 6c61 7373 290a 636c 6173 7320 5261 7750  lass).class RawP
-00008940: 6361 7052 6561 6465 723a 0a20 2020 2022  capReader:.    "
-00008950: 2222 4120 7374 6174 6566 756c 2070 6361  ""A stateful pca
-00008960: 7020 7265 6164 6572 2e20 4561 6368 2070  p reader. Each p
-00008970: 6163 6b65 7420 6973 2072 6574 7572 6e65  acket is returne
-00008980: 6420 6173 2061 2073 7472 696e 6722 2222  d as a string"""
-00008990: 0a0a 2020 2020 2320 544f 444f 3a20 7573  ..    # TODO: us
-000089a0: 6520 4765 6e65 7269 6373 2074 6f20 7072  e Generics to pr
-000089b0: 6f70 6572 6c79 2074 7970 6520 7468 6520  operly type the 
-000089c0: 7661 7269 6f75 7320 7265 6164 6572 732e  various readers.
-000089d0: 0a20 2020 2023 2041 7320 6f66 2072 6967  .    # As of rig
-000089e0: 6874 206e 6f77 2c20 5261 7750 6361 7052  ht now, RawPcapR
-000089f0: 6561 6465 7220 6973 2074 7970 6564 2061  eader is typed a
-00008a00: 7320 6966 2069 7420 7265 7475 726e 6564  s if it returned
-00008a10: 2070 6163 6b65 7473 0a20 2020 2023 2062   packets.    # b
-00008a20: 6563 6175 7365 2061 6c6c 206f 6620 6974  ecause all of it
-00008a30: 7320 6368 696c 6420 646f 2e20 4669 7820  s child do. Fix 
-00008a40: 7468 6174 0a0a 2020 2020 6e6f 6e62 6c6f  that..    nonblo
-00008a50: 636b 696e 675f 736f 636b 6574 203d 2054  cking_socket = T
-00008a60: 7275 650a 2020 2020 5061 636b 6574 4d65  rue.    PacketMe
-00008a70: 7461 6461 7461 203d 2063 6f6c 6c65 6374  tadata = collect
-00008a80: 696f 6e73 2e6e 616d 6564 7475 706c 6528  ions.namedtuple(
-00008a90: 2250 6163 6b65 744d 6574 6164 6174 6122  "PacketMetadata"
-00008aa0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ac0: 2020 2020 2020 2020 2020 2020 2020 5b22                ["
-00008ad0: 7365 6322 2c20 2275 7365 6322 2c20 2277  sec", "usec", "w
-00008ae0: 6972 656c 656e 222c 2022 6361 706c 656e  irelen", "caplen
-00008af0: 225d 2920 2023 206e 6f71 613a 2045 3530  "])  # noqa: E50
-00008b00: 310a 0a20 2020 2064 6566 205f 5f69 6e69  1..    def __ini
-00008b10: 745f 5f28 7365 6c66 2c20 6669 6c65 6e61  t__(self, filena
-00008b20: 6d65 2c20 6664 6573 633d 4e6f 6e65 2c20  me, fdesc=None, 
-00008b30: 6d61 6769 633d 4e6f 6e65 293a 2020 2320  magic=None):  # 
-00008b40: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
-00008b50: 2020 2020 2023 2074 7970 653a 2028 7374       # type: (st
-00008b60: 722c 205f 4279 7465 5374 7265 616d 2c20  r, _ByteStream, 
-00008b70: 6279 7465 7329 202d 3e20 4e6f 6e65 0a20  bytes) -> None. 
-00008b80: 2020 2020 2020 2073 656c 662e 6669 6c65         self.file
-00008b90: 6e61 6d65 203d 2066 696c 656e 616d 650a  name = filename.
-00008ba0: 2020 2020 2020 2020 7365 6c66 2e66 203d          self.f =
-00008bb0: 2066 6465 7363 0a20 2020 2020 2020 2069   fdesc.        i
-00008bc0: 6620 6d61 6769 6320 3d3d 2062 225c 7861  f magic == b"\xa
-00008bd0: 315c 7862 325c 7863 335c 7864 3422 3a20  1\xb2\xc3\xd4": 
-00008be0: 2023 2062 6967 2065 6e64 6961 6e0a 2020   # big endian.  
-00008bf0: 2020 2020 2020 2020 2020 7365 6c66 2e65            self.e
-00008c00: 6e64 6961 6e20 3d20 223e 220a 2020 2020  ndian = ">".    
-00008c10: 2020 2020 2020 2020 7365 6c66 2e6e 616e          self.nan
-00008c20: 6f20 3d20 4661 6c73 650a 2020 2020 2020  o = False.      
-00008c30: 2020 656c 6966 206d 6167 6963 203d 3d20    elif magic == 
-00008c40: 6222 5c78 6434 5c78 6333 5c78 6232 5c78  b"\xd4\xc3\xb2\x
-00008c50: 6131 223a 2020 2320 6c69 7474 6c65 2065  a1":  # little e
-00008c60: 6e64 6961 6e0a 2020 2020 2020 2020 2020  ndian.          
-00008c70: 2020 7365 6c66 2e65 6e64 6961 6e20 3d20    self.endian = 
-00008c80: 223c 220a 2020 2020 2020 2020 2020 2020  "<".            
-00008c90: 7365 6c66 2e6e 616e 6f20 3d20 4661 6c73  self.nano = Fals
-00008ca0: 650a 2020 2020 2020 2020 656c 6966 206d  e.        elif m
-00008cb0: 6167 6963 203d 3d20 6222 5c78 6131 5c78  agic == b"\xa1\x
-00008cc0: 6232 5c78 3363 5c78 3464 223a 2020 2320  b2\x3c\x4d":  # 
-00008cd0: 6269 6720 656e 6469 616e 2c20 6e61 6e6f  big endian, nano
-00008ce0: 7365 636f 6e64 2d70 7265 6369 7369 6f6e  second-precision
-00008cf0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00008d00: 662e 656e 6469 616e 203d 2022 3e22 0a20  f.endian = ">". 
-00008d10: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00008d20: 6e61 6e6f 203d 2054 7275 650a 2020 2020  nano = True.    
-00008d30: 2020 2020 656c 6966 206d 6167 6963 203d      elif magic =
-00008d40: 3d20 6222 5c78 3464 5c78 3363 5c78 6232  = b"\x4d\x3c\xb2
-00008d50: 5c78 6131 223a 2020 2320 6c69 7474 6c65  \xa1":  # little
-00008d60: 2065 6e64 6961 6e2c 206e 616e 6f73 6563   endian, nanosec
-00008d70: 6f6e 642d 7072 6563 6973 696f 6e20 2023  ond-precision  #
-00008d80: 206e 6f71 613a 2045 3530 310a 2020 2020   noqa: E501.    
-00008d90: 2020 2020 2020 2020 7365 6c66 2e65 6e64          self.end
-00008da0: 6961 6e20 3d20 223c 220a 2020 2020 2020  ian = "<".      
-00008db0: 2020 2020 2020 7365 6c66 2e6e 616e 6f20        self.nano 
-00008dc0: 3d20 5472 7565 0a20 2020 2020 2020 2065  = True.        e
-00008dd0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00008de0: 2072 6169 7365 2053 6361 7079 5f45 7863   raise Scapy_Exc
-00008df0: 6570 7469 6f6e 280a 2020 2020 2020 2020  eption(.        
-00008e00: 2020 2020 2020 2020 224e 6f74 2061 2070          "Not a p
-00008e10: 6361 7020 6361 7074 7572 6520 6669 6c65  cap capture file
-00008e20: 2028 6261 6420 6d61 6769 633a 2025 7229   (bad magic: %r)
-00008e30: 2220 2520 6d61 6769 630a 2020 2020 2020  " % magic.      
-00008e40: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00008e50: 6864 7220 3d20 7365 6c66 2e66 2e72 6561  hdr = self.f.rea
-00008e60: 6428 3230 290a 2020 2020 2020 2020 6966  d(20).        if
-00008e70: 206c 656e 2868 6472 2920 3c20 3230 3a0a   len(hdr) < 20:.
-00008e80: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00008e90: 6520 5363 6170 795f 4578 6365 7074 696f  e Scapy_Exceptio
-00008ea0: 6e28 2249 6e76 616c 6964 2070 6361 7020  n("Invalid pcap 
-00008eb0: 6669 6c65 2028 746f 6f20 7368 6f72 7429  file (too short)
-00008ec0: 2229 0a20 2020 2020 2020 2076 6572 6d61  ").        verma
-00008ed0: 6a2c 2076 6572 6d69 6e2c 2074 7a2c 2073  j, vermin, tz, s
-00008ee0: 6967 2c20 736e 6170 6c65 6e2c 206c 696e  ig, snaplen, lin
-00008ef0: 6b74 7970 6520 3d20 7374 7275 6374 2e75  ktype = struct.u
-00008f00: 6e70 6163 6b28 0a20 2020 2020 2020 2020  npack(.         
-00008f10: 2020 2073 656c 662e 656e 6469 616e 202b     self.endian +
-00008f20: 2022 4848 4949 4949 222c 2068 6472 0a20   "HHIIII", hdr. 
-00008f30: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00008f40: 2073 656c 662e 6c69 6e6b 7479 7065 203d   self.linktype =
-00008f50: 206c 696e 6b74 7970 650a 2020 2020 2020   linktype.      
-00008f60: 2020 7365 6c66 2e73 6e61 706c 656e 203d    self.snaplen =
-00008f70: 2073 6e61 706c 656e 0a0a 2020 2020 6465   snaplen..    de
-00008f80: 6620 5f5f 6974 6572 5f5f 2873 656c 6629  f __iter__(self)
-00008f90: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-00008fa0: 3a20 2829 202d 3e20 5261 7750 6361 7052  : () -> RawPcapR
-00008fb0: 6561 6465 720a 2020 2020 2020 2020 7265  eader.        re
-00008fc0: 7475 726e 2073 656c 660a 0a20 2020 2064  turn self..    d
-00008fd0: 6566 206e 6578 7428 7365 6c66 293a 0a20  ef next(self):. 
-00008fe0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-00008ff0: 2920 2d3e 2050 6163 6b65 740a 2020 2020  ) -> Packet.    
-00009000: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00009010: 696d 706c 656d 656e 7420 7468 6520 6974  implement the it
-00009020: 6572 6174 6f72 2070 726f 746f 636f 6c20  erator protocol 
-00009030: 6f6e 2061 2073 6574 206f 6620 7061 636b  on a set of pack
-00009040: 6574 7320 696e 2061 2070 6361 7020 6669  ets in a pcap fi
-00009050: 6c65 0a20 2020 2020 2020 2022 2222 0a20  le.        """. 
-00009060: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-00009070: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00009080: 656c 662e 5f72 6561 645f 7061 636b 6574  elf._read_packet
-00009090: 2829 2020 2320 7479 7065 3a20 6967 6e6f  ()  # type: igno
-000090a0: 7265 0a20 2020 2020 2020 2065 7863 6570  re.        excep
-000090b0: 7420 454f 4645 7272 6f72 3a0a 2020 2020  t EOFError:.    
-000090c0: 2020 2020 2020 2020 7261 6973 6520 5374          raise St
-000090d0: 6f70 4974 6572 6174 696f 6e0a 0a20 2020  opIteration..   
-000090e0: 2064 6566 205f 5f6e 6578 745f 5f28 7365   def __next__(se
-000090f0: 6c66 293a 0a20 2020 2020 2020 2023 2074  lf):.        # t
-00009100: 7970 653a 2028 2920 2d3e 2050 6163 6b65  ype: () -> Packe
-00009110: 740a 2020 2020 2020 2020 7265 7475 726e  t.        return
-00009120: 2073 656c 662e 6e65 7874 2829 0a0a 2020   self.next()..  
-00009130: 2020 6465 6620 5f72 6561 645f 7061 636b    def _read_pack
-00009140: 6574 2873 656c 662c 2073 697a 653d 4d54  et(self, size=MT
-00009150: 5529 3a0a 2020 2020 2020 2020 2320 7479  U):.        # ty
-00009160: 7065 3a20 2869 6e74 2920 2d3e 2054 7570  pe: (int) -> Tup
-00009170: 6c65 5b62 7974 6573 2c20 5261 7750 6361  le[bytes, RawPca
-00009180: 7052 6561 6465 722e 5061 636b 6574 4d65  pReader.PacketMe
-00009190: 7461 6461 7461 5d0a 2020 2020 2020 2020  tadata].        
-000091a0: 2222 2272 6574 7572 6e20 6120 7369 6e67  """return a sing
-000091b0: 6c65 2070 6163 6b65 7420 7265 6164 2066  le packet read f
-000091c0: 726f 6d20 7468 6520 6669 6c65 2061 7320  rom the file as 
-000091d0: 6120 7475 706c 6520 636f 6e74 6169 6e69  a tuple containi
-000091e0: 6e67 0a20 2020 2020 2020 2028 706b 745f  ng.        (pkt_
-000091f0: 6461 7461 2c20 706b 745f 6d65 7461 6461  data, pkt_metada
-00009200: 7461 290a 0a20 2020 2020 2020 2072 6169  ta)..        rai
-00009210: 7365 2045 4f46 4572 726f 7220 7768 656e  se EOFError when
-00009220: 206e 6f20 6d6f 7265 2070 6163 6b65 7473   no more packets
-00009230: 2061 7265 2061 7661 696c 6162 6c65 0a20   are available. 
-00009240: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00009250: 2020 2068 6472 203d 2073 656c 662e 662e     hdr = self.f.
-00009260: 7265 6164 2831 3629 0a20 2020 2020 2020  read(16).       
-00009270: 2069 6620 6c65 6e28 6864 7229 203c 2031   if len(hdr) < 1
-00009280: 363a 0a20 2020 2020 2020 2020 2020 2072  6:.            r
-00009290: 6169 7365 2045 4f46 4572 726f 720a 2020  aise EOFError.  
-000092a0: 2020 2020 2020 7365 632c 2075 7365 632c        sec, usec,
-000092b0: 2063 6170 6c65 6e2c 2077 6972 656c 656e   caplen, wirelen
-000092c0: 203d 2073 7472 7563 742e 756e 7061 636b   = struct.unpack
-000092d0: 2873 656c 662e 656e 6469 616e 202b 2022  (self.endian + "
-000092e0: 4949 4949 222c 2068 6472 290a 2020 2020  IIII", hdr).    
-000092f0: 2020 2020 7265 7475 726e 2028 7365 6c66      return (self
-00009300: 2e66 2e72 6561 6428 6361 706c 656e 295b  .f.read(caplen)[
-00009310: 3a73 697a 655d 2c0a 2020 2020 2020 2020  :size],.        
-00009320: 2020 2020 2020 2020 5261 7750 6361 7052          RawPcapR
-00009330: 6561 6465 722e 5061 636b 6574 4d65 7461  eader.PacketMeta
-00009340: 6461 7461 2873 6563 3d73 6563 2c20 7573  data(sec=sec, us
-00009350: 6563 3d75 7365 632c 0a20 2020 2020 2020  ec=usec,.       
-00009360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009380: 2020 2020 2020 7769 7265 6c65 6e3d 7769        wirelen=wi
-00009390: 7265 6c65 6e2c 2063 6170 6c65 6e3d 6361  relen, caplen=ca
-000093a0: 706c 656e 2929 0a0a 2020 2020 6465 6620  plen))..    def 
-000093b0: 7265 6164 5f70 6163 6b65 7428 7365 6c66  read_packet(self
-000093c0: 2c20 7369 7a65 3d4d 5455 293a 0a20 2020  , size=MTU):.   
-000093d0: 2020 2020 2023 2074 7970 653a 2028 696e       # type: (in
-000093e0: 7429 202d 3e20 5061 636b 6574 0a20 2020  t) -> Packet.   
-000093f0: 2020 2020 2072 6169 7365 2045 7863 6570       raise Excep
-00009400: 7469 6f6e 280a 2020 2020 2020 2020 2020  tion(.          
-00009410: 2020 2243 616e 6e6f 7420 6361 6c6c 2072    "Cannot call r
-00009420: 6561 645f 7061 636b 6574 2829 2069 6e20  ead_packet() in 
-00009430: 5261 7750 6361 7052 6561 6465 722e 2055  RawPcapReader. U
-00009440: 7365 2022 0a20 2020 2020 2020 2020 2020  se ".           
-00009450: 2022 5f72 6561 645f 7061 636b 6574 2829   "_read_packet()
-00009460: 220a 2020 2020 2020 2020 290a 0a20 2020  ".        )..   
-00009470: 2064 6566 2064 6973 7061 7463 6828 7365   def dispatch(se
-00009480: 6c66 2c0a 2020 2020 2020 2020 2020 2020  lf,.            
-00009490: 2020 2020 2063 616c 6c62 6163 6b20 2023       callback  #
-000094a0: 2074 7970 653a 2043 616c 6c61 626c 655b   type: Callable[
-000094b0: 5b54 7570 6c65 5b62 7974 6573 2c20 5261  [Tuple[bytes, Ra
-000094c0: 7750 6361 7052 6561 6465 722e 5061 636b  wPcapReader.Pack
-000094d0: 6574 4d65 7461 6461 7461 5d5d 2c20 416e  etMetadata]], An
-000094e0: 795d 2020 2320 6e6f 7161 3a20 4535 3031  y]  # noqa: E501
-000094f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009500: 2020 293a 0a20 2020 2020 2020 2023 2074    ):.        # t
-00009510: 7970 653a 2028 2e2e 2e29 202d 3e20 4e6f  ype: (...) -> No
-00009520: 6e65 0a20 2020 2020 2020 2022 2222 6361  ne.        """ca
-00009530: 6c6c 2074 6865 2073 7065 6369 6669 6564  ll the specified
-00009540: 2063 616c 6c62 6163 6b20 726f 7574 696e   callback routin
-00009550: 6520 666f 7220 6561 6368 2070 6163 6b65  e for each packe
-00009560: 7420 7265 6164 0a0a 2020 2020 2020 2020  t read..        
-00009570: 5468 6973 2069 7320 6a75 7374 2061 2063  This is just a c
-00009580: 6f6e 7665 6e69 656e 6365 2066 756e 6374  onvenience funct
-00009590: 696f 6e20 666f 7220 7468 6520 6d61 696e  ion for the main
-000095a0: 206c 6f6f 700a 2020 2020 2020 2020 7468   loop.        th
-000095b0: 6174 2061 6c6c 6f77 7320 666f 7220 6561  at allows for ea
-000095c0: 7379 206c 6175 6e63 6869 6e67 206f 6620  sy launching of 
-000095d0: 7061 636b 6574 2070 726f 6365 7373 696e  packet processin
-000095e0: 6720 696e 2061 0a20 2020 2020 2020 2074  g in a.        t
-000095f0: 6872 6561 642e 0a20 2020 2020 2020 2022  hread..        "
-00009600: 2222 0a20 2020 2020 2020 2066 6f72 2070  "".        for p
-00009610: 2069 6e20 7365 6c66 3a0a 2020 2020 2020   in self:.      
-00009620: 2020 2020 2020 6361 6c6c 6261 636b 2870        callback(p
-00009630: 290a 0a20 2020 2064 6566 205f 7265 6164  )..    def _read
-00009640: 5f61 6c6c 2873 656c 662c 2063 6f75 6e74  _all(self, count
-00009650: 3d2d 3129 3a0a 2020 2020 2020 2020 2320  =-1):.        # 
-00009660: 7479 7065 3a20 2869 6e74 2920 2d3e 204c  type: (int) -> L
-00009670: 6973 745b 5061 636b 6574 5d0a 2020 2020  ist[Packet].    
-00009680: 2020 2020 2222 2272 6574 7572 6e20 6120      """return a 
-00009690: 6c69 7374 206f 6620 616c 6c20 7061 636b  list of all pack
-000096a0: 6574 7320 696e 2074 6865 2070 6361 7020  ets in the pcap 
-000096b0: 6669 6c65 0a20 2020 2020 2020 2022 2222  file.        """
-000096c0: 0a20 2020 2020 2020 2072 6573 203d 205b  .        res = [
-000096d0: 5d20 2023 2074 7970 653a 204c 6973 745b  ]  # type: List[
-000096e0: 5061 636b 6574 5d0a 2020 2020 2020 2020  Packet].        
-000096f0: 7768 696c 6520 636f 756e 7420 213d 2030  while count != 0
-00009700: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
-00009710: 756e 7420 2d3d 2031 0a20 2020 2020 2020  unt -= 1.       
-00009720: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00009730: 2020 2020 2020 2020 2020 7020 3d20 7365            p = se
-00009740: 6c66 2e72 6561 645f 7061 636b 6574 2829  lf.read_packet()
-00009750: 2020 2320 7479 7065 3a20 5061 636b 6574    # type: Packet
-00009760: 0a20 2020 2020 2020 2020 2020 2065 7863  .            exc
-00009770: 6570 7420 454f 4645 7272 6f72 3a0a 2020  ept EOFError:.  
-00009780: 2020 2020 2020 2020 2020 2020 2020 6272                br
-00009790: 6561 6b0a 2020 2020 2020 2020 2020 2020  eak.            
-000097a0: 7265 732e 6170 7065 6e64 2870 290a 2020  res.append(p).  
-000097b0: 2020 2020 2020 7265 7475 726e 2072 6573        return res
-000097c0: 0a0a 2020 2020 6465 6620 7265 6376 2873  ..    def recv(s
-000097d0: 656c 662c 2073 697a 653d 4d54 5529 3a0a  elf, size=MTU):.
-000097e0: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-000097f0: 2869 6e74 2920 2d3e 2062 7974 6573 0a20  (int) -> bytes. 
-00009800: 2020 2020 2020 2022 2222 2045 6d75 6c61         """ Emula
-00009810: 7465 2061 2073 6f63 6b65 740a 2020 2020  te a socket.    
-00009820: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00009830: 7265 7475 726e 2073 656c 662e 5f72 6561  return self._rea
-00009840: 645f 7061 636b 6574 2873 697a 653d 7369  d_packet(size=si
-00009850: 7a65 295b 305d 0a0a 2020 2020 6465 6620  ze)[0]..    def 
-00009860: 6669 6c65 6e6f 2873 656c 6629 3a0a 2020  fileno(self):.  
-00009870: 2020 2020 2020 2320 7479 7065 3a20 2829        # type: ()
-00009880: 202d 3e20 696e 740a 2020 2020 2020 2020   -> int.        
-00009890: 7265 7475 726e 202d 3120 6966 2057 494e  return -1 if WIN
-000098a0: 444f 5753 2065 6c73 6520 7365 6c66 2e66  DOWS else self.f
-000098b0: 2e66 696c 656e 6f28 290a 0a20 2020 2064  .fileno()..    d
-000098c0: 6566 2063 6c6f 7365 2873 656c 6629 3a0a  ef close(self):.
-000098d0: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-000098e0: 2829 202d 3e20 4f70 7469 6f6e 616c 5b41  () -> Optional[A
-000098f0: 6e79 5d0a 2020 2020 2020 2020 7265 7475  ny].        retu
-00009900: 726e 2073 656c 662e 662e 636c 6f73 6528  rn self.f.close(
-00009910: 290a 0a20 2020 2064 6566 205f 5f65 7869  )..    def __exi
-00009920: 745f 5f28 7365 6c66 2c20 6578 635f 7479  t__(self, exc_ty
-00009930: 7065 2c20 6578 635f 7661 6c75 652c 2074  pe, exc_value, t
-00009940: 7261 6362 6163 6b29 3a0a 2020 2020 2020  racback):.      
-00009950: 2020 2320 7479 7065 3a20 284f 7074 696f    # type: (Optio
-00009960: 6e61 6c5b 416e 795d 2c20 4f70 7469 6f6e  nal[Any], Option
-00009970: 616c 5b41 6e79 5d2c 204f 7074 696f 6e61  al[Any], Optiona
-00009980: 6c5b 416e 795d 2920 2d3e 204e 6f6e 650a  l[Any]) -> None.
-00009990: 2020 2020 2020 2020 7365 6c66 2e63 6c6f          self.clo
-000099a0: 7365 2829 0a0a 2020 2020 2320 656d 756c  se()..    # emul
-000099b0: 6174 6520 5375 7065 7253 6f63 6b65 740a  ate SuperSocket.
-000099c0: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
-000099d0: 640a 2020 2020 6465 6620 7365 6c65 6374  d.    def select
-000099e0: 2873 6f63 6b65 7473 2c20 2023 2074 7970  (sockets,  # typ
-000099f0: 653a 204c 6973 745b 5375 7065 7253 6f63  e: List[SuperSoc
-00009a00: 6b65 745d 0a20 2020 2020 2020 2020 2020  ket].           
-00009a10: 2020 2020 7265 6d61 696e 3d4e 6f6e 652c      remain=None,
-00009a20: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-00009a30: 616c 5b66 6c6f 6174 5d0a 2020 2020 2020  al[float].      
-00009a40: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
-00009a50: 2020 2020 2320 7479 7065 3a20 282e 2e2e      # type: (...
-00009a60: 2920 2d3e 204c 6973 745b 5375 7065 7253  ) -> List[SuperS
-00009a70: 6f63 6b65 745d 0a20 2020 2020 2020 2072  ocket].        r
-00009a80: 6574 7572 6e20 736f 636b 6574 730a 0a0a  eturn sockets...
-00009a90: 636c 6173 7320 5063 6170 5265 6164 6572  class PcapReader
-00009aa0: 2852 6177 5063 6170 5265 6164 6572 2c20  (RawPcapReader, 
-00009ab0: 5f53 7570 6572 536f 636b 6574 293a 0a20  _SuperSocket):. 
-00009ac0: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-00009ad0: 7365 6c66 2c20 6669 6c65 6e61 6d65 2c20  self, filename, 
-00009ae0: 6664 6573 633d 4e6f 6e65 2c20 6d61 6769  fdesc=None, magi
-00009af0: 633d 4e6f 6e65 293a 2020 2320 7479 7065  c=None):  # type
-00009b00: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
-00009b10: 2023 2074 7970 653a 2028 7374 722c 2049   # type: (str, I
-00009b20: 4f5b 6279 7465 735d 2c20 6279 7465 7329  O[bytes], bytes)
-00009b30: 202d 3e20 4e6f 6e65 0a20 2020 2020 2020   -> None.       
-00009b40: 2052 6177 5063 6170 5265 6164 6572 2e5f   RawPcapReader._
-00009b50: 5f69 6e69 745f 5f28 7365 6c66 2c20 6669  _init__(self, fi
-00009b60: 6c65 6e61 6d65 2c20 6664 6573 632c 206d  lename, fdesc, m
-00009b70: 6167 6963 290a 2020 2020 2020 2020 7472  agic).        tr
-00009b80: 793a 0a20 2020 2020 2020 2020 2020 2073  y:.            s
-00009b90: 656c 662e 4c4c 636c 7320 3d20 636f 6e66  elf.LLcls = conf
-00009ba0: 2e6c 3274 7970 6573 2e6e 756d 326c 6179  .l2types.num2lay
-00009bb0: 6572 5b0a 2020 2020 2020 2020 2020 2020  er[.            
-00009bc0: 2020 2020 7365 6c66 2e6c 696e 6b74 7970      self.linktyp
-00009bd0: 650a 2020 2020 2020 2020 2020 2020 5d20  e.            ] 
-00009be0: 2023 2074 7970 653a 2054 7970 655b 5061   # type: Type[Pa
-00009bf0: 636b 6574 5d0a 2020 2020 2020 2020 6578  cket].        ex
-00009c00: 6365 7074 204b 6579 4572 726f 723a 0a20  cept KeyError:. 
-00009c10: 2020 2020 2020 2020 2020 2077 6172 6e69             warni
-00009c20: 6e67 2822 5063 6170 5265 6164 6572 3a20  ng("PcapReader: 
-00009c30: 756e 6b6e 6f77 6e20 4c4c 2074 7970 6520  unknown LL type 
-00009c40: 5b25 695d 2f5b 2523 785d 2e20 5573 696e  [%i]/[%#x]. Usin
-00009c50: 6720 5261 7720 7061 636b 6574 7322 2025  g Raw packets" %
-00009c60: 2028 7365 6c66 2e6c 696e 6b74 7970 652c   (self.linktype,
-00009c70: 2073 656c 662e 6c69 6e6b 7479 7065 2929   self.linktype))
-00009c80: 2020 2320 6e6f 7161 3a20 4535 3031 0a20    # noqa: E501. 
-00009c90: 2020 2020 2020 2020 2020 2069 6620 636f             if co
-00009ca0: 6e66 2e72 6177 5f6c 6179 6572 2069 7320  nf.raw_layer is 
-00009cb0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-00009cc0: 2020 2020 2020 2320 636f 6e66 2e72 6177        # conf.raw
-00009cd0: 5f6c 6179 6572 2069 7320 7365 7420 6f6e  _layer is set on
-00009ce0: 2069 6d70 6f72 740a 2020 2020 2020 2020   import.        
-00009cf0: 2020 2020 2020 2020 696d 706f 7274 2073          import s
-00009d00: 6361 7079 2e70 6163 6b65 7420 2023 206e  capy.packet  # n
-00009d10: 6f71 613a 2046 3430 310a 2020 2020 2020  oqa: F401.      
-00009d20: 2020 2020 2020 7365 6c66 2e4c 4c63 6c73        self.LLcls
-00009d30: 203d 2063 6f6e 662e 7261 775f 6c61 7965   = conf.raw_laye
-00009d40: 720a 0a20 2020 2064 6566 205f 5f65 6e74  r..    def __ent
+00005bb0: 2065 7863 5f76 616c 7565 2c20 2023 2074   exc_value,  # t
+00005bc0: 7970 653a 204f 7074 696f 6e61 6c5b 4578  ype: Optional[Ex
+00005bd0: 6365 7074 696f 6e5d 0a20 2020 2020 2020  ception].       
+00005be0: 2020 2020 2020 2020 2020 7472 6163 6562            traceb
+00005bf0: 6163 6b2c 2020 2320 7479 7065 3a20 4f70  ack,  # type: Op
+00005c00: 7469 6f6e 616c 5b41 6e79 5d0a 2020 2020  tional[Any].    
+00005c10: 2020 2020 2020 2020 2020 2020 2029 3a0a               ):.
+00005c20: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
+00005c30: 282e 2e2e 2920 2d3e 204f 7074 696f 6e61  (...) -> Optiona
+00005c40: 6c5b 626f 6f6c 5d0a 2020 2020 2020 2020  l[bool].        
+00005c50: 6966 2065 7863 5f76 616c 7565 2069 7320  if exc_value is 
+00005c60: 4e6f 6e65 206f 7220 6578 635f 7479 7065  None or exc_type
+00005c70: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00005c80: 2020 2020 2020 7265 7475 726e 204e 6f6e        return Non
+00005c90: 650a 2020 2020 2020 2020 2320 4572 726f  e.        # Erro
+00005ca0: 7265 640a 2020 2020 2020 2020 6966 2069  red.        if i
+00005cb0: 7369 6e73 7461 6e63 6528 6578 635f 7661  sinstance(exc_va
+00005cc0: 6c75 652c 2045 6e76 6972 6f6e 6d65 6e74  lue, Environment
+00005cd0: 4572 726f 7229 3a0a 2020 2020 2020 2020  Error):.        
+00005ce0: 2020 2020 6d73 6720 3d20 2243 6f75 6c64      msg = "Could
+00005cf0: 206e 6f74 2065 7865 6375 7465 2025 732c   not execute %s,
+00005d00: 2069 7320 6974 2069 6e73 7461 6c6c 6564   is it installed
+00005d10: 3f22 2025 2073 656c 662e 7072 6f67 0a20  ?" % self.prog. 
+00005d20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00005d30: 2020 2020 2020 2020 206d 7367 203d 2022           msg = "
+00005d40: 2573 3a20 6578 6563 7574 696f 6e20 6661  %s: execution fa
+00005d50: 696c 6564 2028 2573 2922 2025 2028 0a20  iled (%s)" % (. 
+00005d60: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00005d70: 656c 662e 7072 6f67 2c0a 2020 2020 2020  elf.prog,.      
+00005d80: 2020 2020 2020 2020 2020 6578 635f 7479            exc_ty
+00005d90: 7065 2e5f 5f63 6c61 7373 5f5f 2e5f 5f6e  pe.__class__.__n
+00005da0: 616d 655f 5f0a 2020 2020 2020 2020 2020  ame__.          
+00005db0: 2020 290a 2020 2020 2020 2020 6966 206e    ).        if n
+00005dc0: 6f74 2073 656c 662e 7375 7070 7265 7373  ot self.suppress
+00005dd0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00005de0: 6973 6520 6578 635f 7479 7065 286d 7367  ise exc_type(msg
+00005df0: 290a 2020 2020 2020 2020 6c6f 675f 7275  ).        log_ru
+00005e00: 6e74 696d 652e 6572 726f 7228 6d73 672c  ntime.error(msg,
+00005e10: 2065 7863 5f69 6e66 6f3d 5472 7565 290a   exc_info=True).
+00005e20: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+00005e30: 7275 6520 2023 2053 7570 7072 6573 7320  rue  # Suppress 
+00005e40: 7468 6520 6578 6365 7074 696f 6e0a 0a0a  the exception...
+00005e50: 636c 6173 7320 436f 6e74 6578 744d 616e  class ContextMan
+00005e60: 6167 6572 4361 7074 7572 654f 7574 7075  agerCaptureOutpu
+00005e70: 7428 6f62 6a65 6374 293a 0a20 2020 2022  t(object):.    "
+00005e80: 2222 0a20 2020 2043 6f6e 7465 7874 206d  "".    Context m
+00005e90: 616e 6167 6572 2074 6861 7420 696e 7465  anager that inte
+00005ea0: 7263 6570 7420 7468 6520 636f 6e73 6f6c  rcept the consol
+00005eb0: 6527 7320 6f75 7470 7574 2e0a 0a20 2020  e's output...   
+00005ec0: 2045 7861 6d70 6c65 3a0a 2020 2020 3e3e   Example:.    >>
+00005ed0: 3e20 7769 7468 2043 6f6e 7465 7874 4d61  > with ContextMa
+00005ee0: 6e61 6765 7243 6170 7475 7265 4f75 7470  nagerCaptureOutp
+00005ef0: 7574 2829 2061 7320 636d 636f 3a0a 2020  ut() as cmco:.  
+00005f00: 2020 2e2e 2e20 2020 2020 7072 696e 7428    ...     print(
+00005f10: 2268 6579 2229 0a20 2020 202e 2e2e 2020  "hey").    ...  
+00005f20: 2020 2061 7373 6572 7420 636d 636f 2e67     assert cmco.g
+00005f30: 6574 5f6f 7574 7075 7428 2920 3d3d 2022  et_output() == "
+00005f40: 6865 7922 0a20 2020 2022 2222 0a0a 2020  hey".    """..  
+00005f50: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+00005f60: 656c 6629 3a0a 2020 2020 2020 2020 2320  elf):.        # 
+00005f70: 7479 7065 3a20 2829 202d 3e20 4e6f 6e65  type: () -> None
+00005f80: 0a20 2020 2020 2020 2073 656c 662e 7265  .        self.re
+00005f90: 7375 6c74 5f65 7870 6f72 745f 6f62 6a65  sult_export_obje
+00005fa0: 6374 203d 2022 220a 2020 2020 2020 2020  ct = "".        
+00005fb0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+00005fc0: 2069 6d70 6f72 7420 6d6f 636b 2020 2320   import mock  # 
+00005fd0: 6e6f 7161 3a20 4634 3031 0a20 2020 2020  noqa: F401.     
+00005fe0: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
+00005ff0: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
+00006000: 2072 6169 7365 2049 6d70 6f72 7445 7272   raise ImportErr
+00006010: 6f72 2822 5468 6520 6d6f 636b 206d 6f64  or("The mock mod
+00006020: 756c 6520 6e65 6564 7320 746f 2062 6520  ule needs to be 
+00006030: 696e 7374 616c 6c65 6420 2122 290a 0a20  installed !").. 
+00006040: 2020 2064 6566 205f 5f65 6e74 6572 5f5f     def __enter__
+00006050: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00006060: 2320 7479 7065 3a20 2829 202d 3e20 436f  # type: () -> Co
+00006070: 6e74 6578 744d 616e 6167 6572 4361 7074  ntextManagerCapt
+00006080: 7572 654f 7574 7075 740a 2020 2020 2020  ureOutput.      
+00006090: 2020 696d 706f 7274 206d 6f63 6b0a 0a20    import mock.. 
+000060a0: 2020 2020 2020 2064 6566 2077 7269 7465         def write
+000060b0: 2873 2c20 6465 636f 7261 746f 723d 7365  (s, decorator=se
+000060c0: 6c66 293a 0a20 2020 2020 2020 2020 2020  lf):.           
+000060d0: 2023 2074 7970 653a 2028 7374 722c 2043   # type: (str, C
+000060e0: 6f6e 7465 7874 4d61 6e61 6765 7243 6170  ontextManagerCap
+000060f0: 7475 7265 4f75 7470 7574 2920 2d3e 204e  tureOutput) -> N
+00006100: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
+00006110: 6465 636f 7261 746f 722e 7265 7375 6c74  decorator.result
+00006120: 5f65 7870 6f72 745f 6f62 6a65 6374 202b  _export_object +
+00006130: 3d20 730a 2020 2020 2020 2020 6d6f 636b  = s.        mock
+00006140: 5f73 7464 6f75 7420 3d20 6d6f 636b 2e4d  _stdout = mock.M
+00006150: 6f63 6b28 290a 2020 2020 2020 2020 6d6f  ock().        mo
+00006160: 636b 5f73 7464 6f75 742e 7772 6974 6520  ck_stdout.write 
+00006170: 3d20 7772 6974 650a 2020 2020 2020 2020  = write.        
+00006180: 7365 6c66 2e62 636b 5f73 7464 6f75 7420  self.bck_stdout 
+00006190: 3d20 7379 732e 7374 646f 7574 0a20 2020  = sys.stdout.   
+000061a0: 2020 2020 2073 7973 2e73 7464 6f75 7420       sys.stdout 
+000061b0: 3d20 6d6f 636b 5f73 7464 6f75 740a 2020  = mock_stdout.  
+000061c0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000061d0: 660a 0a20 2020 2064 6566 205f 5f65 7869  f..    def __exi
+000061e0: 745f 5f28 7365 6c66 2c20 2a65 7863 293a  t__(self, *exc):
+000061f0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+00006200: 2028 2a41 6e79 2920 2d3e 204c 6974 6572   (*Any) -> Liter
+00006210: 616c 5b46 616c 7365 5d0a 2020 2020 2020  al[False].      
+00006220: 2020 7379 732e 7374 646f 7574 203d 2073    sys.stdout = s
+00006230: 656c 662e 6263 6b5f 7374 646f 7574 0a20  elf.bck_stdout. 
+00006240: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
+00006250: 6c73 650a 0a20 2020 2064 6566 2067 6574  lse..    def get
+00006260: 5f6f 7574 7075 7428 7365 6c66 2c20 6576  _output(self, ev
+00006270: 616c 5f62 7974 6573 3d46 616c 7365 293a  al_bytes=False):
+00006280: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+00006290: 2028 626f 6f6c 2920 2d3e 2073 7472 0a20   (bool) -> str. 
+000062a0: 2020 2020 2020 2069 6620 7365 6c66 2e72         if self.r
+000062b0: 6573 756c 745f 6578 706f 7274 5f6f 626a  esult_export_obj
+000062c0: 6563 742e 7374 6172 7473 7769 7468 2822  ect.startswith("
+000062d0: 6227 2229 2061 6e64 2065 7661 6c5f 6279  b'") and eval_by
+000062e0: 7465 733a 0a20 2020 2020 2020 2020 2020  tes:.           
+000062f0: 2072 6574 7572 6e20 706c 6169 6e5f 7374   return plain_st
+00006300: 7228 6576 616c 2873 656c 662e 7265 7375  r(eval(self.resu
+00006310: 6c74 5f65 7870 6f72 745f 6f62 6a65 6374  lt_export_object
+00006320: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
+00006330: 6e20 7365 6c66 2e72 6573 756c 745f 6578  n self.result_ex
+00006340: 706f 7274 5f6f 626a 6563 740a 0a0a 6465  port_object...de
+00006350: 6620 646f 5f67 7261 7068 280a 2020 2020  f do_graph(.    
+00006360: 6772 6170 682c 2020 2320 7479 7065 3a20  graph,  # type: 
+00006370: 7374 720a 2020 2020 7072 6f67 3d4e 6f6e  str.    prog=Non
+00006380: 652c 2020 2320 7479 7065 3a20 4f70 7469  e,  # type: Opti
+00006390: 6f6e 616c 5b73 7472 5d0a 2020 2020 666f  onal[str].    fo
+000063a0: 726d 6174 3d4e 6f6e 652c 2020 2320 7479  rmat=None,  # ty
+000063b0: 7065 3a20 4f70 7469 6f6e 616c 5b73 7472  pe: Optional[str
+000063c0: 5d0a 2020 2020 7461 7267 6574 3d4e 6f6e  ].    target=Non
+000063d0: 652c 2020 2320 7479 7065 3a20 4f70 7469  e,  # type: Opti
+000063e0: 6f6e 616c 5b55 6e69 6f6e 5b49 4f5b 6279  onal[Union[IO[by
+000063f0: 7465 735d 2c20 7374 725d 5d0a 2020 2020  tes], str]].    
+00006400: 7479 7065 3d4e 6f6e 652c 2020 2320 7479  type=None,  # ty
+00006410: 7065 3a20 4f70 7469 6f6e 616c 5b73 7472  pe: Optional[str
+00006420: 5d0a 2020 2020 7374 7269 6e67 3d4e 6f6e  ].    string=Non
+00006430: 652c 2020 2320 7479 7065 3a20 4f70 7469  e,  # type: Opti
+00006440: 6f6e 616c 5b62 6f6f 6c5d 0a20 2020 206f  onal[bool].    o
+00006450: 7074 696f 6e73 3d4e 6f6e 6520 2023 2074  ptions=None  # t
+00006460: 7970 653a 204f 7074 696f 6e61 6c5b 4c69  ype: Optional[Li
+00006470: 7374 5b73 7472 5d5d 0a29 3a0a 2020 2020  st[str]].):.    
+00006480: 2320 7479 7065 3a20 282e 2e2e 2920 2d3e  # type: (...) ->
+00006490: 204f 7074 696f 6e61 6c5b 7374 725d 0a20   Optional[str]. 
+000064a0: 2020 2022 2222 5072 6f63 6573 7365 7320     """Processes 
+000064b0: 6772 6170 6820 6465 7363 7269 7074 696f  graph descriptio
+000064c0: 6e20 7573 696e 6720 616e 2065 7874 6572  n using an exter
+000064d0: 6e61 6c20 736f 6674 7761 7265 2e0a 2020  nal software..  
+000064e0: 2020 5468 6973 206d 6574 686f 6420 6973    This method is
+000064f0: 2075 7365 6420 746f 2063 6f6e 7665 7274   used to convert
+00006500: 2061 2067 7261 7068 7669 7a20 666f 726d   a graphviz form
+00006510: 6174 2074 6f20 616e 2069 6d61 6765 2e0a  at to an image..
+00006520: 0a20 2020 203a 7061 7261 6d20 6772 6170  .    :param grap
+00006530: 683a 2047 7261 7068 5669 7a20 6772 6170  h: GraphViz grap
+00006540: 6820 6465 7363 7269 7074 696f 6e0a 2020  h description.  
+00006550: 2020 3a70 6172 616d 2070 726f 673a 2077    :param prog: w
+00006560: 6869 6368 2067 7261 7068 7669 7a20 7072  hich graphviz pr
+00006570: 6f67 7261 6d20 746f 2075 7365 0a20 2020  ogram to use.   
+00006580: 203a 7061 7261 6d20 666f 726d 6174 3a20   :param format: 
+00006590: 6f75 7470 7574 2074 7970 6520 2873 7667  output type (svg
+000065a0: 2c20 7073 2c20 6769 662c 206a 7067 2c20  , ps, gif, jpg, 
+000065b0: 6574 632e 292c 2070 6173 7365 6420 746f  etc.), passed to
+000065c0: 2064 6f74 2773 2022 2d54 220a 2020 2020   dot's "-T".    
+000065d0: 2020 2020 6f70 7469 6f6e 0a20 2020 203a      option.    :
+000065e0: 7061 7261 6d20 7374 7269 6e67 3a20 6966  param string: if
+000065f0: 206e 6f74 204e 6f6e 652c 2073 696d 706c   not None, simpl
+00006600: 7920 7265 7475 726e 2074 6865 2067 7261  y return the gra
+00006610: 7068 2073 7472 696e 670a 2020 2020 3a70  ph string.    :p
+00006620: 6172 616d 2074 6172 6765 743a 2066 696c  aram target: fil
+00006630: 656e 616d 6520 6f72 2072 6564 6972 6563  ename or redirec
+00006640: 742e 2044 6566 6175 6c74 7320 7069 7065  t. Defaults pipe
+00006650: 2074 6f20 496d 6167 656d 6167 6963 6b27   to Imagemagick'
+00006660: 730a 2020 2020 2020 2020 6469 7370 6c61  s.        displa
+00006670: 7920 7072 6f67 7261 6d0a 2020 2020 3a70  y program.    :p
+00006680: 6172 616d 206f 7074 696f 6e73 3a20 6f70  aram options: op
+00006690: 7469 6f6e 7320 746f 2062 6520 7061 7373  tions to be pass
+000066a0: 6564 2074 6f20 7072 6f67 0a20 2020 2022  ed to prog.    "
+000066b0: 2222 0a0a 2020 2020 6966 2066 6f72 6d61  ""..    if forma
+000066c0: 7420 6973 204e 6f6e 653a 0a20 2020 2020  t is None:.     
+000066d0: 2020 2066 6f72 6d61 7420 3d20 2273 7667     format = "svg
+000066e0: 220a 2020 2020 6966 2073 7472 696e 673a  ".    if string:
+000066f0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00006700: 6772 6170 680a 2020 2020 6966 2074 7970  graph.    if typ
+00006710: 6520 6973 206e 6f74 204e 6f6e 653a 0a20  e is not None:. 
+00006720: 2020 2020 2020 2077 6172 6e69 6e67 732e         warnings.
+00006730: 7761 726e 280a 2020 2020 2020 2020 2020  warn(.          
+00006740: 2020 2274 7970 6520 6973 2064 6570 7265    "type is depre
+00006750: 6361 7465 642c 2061 6e64 2077 6173 2072  cated, and was r
+00006760: 656e 616d 6564 2066 6f72 6d61 7422 2c0a  enamed format",.
+00006770: 2020 2020 2020 2020 2020 2020 4465 7072              Depr
+00006780: 6563 6174 696f 6e57 6172 6e69 6e67 0a20  ecationWarning. 
+00006790: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000067a0: 2066 6f72 6d61 7420 3d20 7479 7065 0a20   format = type. 
+000067b0: 2020 2069 6620 7072 6f67 2069 7320 4e6f     if prog is No
+000067c0: 6e65 3a0a 2020 2020 2020 2020 7072 6f67  ne:.        prog
+000067d0: 203d 2063 6f6e 662e 7072 6f67 2e64 6f74   = conf.prog.dot
+000067e0: 0a20 2020 2073 7461 7274 5f76 6965 7765  .    start_viewe
+000067f0: 7220 3d20 4661 6c73 650a 2020 2020 6966  r = False.    if
+00006800: 2074 6172 6765 7420 6973 204e 6f6e 653a   target is None:
+00006810: 0a20 2020 2020 2020 2069 6620 5749 4e44  .        if WIND
+00006820: 4f57 533a 0a20 2020 2020 2020 2020 2020  OWS:.           
+00006830: 2074 6172 6765 7420 3d20 6765 745f 7465   target = get_te
+00006840: 6d70 5f66 696c 6528 6175 746f 6578 743d  mp_file(autoext=
+00006850: 222e 2220 2b20 666f 726d 6174 290a 2020  "." + format).  
+00006860: 2020 2020 2020 2020 2020 7374 6172 745f            start_
+00006870: 7669 6577 6572 203d 2054 7275 650a 2020  viewer = True.  
+00006880: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00006890: 2020 2020 2020 2020 7769 7468 2043 6f6e          with Con
+000068a0: 7465 7874 4d61 6e61 6765 7253 7562 7072  textManagerSubpr
+000068b0: 6f63 6573 7328 636f 6e66 2e70 726f 672e  ocess(conf.prog.
+000068c0: 6469 7370 6c61 7929 3a0a 2020 2020 2020  display):.      
+000068d0: 2020 2020 2020 2020 2020 7461 7267 6574            target
+000068e0: 203d 2073 7562 7072 6f63 6573 732e 506f   = subprocess.Po
+000068f0: 7065 6e28 5b63 6f6e 662e 7072 6f67 2e64  pen([conf.prog.d
+00006900: 6973 706c 6179 5d2c 0a20 2020 2020 2020  isplay],.       
+00006910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006930: 2020 2073 7464 696e 3d73 7562 7072 6f63     stdin=subproc
+00006940: 6573 732e 5049 5045 292e 7374 6469 6e0a  ess.PIPE).stdin.
+00006950: 2020 2020 6966 2066 6f72 6d61 7420 6973      if format is
+00006960: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00006970: 2020 2066 6f72 6d61 7420 3d20 222d 5425     format = "-T%
+00006980: 7322 2025 2066 6f72 6d61 740a 2020 2020  s" % format.    
+00006990: 6966 2069 7369 6e73 7461 6e63 6528 7461  if isinstance(ta
+000069a0: 7267 6574 2c20 7374 7229 3a0a 2020 2020  rget, str):.    
+000069b0: 2020 2020 6966 2074 6172 6765 742e 7374      if target.st
+000069c0: 6172 7473 7769 7468 2827 7c27 293a 0a20  artswith('|'):. 
+000069d0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
+000069e0: 7420 3d20 7375 6270 726f 6365 7373 2e50  t = subprocess.P
+000069f0: 6f70 656e 2874 6172 6765 745b 313a 5d2e  open(target[1:].
+00006a00: 6c73 7472 6970 2829 2c20 7368 656c 6c3d  lstrip(), shell=
+00006a10: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+00006a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006a30: 2020 2020 2020 2020 2020 2020 7374 6469              stdi
+00006a40: 6e3d 7375 6270 726f 6365 7373 2e50 4950  n=subprocess.PIP
+00006a50: 4529 2e73 7464 696e 0a20 2020 2020 2020  E).stdin.       
+00006a60: 2065 6c69 6620 7461 7267 6574 2e73 7461   elif target.sta
+00006a70: 7274 7377 6974 6828 273e 2729 3a0a 2020  rtswith('>'):.  
+00006a80: 2020 2020 2020 2020 2020 7461 7267 6574            target
+00006a90: 203d 206f 7065 6e28 7461 7267 6574 5b31   = open(target[1
+00006aa0: 3a5d 2e6c 7374 7269 7028 292c 2022 7762  :].lstrip(), "wb
+00006ab0: 2229 0a20 2020 2020 2020 2065 6c73 653a  ").        else:
+00006ac0: 0a20 2020 2020 2020 2020 2020 2074 6172  .            tar
+00006ad0: 6765 7420 3d20 6f70 656e 286f 732e 7061  get = open(os.pa
+00006ae0: 7468 2e61 6273 7061 7468 2874 6172 6765  th.abspath(targe
+00006af0: 7429 2c20 2277 6222 290a 2020 2020 7461  t), "wb").    ta
+00006b00: 7267 6574 203d 2063 6173 7428 494f 5b62  rget = cast(IO[b
+00006b10: 7974 6573 5d2c 2074 6172 6765 7429 0a20  ytes], target). 
+00006b20: 2020 2070 726f 6320 3d20 7375 6270 726f     proc = subpro
+00006b30: 6365 7373 2e50 6f70 656e 280a 2020 2020  cess.Popen(.    
+00006b40: 2020 2020 225c 2225 735c 2220 2573 2025      "\"%s\" %s %
+00006b50: 7322 2025 2028 7072 6f67 2c20 6f70 7469  s" % (prog, opti
+00006b60: 6f6e 7320 6f72 2022 222c 2066 6f72 6d61  ons or "", forma
+00006b70: 7420 6f72 2022 2229 2c0a 2020 2020 2020  t or ""),.      
+00006b80: 2020 7368 656c 6c3d 5472 7565 2c20 7374    shell=True, st
+00006b90: 6469 6e3d 7375 6270 726f 6365 7373 2e50  din=subprocess.P
+00006ba0: 4950 452c 2073 7464 6f75 743d 7461 7267  IPE, stdout=targ
+00006bb0: 6574 2c0a 2020 2020 2020 2020 7374 6465  et,.        stde
+00006bc0: 7272 3d73 7562 7072 6f63 6573 732e 5049  rr=subprocess.PI
+00006bd0: 5045 0a20 2020 2029 0a20 2020 205f 2c20  PE.    ).    _, 
+00006be0: 7374 6465 7272 203d 2070 726f 632e 636f  stderr = proc.co
+00006bf0: 6d6d 756e 6963 6174 6528 6279 7465 735f  mmunicate(bytes_
+00006c00: 656e 636f 6465 2867 7261 7068 2929 0a20  encode(graph)). 
+00006c10: 2020 2069 6620 7072 6f63 2e72 6574 7572     if proc.retur
+00006c20: 6e63 6f64 6520 213d 2030 3a0a 2020 2020  ncode != 0:.    
+00006c30: 2020 2020 7261 6973 6520 4f53 4572 726f      raise OSErro
+00006c40: 7228 0a20 2020 2020 2020 2020 2020 2022  r(.            "
+00006c50: 4772 6170 6856 697a 2063 616c 6c20 6661  GraphViz call fa
+00006c60: 696c 6564 2028 6973 2069 7420 696e 7374  iled (is it inst
+00006c70: 616c 6c65 643f 293a 5c6e 2220 2b0a 2020  alled?):\n" +.  
+00006c80: 2020 2020 2020 2020 2020 706c 6169 6e5f            plain_
+00006c90: 7374 7228 7374 6465 7272 290a 2020 2020  str(stderr).    
+00006ca0: 2020 2020 290a 2020 2020 7472 793a 0a20      ).    try:. 
+00006cb0: 2020 2020 2020 2074 6172 6765 742e 636c         target.cl
+00006cc0: 6f73 6528 290a 2020 2020 6578 6365 7074  ose().    except
+00006cd0: 2045 7863 6570 7469 6f6e 3a0a 2020 2020   Exception:.    
+00006ce0: 2020 2020 7061 7373 0a20 2020 2069 6620      pass.    if 
+00006cf0: 7374 6172 745f 7669 6577 6572 3a0a 2020  start_viewer:.  
+00006d00: 2020 2020 2020 2320 576f 726b 6172 6f75        # Workarou
+00006d10: 6e64 2066 6f72 2066 696c 6520 6e6f 7420  nd for file not 
+00006d20: 666f 756e 6420 6572 726f 723a 2057 6520  found error: We 
+00006d30: 7761 6974 2075 6e74 696c 2074 656d 7066  wait until tempf
+00006d40: 696c 6520 6973 2077 7269 7474 656e 2e20  ile is written. 
+00006d50: 2023 206e 6f71 613a 2045 3530 310a 2020   # noqa: E501.  
+00006d60: 2020 2020 2020 7761 6974 696e 675f 7374        waiting_st
+00006d70: 6172 7420 3d20 7469 6d65 2e74 696d 6528  art = time.time(
+00006d80: 290a 2020 2020 2020 2020 7768 696c 6520  ).        while 
+00006d90: 6e6f 7420 6f73 2e70 6174 682e 6578 6973  not os.path.exis
+00006da0: 7473 2874 6172 6765 742e 6e61 6d65 293a  ts(target.name):
+00006db0: 0a20 2020 2020 2020 2020 2020 2074 696d  .            tim
+00006dc0: 652e 736c 6565 7028 302e 3129 0a20 2020  e.sleep(0.1).   
+00006dd0: 2020 2020 2020 2020 2069 6620 7469 6d65           if time
+00006de0: 2e74 696d 6528 2920 2d20 7761 6974 696e  .time() - waitin
+00006df0: 675f 7374 6172 7420 3e20 333a 0a20 2020  g_start > 3:.   
+00006e00: 2020 2020 2020 2020 2020 2020 2077 6172               war
+00006e10: 6e69 6e67 2822 5465 6d70 6f72 6172 7920  ning("Temporary 
+00006e20: 6669 6c65 2027 2573 2720 636f 756c 6420  file '%s' could 
+00006e30: 6e6f 7420 6265 2077 7269 7474 656e 2e20  not be written. 
+00006e40: 4772 6170 6869 6320 7769 6c6c 206e 6f74  Graphic will not
+00006e50: 2062 6520 6469 7370 6c61 7965 642e 222c   be displayed.",
+00006e60: 2074 656d 7066 696c 6529 2020 2320 6e6f   tempfile)  # no
+00006e70: 7161 3a20 4535 3031 0a20 2020 2020 2020  qa: E501.       
+00006e80: 2020 2020 2020 2020 2062 7265 616b 0a20           break. 
+00006e90: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00006ea0: 2020 2020 2020 2020 2069 6620 5749 4e44           if WIND
+00006eb0: 4f57 5320 616e 6420 636f 6e66 2e70 726f  OWS and conf.pro
+00006ec0: 672e 6469 7370 6c61 7920 3d3d 2063 6f6e  g.display == con
+00006ed0: 662e 7072 6f67 2e5f 6465 6661 756c 743a  f.prog._default:
+00006ee0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006ef0: 206f 732e 7374 6172 7466 696c 6528 7461   os.startfile(ta
+00006f00: 7267 6574 2e6e 616d 6529 0a20 2020 2020  rget.name).     
+00006f10: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00006f20: 2020 2020 2020 2020 2020 2020 2077 6974               wit
+00006f30: 6820 436f 6e74 6578 744d 616e 6167 6572  h ContextManager
+00006f40: 5375 6270 726f 6365 7373 2863 6f6e 662e  Subprocess(conf.
+00006f50: 7072 6f67 2e64 6973 706c 6179 293a 0a20  prog.display):. 
+00006f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006f70: 2020 2073 7562 7072 6f63 6573 732e 506f     subprocess.Po
+00006f80: 7065 6e28 5b63 6f6e 662e 7072 6f67 2e64  pen([conf.prog.d
+00006f90: 6973 706c 6179 2c20 7461 7267 6574 2e6e  isplay, target.n
+00006fa0: 616d 655d 290a 2020 2020 7265 7475 726e  ame]).    return
+00006fb0: 204e 6f6e 650a 0a0a 5f54 4558 5f54 5220   None..._TEX_TR 
+00006fc0: 3d20 7b0a 2020 2020 227b 223a 2022 7b5c  = {.    "{": "{\
+00006fd0: 5c74 745c 5c63 6861 7231 3233 7d22 2c0a  \tt\\char123}",.
+00006fe0: 2020 2020 227d 223a 2022 7b5c 5c74 745c      "}": "{\\tt\
+00006ff0: 5c63 6861 7231 3235 7d22 2c0a 2020 2020  \char125}",.    
+00007000: 225c 5c22 3a20 227b 5c5c 7474 5c5c 6368  "\\": "{\\tt\\ch
+00007010: 6172 3932 7d22 2c0a 2020 2020 225e 223a  ar92}",.    "^":
+00007020: 2022 5c5c 5e7b 7d22 2c0a 2020 2020 2224   "\\^{}",.    "$
+00007030: 223a 2022 5c5c 2422 2c0a 2020 2020 2223  ": "\\$",.    "#
+00007040: 223a 2022 5c5c 2322 2c0a 2020 2020 225f  ": "\\#",.    "_
+00007050: 223a 2022 5c5c 5f22 2c0a 2020 2020 2226  ": "\\_",.    "&
+00007060: 223a 2022 5c5c 2622 2c0a 2020 2020 2225  ": "\\&",.    "%
+00007070: 223a 2022 5c5c 2522 2c0a 2020 2020 227c  ": "\\%",.    "|
+00007080: 223a 2022 7b5c 5c74 745c 5c63 6861 7231  ": "{\\tt\\char1
+00007090: 3234 7d22 2c0a 2020 2020 227e 223a 2022  24}",.    "~": "
+000070a0: 7b5c 5c74 745c 5c63 6861 7231 3236 7d22  {\\tt\\char126}"
+000070b0: 2c0a 2020 2020 223c 223a 2022 7b5c 5c74  ,.    "<": "{\\t
+000070c0: 745c 5c63 6861 7236 307d 222c 0a20 2020  t\\char60}",.   
+000070d0: 2022 3e22 3a20 227b 5c5c 7474 5c5c 6368   ">": "{\\tt\\ch
+000070e0: 6172 3632 7d22 2c0a 7d0a 0a0a 6465 6620  ar62}",.}...def 
+000070f0: 7465 785f 6573 6361 7065 2878 293a 0a20  tex_escape(x):. 
+00007100: 2020 2023 2074 7970 653a 2028 7374 7229     # type: (str)
+00007110: 202d 3e20 7374 720a 2020 2020 7320 3d20   -> str.    s = 
+00007120: 2222 0a20 2020 2066 6f72 2063 2069 6e20  "".    for c in 
+00007130: 783a 0a20 2020 2020 2020 2073 202b 3d20  x:.        s += 
+00007140: 5f54 4558 5f54 522e 6765 7428 632c 2063  _TEX_TR.get(c, c
+00007150: 290a 2020 2020 7265 7475 726e 2073 0a0a  ).    return s..
+00007160: 0a64 6566 2063 6f6c 6765 6e28 2a6c 7374  .def colgen(*lst
+00007170: 636f 6c2c 2020 2320 7479 7065 3a20 416e  col,  # type: An
+00007180: 790a 2020 2020 2020 2020 2020 202a 2a6b  y.           **k
+00007190: 6172 6773 2020 2320 7479 7065 3a20 416e  args  # type: An
+000071a0: 790a 2020 2020 2020 2020 2020 2029 3a0a  y.           ):.
+000071b0: 2020 2020 2320 7479 7065 3a20 282e 2e2e      # type: (...
+000071c0: 2920 2d3e 2049 7465 7261 746f 725b 416e  ) -> Iterator[An
+000071d0: 795d 0a20 2020 2022 2222 5265 7475 726e  y].    """Return
+000071e0: 7320 6120 6765 6e65 7261 746f 7220 7468  s a generator th
+000071f0: 6174 206d 6978 6573 2070 726f 7669 6465  at mixes provide
+00007200: 6420 7175 616e 7469 7469 6573 2066 6f72  d quantities for
+00007210: 6576 6572 0a20 2020 2074 7261 6e73 3a20  ever.    trans: 
+00007220: 6120 6675 6e63 7469 6f6e 2074 6f20 636f  a function to co
+00007230: 6e76 6572 7420 7468 6520 7468 7265 6520  nvert the three 
+00007240: 6172 6775 6d65 6e74 7320 696e 746f 2061  arguments into a
+00007250: 2063 6f6c 6f72 2e20 6c61 6d62 6461 2078   color. lambda x
+00007260: 2c79 2c7a 3a28 782c 792c 7a29 2062 7920  ,y,z:(x,y,z) by 
+00007270: 6465 6661 756c 7422 2222 2020 2320 6e6f  default"""  # no
+00007280: 7161 3a20 4535 3031 0a20 2020 2069 6620  qa: E501.    if 
+00007290: 6c65 6e28 6c73 7463 6f6c 2920 3c20 323a  len(lstcol) < 2:
+000072a0: 0a20 2020 2020 2020 206c 7374 636f 6c20  .        lstcol 
+000072b0: 2a3d 2032 0a20 2020 2074 7261 6e73 203d  *= 2.    trans =
+000072c0: 206b 6172 6773 2e67 6574 2822 7472 616e   kargs.get("tran
+000072d0: 7322 2c20 6c61 6d62 6461 2078 2c20 792c  s", lambda x, y,
+000072e0: 207a 3a20 2878 2c20 792c 207a 2929 0a20   z: (x, y, z)). 
+000072f0: 2020 2077 6869 6c65 2054 7275 653a 0a20     while True:. 
+00007300: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+00007310: 7261 6e67 6528 6c65 6e28 6c73 7463 6f6c  range(len(lstcol
+00007320: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+00007330: 666f 7220 6a20 696e 2072 616e 6765 286c  for j in range(l
+00007340: 656e 286c 7374 636f 6c29 293a 0a20 2020  en(lstcol)):.   
+00007350: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00007360: 206b 2069 6e20 7261 6e67 6528 6c65 6e28   k in range(len(
+00007370: 6c73 7463 6f6c 2929 3a0a 2020 2020 2020  lstcol)):.      
+00007380: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00007390: 2069 2021 3d20 6a20 6f72 206a 2021 3d20   i != j or j != 
+000073a0: 6b20 6f72 206b 2021 3d20 693a 0a20 2020  k or k != i:.   
+000073b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000073c0: 2020 2020 2079 6965 6c64 2074 7261 6e73       yield trans
+000073d0: 286c 7374 636f 6c5b 2869 202b 206a 2920  (lstcol[(i + j) 
+000073e0: 2520 6c65 6e28 6c73 7463 6f6c 295d 2c20  % len(lstcol)], 
+000073f0: 6c73 7463 6f6c 5b28 6a20 2b20 6b29 2025  lstcol[(j + k) %
+00007400: 206c 656e 286c 7374 636f 6c29 5d2c 206c   len(lstcol)], l
+00007410: 7374 636f 6c5b 286b 202b 2069 2920 2520  stcol[(k + i) % 
+00007420: 6c65 6e28 6c73 7463 6f6c 295d 2920 2023  len(lstcol)])  #
+00007430: 206e 6f71 613a 2045 3530 310a 0a0a 6465   noqa: E501...de
+00007440: 6620 696e 6372 656d 656e 7461 6c5f 6c61  f incremental_la
+00007450: 6265 6c28 6c61 6265 6c3d 2274 6167 2530  bel(label="tag%0
+00007460: 3569 222c 2073 7461 7274 3d30 293a 0a20  5i", start=0):. 
+00007470: 2020 2023 2074 7970 653a 2028 7374 722c     # type: (str,
+00007480: 2069 6e74 2920 2d3e 2049 7465 7261 746f   int) -> Iterato
+00007490: 725b 7374 725d 0a20 2020 2077 6869 6c65  r[str].    while
+000074a0: 2054 7275 653a 0a20 2020 2020 2020 2079   True:.        y
+000074b0: 6965 6c64 206c 6162 656c 2025 2073 7461  ield label % sta
+000074c0: 7274 0a20 2020 2020 2020 2073 7461 7274  rt.        start
+000074d0: 202b 3d20 310a 0a0a 6465 6620 6269 6e72   += 1...def binr
+000074e0: 6570 7228 7661 6c29 3a0a 2020 2020 2320  epr(val):.    # 
+000074f0: 7479 7065 3a20 2869 6e74 2920 2d3e 2073  type: (int) -> s
+00007500: 7472 0a20 2020 2072 6574 7572 6e20 6269  tr.    return bi
+00007510: 6e28 7661 6c29 5b32 3a5d 0a0a 0a64 6566  n(val)[2:]...def
+00007520: 206c 6f6e 675f 636f 6e76 6572 7465 7228   long_converter(
+00007530: 7329 3a0a 2020 2020 2320 7479 7065 3a20  s):.    # type: 
+00007540: 2873 7472 2920 2d3e 2069 6e74 0a20 2020  (str) -> int.   
+00007550: 2072 6574 7572 6e20 696e 7428 732e 7265   return int(s.re
+00007560: 706c 6163 6528 275c 6e27 2c20 2727 292e  place('\n', '').
+00007570: 7265 706c 6163 6528 2720 272c 2027 2729  replace(' ', '')
+00007580: 2c20 3136 290a 0a23 2323 2323 2323 2323  , 16)..#########
+00007590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000075a0: 0a23 2020 2020 456e 756d 206d 616e 6167  .#    Enum manag
+000075b0: 656d 656e 7420 2020 2023 0a23 2323 2323  ement    #.#####
+000075c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000075d0: 2323 2323 0a0a 0a63 6c61 7373 2045 6e75  ####...class Enu
+000075e0: 6d45 6c65 6d65 6e74 3a0a 2020 2020 6465  mElement:.    de
+000075f0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+00007600: 206b 6579 2c20 7661 6c75 6529 3a0a 2020   key, value):.  
+00007610: 2020 2020 2020 2320 7479 7065 3a20 2873        # type: (s
+00007620: 7472 2c20 696e 7429 202d 3e20 4e6f 6e65  tr, int) -> None
+00007630: 0a20 2020 2020 2020 2073 656c 662e 5f6b  .        self._k
+00007640: 6579 203d 206b 6579 0a20 2020 2020 2020  ey = key.       
+00007650: 2073 656c 662e 5f76 616c 7565 203d 2076   self._value = v
+00007660: 616c 7565 0a0a 2020 2020 6465 6620 5f5f  alue..    def __
+00007670: 7265 7072 5f5f 2873 656c 6629 3a0a 2020  repr__(self):.  
+00007680: 2020 2020 2020 2320 7479 7065 3a20 2829        # type: ()
+00007690: 202d 3e20 7374 720a 2020 2020 2020 2020   -> str.        
+000076a0: 7265 7475 726e 2022 3c25 7320 2573 5b25  return "<%s %s[%
+000076b0: 725d 3e22 2025 2028 7365 6c66 2e5f 5f64  r]>" % (self.__d
+000076c0: 6963 745f 5f2e 6765 7428 225f 6e61 6d65  ict__.get("_name
+000076d0: 222c 2073 656c 662e 5f5f 636c 6173 735f  ", self.__class_
+000076e0: 5f2e 5f5f 6e61 6d65 5f5f 292c 2073 656c  _.__name__), sel
+000076f0: 662e 5f6b 6579 2c20 7365 6c66 2e5f 7661  f._key, self._va
+00007700: 6c75 6529 2020 2320 6e6f 7161 3a20 4535  lue)  # noqa: E5
+00007710: 3031 0a0a 2020 2020 6465 6620 5f5f 6765  01..    def __ge
+00007720: 7461 7474 725f 5f28 7365 6c66 2c20 6174  tattr__(self, at
+00007730: 7472 293a 0a20 2020 2020 2020 2023 2074  tr):.        # t
+00007740: 7970 653a 2028 7374 7229 202d 3e20 416e  ype: (str) -> An
+00007750: 790a 2020 2020 2020 2020 7265 7475 726e  y.        return
+00007760: 2067 6574 6174 7472 2873 656c 662e 5f76   getattr(self._v
+00007770: 616c 7565 2c20 6174 7472 290a 0a20 2020  alue, attr)..   
+00007780: 2064 6566 205f 5f73 7472 5f5f 2873 656c   def __str__(sel
+00007790: 6629 3a0a 2020 2020 2020 2020 2320 7479  f):.        # ty
+000077a0: 7065 3a20 2829 202d 3e20 7374 720a 2020  pe: () -> str.  
+000077b0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000077c0: 662e 5f6b 6579 0a0a 2020 2020 6465 6620  f._key..    def 
+000077d0: 5f5f 6279 7465 735f 5f28 7365 6c66 293a  __bytes__(self):
+000077e0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+000077f0: 2028 2920 2d3e 2062 7974 6573 0a20 2020   () -> bytes.   
+00007800: 2020 2020 2072 6574 7572 6e20 6279 7465       return byte
+00007810: 735f 656e 636f 6465 2873 656c 662e 5f5f  s_encode(self.__
+00007820: 7374 725f 5f28 2929 0a0a 2020 2020 6465  str__())..    de
+00007830: 6620 5f5f 6861 7368 5f5f 2873 656c 6629  f __hash__(self)
+00007840: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
+00007850: 3a20 2829 202d 3e20 696e 740a 2020 2020  : () -> int.    
+00007860: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00007870: 5f76 616c 7565 0a0a 2020 2020 6465 6620  _value..    def 
+00007880: 5f5f 696e 745f 5f28 7365 6c66 293a 0a20  __int__(self):. 
+00007890: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+000078a0: 2920 2d3e 2069 6e74 0a20 2020 2020 2020  ) -> int.       
+000078b0: 2072 6574 7572 6e20 696e 7428 7365 6c66   return int(self
+000078c0: 2e5f 7661 6c75 6529 0a0a 2020 2020 6465  ._value)..    de
+000078d0: 6620 5f5f 6571 5f5f 2873 656c 662c 206f  f __eq__(self, o
+000078e0: 7468 6572 293a 0a20 2020 2020 2020 2023  ther):.        #
+000078f0: 2074 7970 653a 2028 416e 7929 202d 3e20   type: (Any) -> 
+00007900: 626f 6f6c 0a20 2020 2020 2020 2072 6574  bool.        ret
+00007910: 7572 6e20 7365 6c66 2e5f 7661 6c75 6520  urn self._value 
+00007920: 3d3d 2069 6e74 286f 7468 6572 290a 0a20  == int(other).. 
+00007930: 2020 2064 6566 205f 5f6e 6571 5f5f 2873     def __neq__(s
+00007940: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+00007950: 2020 2020 2023 2074 7970 653a 2028 416e       # type: (An
+00007960: 7929 202d 3e20 626f 6f6c 0a20 2020 2020  y) -> bool.     
+00007970: 2020 2072 6574 7572 6e20 6e6f 7420 7365     return not se
+00007980: 6c66 2e5f 5f65 715f 5f28 6f74 6865 7229  lf.__eq__(other)
+00007990: 0a0a 0a63 6c61 7373 2045 6e75 6d5f 6d65  ...class Enum_me
+000079a0: 7461 636c 6173 7328 7479 7065 293a 0a20  taclass(type):. 
+000079b0: 2020 2065 6c65 6d65 6e74 5f63 6c61 7373     element_class
+000079c0: 203d 2045 6e75 6d45 6c65 6d65 6e74 0a0a   = EnumElement..
+000079d0: 2020 2020 6465 6620 5f5f 6e65 775f 5f28      def __new__(
+000079e0: 636c 732c 206e 616d 652c 2062 6173 6573  cls, name, bases
+000079f0: 2c20 6463 7429 3a0a 2020 2020 2020 2020  , dct):.        
+00007a00: 2320 7479 7065 3a20 2841 6e79 2c20 7374  # type: (Any, st
+00007a10: 722c 2041 6e79 2c20 4469 6374 5b73 7472  r, Any, Dict[str
+00007a20: 2c20 416e 795d 2920 2d3e 2041 6e79 0a20  , Any]) -> Any. 
+00007a30: 2020 2020 2020 2072 6469 6374 203d 207b         rdict = {
+00007a40: 7d0a 2020 2020 2020 2020 666f 7220 6b2c  }.        for k,
+00007a50: 2076 2069 6e20 6463 742e 6974 656d 7328   v in dct.items(
+00007a60: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
+00007a70: 6620 6973 696e 7374 616e 6365 2876 2c20  f isinstance(v, 
+00007a80: 696e 7429 3a0a 2020 2020 2020 2020 2020  int):.          
+00007a90: 2020 2020 2020 7620 3d20 636c 732e 656c        v = cls.el
+00007aa0: 656d 656e 745f 636c 6173 7328 6b2c 2076  ement_class(k, v
+00007ab0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00007ac0: 2020 6463 745b 6b5d 203d 2076 0a20 2020    dct[k] = v.   
+00007ad0: 2020 2020 2020 2020 2020 2020 2072 6469               rdi
+00007ae0: 6374 5b76 5d20 3d20 6b0a 2020 2020 2020  ct[v] = k.      
+00007af0: 2020 6463 745b 225f 5f72 6469 6374 5f5f    dct["__rdict__
+00007b00: 225d 203d 2072 6469 6374 0a20 2020 2020  "] = rdict.     
+00007b10: 2020 2072 6574 7572 6e20 7375 7065 7228     return super(
+00007b20: 456e 756d 5f6d 6574 6163 6c61 7373 2c20  Enum_metaclass, 
+00007b30: 636c 7329 2e5f 5f6e 6577 5f5f 2863 6c73  cls).__new__(cls
+00007b40: 2c20 6e61 6d65 2c20 6261 7365 732c 2064  , name, bases, d
+00007b50: 6374 290a 0a20 2020 2064 6566 205f 5f67  ct)..    def __g
+00007b60: 6574 6974 656d 5f5f 2873 656c 662c 2061  etitem__(self, a
+00007b70: 7474 7229 3a0a 2020 2020 2020 2020 2320  ttr):.        # 
+00007b80: 7479 7065 3a20 2869 6e74 2920 2d3e 2041  type: (int) -> A
+00007b90: 6e79 0a20 2020 2020 2020 2072 6574 7572  ny.        retur
+00007ba0: 6e20 7365 6c66 2e5f 5f72 6469 6374 5f5f  n self.__rdict__
+00007bb0: 5b61 7474 725d 2020 2320 7479 7065 3a20  [attr]  # type: 
+00007bc0: 6967 6e6f 7265 0a0a 2020 2020 6465 6620  ignore..    def 
+00007bd0: 5f5f 636f 6e74 6169 6e73 5f5f 2873 656c  __contains__(sel
+00007be0: 662c 2076 616c 293a 0a20 2020 2020 2020  f, val):.       
+00007bf0: 2023 2074 7970 653a 2028 696e 7429 202d   # type: (int) -
+00007c00: 3e20 626f 6f6c 0a20 2020 2020 2020 2072  > bool.        r
+00007c10: 6574 7572 6e20 7661 6c20 696e 2073 656c  eturn val in sel
+00007c20: 662e 5f5f 7264 6963 745f 5f20 2023 2074  f.__rdict__  # t
+00007c30: 7970 653a 2069 676e 6f72 650a 0a20 2020  ype: ignore..   
+00007c40: 2064 6566 2067 6574 2873 656c 662c 2061   def get(self, a
+00007c50: 7474 722c 2076 616c 3d4e 6f6e 6529 3a0a  ttr, val=None):.
+00007c60: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
+00007c70: 2873 7472 2c20 4f70 7469 6f6e 616c 5b41  (str, Optional[A
+00007c80: 6e79 5d29 202d 3e20 416e 790a 2020 2020  ny]) -> Any.    
+00007c90: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00007ca0: 5f5f 7264 6963 745f 5f2e 6765 7428 6174  __rdict__.get(at
+00007cb0: 7472 2c20 7661 6c29 2020 2320 7479 7065  tr, val)  # type
+00007cc0: 3a20 6967 6e6f 7265 0a0a 2020 2020 6465  : ignore..    de
+00007cd0: 6620 5f5f 7265 7072 5f5f 2873 656c 6629  f __repr__(self)
+00007ce0: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
+00007cf0: 3a20 2829 202d 3e20 7374 720a 2020 2020  : () -> str.    
+00007d00: 2020 2020 7265 7475 726e 2022 3c25 733e      return "<%s>
+00007d10: 2220 2520 7365 6c66 2e5f 5f64 6963 745f  " % self.__dict_
+00007d20: 5f2e 6765 7428 226e 616d 6522 2c20 7365  _.get("name", se
+00007d30: 6c66 2e5f 5f6e 616d 655f 5f29 0a0a 0a23  lf.__name__)...#
+00007d40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00007d50: 2323 0a23 2020 4f62 6a65 6374 2073 6176  ##.#  Object sav
+00007d60: 696e 6720 2023 0a23 2323 2323 2323 2323  ing  #.#########
+00007d70: 2323 2323 2323 2323 2323 0a0a 0a64 6566  ##########...def
+00007d80: 2065 7870 6f72 745f 6f62 6a65 6374 286f   export_object(o
+00007d90: 626a 293a 0a20 2020 2023 2074 7970 653a  bj):.    # type:
+00007da0: 2028 416e 7929 202d 3e20 4e6f 6e65 0a20   (Any) -> None. 
+00007db0: 2020 2069 6d70 6f72 7420 7a6c 6962 0a20     import zlib. 
+00007dc0: 2020 2070 7269 6e74 2862 7974 6573 5f62     print(bytes_b
+00007dd0: 6173 6536 3428 7a6c 6962 2e63 6f6d 7072  ase64(zlib.compr
+00007de0: 6573 7328 7069 636b 6c65 2e64 756d 7073  ess(pickle.dumps
+00007df0: 286f 626a 2c20 3229 2c20 3929 2929 0a0a  (obj, 2), 9)))..
+00007e00: 0a64 6566 2069 6d70 6f72 745f 6f62 6a65  .def import_obje
+00007e10: 6374 286f 626a 3d4e 6f6e 6529 3a0a 2020  ct(obj=None):.  
+00007e20: 2020 2320 7479 7065 3a20 284f 7074 696f    # type: (Optio
+00007e30: 6e61 6c5b 7374 725d 2920 2d3e 2041 6e79  nal[str]) -> Any
+00007e40: 0a20 2020 2069 6d70 6f72 7420 7a6c 6962  .    import zlib
+00007e50: 0a20 2020 2069 6620 6f62 6a20 6973 204e  .    if obj is N
+00007e60: 6f6e 653a 0a20 2020 2020 2020 206f 626a  one:.        obj
+00007e70: 203d 2073 7973 2e73 7464 696e 2e72 6561   = sys.stdin.rea
+00007e80: 6428 290a 2020 2020 7265 7475 726e 2070  d().    return p
+00007e90: 6963 6b6c 652e 6c6f 6164 7328 7a6c 6962  ickle.loads(zlib
+00007ea0: 2e64 6563 6f6d 7072 6573 7328 6261 7365  .decompress(base
+00007eb0: 3634 5f62 7974 6573 286f 626a 2e73 7472  64_bytes(obj.str
+00007ec0: 6970 2829 2929 2920 2023 206e 6f71 613a  ip())))  # noqa:
+00007ed0: 2045 3530 310a 0a0a 6465 6620 7361 7665   E501...def save
+00007ee0: 5f6f 626a 6563 7428 666e 616d 652c 206f  _object(fname, o
+00007ef0: 626a 293a 0a20 2020 2023 2074 7970 653a  bj):.    # type:
+00007f00: 2028 7374 722c 2041 6e79 2920 2d3e 204e   (str, Any) -> N
+00007f10: 6f6e 650a 2020 2020 2222 2250 6963 6b6c  one.    """Pickl
+00007f20: 6520 6120 5079 7468 6f6e 206f 626a 6563  e a Python objec
+00007f30: 7422 2222 0a0a 2020 2020 6664 203d 2067  t"""..    fd = g
+00007f40: 7a69 702e 6f70 656e 2866 6e61 6d65 2c20  zip.open(fname, 
+00007f50: 2277 6222 290a 2020 2020 7069 636b 6c65  "wb").    pickle
+00007f60: 2e64 756d 7028 6f62 6a2c 2066 6429 0a20  .dump(obj, fd). 
+00007f70: 2020 2066 642e 636c 6f73 6528 290a 0a0a     fd.close()...
+00007f80: 6465 6620 6c6f 6164 5f6f 626a 6563 7428  def load_object(
+00007f90: 666e 616d 6529 3a0a 2020 2020 2320 7479  fname):.    # ty
+00007fa0: 7065 3a20 2873 7472 2920 2d3e 2041 6e79  pe: (str) -> Any
+00007fb0: 0a20 2020 2022 2222 756e 7069 636b 6c65  .    """unpickle
+00007fc0: 2061 2050 7974 686f 6e20 6f62 6a65 6374   a Python object
+00007fd0: 2222 220a 2020 2020 7265 7475 726e 2070  """.    return p
+00007fe0: 6963 6b6c 652e 6c6f 6164 2867 7a69 702e  ickle.load(gzip.
+00007ff0: 6f70 656e 2866 6e61 6d65 2c20 2272 6222  open(fname, "rb"
+00008000: 2929 0a0a 0a40 636f 6e66 2e63 6f6d 6d61  ))...@conf.comma
+00008010: 6e64 732e 7265 6769 7374 6572 0a64 6566  nds.register.def
+00008020: 2063 6f72 7275 7074 5f62 7974 6573 2864   corrupt_bytes(d
+00008030: 6174 612c 2070 3d30 2e30 312c 206e 3d4e  ata, p=0.01, n=N
+00008040: 6f6e 6529 3a0a 2020 2020 2320 7479 7065  one):.    # type
+00008050: 3a20 2873 7472 2c20 666c 6f61 742c 204f  : (str, float, O
+00008060: 7074 696f 6e61 6c5b 696e 745d 2920 2d3e  ptional[int]) ->
+00008070: 2062 7974 6573 0a20 2020 2022 2222 0a20   bytes.    """. 
+00008080: 2020 2043 6f72 7275 7074 2061 2067 6976     Corrupt a giv
+00008090: 656e 2070 6572 6365 6e74 6167 6520 2861  en percentage (a
+000080a0: 7420 6c65 6173 7420 6f6e 6520 6279 7465  t least one byte
+000080b0: 2920 6f72 206e 756d 6265 7220 6f66 2062  ) or number of b
+000080c0: 7974 6573 0a20 2020 2066 726f 6d20 6120  ytes.    from a 
+000080d0: 7374 7269 6e67 0a20 2020 2022 2222 0a20  string.    """. 
+000080e0: 2020 2073 203d 2061 7272 6179 2e61 7272     s = array.arr
+000080f0: 6179 2822 4222 2c20 6279 7465 735f 656e  ay("B", bytes_en
+00008100: 636f 6465 2864 6174 6129 290a 2020 2020  code(data)).    
+00008110: 735f 6c65 6e20 3d20 6c65 6e28 7329 0a20  s_len = len(s). 
+00008120: 2020 2069 6620 6e20 6973 204e 6f6e 653a     if n is None:
+00008130: 0a20 2020 2020 2020 206e 203d 206d 6178  .        n = max
+00008140: 2831 2c20 696e 7428 735f 6c65 6e20 2a20  (1, int(s_len * 
+00008150: 7029 290a 2020 2020 666f 7220 6920 696e  p)).    for i in
+00008160: 2072 616e 646f 6d2e 7361 6d70 6c65 2872   random.sample(r
+00008170: 616e 6765 2873 5f6c 656e 292c 206e 293a  ange(s_len), n):
+00008180: 0a20 2020 2020 2020 2073 5b69 5d20 3d20  .        s[i] = 
+00008190: 2873 5b69 5d20 2b20 7261 6e64 6f6d 2e72  (s[i] + random.r
+000081a0: 616e 6469 6e74 2831 2c20 3235 3529 2920  andint(1, 255)) 
+000081b0: 2520 3235 360a 2020 2020 7265 7475 726e  % 256.    return
+000081c0: 2073 2e74 6f62 7974 6573 2829 0a0a 0a40   s.tobytes()...@
+000081d0: 636f 6e66 2e63 6f6d 6d61 6e64 732e 7265  conf.commands.re
+000081e0: 6769 7374 6572 0a64 6566 2063 6f72 7275  gister.def corru
+000081f0: 7074 5f62 6974 7328 6461 7461 2c20 703d  pt_bits(data, p=
+00008200: 302e 3031 2c20 6e3d 4e6f 6e65 293a 0a20  0.01, n=None):. 
+00008210: 2020 2023 2074 7970 653a 2028 7374 722c     # type: (str,
+00008220: 2066 6c6f 6174 2c20 4f70 7469 6f6e 616c   float, Optional
+00008230: 5b69 6e74 5d29 202d 3e20 6279 7465 730a  [int]) -> bytes.
+00008240: 2020 2020 2222 220a 2020 2020 466c 6970      """.    Flip
+00008250: 2061 2067 6976 656e 2070 6572 6365 6e74   a given percent
+00008260: 6167 6520 2861 7420 6c65 6173 7420 6f6e  age (at least on
+00008270: 6520 6269 7429 206f 7220 6e75 6d62 6572  e bit) or number
+00008280: 206f 6620 6269 7473 0a20 2020 2066 726f   of bits.    fro
+00008290: 6d20 6120 7374 7269 6e67 0a20 2020 2022  m a string.    "
+000082a0: 2222 0a20 2020 2073 203d 2061 7272 6179  "".    s = array
+000082b0: 2e61 7272 6179 2822 4222 2c20 6279 7465  .array("B", byte
+000082c0: 735f 656e 636f 6465 2864 6174 6129 290a  s_encode(data)).
+000082d0: 2020 2020 735f 6c65 6e20 3d20 6c65 6e28      s_len = len(
+000082e0: 7329 202a 2038 0a20 2020 2069 6620 6e20  s) * 8.    if n 
+000082f0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00008300: 206e 203d 206d 6178 2831 2c20 696e 7428   n = max(1, int(
+00008310: 735f 6c65 6e20 2a20 7029 290a 2020 2020  s_len * p)).    
+00008320: 666f 7220 6920 696e 2072 616e 646f 6d2e  for i in random.
+00008330: 7361 6d70 6c65 2872 616e 6765 2873 5f6c  sample(range(s_l
+00008340: 656e 292c 206e 293a 0a20 2020 2020 2020  en), n):.       
+00008350: 2073 5b69 202f 2f20 385d 205e 3d20 3120   s[i // 8] ^= 1 
+00008360: 3c3c 2028 6920 2520 3829 0a20 2020 2072  << (i % 8).    r
+00008370: 6574 7572 6e20 732e 746f 6279 7465 7328  eturn s.tobytes(
+00008380: 290a 0a0a 2323 2323 2323 2323 2323 2323  )...############
+00008390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000083a0: 230a 2320 2070 6361 7020 6361 7074 7572  #.#  pcap captur
+000083b0: 6520 6669 6c65 2073 7475 6666 2020 230a  e file stuff  #.
+000083c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000083d0: 2323 2323 2323 2323 2323 2323 230a 0a40  #############..@
+000083e0: 636f 6e66 2e63 6f6d 6d61 6e64 732e 7265  conf.commands.re
+000083f0: 6769 7374 6572 0a64 6566 2077 7270 6361  gister.def wrpca
+00008400: 7028 6669 6c65 6e61 6d65 2c20 2023 2074  p(filename,  # t
+00008410: 7970 653a 2055 6e69 6f6e 5b49 4f5b 6279  ype: Union[IO[by
+00008420: 7465 735d 2c20 7374 725d 0a20 2020 2020  tes], str].     
+00008430: 2020 2020 2020 706b 742c 2020 2320 7479        pkt,  # ty
+00008440: 7065 3a20 5f50 6163 6b65 7449 7465 7261  pe: _PacketItera
+00008450: 626c 650a 2020 2020 2020 2020 2020 202a  ble.           *
+00008460: 6172 6773 2c20 2023 2074 7970 653a 2041  args,  # type: A
+00008470: 6e79 0a20 2020 2020 2020 2020 2020 2a2a  ny.           **
+00008480: 6b61 7267 7320 2023 2074 7970 653a 2041  kargs  # type: A
+00008490: 6e79 0a20 2020 2020 2020 2020 2020 293a  ny.           ):
+000084a0: 0a20 2020 2023 2074 7970 653a 2028 2e2e  .    # type: (..
+000084b0: 2e29 202d 3e20 4e6f 6e65 0a20 2020 2022  .) -> None.    "
+000084c0: 2222 5772 6974 6520 6120 6c69 7374 206f  ""Write a list o
+000084d0: 6620 7061 636b 6574 7320 746f 2061 2070  f packets to a p
+000084e0: 6361 7020 6669 6c65 0a0a 2020 2020 3a70  cap file..    :p
+000084f0: 6172 616d 2066 696c 656e 616d 653a 2074  aram filename: t
+00008500: 6865 206e 616d 6520 6f66 2074 6865 2066  he name of the f
+00008510: 696c 6520 746f 2077 7269 7465 2070 6163  ile to write pac
+00008520: 6b65 7473 2074 6f2c 206f 7220 616e 206f  kets to, or an o
+00008530: 7065 6e2c 0a20 2020 2020 2020 2077 7269  pen,.        wri
+00008540: 7461 626c 6520 6669 6c65 2d6c 696b 6520  table file-like 
+00008550: 6f62 6a65 6374 2e20 5468 6520 6669 6c65  object. The file
+00008560: 2064 6573 6372 6970 746f 7220 7769 6c6c   descriptor will
+00008570: 2062 650a 2020 2020 2020 2020 636c 6f73   be.        clos
+00008580: 6564 2061 7420 7468 6520 656e 6420 6f66  ed at the end of
+00008590: 2074 6865 2063 616c 6c2c 2073 6f20 646f   the call, so do
+000085a0: 206e 6f74 2075 7365 2061 6e20 6f62 6a65   not use an obje
+000085b0: 6374 2079 6f75 0a20 2020 2020 2020 2064  ct you.        d
+000085c0: 6f20 6e6f 7420 7761 6e74 2074 6f20 636c  o not want to cl
+000085d0: 6f73 6520 2865 2e67 2e2c 2072 756e 6e69  ose (e.g., runni
+000085e0: 6e67 2077 7270 6361 7028 7379 732e 7374  ng wrpcap(sys.st
+000085f0: 646f 7574 2c20 5b5d 290a 2020 2020 2020  dout, []).      
+00008600: 2020 696e 2069 6e74 6572 6163 7469 7665    in interactive
+00008610: 206d 6f64 6520 7769 6c6c 2063 7261 7368   mode will crash
+00008620: 2053 6361 7079 292e 0a20 2020 203a 7061   Scapy)..    :pa
+00008630: 7261 6d20 677a 3a20 7365 7420 746f 2031  ram gz: set to 1
+00008640: 2074 6f20 7361 7665 2061 2067 7a69 7070   to save a gzipp
+00008650: 6564 2063 6170 7475 7265 0a20 2020 203a  ed capture.    :
+00008660: 7061 7261 6d20 6c69 6e6b 7479 7065 3a20  param linktype: 
+00008670: 666f 7263 6520 6c69 6e6b 7479 7065 2076  force linktype v
+00008680: 616c 7565 0a20 2020 203a 7061 7261 6d20  alue.    :param 
+00008690: 656e 6469 616e 6e65 7373 3a20 223c 2220  endianness: "<" 
+000086a0: 6f72 2022 3e22 2c20 666f 7263 6520 656e  or ">", force en
+000086b0: 6469 616e 6e65 7373 0a20 2020 203a 7061  dianness.    :pa
+000086c0: 7261 6d20 7379 6e63 3a20 646f 206e 6f74  ram sync: do not
+000086d0: 2062 7566 6665 7269 7a65 2077 7269 7465   bufferize write
+000086e0: 7320 746f 2074 6865 2063 6170 7475 7265  s to the capture
+000086f0: 2066 696c 650a 2020 2020 2222 220a 2020   file.    """.  
+00008700: 2020 7769 7468 2050 6361 7057 7269 7465    with PcapWrite
+00008710: 7228 6669 6c65 6e61 6d65 2c20 2a61 7267  r(filename, *arg
+00008720: 732c 202a 2a6b 6172 6773 2920 6173 2066  s, **kargs) as f
+00008730: 6465 7363 3a0a 2020 2020 2020 2020 6664  desc:.        fd
+00008740: 6573 632e 7772 6974 6528 706b 7429 0a0a  esc.write(pkt)..
+00008750: 0a40 636f 6e66 2e63 6f6d 6d61 6e64 732e  .@conf.commands.
+00008760: 7265 6769 7374 6572 0a64 6566 2077 7270  register.def wrp
+00008770: 6361 706e 6728 6669 6c65 6e61 6d65 2c20  capng(filename, 
+00008780: 2023 2074 7970 653a 2073 7472 0a20 2020   # type: str.   
+00008790: 2020 2020 2020 2020 2020 706b 742c 2020            pkt,  
+000087a0: 2320 7479 7065 3a20 5f50 6163 6b65 7449  # type: _PacketI
+000087b0: 7465 7261 626c 650a 2020 2020 2020 2020  terable.        
+000087c0: 2020 2020 2029 3a0a 2020 2020 2320 7479       ):.    # ty
+000087d0: 7065 3a20 282e 2e2e 2920 2d3e 204e 6f6e  pe: (...) -> Non
+000087e0: 650a 2020 2020 2222 2257 7269 7465 2061  e.    """Write a
+000087f0: 206c 6973 7420 6f66 2070 6163 6b65 7473   list of packets
+00008800: 2074 6f20 6120 7063 6170 6e67 2066 696c   to a pcapng fil
+00008810: 650a 0a20 2020 203a 7061 7261 6d20 6669  e..    :param fi
+00008820: 6c65 6e61 6d65 3a20 7468 6520 6e61 6d65  lename: the name
+00008830: 206f 6620 7468 6520 6669 6c65 2074 6f20   of the file to 
+00008840: 7772 6974 6520 7061 636b 6574 7320 746f  write packets to
+00008850: 2c20 6f72 2061 6e20 6f70 656e 2c0a 2020  , or an open,.  
+00008860: 2020 2020 2020 7772 6974 6162 6c65 2066        writable f
+00008870: 696c 652d 6c69 6b65 206f 626a 6563 742e  ile-like object.
+00008880: 2054 6865 2066 696c 6520 6465 7363 7269   The file descri
+00008890: 7074 6f72 2077 696c 6c20 6265 0a20 2020  ptor will be.   
+000088a0: 2020 2020 2063 6c6f 7365 6420 6174 2074       closed at t
+000088b0: 6865 2065 6e64 206f 6620 7468 6520 6361  he end of the ca
+000088c0: 6c6c 2c20 736f 2064 6f20 6e6f 7420 7573  ll, so do not us
+000088d0: 6520 616e 206f 626a 6563 7420 796f 750a  e an object you.
+000088e0: 2020 2020 2020 2020 646f 206e 6f74 2077          do not w
+000088f0: 616e 7420 746f 2063 6c6f 7365 2028 652e  ant to close (e.
+00008900: 672e 2c20 7275 6e6e 696e 6720 7772 7063  g., running wrpc
+00008910: 6170 6e67 2873 7973 2e73 7464 6f75 742c  apng(sys.stdout,
+00008920: 205b 5d29 0a20 2020 2020 2020 2069 6e20   []).        in 
+00008930: 696e 7465 7261 6374 6976 6520 6d6f 6465  interactive mode
+00008940: 2077 696c 6c20 6372 6173 6820 5363 6170   will crash Scap
+00008950: 7929 2e0a 2020 2020 3a70 6172 616d 2070  y)..    :param p
+00008960: 6b74 3a20 7061 636b 6574 7320 746f 2077  kt: packets to w
+00008970: 7269 7465 0a20 2020 2022 2222 0a20 2020  rite.    """.   
+00008980: 2077 6974 6820 5063 6170 4e67 5772 6974   with PcapNgWrit
+00008990: 6572 2866 696c 656e 616d 6529 2061 7320  er(filename) as 
+000089a0: 6664 6573 633a 0a20 2020 2020 2020 2066  fdesc:.        f
+000089b0: 6465 7363 2e77 7269 7465 2870 6b74 290a  desc.write(pkt).
+000089c0: 0a0a 4063 6f6e 662e 636f 6d6d 616e 6473  ..@conf.commands
+000089d0: 2e72 6567 6973 7465 720a 6465 6620 7264  .register.def rd
+000089e0: 7063 6170 2866 696c 656e 616d 652c 2063  pcap(filename, c
+000089f0: 6f75 6e74 3d2d 3129 3a0a 2020 2020 2320  ount=-1):.    # 
+00008a00: 7479 7065 3a20 2855 6e69 6f6e 5b49 4f5b  type: (Union[IO[
+00008a10: 6279 7465 735d 2c20 7374 725d 2c20 696e  bytes], str], in
+00008a20: 7429 202d 3e20 5061 636b 6574 4c69 7374  t) -> PacketList
+00008a30: 0a20 2020 2022 2222 5265 6164 2061 2070  .    """Read a p
+00008a40: 6361 7020 6f72 2070 6361 706e 6720 6669  cap or pcapng fi
+00008a50: 6c65 2061 6e64 2072 6574 7572 6e20 6120  le and return a 
+00008a60: 7061 636b 6574 206c 6973 740a 0a20 2020  packet list..   
+00008a70: 203a 7061 7261 6d20 636f 756e 743a 2072   :param count: r
+00008a80: 6561 6420 6f6e 6c79 203c 636f 756e 743e  ead only <count>
+00008a90: 2070 6163 6b65 7473 0a20 2020 2022 2222   packets.    """
+00008aa0: 0a20 2020 2023 2052 616e 743a 204f 7572  .    # Rant: Our
+00008ab0: 2063 6f6d 706c 6963 6174 6564 2075 7365   complicated use
+00008ac0: 206f 6620 6d65 7461 636c 6173 7365 7320   of metaclasses 
+00008ad0: 616e 6420 6573 7065 6369 616c 6c79 2074  and especially t
+00008ae0: 6865 0a20 2020 2023 205f 5f63 616c 6c5f  he.    # __call_
+00008af0: 5f20 6675 6e63 7469 6f6e 2069 732c 206f  _ function is, o
+00008b00: 6620 636f 7572 7365 2c20 6e6f 7420 7375  f course, not su
+00008b10: 7070 6f72 7465 6420 6279 204d 7950 792e  pported by MyPy.
+00008b20: 0a20 2020 2023 204f 6e65 2064 6179 2077  .    # One day w
+00008b30: 6520 7368 6f75 6c64 2073 696d 706c 6966  e should simplif
+00008b40: 7920 7468 6973 206d 6573 7320 616e 6420  y this mess and 
+00008b50: 7573 6520 6120 6d75 6368 2073 696d 706c  use a much simpl
+00008b60: 6572 0a20 2020 2023 206c 6179 6f75 7420  er.    # layout 
+00008b70: 7468 6174 2077 696c 6c20 6163 7475 616c  that will actual
+00008b80: 6c79 2062 6520 7375 7070 6f72 7465 6420  ly be supported 
+00008b90: 616e 6420 7072 6f70 6572 6c79 2064 6973  and properly dis
+00008ba0: 7365 6374 6564 2e0a 2020 2020 7769 7468  sected..    with
+00008bb0: 2050 6361 7052 6561 6465 7228 6669 6c65   PcapReader(file
+00008bc0: 6e61 6d65 2920 6173 2066 6465 7363 3a20  name) as fdesc: 
+00008bd0: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
+00008be0: 2020 2020 2020 2020 7265 7475 726e 2066          return f
+00008bf0: 6465 7363 2e72 6561 645f 616c 6c28 636f  desc.read_all(co
+00008c00: 756e 743d 636f 756e 7429 0a0a 0a23 204e  unt=count)...# N
+00008c10: 4f54 453a 2054 7970 6520 6869 6e74 696e  OTE: Type hintin
+00008c20: 670a 2320 4d79 7079 2064 6f65 736e 2774  g.# Mypy doesn't
+00008c30: 2075 6e64 6572 7374 616e 6420 7468 6520   understand the 
+00008c40: 666f 6c6c 6f77 696e 6720 6d65 7461 636c  following metacl
+00008c50: 6173 732c 2061 6e64 2074 6869 6e6b 7320  ass, and thinks 
+00008c60: 6561 6368 0a23 2063 6f6e 7374 7275 6374  each.# construct
+00008c70: 6f72 2028 5063 6170 5265 6164 6572 2e2e  or (PcapReader..
+00008c80: 2e29 206e 6565 6473 2033 2061 7267 756d  .) needs 3 argum
+00008c90: 656e 7473 2065 6163 682e 2054 6f20 6176  ents each. To av
+00008ca0: 6f69 6420 7468 6973 2c0a 2320 7765 2061  oid this,.# we a
+00008cb0: 6464 2061 2066 616b 6520 283d 4e6f 6e65  dd a fake (=None
+00008cc0: 2920 746f 2074 6865 206c 6173 7420 3220  ) to the last 2 
+00008cd0: 6172 6775 6d65 6e74 7320 7468 656e 2066  arguments then f
+00008ce0: 6f72 6365 2074 6865 2076 616c 7565 0a23  orce the value.#
+00008cf0: 2074 6f20 6e6f 7420 6265 204e 6f6e 6520   to not be None 
+00008d00: 696e 2074 6865 2073 6967 6e61 7475 7265  in the signature
+00008d10: 2061 6e64 2070 6163 6b20 7468 6520 7768   and pack the wh
+00008d20: 6f6c 6520 7468 696e 6720 696e 2061 6e20  ole thing in an 
+00008d30: 6967 6e6f 7265 2e0a 2320 5468 6973 2061  ignore..# This a
+00008d40: 6c6c 6f77 7320 746f 206e 6f74 2068 6176  llows to not hav
+00008d50: 6520 2320 7479 7065 3a20 6967 6e6f 7265  e # type: ignore
+00008d60: 2065 7665 7279 2074 696d 6520 7765 2063   every time we c
+00008d70: 616c 6c20 7468 6f73 650a 2320 636f 6e73  all those.# cons
+00008d80: 7472 7563 746f 7273 2e0a 0a63 6c61 7373  tructors...class
+00008d90: 2050 6361 7052 6561 6465 725f 6d65 7461   PcapReader_meta
+00008da0: 636c 6173 7328 7479 7065 293a 0a20 2020  class(type):.   
+00008db0: 2022 2222 4d65 7461 636c 6173 7320 666f   """Metaclass fo
+00008dc0: 7220 2852 6177 2950 6361 7028 4e67 2952  r (Raw)Pcap(Ng)R
+00008dd0: 6561 6465 7273 2222 220a 0a20 2020 2064  eaders"""..    d
+00008de0: 6566 205f 5f6e 6577 5f5f 2863 6c73 2c20  ef __new__(cls, 
+00008df0: 6e61 6d65 2c20 6261 7365 732c 2064 6374  name, bases, dct
+00008e00: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+00008e10: 653a 2028 416e 792c 2073 7472 2c20 416e  e: (Any, str, An
+00008e20: 792c 2044 6963 745b 7374 722c 2041 6e79  y, Dict[str, Any
+00008e30: 5d29 202d 3e20 416e 790a 2020 2020 2020  ]) -> Any.      
+00008e40: 2020 2222 2254 6865 2060 616c 7465 726e    """The `altern
+00008e50: 6174 6976 6560 2063 6c61 7373 2061 7474  ative` class att
+00008e60: 7269 6275 7465 2069 7320 6465 636c 6172  ribute is declar
+00008e70: 6564 2069 6e20 7468 6520 5063 6170 4e67  ed in the PcapNg
+00008e80: 0a20 2020 2020 2020 2076 6172 6961 6e74  .        variant
+00008e90: 2c20 616e 6420 7365 7420 6865 7265 2074  , and set here t
+00008ea0: 6f20 7468 6520 5063 6170 2076 6172 6961  o the Pcap varia
+00008eb0: 6e74 2e0a 0a20 2020 2020 2020 2022 2222  nt...        """
+00008ec0: 0a20 2020 2020 2020 206e 6577 636c 7320  .        newcls 
+00008ed0: 3d20 7375 7065 7228 5063 6170 5265 6164  = super(PcapRead
+00008ee0: 6572 5f6d 6574 6163 6c61 7373 2c20 636c  er_metaclass, cl
+00008ef0: 7329 2e5f 5f6e 6577 5f5f 280a 2020 2020  s).__new__(.    
+00008f00: 2020 2020 2020 2020 636c 732c 206e 616d          cls, nam
+00008f10: 652c 2062 6173 6573 2c20 6463 740a 2020  e, bases, dct.  
+00008f20: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00008f30: 6966 2027 616c 7465 726e 6174 6976 6527  if 'alternative'
+00008f40: 2069 6e20 6463 743a 0a20 2020 2020 2020   in dct:.       
+00008f50: 2020 2020 2064 6374 5b27 616c 7465 726e       dct['altern
+00008f60: 6174 6976 6527 5d2e 616c 7465 726e 6174  ative'].alternat
+00008f70: 6976 6520 3d20 6e65 7763 6c73 0a20 2020  ive = newcls.   
+00008f80: 2020 2020 2072 6574 7572 6e20 6e65 7763       return newc
+00008f90: 6c73 0a0a 2020 2020 6465 6620 5f5f 6361  ls..    def __ca
+00008fa0: 6c6c 5f5f 2863 6c73 2c20 6669 6c65 6e61  ll__(cls, filena
+00008fb0: 6d65 293a 0a20 2020 2020 2020 2023 2074  me):.        # t
+00008fc0: 7970 653a 2028 556e 696f 6e5b 494f 5b62  ype: (Union[IO[b
+00008fd0: 7974 6573 5d2c 2073 7472 5d29 202d 3e20  ytes], str]) -> 
+00008fe0: 416e 790a 2020 2020 2020 2020 2222 2243  Any.        """C
+00008ff0: 7265 6174 6573 2061 2063 6c73 2069 6e73  reates a cls ins
+00009000: 7461 6e63 652c 2075 7365 2074 6865 2060  tance, use the `
+00009010: 616c 7465 726e 6174 6976 6560 2069 6620  alternative` if 
+00009020: 7468 6174 0a20 2020 2020 2020 2066 6169  that.        fai
+00009030: 6c73 2e0a 0a20 2020 2020 2020 2022 2222  ls...        """
+00009040: 0a20 2020 2020 2020 2069 203d 2063 6c73  .        i = cls
+00009050: 2e5f 5f6e 6577 5f5f 280a 2020 2020 2020  .__new__(.      
+00009060: 2020 2020 2020 636c 732c 0a20 2020 2020        cls,.     
+00009070: 2020 2020 2020 2063 6c73 2e5f 5f6e 616d         cls.__nam
+00009080: 655f 5f2c 0a20 2020 2020 2020 2020 2020  e__,.           
+00009090: 2063 6c73 2e5f 5f62 6173 6573 5f5f 2c0a   cls.__bases__,.
+000090a0: 2020 2020 2020 2020 2020 2020 636c 732e              cls.
+000090b0: 5f5f 6469 6374 5f5f 2020 2320 7479 7065  __dict__  # type
+000090c0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+000090d0: 2029 0a20 2020 2020 2020 2066 696c 656e   ).        filen
+000090e0: 616d 652c 2066 6465 7363 2c20 6d61 6769  ame, fdesc, magi
+000090f0: 6320 3d20 636c 732e 6f70 656e 2866 696c  c = cls.open(fil
+00009100: 656e 616d 6529 0a20 2020 2020 2020 2069  ename).        i
+00009110: 6620 6e6f 7420 6d61 6769 633a 0a20 2020  f not magic:.   
+00009120: 2020 2020 2020 2020 2072 6169 7365 2053           raise S
+00009130: 6361 7079 5f45 7863 6570 7469 6f6e 280a  capy_Exception(.
+00009140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009150: 224e 6f20 6461 7461 2063 6f75 6c64 2062  "No data could b
+00009160: 6520 7265 6164 2122 0a20 2020 2020 2020  e read!".       
+00009170: 2020 2020 2029 0a20 2020 2020 2020 2074       ).        t
+00009180: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+00009190: 692e 5f5f 696e 6974 5f5f 2866 696c 656e  i.__init__(filen
+000091a0: 616d 652c 2066 6465 7363 2c20 6d61 6769  ame, fdesc, magi
+000091b0: 6329 0a20 2020 2020 2020 2020 2020 2072  c).            r
+000091c0: 6574 7572 6e20 690a 2020 2020 2020 2020  eturn i.        
+000091d0: 6578 6365 7074 2028 5363 6170 795f 4578  except (Scapy_Ex
+000091e0: 6365 7074 696f 6e2c 2045 4f46 4572 726f  ception, EOFErro
+000091f0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+00009200: 7061 7373 0a0a 2020 2020 2020 2020 6966  pass..        if
+00009210: 2022 616c 7465 726e 6174 6976 6522 2069   "alternative" i
+00009220: 6e20 636c 732e 5f5f 6469 6374 5f5f 3a0a  n cls.__dict__:.
+00009230: 2020 2020 2020 2020 2020 2020 636c 7320              cls 
+00009240: 3d20 636c 732e 5f5f 6469 6374 5f5f 5b22  = cls.__dict__["
+00009250: 616c 7465 726e 6174 6976 6522 5d0a 2020  alternative"].  
+00009260: 2020 2020 2020 2020 2020 6920 3d20 636c            i = cl
+00009270: 732e 5f5f 6e65 775f 5f28 0a20 2020 2020  s.__new__(.     
+00009280: 2020 2020 2020 2020 2020 2063 6c73 2c0a             cls,.
+00009290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000092a0: 636c 732e 5f5f 6e61 6d65 5f5f 2c0a 2020  cls.__name__,.  
+000092b0: 2020 2020 2020 2020 2020 2020 2020 636c                cl
+000092c0: 732e 5f5f 6261 7365 735f 5f2c 0a20 2020  s.__bases__,.   
+000092d0: 2020 2020 2020 2020 2020 2020 2063 6c73               cls
+000092e0: 2e5f 5f64 6963 745f 5f20 2023 2074 7970  .__dict__  # typ
+000092f0: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
+00009300: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00009310: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00009320: 2020 2020 2020 2020 2069 2e5f 5f69 6e69           i.__ini
+00009330: 745f 5f28 6669 6c65 6e61 6d65 2c20 6664  t__(filename, fd
+00009340: 6573 632c 206d 6167 6963 290a 2020 2020  esc, magic).    
+00009350: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00009360: 726e 2069 0a20 2020 2020 2020 2020 2020  rn i.           
+00009370: 2065 7863 6570 7420 2853 6361 7079 5f45   except (Scapy_E
+00009380: 7863 6570 7469 6f6e 2c20 454f 4645 7272  xception, EOFErr
+00009390: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
+000093a0: 2020 2020 2070 6173 730a 0a20 2020 2020       pass..     
+000093b0: 2020 2072 6169 7365 2053 6361 7079 5f45     raise Scapy_E
+000093c0: 7863 6570 7469 6f6e 2822 4e6f 7420 6120  xception("Not a 
+000093d0: 7375 7070 6f72 7465 6420 6361 7074 7572  supported captur
+000093e0: 6520 6669 6c65 2229 0a0a 2020 2020 4073  e file")..    @s
+000093f0: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+00009400: 6465 6620 6f70 656e 2866 6e61 6d65 2020  def open(fname  
+00009410: 2320 7479 7065 3a20 556e 696f 6e5b 494f  # type: Union[IO
+00009420: 5b62 7974 6573 5d2c 2073 7472 5d0a 2020  [bytes], str].  
+00009430: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
+00009440: 2020 2020 2020 2320 7479 7065 3a20 282e        # type: (.
+00009450: 2e2e 2920 2d3e 2054 7570 6c65 5b73 7472  ..) -> Tuple[str
+00009460: 2c20 5f42 7974 6553 7472 6561 6d2c 2062  , _ByteStream, b
+00009470: 7974 6573 5d0a 2020 2020 2020 2020 2222  ytes].        ""
+00009480: 224f 7065 6e20 2869 6620 6e65 6365 7373  "Open (if necess
+00009490: 6172 7929 2066 696c 656e 616d 652c 2061  ary) filename, a
+000094a0: 6e64 2072 6561 6420 7468 6520 6d61 6769  nd read the magi
+000094b0: 632e 2222 220a 2020 2020 2020 2020 6966  c.""".        if
+000094c0: 2069 7369 6e73 7461 6e63 6528 666e 616d   isinstance(fnam
+000094d0: 652c 2073 7472 293a 0a20 2020 2020 2020  e, str):.       
+000094e0: 2020 2020 2066 696c 656e 616d 6520 3d20       filename = 
+000094f0: 666e 616d 650a 2020 2020 2020 2020 2020  fname.          
+00009500: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+00009510: 2020 2020 2020 2066 6465 7363 203d 2067         fdesc = g
+00009520: 7a69 702e 6f70 656e 2866 696c 656e 616d  zip.open(filenam
+00009530: 652c 2022 7262 2229 2020 2320 7479 7065  e, "rb")  # type
+00009540: 3a20 5f42 7974 6553 7472 6561 6d0a 2020  : _ByteStream.  
+00009550: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+00009560: 6769 6320 3d20 6664 6573 632e 7265 6164  gic = fdesc.read
+00009570: 2834 290a 2020 2020 2020 2020 2020 2020  (4).            
+00009580: 6578 6365 7074 2049 4f45 7272 6f72 3a0a  except IOError:.
+00009590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000095a0: 6664 6573 6320 3d20 6f70 656e 2866 696c  fdesc = open(fil
+000095b0: 656e 616d 652c 2022 7262 2229 0a20 2020  ename, "rb").   
+000095c0: 2020 2020 2020 2020 2020 2020 206d 6167               mag
+000095d0: 6963 203d 2066 6465 7363 2e72 6561 6428  ic = fdesc.read(
+000095e0: 3429 0a20 2020 2020 2020 2065 6c73 653a  4).        else:
+000095f0: 0a20 2020 2020 2020 2020 2020 2066 6465  .            fde
+00009600: 7363 203d 2066 6e61 6d65 0a20 2020 2020  sc = fname.     
+00009610: 2020 2020 2020 2066 696c 656e 616d 6520         filename 
+00009620: 3d20 6765 7461 7474 7228 6664 6573 632c  = getattr(fdesc,
+00009630: 2022 6e61 6d65 222c 2022 4e6f 206e 616d   "name", "No nam
+00009640: 6522 290a 2020 2020 2020 2020 2020 2020  e").            
+00009650: 6d61 6769 6320 3d20 6664 6573 632e 7265  magic = fdesc.re
+00009660: 6164 2834 290a 2020 2020 2020 2020 7265  ad(4).        re
+00009670: 7475 726e 2066 696c 656e 616d 652c 2066  turn filename, f
+00009680: 6465 7363 2c20 6d61 6769 630a 0a0a 636c  desc, magic...cl
+00009690: 6173 7320 5261 7750 6361 7052 6561 6465  ass RawPcapReade
+000096a0: 7228 6d65 7461 636c 6173 733d 5063 6170  r(metaclass=Pcap
+000096b0: 5265 6164 6572 5f6d 6574 6163 6c61 7373  Reader_metaclass
+000096c0: 293a 0a20 2020 2022 2222 4120 7374 6174  ):.    """A stat
+000096d0: 6566 756c 2070 6361 7020 7265 6164 6572  eful pcap reader
+000096e0: 2e20 4561 6368 2070 6163 6b65 7420 6973  . Each packet is
+000096f0: 2072 6574 7572 6e65 6420 6173 2061 2073   returned as a s
+00009700: 7472 696e 6722 2222 0a0a 2020 2020 2320  tring"""..    # 
+00009710: 544f 444f 3a20 7573 6520 4765 6e65 7269  TODO: use Generi
+00009720: 6373 2074 6f20 7072 6f70 6572 6c79 2074  cs to properly t
+00009730: 7970 6520 7468 6520 7661 7269 6f75 7320  ype the various 
+00009740: 7265 6164 6572 732e 0a20 2020 2023 2041  readers..    # A
+00009750: 7320 6f66 2072 6967 6874 206e 6f77 2c20  s of right now, 
+00009760: 5261 7750 6361 7052 6561 6465 7220 6973  RawPcapReader is
+00009770: 2074 7970 6564 2061 7320 6966 2069 7420   typed as if it 
+00009780: 7265 7475 726e 6564 2070 6163 6b65 7473  returned packets
+00009790: 0a20 2020 2023 2062 6563 6175 7365 2061  .    # because a
+000097a0: 6c6c 206f 6620 6974 7320 6368 696c 6420  ll of its child 
+000097b0: 646f 2e20 4669 7820 7468 6174 0a0a 2020  do. Fix that..  
+000097c0: 2020 6e6f 6e62 6c6f 636b 696e 675f 736f    nonblocking_so
+000097d0: 636b 6574 203d 2054 7275 650a 2020 2020  cket = True.    
+000097e0: 5061 636b 6574 4d65 7461 6461 7461 203d  PacketMetadata =
+000097f0: 2063 6f6c 6c65 6374 696f 6e73 2e6e 616d   collections.nam
+00009800: 6564 7475 706c 6528 2250 6163 6b65 744d  edtuple("PacketM
+00009810: 6574 6164 6174 6122 2c0a 2020 2020 2020  etadata",.      
+00009820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009840: 2020 2020 2020 5b22 7365 6322 2c20 2275        ["sec", "u
+00009850: 7365 6322 2c20 2277 6972 656c 656e 222c  sec", "wirelen",
+00009860: 2022 6361 706c 656e 225d 2920 2023 206e   "caplen"])  # n
+00009870: 6f71 613a 2045 3530 310a 0a20 2020 2064  oqa: E501..    d
+00009880: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+00009890: 2c20 6669 6c65 6e61 6d65 2c20 6664 6573  , filename, fdes
+000098a0: 633d 4e6f 6e65 2c20 6d61 6769 633d 4e6f  c=None, magic=No
+000098b0: 6e65 293a 2020 2320 7479 7065 3a20 6967  ne):  # type: ig
+000098c0: 6e6f 7265 0a20 2020 2020 2020 2023 2074  nore.        # t
+000098d0: 7970 653a 2028 7374 722c 205f 4279 7465  ype: (str, _Byte
+000098e0: 5374 7265 616d 2c20 6279 7465 7329 202d  Stream, bytes) -
+000098f0: 3e20 4e6f 6e65 0a20 2020 2020 2020 2073  > None.        s
+00009900: 656c 662e 6669 6c65 6e61 6d65 203d 2066  elf.filename = f
+00009910: 696c 656e 616d 650a 2020 2020 2020 2020  ilename.        
+00009920: 7365 6c66 2e66 203d 2066 6465 7363 0a20  self.f = fdesc. 
+00009930: 2020 2020 2020 2069 6620 6d61 6769 6320         if magic 
+00009940: 3d3d 2062 225c 7861 315c 7862 325c 7863  == b"\xa1\xb2\xc
+00009950: 335c 7864 3422 3a20 2023 2062 6967 2065  3\xd4":  # big e
+00009960: 6e64 6961 6e0a 2020 2020 2020 2020 2020  ndian.          
+00009970: 2020 7365 6c66 2e65 6e64 6961 6e20 3d20    self.endian = 
+00009980: 223e 220a 2020 2020 2020 2020 2020 2020  ">".            
+00009990: 7365 6c66 2e6e 616e 6f20 3d20 4661 6c73  self.nano = Fals
+000099a0: 650a 2020 2020 2020 2020 656c 6966 206d  e.        elif m
+000099b0: 6167 6963 203d 3d20 6222 5c78 6434 5c78  agic == b"\xd4\x
+000099c0: 6333 5c78 6232 5c78 6131 223a 2020 2320  c3\xb2\xa1":  # 
+000099d0: 6c69 7474 6c65 2065 6e64 6961 6e0a 2020  little endian.  
+000099e0: 2020 2020 2020 2020 2020 7365 6c66 2e65            self.e
+000099f0: 6e64 6961 6e20 3d20 223c 220a 2020 2020  ndian = "<".    
+00009a00: 2020 2020 2020 2020 7365 6c66 2e6e 616e          self.nan
+00009a10: 6f20 3d20 4661 6c73 650a 2020 2020 2020  o = False.      
+00009a20: 2020 656c 6966 206d 6167 6963 203d 3d20    elif magic == 
+00009a30: 6222 5c78 6131 5c78 6232 5c78 3363 5c78  b"\xa1\xb2\x3c\x
+00009a40: 3464 223a 2020 2320 6269 6720 656e 6469  4d":  # big endi
+00009a50: 616e 2c20 6e61 6e6f 7365 636f 6e64 2d70  an, nanosecond-p
+00009a60: 7265 6369 7369 6f6e 0a20 2020 2020 2020  recision.       
+00009a70: 2020 2020 2073 656c 662e 656e 6469 616e       self.endian
+00009a80: 203d 2022 3e22 0a20 2020 2020 2020 2020   = ">".         
+00009a90: 2020 2073 656c 662e 6e61 6e6f 203d 2054     self.nano = T
+00009aa0: 7275 650a 2020 2020 2020 2020 656c 6966  rue.        elif
+00009ab0: 206d 6167 6963 203d 3d20 6222 5c78 3464   magic == b"\x4d
+00009ac0: 5c78 3363 5c78 6232 5c78 6131 223a 2020  \x3c\xb2\xa1":  
+00009ad0: 2320 6c69 7474 6c65 2065 6e64 6961 6e2c  # little endian,
+00009ae0: 206e 616e 6f73 6563 6f6e 642d 7072 6563   nanosecond-prec
+00009af0: 6973 696f 6e20 2023 206e 6f71 613a 2045  ision  # noqa: E
+00009b00: 3530 310a 2020 2020 2020 2020 2020 2020  501.            
+00009b10: 7365 6c66 2e65 6e64 6961 6e20 3d20 223c  self.endian = "<
+00009b20: 220a 2020 2020 2020 2020 2020 2020 7365  ".            se
+00009b30: 6c66 2e6e 616e 6f20 3d20 5472 7565 0a20  lf.nano = True. 
+00009b40: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00009b50: 2020 2020 2020 2020 2072 6169 7365 2053           raise S
+00009b60: 6361 7079 5f45 7863 6570 7469 6f6e 280a  capy_Exception(.
+00009b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b80: 224e 6f74 2061 2070 6361 7020 6361 7074  "Not a pcap capt
+00009b90: 7572 6520 6669 6c65 2028 6261 6420 6d61  ure file (bad ma
+00009ba0: 6769 633a 2025 7229 2220 2520 6d61 6769  gic: %r)" % magi
+00009bb0: 630a 2020 2020 2020 2020 2020 2020 290a  c.            ).
+00009bc0: 2020 2020 2020 2020 6864 7220 3d20 7365          hdr = se
+00009bd0: 6c66 2e66 2e72 6561 6428 3230 290a 2020  lf.f.read(20).  
+00009be0: 2020 2020 2020 6966 206c 656e 2868 6472        if len(hdr
+00009bf0: 2920 3c20 3230 3a0a 2020 2020 2020 2020  ) < 20:.        
+00009c00: 2020 2020 7261 6973 6520 5363 6170 795f      raise Scapy_
+00009c10: 4578 6365 7074 696f 6e28 2249 6e76 616c  Exception("Inval
+00009c20: 6964 2070 6361 7020 6669 6c65 2028 746f  id pcap file (to
+00009c30: 6f20 7368 6f72 7429 2229 0a20 2020 2020  o short)").     
+00009c40: 2020 2076 6572 6d61 6a2c 2076 6572 6d69     vermaj, vermi
+00009c50: 6e2c 2074 7a2c 2073 6967 2c20 736e 6170  n, tz, sig, snap
+00009c60: 6c65 6e2c 206c 696e 6b74 7970 6520 3d20  len, linktype = 
+00009c70: 7374 7275 6374 2e75 6e70 6163 6b28 0a20  struct.unpack(. 
+00009c80: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00009c90: 656e 6469 616e 202b 2022 4848 4949 4949  endian + "HHIIII
+00009ca0: 222c 2068 6472 0a20 2020 2020 2020 2029  ", hdr.        )
+00009cb0: 0a20 2020 2020 2020 2073 656c 662e 6c69  .        self.li
+00009cc0: 6e6b 7479 7065 203d 206c 696e 6b74 7970  nktype = linktyp
+00009cd0: 650a 2020 2020 2020 2020 7365 6c66 2e73  e.        self.s
+00009ce0: 6e61 706c 656e 203d 2073 6e61 706c 656e  naplen = snaplen
+00009cf0: 0a0a 2020 2020 6465 6620 5f5f 656e 7465  ..    def __ente
+00009d00: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
+00009d10: 2020 2023 2074 7970 653a 2028 2920 2d3e     # type: () ->
+00009d20: 2052 6177 5063 6170 5265 6164 6572 0a20   RawPcapReader. 
+00009d30: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00009d40: 6c66 0a0a 2020 2020 6465 6620 5f5f 6974  lf..    def __it
 00009d50: 6572 5f5f 2873 656c 6629 3a0a 2020 2020  er__(self):.    
 00009d60: 2020 2020 2320 7479 7065 3a20 2829 202d      # type: () -
-00009d70: 3e20 5063 6170 5265 6164 6572 0a20 2020  > PcapReader.   
-00009d80: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00009d90: 0a0a 2020 2020 6465 6620 7265 6164 5f70  ..    def read_p
-00009da0: 6163 6b65 7428 7365 6c66 2c20 7369 7a65  acket(self, size
-00009db0: 3d4d 5455 293a 0a20 2020 2020 2020 2023  =MTU):.        #
-00009dc0: 2074 7970 653a 2028 696e 7429 202d 3e20   type: (int) -> 
-00009dd0: 5061 636b 6574 0a20 2020 2020 2020 2072  Packet.        r
-00009de0: 7020 3d20 7375 7065 7228 5063 6170 5265  p = super(PcapRe
-00009df0: 6164 6572 2c20 7365 6c66 292e 5f72 6561  ader, self)._rea
-00009e00: 645f 7061 636b 6574 2873 697a 653d 7369  d_packet(size=si
-00009e10: 7a65 290a 2020 2020 2020 2020 6966 2072  ze).        if r
-00009e20: 7020 6973 204e 6f6e 653a 0a20 2020 2020  p is None:.     
-00009e30: 2020 2020 2020 2072 6169 7365 2045 4f46         raise EOF
-00009e40: 4572 726f 720a 2020 2020 2020 2020 732c  Error.        s,
-00009e50: 2070 6b74 5f69 6e66 6f20 3d20 7270 0a0a   pkt_info = rp..
-00009e60: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-00009e70: 2020 2020 2020 2020 2070 203d 2073 656c           p = sel
-00009e80: 662e 4c4c 636c 7328 7329 2020 2320 7479  f.LLcls(s)  # ty
-00009e90: 7065 3a20 5061 636b 6574 0a20 2020 2020  pe: Packet.     
-00009ea0: 2020 2065 7863 6570 7420 4b65 7962 6f61     except Keyboa
-00009eb0: 7264 496e 7465 7272 7570 743a 0a20 2020  rdInterrupt:.   
-00009ec0: 2020 2020 2020 2020 2072 6169 7365 0a20           raise. 
-00009ed0: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
-00009ee0: 6365 7074 696f 6e3a 0a20 2020 2020 2020  ception:.       
-00009ef0: 2020 2020 2069 6620 636f 6e66 2e64 6562       if conf.deb
-00009f00: 7567 5f64 6973 7365 6374 6f72 3a0a 2020  ug_dissector:.  
-00009f10: 2020 2020 2020 2020 2020 2020 2020 6672                fr
-00009f20: 6f6d 2073 6361 7079 2e73 656e 6472 6563  om scapy.sendrec
-00009f30: 7620 696d 706f 7274 2064 6562 7567 0a20  v import debug. 
-00009f40: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00009f50: 6562 7567 2e63 7261 7368 6564 5f6f 6e20  ebug.crashed_on 
-00009f60: 3d20 2873 656c 662e 4c4c 636c 732c 2073  = (self.LLcls, s
-00009f70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00009f80: 2020 7261 6973 650a 2020 2020 2020 2020    raise.        
-00009f90: 2020 2020 6966 2063 6f6e 662e 7261 775f      if conf.raw_
-00009fa0: 6c61 7965 7220 6973 204e 6f6e 653a 0a20  layer is None:. 
-00009fb0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00009fc0: 2063 6f6e 662e 7261 775f 6c61 7965 7220   conf.raw_layer 
-00009fd0: 6973 2073 6574 206f 6e20 696d 706f 7274  is set on import
-00009fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009ff0: 2069 6d70 6f72 7420 7363 6170 792e 7061   import scapy.pa
-0000a000: 636b 6574 2020 2320 6e6f 7161 3a20 4634  cket  # noqa: F4
-0000a010: 3031 0a20 2020 2020 2020 2020 2020 2070  01.            p
-0000a020: 203d 2063 6f6e 662e 7261 775f 6c61 7965   = conf.raw_laye
-0000a030: 7228 7329 0a20 2020 2020 2020 2070 6f77  r(s).        pow
-0000a040: 6572 203d 2044 6563 696d 616c 2831 3029  er = Decimal(10)
-0000a050: 202a 2a20 4465 6369 6d61 6c28 2d39 2069   ** Decimal(-9 i
-0000a060: 6620 7365 6c66 2e6e 616e 6f20 656c 7365  f self.nano else
-0000a070: 202d 3629 0a20 2020 2020 2020 2070 2e74   -6).        p.t
-0000a080: 696d 6520 3d20 4544 6563 696d 616c 2870  ime = EDecimal(p
-0000a090: 6b74 5f69 6e66 6f2e 7365 6320 2b20 706f  kt_info.sec + po
-0000a0a0: 7765 7220 2a20 706b 745f 696e 666f 2e75  wer * pkt_info.u
-0000a0b0: 7365 6329 0a20 2020 2020 2020 2070 2e77  sec).        p.w
-0000a0c0: 6972 656c 656e 203d 2070 6b74 5f69 6e66  irelen = pkt_inf
-0000a0d0: 6f2e 7769 7265 6c65 6e0a 2020 2020 2020  o.wirelen.      
-0000a0e0: 2020 7265 7475 726e 2070 0a0a 2020 2020    return p..    
-0000a0f0: 6465 6620 7265 6376 2873 656c 662c 2073  def recv(self, s
-0000a100: 697a 653d 4d54 5529 3a0a 2020 2020 2020  ize=MTU):.      
-0000a110: 2020 2320 7479 7065 3a20 2869 6e74 2920    # type: (int) 
-0000a120: 2d3e 2050 6163 6b65 740a 2020 2020 2020  -> Packet.      
-0000a130: 2020 7265 7475 726e 2073 656c 662e 7265    return self.re
-0000a140: 6164 5f70 6163 6b65 7428 7369 7a65 3d73  ad_packet(size=s
-0000a150: 697a 6529 0a0a 2020 2020 6465 6620 6e65  ize)..    def ne
-0000a160: 7874 2873 656c 6629 3a0a 2020 2020 2020  xt(self):.      
-0000a170: 2020 2320 7479 7065 3a20 2829 202d 3e20    # type: () -> 
-0000a180: 5061 636b 6574 0a20 2020 2020 2020 2074  Packet.        t
-0000a190: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-0000a1a0: 7265 7475 726e 2073 656c 662e 7265 6164  return self.read
-0000a1b0: 5f70 6163 6b65 7428 290a 2020 2020 2020  _packet().      
-0000a1c0: 2020 6578 6365 7074 2045 4f46 4572 726f    except EOFErro
-0000a1d0: 723a 0a20 2020 2020 2020 2020 2020 2072  r:.            r
-0000a1e0: 6169 7365 2053 746f 7049 7465 7261 7469  aise StopIterati
-0000a1f0: 6f6e 0a0a 2020 2020 6465 6620 7265 6164  on..    def read
-0000a200: 5f61 6c6c 2873 656c 662c 2063 6f75 6e74  _all(self, count
-0000a210: 3d2d 3129 3a0a 2020 2020 2020 2020 2320  =-1):.        # 
-0000a220: 7479 7065 3a20 2869 6e74 2920 2d3e 2050  type: (int) -> P
-0000a230: 6163 6b65 744c 6973 740a 2020 2020 2020  acketList.      
-0000a240: 2020 7265 7320 3d20 7365 6c66 2e5f 7265    res = self._re
-0000a250: 6164 5f61 6c6c 2863 6f75 6e74 290a 2020  ad_all(count).  
-0000a260: 2020 2020 2020 6672 6f6d 2073 6361 7079        from scapy
-0000a270: 2069 6d70 6f72 7420 706c 6973 740a 2020   import plist.  
-0000a280: 2020 2020 2020 7265 7475 726e 2070 6c69        return pli
-0000a290: 7374 2e50 6163 6b65 744c 6973 7428 7265  st.PacketList(re
-0000a2a0: 732c 206e 616d 653d 6f73 2e70 6174 682e  s, name=os.path.
-0000a2b0: 6261 7365 6e61 6d65 2873 656c 662e 6669  basename(self.fi
-0000a2c0: 6c65 6e61 6d65 2929 0a0a 0a63 6c61 7373  lename))...class
-0000a2d0: 2052 6177 5063 6170 4e67 5265 6164 6572   RawPcapNgReader
-0000a2e0: 2852 6177 5063 6170 5265 6164 6572 293a  (RawPcapReader):
-0000a2f0: 0a20 2020 2022 2222 4120 7374 6174 6566  .    """A statef
-0000a300: 756c 2070 6361 706e 6720 7265 6164 6572  ul pcapng reader
-0000a310: 2e20 4561 6368 2070 6163 6b65 7420 6973  . Each packet is
-0000a320: 2072 6574 7572 6e65 6420 6173 0a20 2020   returned as.   
-0000a330: 2062 7974 6573 2e0a 0a20 2020 2022 2222   bytes...    """
-0000a340: 0a0a 2020 2020 616c 7465 726e 6174 6976  ..    alternativ
-0000a350: 6520 3d20 5261 7750 6361 7052 6561 6465  e = RawPcapReade
-0000a360: 7220 2023 2074 7970 653a 2054 7970 655b  r  # type: Type[
-0000a370: 416e 795d 0a0a 2020 2020 5061 636b 6574  Any]..    Packet
-0000a380: 4d65 7461 6461 7461 203d 2063 6f6c 6c65  Metadata = colle
-0000a390: 6374 696f 6e73 2e6e 616d 6564 7475 706c  ctions.namedtupl
-0000a3a0: 6528 2250 6163 6b65 744d 6574 6164 6174  e("PacketMetadat
-0000a3b0: 614e 6722 2c20 2023 2074 7970 653a 2069  aNg",  # type: i
-0000a3c0: 676e 6f72 650a 2020 2020 2020 2020 2020  gnore.          
-0000a3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3f0: 2020 5b22 6c69 6e6b 7479 7065 222c 2022    ["linktype", "
-0000a400: 7473 7265 736f 6c22 2c0a 2020 2020 2020  tsresol",.      
-0000a410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a430: 2020 2020 2020 2022 7473 6869 6768 222c         "tshigh",
-0000a440: 2022 7473 6c6f 7722 2c20 2277 6972 656c   "tslow", "wirel
-0000a450: 656e 222c 0a20 2020 2020 2020 2020 2020  en",.           
-0000a460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a480: 2020 2263 6f6d 6d65 6e74 225d 290a 0a20    "comment"]).. 
-0000a490: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-0000a4a0: 7365 6c66 2c20 6669 6c65 6e61 6d65 2c20  self, filename, 
-0000a4b0: 6664 6573 633d 4e6f 6e65 2c20 6d61 6769  fdesc=None, magi
-0000a4c0: 633d 4e6f 6e65 293a 2020 2320 7479 7065  c=None):  # type
-0000a4d0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
-0000a4e0: 2023 2074 7970 653a 2028 7374 722c 2049   # type: (str, I
-0000a4f0: 4f5b 6279 7465 735d 2c20 6279 7465 7329  O[bytes], bytes)
-0000a500: 202d 3e20 4e6f 6e65 0a20 2020 2020 2020   -> None.       
-0000a510: 2073 656c 662e 6669 6c65 6e61 6d65 203d   self.filename =
-0000a520: 2066 696c 656e 616d 650a 2020 2020 2020   filename.      
-0000a530: 2020 7365 6c66 2e66 203d 2066 6465 7363    self.f = fdesc
-0000a540: 0a20 2020 2020 2020 2023 2041 206c 6973  .        # A lis
-0000a550: 7420 6f66 2028 6c69 6e6b 7479 7065 2c20  t of (linktype, 
-0000a560: 736e 6170 6c65 6e2c 2074 7372 6573 6f6c  snaplen, tsresol
-0000a570: 293b 2077 696c 6c20 6265 2070 6f70 756c  ); will be popul
-0000a580: 6174 6564 2062 7920 4944 4273 2e0a 2020  ated by IDBs..  
-0000a590: 2020 2020 2020 7365 6c66 2e69 6e74 6572        self.inter
-0000a5a0: 6661 6365 7320 3d20 5b5d 2020 2320 7479  faces = []  # ty
-0000a5b0: 7065 3a20 4c69 7374 5b54 7570 6c65 5b69  pe: List[Tuple[i
-0000a5c0: 6e74 2c20 696e 742c 2069 6e74 5d5d 0a20  nt, int, int]]. 
-0000a5d0: 2020 2020 2020 2073 656c 662e 6465 6661         self.defa
-0000a5e0: 756c 745f 6f70 7469 6f6e 7320 3d20 7b0a  ult_options = {.
-0000a5f0: 2020 2020 2020 2020 2020 2020 2274 7372              "tsr
-0000a600: 6573 6f6c 223a 2031 3030 3030 3030 0a20  esol": 1000000. 
-0000a610: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000a620: 2073 656c 662e 626c 6f63 6b74 7970 6573   self.blocktypes
-0000a630: 203d 207b 0a20 2020 2020 2020 2020 2020   = {.           
-0000a640: 2031 3a20 7365 6c66 2e5f 7265 6164 5f62   1: self._read_b
-0000a650: 6c6f 636b 5f69 6462 2c0a 2020 2020 2020  lock_idb,.      
-0000a660: 2020 2020 2020 323a 2073 656c 662e 5f72        2: self._r
-0000a670: 6561 645f 626c 6f63 6b5f 706b 742c 0a20  ead_block_pkt,. 
-0000a680: 2020 2020 2020 2020 2020 2033 3a20 7365             3: se
-0000a690: 6c66 2e5f 7265 6164 5f62 6c6f 636b 5f73  lf._read_block_s
-0000a6a0: 7062 2c0a 2020 2020 2020 2020 2020 2020  pb,.            
-0000a6b0: 363a 2073 656c 662e 5f72 6561 645f 626c  6: self._read_bl
-0000a6c0: 6f63 6b5f 6570 622c 0a20 2020 2020 2020  ock_epb,.       
-0000a6d0: 2020 2020 2031 303a 2073 656c 662e 5f72       10: self._r
-0000a6e0: 6561 645f 626c 6f63 6b5f 6473 622c 0a20  ead_block_dsb,. 
-0000a6f0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000a700: 2073 656c 662e 656e 6469 616e 203d 2022   self.endian = "
-0000a710: 2122 2020 2320 5769 6c6c 2062 6520 6f76  !"  # Will be ov
-0000a720: 6572 7772 6974 7465 6e20 6279 2066 6972  erwritten by fir
-0000a730: 7374 2053 4842 0a0a 2020 2020 2020 2020  st SHB..        
-0000a740: 6966 206d 6167 6963 2021 3d20 6222 5c78  if magic != b"\x
-0000a750: 3061 5c78 3064 5c78 3064 5c78 3061 223a  0a\x0d\x0d\x0a":
-0000a760: 2020 2320 5063 6170 4e67 3a0a 2020 2020    # PcapNg:.    
-0000a770: 2020 2020 2020 2020 7261 6973 6520 5363          raise Sc
-0000a780: 6170 795f 4578 6365 7074 696f 6e28 0a20  apy_Exception(. 
-0000a790: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000a7a0: 4e6f 7420 6120 7063 6170 6e67 2063 6170  Not a pcapng cap
-0000a7b0: 7475 7265 2066 696c 6520 2862 6164 206d  ture file (bad m
-0000a7c0: 6167 6963 3a20 2572 2922 2025 206d 6167  agic: %r)" % mag
-0000a7d0: 6963 0a20 2020 2020 2020 2020 2020 2029  ic.            )
-0000a7e0: 0a0a 2020 2020 2020 2020 7472 793a 0a20  ..        try:. 
-0000a7f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000a800: 5f72 6561 645f 626c 6f63 6b5f 7368 6228  _read_block_shb(
-0000a810: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
-0000a820: 2045 4f46 4572 726f 723a 0a20 2020 2020   EOFError:.     
-0000a830: 2020 2020 2020 2072 6169 7365 2053 6361         raise Sca
-0000a840: 7079 5f45 7863 6570 7469 6f6e 280a 2020  py_Exception(.  
-0000a850: 2020 2020 2020 2020 2020 2020 2020 2254                "T
-0000a860: 6865 2066 6972 7374 2053 4842 206f 6620  he first SHB of 
-0000a870: 7468 6520 7063 6170 6e67 2066 696c 6520  the pcapng file 
-0000a880: 6973 206d 616c 666f 726d 6564 2021 220a  is malformed !".
-0000a890: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
-0000a8a0: 2020 2064 6566 205f 7265 6164 5f62 6c6f     def _read_blo
-0000a8b0: 636b 2873 656c 662c 2073 697a 653d 4d54  ck(self, size=MT
-0000a8c0: 5529 3a0a 2020 2020 2020 2020 2320 7479  U):.        # ty
-0000a8d0: 7065 3a20 2869 6e74 2920 2d3e 204f 7074  pe: (int) -> Opt
-0000a8e0: 696f 6e61 6c5b 5475 706c 655b 6279 7465  ional[Tuple[byte
-0000a8f0: 732c 2052 6177 5063 6170 4e67 5265 6164  s, RawPcapNgRead
-0000a900: 6572 2e50 6163 6b65 744d 6574 6164 6174  er.PacketMetadat
-0000a910: 615d 5d20 2023 206e 6f71 613a 2045 3530  a]]  # noqa: E50
-0000a920: 310a 2020 2020 2020 2020 7472 793a 0a20  1.        try:. 
-0000a930: 2020 2020 2020 2020 2020 2062 6c6f 636b             block
-0000a940: 7479 7065 203d 2073 7472 7563 742e 756e  type = struct.un
-0000a950: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-0000a960: 202b 2022 4922 2c20 7365 6c66 2e66 2e72   + "I", self.f.r
-0000a970: 6561 6428 3429 295b 305d 0a20 2020 2020  ead(4))[0].     
-0000a980: 2020 2065 7863 6570 7420 7374 7275 6374     except struct
-0000a990: 2e65 7272 6f72 3a0a 2020 2020 2020 2020  .error:.        
-0000a9a0: 2020 2020 7261 6973 6520 454f 4645 7272      raise EOFErr
-0000a9b0: 6f72 0a20 2020 2020 2020 2069 6620 626c  or.        if bl
-0000a9c0: 6f63 6b74 7970 6520 3d3d 2030 7830 4130  ocktype == 0x0A0
-0000a9d0: 4430 4430 413a 0a20 2020 2020 2020 2020  D0D0A:.         
-0000a9e0: 2020 2023 2054 6869 7320 6675 6e63 7469     # This functi
-0000a9f0: 6f6e 2075 7064 6174 6573 2074 6865 2065  on updates the e
-0000aa00: 6e64 6961 6e6e 6573 7320 6261 7365 6420  ndianness based 
-0000aa10: 6f6e 2074 6865 2062 6c6f 636b 2063 6f6e  on the block con
-0000aa20: 7465 6e74 2e0a 2020 2020 2020 2020 2020  tent..          
-0000aa30: 2020 7365 6c66 2e5f 7265 6164 5f62 6c6f    self._read_blo
-0000aa40: 636b 5f73 6862 2829 0a20 2020 2020 2020  ck_shb().       
-0000aa50: 2020 2020 2072 6574 7572 6e20 4e6f 6e65       return None
-0000aa60: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
-0000aa70: 2020 2020 2020 2020 2020 626c 6f63 6b6c            blockl
-0000aa80: 656e 203d 2073 7472 7563 742e 756e 7061  en = struct.unpa
-0000aa90: 636b 2873 656c 662e 656e 6469 616e 202b  ck(self.endian +
-0000aaa0: 2022 4922 2c20 7365 6c66 2e66 2e72 6561   "I", self.f.rea
-0000aab0: 6428 3429 295b 305d 0a20 2020 2020 2020  d(4))[0].       
-0000aac0: 2065 7863 6570 7420 7374 7275 6374 2e65   except struct.e
-0000aad0: 7272 6f72 3a0a 2020 2020 2020 2020 2020  rror:.          
-0000aae0: 2020 7261 6973 6520 454f 4645 7272 6f72    raise EOFError
-0000aaf0: 0a20 2020 2020 2020 2069 6620 626c 6f63  .        if bloc
-0000ab00: 6b6c 656e 203c 2031 323a 0a20 2020 2020  klen < 12:.     
-0000ab10: 2020 2020 2020 2077 6172 6e69 6e67 2822         warning("
-0000ab20: 496e 7661 6c69 6420 626c 6f63 6b20 6c65  Invalid block le
-0000ab30: 6e67 7468 2021 2229 0a20 2020 2020 2020  ngth !").       
-0000ab40: 2020 2020 2072 6169 7365 2045 4f46 4572       raise EOFEr
-0000ab50: 726f 720a 2020 2020 2020 2020 626c 6f63  ror.        bloc
-0000ab60: 6b20 3d20 7365 6c66 2e66 2e72 6561 6428  k = self.f.read(
-0000ab70: 626c 6f63 6b6c 656e 202d 2031 3229 0a20  blocklen - 12). 
-0000ab80: 2020 2020 2020 2073 656c 662e 5f72 6561         self._rea
-0000ab90: 645f 626c 6f63 6b5f 7461 696c 2862 6c6f  d_block_tail(blo
-0000aba0: 636b 6c65 6e29 0a20 2020 2020 2020 2072  cklen).        r
-0000abb0: 6574 7572 6e20 7365 6c66 2e62 6c6f 636b  eturn self.block
-0000abc0: 7479 7065 732e 6765 7428 0a20 2020 2020  types.get(.     
-0000abd0: 2020 2020 2020 2062 6c6f 636b 7479 7065         blocktype
-0000abe0: 2c0a 2020 2020 2020 2020 2020 2020 6c61  ,.            la
-0000abf0: 6d62 6461 2062 6c6f 636b 2c20 7369 7a65  mbda block, size
-0000ac00: 3a20 4e6f 6e65 0a20 2020 2020 2020 2029  : None.        )
-0000ac10: 2862 6c6f 636b 2c20 7369 7a65 290a 0a20  (block, size).. 
-0000ac20: 2020 2064 6566 205f 7265 6164 5f62 6c6f     def _read_blo
-0000ac30: 636b 5f74 6169 6c28 7365 6c66 2c20 626c  ck_tail(self, bl
-0000ac40: 6f63 6b6c 656e 293a 0a20 2020 2020 2020  ocklen):.       
-0000ac50: 2023 2074 7970 653a 2028 696e 7429 202d   # type: (int) -
-0000ac60: 3e20 4e6f 6e65 0a20 2020 2020 2020 2069  > None.        i
-0000ac70: 6620 626c 6f63 6b6c 656e 2025 2034 3a0a  f blocklen % 4:.
-0000ac80: 2020 2020 2020 2020 2020 2020 7061 6420              pad 
-0000ac90: 3d20 7365 6c66 2e66 2e72 6561 6428 2d62  = self.f.read(-b
-0000aca0: 6c6f 636b 6c65 6e20 2520 3429 0a20 2020  locklen % 4).   
-0000acb0: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
-0000acc0: 2822 5063 6170 4e67 3a20 6261 6420 626c  ("PcapNg: bad bl
-0000acd0: 6f63 6b6c 656e 2025 6420 284d 5553 5420  ocklen %d (MUST 
-0000ace0: 6265 2061 206d 756c 7469 706c 6520 6f66  be a multiple of
-0000acf0: 2034 2e20 220a 2020 2020 2020 2020 2020   4. ".          
-0000ad00: 2020 2020 2020 2020 2020 2249 676e 6f72            "Ignor
-0000ad10: 6564 2070 6164 6469 6e67 2025 7222 2025  ed padding %r" %
-0000ad20: 2028 626c 6f63 6b6c 656e 2c20 7061 6429   (blocklen, pad)
-0000ad30: 290a 2020 2020 2020 2020 7472 793a 0a20  ).        try:. 
-0000ad40: 2020 2020 2020 2020 2020 2069 6620 626c             if bl
-0000ad50: 6f63 6b6c 656e 2021 3d20 7374 7275 6374  ocklen != struct
-0000ad60: 2e75 6e70 6163 6b28 7365 6c66 2e65 6e64  .unpack(self.end
-0000ad70: 6961 6e20 2b20 2749 272c 0a20 2020 2020  ian + 'I',.     
-0000ad80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ada0: 2020 2020 7365 6c66 2e66 2e72 6561 6428      self.f.read(
-0000adb0: 3429 295b 305d 3a0a 2020 2020 2020 2020  4))[0]:.        
-0000adc0: 2020 2020 2020 2020 7261 6973 6520 454f          raise EO
-0000add0: 4645 7272 6f72 2822 5063 6170 4e67 3a20  FError("PcapNg: 
-0000ade0: 496e 7661 6c69 6420 7063 6170 6e67 2062  Invalid pcapng b
-0000adf0: 6c6f 636b 2028 6261 6420 626c 6f63 6b6c  lock (bad blockl
-0000ae00: 656e 2922 290a 2020 2020 2020 2020 6578  en)").        ex
-0000ae10: 6365 7074 2073 7472 7563 742e 6572 726f  cept struct.erro
-0000ae20: 723a 0a20 2020 2020 2020 2020 2020 2072  r:.            r
-0000ae30: 6169 7365 2045 4f46 4572 726f 720a 0a20  aise EOFError.. 
-0000ae40: 2020 2064 6566 205f 7265 6164 5f62 6c6f     def _read_blo
-0000ae50: 636b 5f73 6862 2873 656c 6629 3a0a 2020  ck_shb(self):.  
-0000ae60: 2020 2020 2020 2320 7479 7065 3a20 2829        # type: ()
-0000ae70: 202d 3e20 4e6f 6e65 0a20 2020 2020 2020   -> None.       
-0000ae80: 205f 626c 6f63 6b6c 656e 203d 2073 656c   _blocklen = sel
-0000ae90: 662e 662e 7265 6164 2834 290a 2020 2020  f.f.read(4).    
-0000aea0: 2020 2020 656e 6469 616e 203d 2073 656c      endian = sel
-0000aeb0: 662e 662e 7265 6164 2834 290a 2020 2020  f.f.read(4).    
-0000aec0: 2020 2020 6966 2065 6e64 6961 6e20 3d3d      if endian ==
-0000aed0: 2062 225c 7831 615c 7832 625c 7833 635c   b"\x1a\x2b\x3c\
-0000aee0: 7834 6422 3a0a 2020 2020 2020 2020 2020  x4d":.          
-0000aef0: 2020 7365 6c66 2e65 6e64 6961 6e20 3d20    self.endian = 
-0000af00: 223e 220a 2020 2020 2020 2020 656c 6966  ">".        elif
-0000af10: 2065 6e64 6961 6e20 3d3d 2062 225c 7834   endian == b"\x4
-0000af20: 645c 7833 635c 7832 625c 7831 6122 3a0a  d\x3c\x2b\x1a":.
-0000af30: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000af40: 2e65 6e64 6961 6e20 3d20 223c 220a 2020  .endian = "<".  
-0000af50: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000af60: 2020 2020 2020 2020 7761 726e 696e 6728          warning(
-0000af70: 2242 6164 206d 6167 6963 2069 6e20 5365  "Bad magic in Se
-0000af80: 6374 696f 6e20 4865 6164 6572 2062 6c6f  ction Header blo
-0000af90: 636b 2028 6e6f 7420 6120 7063 6170 6e67  ck (not a pcapng
-0000afa0: 2066 696c 653f 2922 290a 2020 2020 2020   file?)").      
-0000afb0: 2020 2020 2020 7261 6973 6520 454f 4645        raise EOFE
-0000afc0: 7272 6f72 0a0a 2020 2020 2020 2020 626c  rror..        bl
-0000afd0: 6f63 6b6c 656e 203d 2073 7472 7563 742e  ocklen = struct.
-0000afe0: 756e 7061 636b 2873 656c 662e 656e 6469  unpack(self.endi
-0000aff0: 616e 202b 2022 4922 2c20 5f62 6c6f 636b  an + "I", _block
-0000b000: 6c65 6e29 5b30 5d0a 2020 2020 2020 2020  len)[0].        
-0000b010: 6966 2062 6c6f 636b 6c65 6e20 3c20 3136  if blocklen < 16
-0000b020: 3a0a 2020 2020 2020 2020 2020 2020 7761  :.            wa
-0000b030: 726e 696e 6728 2249 6e76 616c 6964 2053  rning("Invalid S
-0000b040: 4842 2062 6c6f 636b 206c 656e 6774 6821  HB block length!
-0000b050: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
-0000b060: 6169 7365 2045 4f46 4572 726f 720a 2020  aise EOFError.  
-0000b070: 2020 2020 2020 6f70 7469 6f6e 7320 3d20        options = 
-0000b080: 7365 6c66 2e66 2e72 6561 6428 626c 6f63  self.f.read(bloc
-0000b090: 6b6c 656e 202d 2031 3629 0a20 2020 2020  klen - 16).     
-0000b0a0: 2020 2073 656c 662e 5f72 6561 645f 626c     self._read_bl
-0000b0b0: 6f63 6b5f 7461 696c 2862 6c6f 636b 6c65  ock_tail(blockle
-0000b0c0: 6e29 0a20 2020 2020 2020 2073 656c 662e  n).        self.
-0000b0d0: 5f72 6561 645f 6f70 7469 6f6e 7328 6f70  _read_options(op
-0000b0e0: 7469 6f6e 7329 0a0a 2020 2020 6465 6620  tions)..    def 
-0000b0f0: 5f72 6561 645f 7061 636b 6574 2873 656c  _read_packet(sel
-0000b100: 662c 2073 697a 653d 4d54 5529 3a20 2023  f, size=MTU):  #
-0000b110: 2074 7970 653a 2069 676e 6f72 650a 2020   type: ignore.  
-0000b120: 2020 2020 2020 2320 7479 7065 3a20 2869        # type: (i
-0000b130: 6e74 2920 2d3e 2054 7570 6c65 5b62 7974  nt) -> Tuple[byt
-0000b140: 6573 2c20 5261 7750 6361 704e 6752 6561  es, RawPcapNgRea
-0000b150: 6465 722e 5061 636b 6574 4d65 7461 6461  der.PacketMetada
-0000b160: 7461 5d0a 2020 2020 2020 2020 2222 2252  ta].        """R
-0000b170: 6561 6420 626c 6f63 6b73 2075 6e74 696c  ead blocks until
-0000b180: 2069 7420 7265 6163 6865 7320 6569 7468   it reaches eith
-0000b190: 6572 2045 4f46 206f 7220 6120 7061 636b  er EOF or a pack
-0000b1a0: 6574 2c20 616e 640a 2020 2020 2020 2020  et, and.        
-0000b1b0: 7265 7475 726e 7320 4e6f 6e65 206f 7220  returns None or 
-0000b1c0: 2870 6163 6b65 742c 2028 6c69 6e6b 7479  (packet, (linkty
-0000b1d0: 7065 2c20 7365 632c 2075 7365 632c 2077  pe, sec, usec, w
-0000b1e0: 6972 656c 656e 2929 2c0a 2020 2020 2020  irelen)),.      
-0000b1f0: 2020 7768 6572 6520 7061 636b 6574 2069    where packet i
-0000b200: 7320 6120 7374 7269 6e67 2e0a 0a20 2020  s a string...   
-0000b210: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000b220: 2077 6869 6c65 2054 7275 653a 0a20 2020   while True:.   
-0000b230: 2020 2020 2020 2020 2072 6573 203d 2073           res = s
-0000b240: 656c 662e 5f72 6561 645f 626c 6f63 6b28  elf._read_block(
-0000b250: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-0000b260: 2072 6573 2069 7320 6e6f 7420 4e6f 6e65   res is not None
-0000b270: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000b280: 2020 7265 7475 726e 2072 6573 0a0a 2020    return res..  
-0000b290: 2020 6465 6620 5f72 6561 645f 6f70 7469    def _read_opti
-0000b2a0: 6f6e 7328 7365 6c66 2c20 6f70 7469 6f6e  ons(self, option
-0000b2b0: 7329 3a0a 2020 2020 2020 2020 2320 7479  s):.        # ty
-0000b2c0: 7065 3a20 2862 7974 6573 2920 2d3e 2044  pe: (bytes) -> D
-0000b2d0: 6963 745b 7374 722c 2041 6e79 5d0a 2020  ict[str, Any].  
-0000b2e0: 2020 2020 2020 2222 2253 6563 7469 6f6e        """Section
-0000b2f0: 2048 6561 6465 7220 426c 6f63 6b22 2222   Header Block"""
-0000b300: 0a20 2020 2020 2020 206f 7074 7320 3d20  .        opts = 
-0000b310: 7365 6c66 2e64 6566 6175 6c74 5f6f 7074  self.default_opt
-0000b320: 696f 6e73 2e63 6f70 7928 2920 2023 2074  ions.copy()  # t
-0000b330: 7970 653a 2044 6963 745b 7374 722c 2041  ype: Dict[str, A
-0000b340: 6e79 5d0a 2020 2020 2020 2020 7768 696c  ny].        whil
-0000b350: 6520 6c65 6e28 6f70 7469 6f6e 7329 203e  e len(options) >
-0000b360: 3d20 343a 0a20 2020 2020 2020 2020 2020  = 4:.           
-0000b370: 2063 6f64 652c 206c 656e 6774 6820 3d20   code, length = 
-0000b380: 7374 7275 6374 2e75 6e70 6163 6b28 7365  struct.unpack(se
-0000b390: 6c66 2e65 6e64 6961 6e20 2b20 2248 4822  lf.endian + "HH"
-0000b3a0: 2c20 6f70 7469 6f6e 735b 3a34 5d29 0a20  , options[:4]). 
-0000b3b0: 2020 2020 2020 2020 2020 2023 2050 4341             # PCA
-0000b3c0: 5020 4e65 7874 2047 656e 6572 6174 696f  P Next Generatio
-0000b3d0: 6e20 2870 6361 706e 6729 2043 6170 7475  n (pcapng) Captu
-0000b3e0: 7265 2046 696c 6520 466f 726d 6174 0a20  re File Format. 
-0000b3f0: 2020 2020 2020 2020 2020 2023 2034 2e32             # 4.2
-0000b400: 2e20 2d20 496e 7465 7266 6163 6520 4465  . - Interface De
-0000b410: 7363 7269 7074 696f 6e20 426c 6f63 6b0a  scription Block.
-0000b420: 2020 2020 2020 2020 2020 2020 2320 6874              # ht
-0000b430: 7470 3a2f 2f78 6d6c 3272 6663 2e74 6f6f  tp://xml2rfc.too
-0000b440: 6c73 2e69 6574 662e 6f72 672f 6367 692d  ls.ietf.org/cgi-
-0000b450: 6269 6e2f 786d 6c32 7266 632e 6367 693f  bin/xml2rfc.cgi?
-0000b460: 7572 6c3d 6874 7470 733a 2f2f 7261 772e  url=https://raw.
-0000b470: 6769 7468 7562 7573 6572 636f 6e74 656e  githubuserconten
-0000b480: 742e 636f 6d2f 7063 6170 6e67 2f70 6361  t.com/pcapng/pca
-0000b490: 706e 672f 6d61 7374 6572 2f64 7261 6674  png/master/draft
-0000b4a0: 2d74 7565 7865 6e2d 6f70 7361 7767 2d70  -tuexen-opsawg-p
-0000b4b0: 6361 706e 672e 786d 6c26 6d6f 6465 4173  capng.xml&modeAs
-0000b4c0: 466f 726d 6174 3d68 746d 6c2f 6173 6369  Format=html/asci
-0000b4d0: 6926 7479 7065 3d61 7363 6969 2372 6663  i&type=ascii#rfc
-0000b4e0: 2e73 6563 7469 6f6e 2e34 2e32 0a20 2020  .section.4.2.   
-0000b4f0: 2020 2020 2020 2020 2069 6620 636f 6465           if code
-0000b500: 203d 3d20 3920 616e 6420 6c65 6e67 7468   == 9 and length
-0000b510: 203d 3d20 3120 616e 6420 6c65 6e28 6f70   == 1 and len(op
-0000b520: 7469 6f6e 7329 203e 3d20 353a 0a20 2020  tions) >= 5:.   
-0000b530: 2020 2020 2020 2020 2020 2020 2074 7372               tsr
-0000b540: 6573 6f6c 203d 206f 7262 286f 7074 696f  esol = orb(optio
-0000b550: 6e73 5b34 5d29 0a20 2020 2020 2020 2020  ns[4]).         
-0000b560: 2020 2020 2020 206f 7074 735b 2274 7372         opts["tsr
-0000b570: 6573 6f6c 225d 203d 2028 3220 6966 2074  esol"] = (2 if t
-0000b580: 7372 6573 6f6c 2026 2031 3238 2065 6c73  sresol & 128 els
-0000b590: 6520 3130 2920 2a2a 2028 0a20 2020 2020  e 10) ** (.     
-0000b5a0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000b5b0: 7372 6573 6f6c 2026 2031 3237 0a20 2020  sresol & 127.   
-0000b5c0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
-0000b5d0: 2020 2020 2020 2020 2020 2069 6620 636f             if co
-0000b5e0: 6465 203d 3d20 3120 616e 6420 6c65 6e67  de == 1 and leng
-0000b5f0: 7468 203e 3d20 3120 616e 6420 3420 2b20  th >= 1 and 4 + 
-0000b600: 6c65 6e67 7468 203c 206c 656e 286f 7074  length < len(opt
-0000b610: 696f 6e73 293a 0a20 2020 2020 2020 2020  ions):.         
-0000b620: 2020 2020 2020 2063 6f6d 6d65 6e74 203d         comment =
-0000b630: 206f 7074 696f 6e73 5b34 3a34 202b 206c   options[4:4 + l
-0000b640: 656e 6774 685d 0a20 2020 2020 2020 2020  ength].         
-0000b650: 2020 2020 2020 206e 6577 6c69 6e65 5f69         newline_i
-0000b660: 6e64 6578 203d 2063 6f6d 6d65 6e74 2e66  ndex = comment.f
-0000b670: 696e 6428 6222 5c6e 2229 0a20 2020 2020  ind(b"\n").     
-0000b680: 2020 2020 2020 2020 2020 2069 6620 6e65             if ne
-0000b690: 776c 696e 655f 696e 6465 7820 3d3d 202d  wline_index == -
-0000b6a0: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
-0000b6b0: 2020 2020 2020 2077 6172 6e69 6e67 2822         warning("
-0000b6c0: 5063 6170 4e67 3a20 696e 7661 6c69 6420  PcapNg: invalid 
-0000b6d0: 636f 6d6d 656e 7420 6f70 7469 6f6e 2229  comment option")
-0000b6e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b6f0: 2020 2020 2062 7265 616b 0a20 2020 2020       break.     
-0000b700: 2020 2020 2020 2020 2020 206f 7074 735b             opts[
-0000b710: 2263 6f6d 6d65 6e74 225d 203d 2063 6f6d  "comment"] = com
-0000b720: 6d65 6e74 5b3a 6e65 776c 696e 655f 696e  ment[:newline_in
-0000b730: 6465 785d 0a20 2020 2020 2020 2020 2020  dex].           
-0000b740: 2069 6620 636f 6465 203d 3d20 303a 0a20   if code == 0:. 
-0000b750: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000b760: 6620 6c65 6e67 7468 2021 3d20 303a 0a20  f length != 0:. 
-0000b770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b780: 2020 2077 6172 6e69 6e67 2822 5063 6170     warning("Pcap
-0000b790: 4e67 3a20 696e 7661 6c69 6420 6f70 7469  Ng: invalid opti
-0000b7a0: 6f6e 206c 656e 6774 6820 2564 2066 6f72  on length %d for
-0000b7b0: 2065 6e64 2d6f 662d 6f70 7469 6f6e 2220   end-of-option" 
-0000b7c0: 2520 6c65 6e67 7468 2920 2023 206e 6f71  % length)  # noq
-0000b7d0: 613a 2045 3530 310a 2020 2020 2020 2020  a: E501.        
-0000b7e0: 2020 2020 2020 2020 6272 6561 6b0a 2020          break.  
-0000b7f0: 2020 2020 2020 2020 2020 6966 206c 656e            if len
-0000b800: 6774 6820 2520 343a 0a20 2020 2020 2020  gth % 4:.       
-0000b810: 2020 2020 2020 2020 206c 656e 6774 6820           length 
-0000b820: 2b3d 2028 3420 2d20 286c 656e 6774 6820  += (4 - (length 
-0000b830: 2520 3429 290a 2020 2020 2020 2020 2020  % 4)).          
-0000b840: 2020 6f70 7469 6f6e 7320 3d20 6f70 7469    options = opti
-0000b850: 6f6e 735b 3420 2b20 6c65 6e67 7468 3a5d  ons[4 + length:]
-0000b860: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000b870: 6f70 7473 0a0a 2020 2020 6465 6620 5f72  opts..    def _r
-0000b880: 6561 645f 626c 6f63 6b5f 6964 6228 7365  ead_block_idb(se
-0000b890: 6c66 2c20 626c 6f63 6b2c 205f 293a 0a20  lf, block, _):. 
-0000b8a0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-0000b8b0: 6279 7465 732c 2069 6e74 2920 2d3e 204e  bytes, int) -> N
-0000b8c0: 6f6e 650a 2020 2020 2020 2020 2222 2249  one.        """I
-0000b8d0: 6e74 6572 6661 6365 2044 6573 6372 6970  nterface Descrip
-0000b8e0: 7469 6f6e 2042 6c6f 636b 2222 220a 2020  tion Block""".  
-0000b8f0: 2020 2020 2020 2320 3220 6279 7465 7320        # 2 bytes 
-0000b900: 4c69 6e6b 5479 7065 202b 2032 2062 7974  LinkType + 2 byt
-0000b910: 6573 2052 6573 6572 7665 640a 2020 2020  es Reserved.    
-0000b920: 2020 2020 2320 3420 6279 7465 7320 536e      # 4 bytes Sn
-0000b930: 6170 6c65 6e0a 2020 2020 2020 2020 6f70  aplen.        op
-0000b940: 7469 6f6e 7320 3d20 7365 6c66 2e5f 7265  tions = self._re
-0000b950: 6164 5f6f 7074 696f 6e73 2862 6c6f 636b  ad_options(block
-0000b960: 5b38 3a2d 345d 290a 2020 2020 2020 2020  [8:-4]).        
-0000b970: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-0000b980: 2069 6e74 6572 6661 6365 203d 2073 7472   interface = str
-0000b990: 7563 742e 756e 7061 636b 2820 2023 2074  uct.unpack(  # t
-0000b9a0: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
-0000b9b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000b9c0: 2e65 6e64 6961 6e20 2b20 2248 7878 4922  .endian + "HxxI"
-0000b9d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000b9e0: 2020 626c 6f63 6b5b 3a38 5d0a 2020 2020    block[:8].    
-0000b9f0: 2020 2020 2020 2020 2920 2b20 286f 7074          ) + (opt
-0000ba00: 696f 6e73 5b22 7473 7265 736f 6c22 5d2c  ions["tsresol"],
-0000ba10: 2920 2023 2074 7970 653a 2054 7570 6c65  )  # type: Tuple
-0000ba20: 5b69 6e74 2c20 696e 742c 2069 6e74 5d0a  [int, int, int].
-0000ba30: 2020 2020 2020 2020 6578 6365 7074 2073          except s
-0000ba40: 7472 7563 742e 6572 726f 723a 0a20 2020  truct.error:.   
-0000ba50: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
-0000ba60: 2822 5063 6170 4e67 3a20 4944 4220 6973  ("PcapNg: IDB is
-0000ba70: 2074 6f6f 2073 6d61 6c6c 2025 642f 3820   too small %d/8 
-0000ba80: 2122 2025 206c 656e 2862 6c6f 636b 2929  !" % len(block))
-0000ba90: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-0000baa0: 7365 2045 4f46 4572 726f 720a 2020 2020  se EOFError.    
-0000bab0: 2020 2020 7365 6c66 2e69 6e74 6572 6661      self.interfa
-0000bac0: 6365 732e 6170 7065 6e64 2869 6e74 6572  ces.append(inter
-0000bad0: 6661 6365 290a 0a20 2020 2064 6566 205f  face)..    def _
-0000bae0: 6368 6563 6b5f 696e 7465 7266 6163 655f  check_interface_
-0000baf0: 6964 2873 656c 662c 2069 6e74 6964 293a  id(self, intid):
-0000bb00: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-0000bb10: 2028 696e 7429 202d 3e20 4e6f 6e65 0a20   (int) -> None. 
-0000bb20: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
-0000bb30: 7468 6520 696e 7465 7266 6163 6520 6964  the interface id
-0000bb40: 2076 616c 7565 2061 6e64 2072 6169 7365   value and raise
-0000bb50: 2045 4f46 4572 726f 7220 6966 2069 6e76   EOFError if inv
-0000bb60: 616c 6964 2e22 2222 0a20 2020 2020 2020  alid.""".       
-0000bb70: 2074 6d70 5f6c 656e 203d 206c 656e 2873   tmp_len = len(s
-0000bb80: 656c 662e 696e 7465 7266 6163 6573 290a  elf.interfaces).
-0000bb90: 2020 2020 2020 2020 6966 2069 6e74 6964          if intid
-0000bba0: 203e 3d20 746d 705f 6c65 6e3a 0a20 2020   >= tmp_len:.   
-0000bbb0: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
-0000bbc0: 2822 5063 6170 4e67 3a20 696e 7661 6c69  ("PcapNg: invali
-0000bbd0: 6420 696e 7465 7266 6163 6520 6964 2025  d interface id %
-0000bbe0: 642f 2564 2220 2520 2869 6e74 6964 2c20  d/%d" % (intid, 
-0000bbf0: 746d 705f 6c65 6e29 290a 2020 2020 2020  tmp_len)).      
-0000bc00: 2020 2020 2020 7261 6973 6520 454f 4645        raise EOFE
-0000bc10: 7272 6f72 0a0a 2020 2020 6465 6620 5f72  rror..    def _r
-0000bc20: 6561 645f 626c 6f63 6b5f 6570 6228 7365  ead_block_epb(se
-0000bc30: 6c66 2c20 626c 6f63 6b2c 2073 697a 6529  lf, block, size)
-0000bc40: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-0000bc50: 3a20 2862 7974 6573 2c20 696e 7429 202d  : (bytes, int) -
-0000bc60: 3e20 5475 706c 655b 6279 7465 732c 2052  > Tuple[bytes, R
-0000bc70: 6177 5063 6170 4e67 5265 6164 6572 2e50  awPcapNgReader.P
-0000bc80: 6163 6b65 744d 6574 6164 6174 615d 0a20  acketMetadata]. 
-0000bc90: 2020 2020 2020 2022 2222 456e 6861 6e63         """Enhanc
-0000bca0: 6564 2050 6163 6b65 7420 426c 6f63 6b22  ed Packet Block"
-0000bcb0: 2222 0a20 2020 2020 2020 2074 7279 3a0a  "".        try:.
-0000bcc0: 2020 2020 2020 2020 2020 2020 696e 7469              inti
-0000bcd0: 642c 2074 7368 6967 682c 2074 736c 6f77  d, tshigh, tslow
-0000bce0: 2c20 6361 706c 656e 2c20 7769 7265 6c65  , caplen, wirele
-0000bcf0: 6e20 3d20 7374 7275 6374 2e75 6e70 6163  n = struct.unpac
-0000bd00: 6b28 0a20 2020 2020 2020 2020 2020 2020  k(.             
-0000bd10: 2020 2073 656c 662e 656e 6469 616e 202b     self.endian +
-0000bd20: 2022 3549 222c 0a20 2020 2020 2020 2020   "5I",.         
-0000bd30: 2020 2020 2020 2062 6c6f 636b 5b3a 3230         block[:20
-0000bd40: 5d2c 0a20 2020 2020 2020 2020 2020 2029  ],.            )
-0000bd50: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-0000bd60: 7374 7275 6374 2e65 7272 6f72 3a0a 2020  struct.error:.  
-0000bd70: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
-0000bd80: 6728 2250 6361 704e 673a 2045 5042 2069  g("PcapNg: EPB i
-0000bd90: 7320 746f 6f20 736d 616c 6c20 2564 2f32  s too small %d/2
-0000bda0: 3020 2122 2025 206c 656e 2862 6c6f 636b  0 !" % len(block
-0000bdb0: 2929 0a20 2020 2020 2020 2020 2020 2072  )).            r
-0000bdc0: 6169 7365 2045 4f46 4572 726f 720a 0a20  aise EOFError.. 
-0000bdd0: 2020 2020 2020 2023 2043 6f6d 7075 7465         # Compute
-0000bde0: 2074 6865 206f 7074 696f 6e73 206f 6666   the options off
-0000bdf0: 7365 7420 7461 6b69 6e67 2070 6164 6469  set taking paddi
-0000be00: 6e67 2069 6e74 6f20 6163 636f 756e 740a  ng into account.
-0000be10: 2020 2020 2020 2020 6966 2063 6170 6c65          if caple
-0000be20: 6e20 2520 343a 0a20 2020 2020 2020 2020  n % 4:.         
-0000be30: 2020 206f 7074 5f6f 6666 7365 7420 3d20     opt_offset = 
-0000be40: 3230 202b 2063 6170 6c65 6e20 2b20 282d  20 + caplen + (-
-0000be50: 6361 706c 656e 2920 2520 340a 2020 2020  caplen) % 4.    
-0000be60: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000be70: 2020 2020 2020 6f70 745f 6f66 6673 6574        opt_offset
-0000be80: 203d 2032 3020 2b20 6361 706c 656e 0a0a   = 20 + caplen..
-0000be90: 2020 2020 2020 2020 2320 5061 7273 6520          # Parse 
-0000bea0: 6f70 7469 6f6e 730a 2020 2020 2020 2020  options.        
-0000beb0: 6f70 7469 6f6e 7320 3d20 7365 6c66 2e5f  options = self._
-0000bec0: 7265 6164 5f6f 7074 696f 6e73 2862 6c6f  read_options(blo
-0000bed0: 636b 5b6f 7074 5f6f 6666 7365 743a 5d29  ck[opt_offset:])
-0000bee0: 0a20 2020 2020 2020 2063 6f6d 6d65 6e74  .        comment
-0000bef0: 203d 206f 7074 696f 6e73 2e67 6574 2822   = options.get("
-0000bf00: 636f 6d6d 656e 7422 2c20 4e6f 6e65 290a  comment", None).
-0000bf10: 0a20 2020 2020 2020 2073 656c 662e 5f63  .        self._c
-0000bf20: 6865 636b 5f69 6e74 6572 6661 6365 5f69  heck_interface_i
-0000bf30: 6428 696e 7469 6429 0a0a 2020 2020 2020  d(intid)..      
-0000bf40: 2020 7265 7475 726e 2028 626c 6f63 6b5b    return (block[
-0000bf50: 3230 3a32 3020 2b20 6361 706c 656e 5d5b  20:20 + caplen][
-0000bf60: 3a73 697a 655d 2c0a 2020 2020 2020 2020  :size],.        
-0000bf70: 2020 2020 2020 2020 5261 7750 6361 704e          RawPcapN
-0000bf80: 6752 6561 6465 722e 5061 636b 6574 4d65  gReader.PacketMe
-0000bf90: 7461 6461 7461 286c 696e 6b74 7970 653d  tadata(linktype=
-0000bfa0: 7365 6c66 2e69 6e74 6572 6661 6365 735b  self.interfaces[
-0000bfb0: 696e 7469 645d 5b30 5d2c 2020 2320 6e6f  intid][0],  # no
-0000bfc0: 7161 3a20 4535 3031 0a20 2020 2020 2020  qa: E501.       
-0000bfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bff0: 2020 2020 2020 2020 7473 7265 736f 6c3d          tsresol=
-0000c000: 7365 6c66 2e69 6e74 6572 6661 6365 735b  self.interfaces[
-0000c010: 696e 7469 645d 5b32 5d2c 2020 2320 6e6f  intid][2],  # no
-0000c020: 7161 3a20 4535 3031 0a20 2020 2020 2020  qa: E501.       
-0000c030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c050: 2020 2020 2020 2020 7473 6869 6768 3d74          tshigh=t
-0000c060: 7368 6967 682c 0a20 2020 2020 2020 2020  shigh,.         
-0000c070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c090: 2020 2020 2020 7473 6c6f 773d 7473 6c6f        tslow=tslo
-0000c0a0: 772c 0a20 2020 2020 2020 2020 2020 2020  w,.             
-0000c0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c0d0: 2020 7769 7265 6c65 6e3d 7769 7265 6c65    wirelen=wirele
-0000c0e0: 6e2c 0a20 2020 2020 2020 2020 2020 2020  n,.             
-0000c0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c110: 2020 636f 6d6d 656e 743d 636f 6d6d 656e    comment=commen
-0000c120: 7429 290a 0a20 2020 2064 6566 205f 7265  t))..    def _re
-0000c130: 6164 5f62 6c6f 636b 5f73 7062 2873 656c  ad_block_spb(sel
-0000c140: 662c 2062 6c6f 636b 2c20 7369 7a65 293a  f, block, size):
-0000c150: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-0000c160: 2028 6279 7465 732c 2069 6e74 2920 2d3e   (bytes, int) ->
-0000c170: 2054 7570 6c65 5b62 7974 6573 2c20 5261   Tuple[bytes, Ra
-0000c180: 7750 6361 704e 6752 6561 6465 722e 5061  wPcapNgReader.Pa
-0000c190: 636b 6574 4d65 7461 6461 7461 5d0a 2020  cketMetadata].  
-0000c1a0: 2020 2020 2020 2222 2253 696d 706c 6520        """Simple 
-0000c1b0: 5061 636b 6574 2042 6c6f 636b 2222 220a  Packet Block""".
-0000c1c0: 2020 2020 2020 2020 2320 2269 7420 4d55          # "it MU
-0000c1d0: 5354 2062 6520 6173 7375 6d65 6420 7468  ST be assumed th
-0000c1e0: 6174 2061 6c6c 2074 6865 2053 696d 706c  at all the Simpl
-0000c1f0: 6520 5061 636b 6574 2042 6c6f 636b 7320  e Packet Blocks 
-0000c200: 6861 7665 0a20 2020 2020 2020 2023 2062  have.        # b
-0000c210: 6565 6e20 6361 7074 7572 6564 206f 6e20  een captured on 
-0000c220: 7468 6520 696e 7465 7266 6163 6520 7072  the interface pr
-0000c230: 6576 696f 7573 6c79 2073 7065 6369 6669  eviously specifi
-0000c240: 6564 2069 6e20 7468 650a 2020 2020 2020  ed in the.      
-0000c250: 2020 2320 6669 7273 7420 496e 7465 7266    # first Interf
-0000c260: 6163 6520 4465 7363 7269 7074 696f 6e20  ace Description 
-0000c270: 426c 6f63 6b2e 220a 2020 2020 2020 2020  Block.".        
-0000c280: 696e 7469 6420 3d20 300a 2020 2020 2020  intid = 0.      
-0000c290: 2020 7365 6c66 2e5f 6368 6563 6b5f 696e    self._check_in
-0000c2a0: 7465 7266 6163 655f 6964 2869 6e74 6964  terface_id(intid
-0000c2b0: 290a 0a20 2020 2020 2020 2074 7279 3a0a  )..        try:.
-0000c2c0: 2020 2020 2020 2020 2020 2020 7769 7265              wire
-0000c2d0: 6c65 6e2c 203d 2073 7472 7563 742e 756e  len, = struct.un
-0000c2e0: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-0000c2f0: 202b 2022 4922 2c20 626c 6f63 6b5b 3a34   + "I", block[:4
-0000c300: 5d29 0a20 2020 2020 2020 2065 7863 6570  ]).        excep
-0000c310: 7420 7374 7275 6374 2e65 7272 6f72 3a0a  t struct.error:.
-0000c320: 2020 2020 2020 2020 2020 2020 7761 726e              warn
-0000c330: 696e 6728 2250 6361 704e 673a 2053 5042  ing("PcapNg: SPB
-0000c340: 2069 7320 746f 6f20 736d 616c 6c20 2564   is too small %d
-0000c350: 2f34 2021 2220 2520 6c65 6e28 626c 6f63  /4 !" % len(bloc
-0000c360: 6b29 290a 2020 2020 2020 2020 2020 2020  k)).            
-0000c370: 7261 6973 6520 454f 4645 7272 6f72 0a0a  raise EOFError..
-0000c380: 2020 2020 2020 2020 6361 706c 656e 203d          caplen =
-0000c390: 206d 696e 2877 6972 656c 656e 2c20 7365   min(wirelen, se
-0000c3a0: 6c66 2e69 6e74 6572 6661 6365 735b 696e  lf.interfaces[in
-0000c3b0: 7469 645d 5b31 5d29 0a20 2020 2020 2020  tid][1]).       
-0000c3c0: 2072 6574 7572 6e20 2862 6c6f 636b 5b34   return (block[4
-0000c3d0: 3a34 202b 2063 6170 6c65 6e5d 5b3a 7369  :4 + caplen][:si
-0000c3e0: 7a65 5d2c 0a20 2020 2020 2020 2020 2020  ze],.           
-0000c3f0: 2020 2020 2052 6177 5063 6170 4e67 5265       RawPcapNgRe
-0000c400: 6164 6572 2e50 6163 6b65 744d 6574 6164  ader.PacketMetad
-0000c410: 6174 6128 6c69 6e6b 7479 7065 3d73 656c  ata(linktype=sel
-0000c420: 662e 696e 7465 7266 6163 6573 5b69 6e74  f.interfaces[int
-0000c430: 6964 5d5b 305d 2c20 2023 206e 6f71 613a  id][0],  # noqa:
-0000c440: 2045 3530 310a 2020 2020 2020 2020 2020   E501.          
-0000c450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c470: 2020 2020 2074 7372 6573 6f6c 3d73 656c       tsresol=sel
-0000c480: 662e 696e 7465 7266 6163 6573 5b69 6e74  f.interfaces[int
-0000c490: 6964 5d5b 325d 2c20 2023 206e 6f71 613a  id][2],  # noqa:
-0000c4a0: 2045 3530 310a 2020 2020 2020 2020 2020   E501.          
-0000c4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c4d0: 2020 2020 2074 7368 6967 683d 4e6f 6e65       tshigh=None
-0000c4e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009d70: 3e20 5261 7750 6361 7052 6561 6465 720a  > RawPcapReader.
+00009d80: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00009d90: 656c 660a 0a20 2020 2064 6566 205f 5f6e  elf..    def __n
+00009da0: 6578 745f 5f28 7365 6c66 293a 0a20 2020  ext__(self):.   
+00009db0: 2020 2020 2023 2074 7970 653a 2028 2920       # type: () 
+00009dc0: 2d3e 2054 7570 6c65 5b62 7974 6573 2c20  -> Tuple[bytes, 
+00009dd0: 5261 7750 6361 7052 6561 6465 722e 5061  RawPcapReader.Pa
+00009de0: 636b 6574 4d65 7461 6461 7461 5d0a 2020  cketMetadata].  
+00009df0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00009e00: 2020 696d 706c 656d 656e 7420 7468 6520    implement the 
+00009e10: 6974 6572 6174 6f72 2070 726f 746f 636f  iterator protoco
+00009e20: 6c20 6f6e 2061 2073 6574 206f 6620 7061  l on a set of pa
+00009e30: 636b 6574 7320 696e 2061 2070 6361 7020  ckets in a pcap 
+00009e40: 6669 6c65 0a20 2020 2020 2020 2022 2222  file.        """
+00009e50: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
+00009e60: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00009e70: 2073 656c 662e 5f72 6561 645f 7061 636b   self._read_pack
+00009e80: 6574 2829 0a20 2020 2020 2020 2065 7863  et().        exc
+00009e90: 6570 7420 454f 4645 7272 6f72 3a0a 2020  ept EOFError:.  
+00009ea0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00009eb0: 5374 6f70 4974 6572 6174 696f 6e0a 0a20  StopIteration.. 
+00009ec0: 2020 2064 6566 205f 7265 6164 5f70 6163     def _read_pac
+00009ed0: 6b65 7428 7365 6c66 2c20 7369 7a65 3d4d  ket(self, size=M
+00009ee0: 5455 293a 0a20 2020 2020 2020 2023 2074  TU):.        # t
+00009ef0: 7970 653a 2028 696e 7429 202d 3e20 5475  ype: (int) -> Tu
+00009f00: 706c 655b 6279 7465 732c 2052 6177 5063  ple[bytes, RawPc
+00009f10: 6170 5265 6164 6572 2e50 6163 6b65 744d  apReader.PacketM
+00009f20: 6574 6164 6174 615d 0a20 2020 2020 2020  etadata].       
+00009f30: 2022 2222 7265 7475 726e 2061 2073 696e   """return a sin
+00009f40: 676c 6520 7061 636b 6574 2072 6561 6420  gle packet read 
+00009f50: 6672 6f6d 2074 6865 2066 696c 6520 6173  from the file as
+00009f60: 2061 2074 7570 6c65 2063 6f6e 7461 696e   a tuple contain
+00009f70: 696e 670a 2020 2020 2020 2020 2870 6b74  ing.        (pkt
+00009f80: 5f64 6174 612c 2070 6b74 5f6d 6574 6164  _data, pkt_metad
+00009f90: 6174 6129 0a0a 2020 2020 2020 2020 7261  ata)..        ra
+00009fa0: 6973 6520 454f 4645 7272 6f72 2077 6865  ise EOFError whe
+00009fb0: 6e20 6e6f 206d 6f72 6520 7061 636b 6574  n no more packet
+00009fc0: 7320 6172 6520 6176 6169 6c61 626c 650a  s are available.
+00009fd0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00009fe0: 2020 2020 6864 7220 3d20 7365 6c66 2e66      hdr = self.f
+00009ff0: 2e72 6561 6428 3136 290a 2020 2020 2020  .read(16).      
+0000a000: 2020 6966 206c 656e 2868 6472 2920 3c20    if len(hdr) < 
+0000a010: 3136 3a0a 2020 2020 2020 2020 2020 2020  16:.            
+0000a020: 7261 6973 6520 454f 4645 7272 6f72 0a20  raise EOFError. 
+0000a030: 2020 2020 2020 2073 6563 2c20 7573 6563         sec, usec
+0000a040: 2c20 6361 706c 656e 2c20 7769 7265 6c65  , caplen, wirele
+0000a050: 6e20 3d20 7374 7275 6374 2e75 6e70 6163  n = struct.unpac
+0000a060: 6b28 7365 6c66 2e65 6e64 6961 6e20 2b20  k(self.endian + 
+0000a070: 2249 4949 4922 2c20 6864 7229 0a20 2020  "IIII", hdr).   
+0000a080: 2020 2020 2072 6574 7572 6e20 2873 656c       return (sel
+0000a090: 662e 662e 7265 6164 2863 6170 6c65 6e29  f.f.read(caplen)
+0000a0a0: 5b3a 7369 7a65 5d2c 0a20 2020 2020 2020  [:size],.       
+0000a0b0: 2020 2020 2020 2020 2052 6177 5063 6170           RawPcap
+0000a0c0: 5265 6164 6572 2e50 6163 6b65 744d 6574  Reader.PacketMet
+0000a0d0: 6164 6174 6128 7365 633d 7365 632c 2075  adata(sec=sec, u
+0000a0e0: 7365 633d 7573 6563 2c0a 2020 2020 2020  sec=usec,.      
+0000a0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a110: 2020 2020 2020 2077 6972 656c 656e 3d77         wirelen=w
+0000a120: 6972 656c 656e 2c20 6361 706c 656e 3d63  irelen, caplen=c
+0000a130: 6170 6c65 6e29 290a 0a20 2020 2064 6566  aplen))..    def
+0000a140: 2072 6561 645f 7061 636b 6574 2873 656c   read_packet(sel
+0000a150: 662c 2073 697a 653d 4d54 5529 3a0a 2020  f, size=MTU):.  
+0000a160: 2020 2020 2020 2320 7479 7065 3a20 2869        # type: (i
+0000a170: 6e74 2920 2d3e 2050 6163 6b65 740a 2020  nt) -> Packet.  
+0000a180: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
+0000a190: 7074 696f 6e28 0a20 2020 2020 2020 2020  ption(.         
+0000a1a0: 2020 2022 4361 6e6e 6f74 2063 616c 6c20     "Cannot call 
+0000a1b0: 7265 6164 5f70 6163 6b65 7428 2920 696e  read_packet() in
+0000a1c0: 2052 6177 5063 6170 5265 6164 6572 2e20   RawPcapReader. 
+0000a1d0: 5573 6520 220a 2020 2020 2020 2020 2020  Use ".          
+0000a1e0: 2020 225f 7265 6164 5f70 6163 6b65 7428    "_read_packet(
+0000a1f0: 2922 0a20 2020 2020 2020 2029 0a0a 2020  )".        )..  
+0000a200: 2020 6465 6620 6469 7370 6174 6368 2873    def dispatch(s
+0000a210: 656c 662c 0a20 2020 2020 2020 2020 2020  elf,.           
+0000a220: 2020 2020 2020 6361 6c6c 6261 636b 2020        callback  
+0000a230: 2320 7479 7065 3a20 4361 6c6c 6162 6c65  # type: Callable
+0000a240: 5b5b 5475 706c 655b 6279 7465 732c 2052  [[Tuple[bytes, R
+0000a250: 6177 5063 6170 5265 6164 6572 2e50 6163  awPcapReader.Pac
+0000a260: 6b65 744d 6574 6164 6174 615d 5d2c 2041  ketMetadata]], A
+0000a270: 6e79 5d20 2023 206e 6f71 613a 2045 3530  ny]  # noqa: E50
+0000a280: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+0000a290: 2020 2029 3a0a 2020 2020 2020 2020 2320     ):.        # 
+0000a2a0: 7479 7065 3a20 282e 2e2e 2920 2d3e 204e  type: (...) -> N
+0000a2b0: 6f6e 650a 2020 2020 2020 2020 2222 2263  one.        """c
+0000a2c0: 616c 6c20 7468 6520 7370 6563 6966 6965  all the specifie
+0000a2d0: 6420 6361 6c6c 6261 636b 2072 6f75 7469  d callback routi
+0000a2e0: 6e65 2066 6f72 2065 6163 6820 7061 636b  ne for each pack
+0000a2f0: 6574 2072 6561 640a 0a20 2020 2020 2020  et read..       
+0000a300: 2054 6869 7320 6973 206a 7573 7420 6120   This is just a 
+0000a310: 636f 6e76 656e 6965 6e63 6520 6675 6e63  convenience func
+0000a320: 7469 6f6e 2066 6f72 2074 6865 206d 6169  tion for the mai
+0000a330: 6e20 6c6f 6f70 0a20 2020 2020 2020 2074  n loop.        t
+0000a340: 6861 7420 616c 6c6f 7773 2066 6f72 2065  hat allows for e
+0000a350: 6173 7920 6c61 756e 6368 696e 6720 6f66  asy launching of
+0000a360: 2070 6163 6b65 7420 7072 6f63 6573 7369   packet processi
+0000a370: 6e67 2069 6e20 610a 2020 2020 2020 2020  ng in a.        
+0000a380: 7468 7265 6164 2e0a 2020 2020 2020 2020  thread..        
+0000a390: 2222 220a 2020 2020 2020 2020 666f 7220  """.        for 
+0000a3a0: 7020 696e 2073 656c 663a 0a20 2020 2020  p in self:.     
+0000a3b0: 2020 2020 2020 2063 616c 6c62 6163 6b28         callback(
+0000a3c0: 7029 0a0a 2020 2020 6465 6620 5f72 6561  p)..    def _rea
+0000a3d0: 645f 616c 6c28 7365 6c66 2c20 636f 756e  d_all(self, coun
+0000a3e0: 743d 2d31 293a 0a20 2020 2020 2020 2023  t=-1):.        #
+0000a3f0: 2074 7970 653a 2028 696e 7429 202d 3e20   type: (int) -> 
+0000a400: 4c69 7374 5b50 6163 6b65 745d 0a20 2020  List[Packet].   
+0000a410: 2020 2020 2022 2222 7265 7475 726e 2061       """return a
+0000a420: 206c 6973 7420 6f66 2061 6c6c 2070 6163   list of all pac
+0000a430: 6b65 7473 2069 6e20 7468 6520 7063 6170  kets in the pcap
+0000a440: 2066 696c 650a 2020 2020 2020 2020 2222   file.        ""
+0000a450: 220a 2020 2020 2020 2020 7265 7320 3d20  ".        res = 
+0000a460: 5b5d 2020 2320 7479 7065 3a20 4c69 7374  []  # type: List
+0000a470: 5b50 6163 6b65 745d 0a20 2020 2020 2020  [Packet].       
+0000a480: 2077 6869 6c65 2063 6f75 6e74 2021 3d20   while count != 
+0000a490: 303a 0a20 2020 2020 2020 2020 2020 2063  0:.            c
+0000a4a0: 6f75 6e74 202d 3d20 310a 2020 2020 2020  ount -= 1.      
+0000a4b0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+0000a4c0: 2020 2020 2020 2020 2020 2070 203d 2073             p = s
+0000a4d0: 656c 662e 7265 6164 5f70 6163 6b65 7428  elf.read_packet(
+0000a4e0: 2920 2023 2074 7970 653a 2050 6163 6b65  )  # type: Packe
+0000a4f0: 740a 2020 2020 2020 2020 2020 2020 6578  t.            ex
+0000a500: 6365 7074 2045 4f46 4572 726f 723a 0a20  cept EOFError:. 
+0000a510: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+0000a520: 7265 616b 0a20 2020 2020 2020 2020 2020  reak.           
+0000a530: 2072 6573 2e61 7070 656e 6428 7029 0a20   res.append(p). 
+0000a540: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
+0000a550: 730a 0a20 2020 2064 6566 2072 6563 7628  s..    def recv(
+0000a560: 7365 6c66 2c20 7369 7a65 3d4d 5455 293a  self, size=MTU):
+0000a570: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+0000a580: 2028 696e 7429 202d 3e20 6279 7465 730a   (int) -> bytes.
+0000a590: 2020 2020 2020 2020 2222 2220 456d 756c          """ Emul
+0000a5a0: 6174 6520 6120 736f 636b 6574 0a20 2020  ate a socket.   
+0000a5b0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000a5c0: 2072 6574 7572 6e20 7365 6c66 2e5f 7265   return self._re
+0000a5d0: 6164 5f70 6163 6b65 7428 7369 7a65 3d73  ad_packet(size=s
+0000a5e0: 697a 6529 5b30 5d0a 0a20 2020 2064 6566  ize)[0]..    def
+0000a5f0: 2066 696c 656e 6f28 7365 6c66 293a 0a20   fileno(self):. 
+0000a600: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+0000a610: 2920 2d3e 2069 6e74 0a20 2020 2020 2020  ) -> int.       
+0000a620: 2072 6574 7572 6e20 2d31 2069 6620 5749   return -1 if WI
+0000a630: 4e44 4f57 5320 656c 7365 2073 656c 662e  NDOWS else self.
+0000a640: 662e 6669 6c65 6e6f 2829 0a0a 2020 2020  f.fileno()..    
+0000a650: 6465 6620 636c 6f73 6528 7365 6c66 293a  def close(self):
+0000a660: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+0000a670: 2028 2920 2d3e 204f 7074 696f 6e61 6c5b   () -> Optional[
+0000a680: 416e 795d 0a20 2020 2020 2020 2072 6574  Any].        ret
+0000a690: 7572 6e20 7365 6c66 2e66 2e63 6c6f 7365  urn self.f.close
+0000a6a0: 2829 0a0a 2020 2020 6465 6620 5f5f 6578  ()..    def __ex
+0000a6b0: 6974 5f5f 2873 656c 662c 2065 7863 5f74  it__(self, exc_t
+0000a6c0: 7970 652c 2065 7863 5f76 616c 7565 2c20  ype, exc_value, 
+0000a6d0: 7472 6163 6261 636b 293a 0a20 2020 2020  tracback):.     
+0000a6e0: 2020 2023 2074 7970 653a 2028 4f70 7469     # type: (Opti
+0000a6f0: 6f6e 616c 5b41 6e79 5d2c 204f 7074 696f  onal[Any], Optio
+0000a700: 6e61 6c5b 416e 795d 2c20 4f70 7469 6f6e  nal[Any], Option
+0000a710: 616c 5b41 6e79 5d29 202d 3e20 4e6f 6e65  al[Any]) -> None
+0000a720: 0a20 2020 2020 2020 2073 656c 662e 636c  .        self.cl
+0000a730: 6f73 6528 290a 0a20 2020 2023 2065 6d75  ose()..    # emu
+0000a740: 6c61 7465 2053 7570 6572 536f 636b 6574  late SuperSocket
+0000a750: 0a20 2020 2040 7374 6174 6963 6d65 7468  .    @staticmeth
+0000a760: 6f64 0a20 2020 2064 6566 2073 656c 6563  od.    def selec
+0000a770: 7428 736f 636b 6574 732c 2020 2320 7479  t(sockets,  # ty
+0000a780: 7065 3a20 4c69 7374 5b53 7570 6572 536f  pe: List[SuperSo
+0000a790: 636b 6574 5d0a 2020 2020 2020 2020 2020  cket].          
+0000a7a0: 2020 2020 2072 656d 6169 6e3d 4e6f 6e65       remain=None
+0000a7b0: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
+0000a7c0: 6e61 6c5b 666c 6f61 745d 0a20 2020 2020  nal[float].     
+0000a7d0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+0000a7e0: 2020 2020 2023 2074 7970 653a 2028 2e2e       # type: (..
+0000a7f0: 2e29 202d 3e20 4c69 7374 5b53 7570 6572  .) -> List[Super
+0000a800: 536f 636b 6574 5d0a 2020 2020 2020 2020  Socket].        
+0000a810: 7265 7475 726e 2073 6f63 6b65 7473 0a0a  return sockets..
+0000a820: 0a63 6c61 7373 2050 6361 7052 6561 6465  .class PcapReade
+0000a830: 7228 5261 7750 6361 7052 6561 6465 7229  r(RawPcapReader)
+0000a840: 3a0a 2020 2020 6465 6620 5f5f 696e 6974  :.    def __init
+0000a850: 5f5f 2873 656c 662c 2066 696c 656e 616d  __(self, filenam
+0000a860: 652c 2066 6465 7363 3d4e 6f6e 652c 206d  e, fdesc=None, m
+0000a870: 6167 6963 3d4e 6f6e 6529 3a20 2023 2074  agic=None):  # t
+0000a880: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
+0000a890: 2020 2020 2320 7479 7065 3a20 2873 7472      # type: (str
+0000a8a0: 2c20 494f 5b62 7974 6573 5d2c 2062 7974  , IO[bytes], byt
+0000a8b0: 6573 2920 2d3e 204e 6f6e 650a 2020 2020  es) -> None.    
+0000a8c0: 2020 2020 5261 7750 6361 7052 6561 6465      RawPcapReade
+0000a8d0: 722e 5f5f 696e 6974 5f5f 2873 656c 662c  r.__init__(self,
+0000a8e0: 2066 696c 656e 616d 652c 2066 6465 7363   filename, fdesc
+0000a8f0: 2c20 6d61 6769 6329 0a20 2020 2020 2020  , magic).       
+0000a900: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+0000a910: 2020 7365 6c66 2e4c 4c63 6c73 203d 2063    self.LLcls = c
+0000a920: 6f6e 662e 6c32 7479 7065 732e 6e75 6d32  onf.l2types.num2
+0000a930: 6c61 7965 725b 0a20 2020 2020 2020 2020  layer[.         
+0000a940: 2020 2020 2020 2073 656c 662e 6c69 6e6b         self.link
+0000a950: 7479 7065 0a20 2020 2020 2020 2020 2020  type.           
+0000a960: 205d 2020 2320 7479 7065 3a20 5479 7065   ]  # type: Type
+0000a970: 5b50 6163 6b65 745d 0a20 2020 2020 2020  [Packet].       
+0000a980: 2065 7863 6570 7420 4b65 7945 7272 6f72   except KeyError
+0000a990: 3a0a 2020 2020 2020 2020 2020 2020 7761  :.            wa
+0000a9a0: 726e 696e 6728 2250 6361 7052 6561 6465  rning("PcapReade
+0000a9b0: 723a 2075 6e6b 6e6f 776e 204c 4c20 7479  r: unknown LL ty
+0000a9c0: 7065 205b 2569 5d2f 5b25 2378 5d2e 2055  pe [%i]/[%#x]. U
+0000a9d0: 7369 6e67 2052 6177 2070 6163 6b65 7473  sing Raw packets
+0000a9e0: 2220 2520 2873 656c 662e 6c69 6e6b 7479  " % (self.linkty
+0000a9f0: 7065 2c20 7365 6c66 2e6c 696e 6b74 7970  pe, self.linktyp
+0000aa00: 6529 2920 2023 206e 6f71 613a 2045 3530  e))  # noqa: E50
+0000aa10: 310a 2020 2020 2020 2020 2020 2020 6966  1.            if
+0000aa20: 2063 6f6e 662e 7261 775f 6c61 7965 7220   conf.raw_layer 
+0000aa30: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0000aa40: 2020 2020 2020 2020 2023 2063 6f6e 662e           # conf.
+0000aa50: 7261 775f 6c61 7965 7220 6973 2073 6574  raw_layer is set
+0000aa60: 206f 6e20 696d 706f 7274 0a20 2020 2020   on import.     
+0000aa70: 2020 2020 2020 2020 2020 2069 6d70 6f72             impor
+0000aa80: 7420 7363 6170 792e 7061 636b 6574 2020  t scapy.packet  
+0000aa90: 2320 6e6f 7161 3a20 4634 3031 0a20 2020  # noqa: F401.   
+0000aaa0: 2020 2020 2020 2020 2073 656c 662e 4c4c           self.LL
+0000aab0: 636c 7320 3d20 636f 6e66 2e72 6177 5f6c  cls = conf.raw_l
+0000aac0: 6179 6572 0a0a 2020 2020 6465 6620 5f5f  ayer..    def __
+0000aad0: 656e 7465 725f 5f28 7365 6c66 293a 0a20  enter__(self):. 
+0000aae0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+0000aaf0: 2920 2d3e 2050 6361 7052 6561 6465 720a  ) -> PcapReader.
+0000ab00: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000ab10: 656c 660a 0a20 2020 2064 6566 2072 6561  elf..    def rea
+0000ab20: 645f 7061 636b 6574 2873 656c 662c 2073  d_packet(self, s
+0000ab30: 697a 653d 4d54 552c 202a 2a6b 7761 7267  ize=MTU, **kwarg
+0000ab40: 7329 3a0a 2020 2020 2020 2020 2320 7479  s):.        # ty
+0000ab50: 7065 3a20 2869 6e74 2c20 2a2a 416e 7929  pe: (int, **Any)
+0000ab60: 202d 3e20 5061 636b 6574 0a20 2020 2020   -> Packet.     
+0000ab70: 2020 2072 7020 3d20 7375 7065 7228 5063     rp = super(Pc
+0000ab80: 6170 5265 6164 6572 2c20 7365 6c66 292e  apReader, self).
+0000ab90: 5f72 6561 645f 7061 636b 6574 2873 697a  _read_packet(siz
+0000aba0: 653d 7369 7a65 290a 2020 2020 2020 2020  e=size).        
+0000abb0: 6966 2072 7020 6973 204e 6f6e 653a 0a20  if rp is None:. 
+0000abc0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0000abd0: 2045 4f46 4572 726f 720a 2020 2020 2020   EOFError.      
+0000abe0: 2020 732c 2070 6b74 5f69 6e66 6f20 3d20    s, pkt_info = 
+0000abf0: 7270 0a0a 2020 2020 2020 2020 7472 793a  rp..        try:
+0000ac00: 0a20 2020 2020 2020 2020 2020 2070 203d  .            p =
+0000ac10: 2073 656c 662e 4c4c 636c 7328 732c 202a   self.LLcls(s, *
+0000ac20: 2a6b 7761 7267 7329 2020 2320 7479 7065  *kwargs)  # type
+0000ac30: 3a20 5061 636b 6574 0a20 2020 2020 2020  : Packet.       
+0000ac40: 2065 7863 6570 7420 4b65 7962 6f61 7264   except Keyboard
+0000ac50: 496e 7465 7272 7570 743a 0a20 2020 2020  Interrupt:.     
+0000ac60: 2020 2020 2020 2072 6169 7365 0a20 2020         raise.   
+0000ac70: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+0000ac80: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
+0000ac90: 2020 2069 6620 636f 6e66 2e64 6562 7567     if conf.debug
+0000aca0: 5f64 6973 7365 6374 6f72 3a0a 2020 2020  _dissector:.    
+0000acb0: 2020 2020 2020 2020 2020 2020 6672 6f6d              from
+0000acc0: 2073 6361 7079 2e73 656e 6472 6563 7620   scapy.sendrecv 
+0000acd0: 696d 706f 7274 2064 6562 7567 0a20 2020  import debug.   
+0000ace0: 2020 2020 2020 2020 2020 2020 2064 6562               deb
+0000acf0: 7567 2e63 7261 7368 6564 5f6f 6e20 3d20  ug.crashed_on = 
+0000ad00: 2873 656c 662e 4c4c 636c 732c 2073 290a  (self.LLcls, s).
+0000ad10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad20: 7261 6973 650a 2020 2020 2020 2020 2020  raise.          
+0000ad30: 2020 6966 2063 6f6e 662e 7261 775f 6c61    if conf.raw_la
+0000ad40: 7965 7220 6973 204e 6f6e 653a 0a20 2020  yer is None:.   
+0000ad50: 2020 2020 2020 2020 2020 2020 2023 2063               # c
+0000ad60: 6f6e 662e 7261 775f 6c61 7965 7220 6973  onf.raw_layer is
+0000ad70: 2073 6574 206f 6e20 696d 706f 7274 0a20   set on import. 
+0000ad80: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000ad90: 6d70 6f72 7420 7363 6170 792e 7061 636b  mport scapy.pack
+0000ada0: 6574 2020 2320 6e6f 7161 3a20 4634 3031  et  # noqa: F401
+0000adb0: 0a20 2020 2020 2020 2020 2020 2070 203d  .            p =
+0000adc0: 2063 6f6e 662e 7261 775f 6c61 7965 7228   conf.raw_layer(
+0000add0: 7329 0a20 2020 2020 2020 2070 6f77 6572  s).        power
+0000ade0: 203d 2044 6563 696d 616c 2831 3029 202a   = Decimal(10) *
+0000adf0: 2a20 4465 6369 6d61 6c28 2d39 2069 6620  * Decimal(-9 if 
+0000ae00: 7365 6c66 2e6e 616e 6f20 656c 7365 202d  self.nano else -
+0000ae10: 3629 0a20 2020 2020 2020 2070 2e74 696d  6).        p.tim
+0000ae20: 6520 3d20 4544 6563 696d 616c 2870 6b74  e = EDecimal(pkt
+0000ae30: 5f69 6e66 6f2e 7365 6320 2b20 706f 7765  _info.sec + powe
+0000ae40: 7220 2a20 706b 745f 696e 666f 2e75 7365  r * pkt_info.use
+0000ae50: 6329 0a20 2020 2020 2020 2070 2e77 6972  c).        p.wir
+0000ae60: 656c 656e 203d 2070 6b74 5f69 6e66 6f2e  elen = pkt_info.
+0000ae70: 7769 7265 6c65 6e0a 2020 2020 2020 2020  wirelen.        
+0000ae80: 7265 7475 726e 2070 0a0a 2020 2020 6465  return p..    de
+0000ae90: 6620 7265 6376 2873 656c 662c 2073 697a  f recv(self, siz
+0000aea0: 653d 4d54 552c 202a 2a6b 7761 7267 7329  e=MTU, **kwargs)
+0000aeb0: 3a20 2023 2074 7970 653a 2069 676e 6f72  :  # type: ignor
+0000aec0: 650a 2020 2020 2020 2020 2320 7479 7065  e.        # type
+0000aed0: 3a20 2869 6e74 2c20 2a2a 416e 7929 202d  : (int, **Any) -
+0000aee0: 3e20 5061 636b 6574 0a20 2020 2020 2020  > Packet.       
+0000aef0: 2072 6574 7572 6e20 7365 6c66 2e72 6561   return self.rea
+0000af00: 645f 7061 636b 6574 2873 697a 653d 7369  d_packet(size=si
+0000af10: 7a65 2c20 2a2a 6b77 6172 6773 290a 0a20  ze, **kwargs).. 
+0000af20: 2020 2064 6566 205f 5f6e 6578 745f 5f28     def __next__(
+0000af30: 7365 6c66 293a 2020 2320 7479 7065 3a20  self):  # type: 
+0000af40: 6967 6e6f 7265 0a20 2020 2020 2020 2023  ignore.        #
+0000af50: 2074 7970 653a 2028 2920 2d3e 2050 6163   type: () -> Pac
+0000af60: 6b65 740a 2020 2020 2020 2020 7472 793a  ket.        try:
+0000af70: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000af80: 7572 6e20 7365 6c66 2e72 6561 645f 7061  urn self.read_pa
+0000af90: 636b 6574 2829 0a20 2020 2020 2020 2065  cket().        e
+0000afa0: 7863 6570 7420 454f 4645 7272 6f72 3a0a  xcept EOFError:.
+0000afb0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000afc0: 6520 5374 6f70 4974 6572 6174 696f 6e0a  e StopIteration.
+0000afd0: 0a20 2020 2064 6566 2072 6561 645f 616c  .    def read_al
+0000afe0: 6c28 7365 6c66 2c20 636f 756e 743d 2d31  l(self, count=-1
+0000aff0: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+0000b000: 653a 2028 696e 7429 202d 3e20 5061 636b  e: (int) -> Pack
+0000b010: 6574 4c69 7374 0a20 2020 2020 2020 2072  etList.        r
+0000b020: 6573 203d 2073 656c 662e 5f72 6561 645f  es = self._read_
+0000b030: 616c 6c28 636f 756e 7429 0a20 2020 2020  all(count).     
+0000b040: 2020 2066 726f 6d20 7363 6170 7920 696d     from scapy im
+0000b050: 706f 7274 2070 6c69 7374 0a20 2020 2020  port plist.     
+0000b060: 2020 2072 6574 7572 6e20 706c 6973 742e     return plist.
+0000b070: 5061 636b 6574 4c69 7374 2872 6573 2c20  PacketList(res, 
+0000b080: 6e61 6d65 3d6f 732e 7061 7468 2e62 6173  name=os.path.bas
+0000b090: 656e 616d 6528 7365 6c66 2e66 696c 656e  ename(self.filen
+0000b0a0: 616d 6529 290a 0a0a 636c 6173 7320 5261  ame))...class Ra
+0000b0b0: 7750 6361 704e 6752 6561 6465 7228 5261  wPcapNgReader(Ra
+0000b0c0: 7750 6361 7052 6561 6465 7229 3a0a 2020  wPcapReader):.  
+0000b0d0: 2020 2222 2241 2073 7461 7465 6675 6c20    """A stateful 
+0000b0e0: 7063 6170 6e67 2072 6561 6465 722e 2045  pcapng reader. E
+0000b0f0: 6163 6820 7061 636b 6574 2069 7320 7265  ach packet is re
+0000b100: 7475 726e 6564 2061 730a 2020 2020 6279  turned as.    by
+0000b110: 7465 732e 0a0a 2020 2020 2222 220a 0a20  tes...    """.. 
+0000b120: 2020 2061 6c74 6572 6e61 7469 7665 203d     alternative =
+0000b130: 2052 6177 5063 6170 5265 6164 6572 2020   RawPcapReader  
+0000b140: 2320 7479 7065 3a20 5479 7065 5b41 6e79  # type: Type[Any
+0000b150: 5d0a 0a20 2020 2050 6163 6b65 744d 6574  ]..    PacketMet
+0000b160: 6164 6174 6120 3d20 636f 6c6c 6563 7469  adata = collecti
+0000b170: 6f6e 732e 6e61 6d65 6474 7570 6c65 2822  ons.namedtuple("
+0000b180: 5061 636b 6574 4d65 7461 6461 7461 4e67  PacketMetadataNg
+0000b190: 222c 2020 2320 7479 7065 3a20 6967 6e6f  ",  # type: igno
+0000b1a0: 7265 0a20 2020 2020 2020 2020 2020 2020  re.             
+0000b1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1c0: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+0000b1d0: 226c 696e 6b74 7970 6522 2c20 2274 7372  "linktype", "tsr
+0000b1e0: 6573 6f6c 222c 0a20 2020 2020 2020 2020  esol",.         
+0000b1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b210: 2020 2020 2274 7368 6967 6822 2c20 2274      "tshigh", "t
+0000b220: 736c 6f77 222c 2022 7769 7265 6c65 6e22  slow", "wirelen"
+0000b230: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000b240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b250: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000b260: 636f 6d6d 656e 7422 2c20 2269 666e 616d  comment", "ifnam
+0000b270: 6522 2c20 2264 6972 6563 7469 6f6e 225d  e", "direction"]
+0000b280: 290a 0a20 2020 2064 6566 205f 5f69 6e69  )..    def __ini
+0000b290: 745f 5f28 7365 6c66 2c20 6669 6c65 6e61  t__(self, filena
+0000b2a0: 6d65 2c20 6664 6573 633d 4e6f 6e65 2c20  me, fdesc=None, 
+0000b2b0: 6d61 6769 633d 4e6f 6e65 293a 2020 2320  magic=None):  # 
+0000b2c0: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+0000b2d0: 2020 2020 2023 2074 7970 653a 2028 7374       # type: (st
+0000b2e0: 722c 2049 4f5b 6279 7465 735d 2c20 6279  r, IO[bytes], by
+0000b2f0: 7465 7329 202d 3e20 4e6f 6e65 0a20 2020  tes) -> None.   
+0000b300: 2020 2020 2073 656c 662e 6669 6c65 6e61       self.filena
+0000b310: 6d65 203d 2066 696c 656e 616d 650a 2020  me = filename.  
+0000b320: 2020 2020 2020 7365 6c66 2e66 203d 2066        self.f = f
+0000b330: 6465 7363 0a20 2020 2020 2020 2023 2041  desc.        # A
+0000b340: 206c 6973 7420 6f66 2028 6c69 6e6b 7479   list of (linkty
+0000b350: 7065 2c20 736e 6170 6c65 6e2c 2074 7372  pe, snaplen, tsr
+0000b360: 6573 6f6c 293b 2077 696c 6c20 6265 2070  esol); will be p
+0000b370: 6f70 756c 6174 6564 2062 7920 4944 4273  opulated by IDBs
+0000b380: 2e0a 2020 2020 2020 2020 7365 6c66 2e69  ..        self.i
+0000b390: 6e74 6572 6661 6365 7320 3d20 5b5d 2020  nterfaces = []  
+0000b3a0: 2320 7479 7065 3a20 4c69 7374 5b54 7570  # type: List[Tup
+0000b3b0: 6c65 5b69 6e74 2c20 696e 742c 2044 6963  le[int, int, Dic
+0000b3c0: 745b 7374 722c 2041 6e79 5d5d 5d0a 2020  t[str, Any]]].  
+0000b3d0: 2020 2020 2020 7365 6c66 2e64 6566 6175        self.defau
+0000b3e0: 6c74 5f6f 7074 696f 6e73 203d 207b 0a20  lt_options = {. 
+0000b3f0: 2020 2020 2020 2020 2020 2022 7473 7265             "tsre
+0000b400: 736f 6c22 3a20 3130 3030 3030 300a 2020  sol": 1000000.  
+0000b410: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+0000b420: 7365 6c66 2e62 6c6f 636b 7479 7065 733a  self.blocktypes:
+0000b430: 2044 6963 745b 0a20 2020 2020 2020 2020   Dict[.         
+0000b440: 2020 2069 6e74 2c0a 2020 2020 2020 2020     int,.        
+0000b450: 2020 2020 4361 6c6c 6162 6c65 5b0a 2020      Callable[.  
+0000b460: 2020 2020 2020 2020 2020 2020 2020 5b62                [b
+0000b470: 7974 6573 2c20 696e 745d 2c0a 2020 2020  ytes, int],.    
+0000b480: 2020 2020 2020 2020 2020 2020 4f70 7469              Opti
+0000b490: 6f6e 616c 5b54 7570 6c65 5b62 7974 6573  onal[Tuple[bytes
+0000b4a0: 2c20 5261 7750 6361 704e 6752 6561 6465  , RawPcapNgReade
+0000b4b0: 722e 5061 636b 6574 4d65 7461 6461 7461  r.PacketMetadata
+0000b4c0: 5d5d 0a20 2020 2020 2020 2020 2020 205d  ]].            ]
+0000b4d0: 5d20 3d20 7b0a 2020 2020 2020 2020 2020  ] = {.          
+0000b4e0: 2020 2020 2020 313a 2073 656c 662e 5f72        1: self._r
+0000b4f0: 6561 645f 626c 6f63 6b5f 6964 622c 0a20  ead_block_idb,. 
+0000b500: 2020 2020 2020 2020 2020 2020 2020 2032                 2
+0000b510: 3a20 7365 6c66 2e5f 7265 6164 5f62 6c6f  : self._read_blo
+0000b520: 636b 5f70 6b74 2c0a 2020 2020 2020 2020  ck_pkt,.        
+0000b530: 2020 2020 2020 2020 333a 2073 656c 662e          3: self.
+0000b540: 5f72 6561 645f 626c 6f63 6b5f 7370 622c  _read_block_spb,
+0000b550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b560: 2036 3a20 7365 6c66 2e5f 7265 6164 5f62   6: self._read_b
+0000b570: 6c6f 636b 5f65 7062 2c0a 2020 2020 2020  lock_epb,.      
+0000b580: 2020 2020 2020 2020 2020 3130 3a20 7365            10: se
+0000b590: 6c66 2e5f 7265 6164 5f62 6c6f 636b 5f64  lf._read_block_d
+0000b5a0: 7362 2c0a 2020 2020 2020 2020 7d0a 2020  sb,.        }.  
+0000b5b0: 2020 2020 2020 7365 6c66 2e65 6e64 6961        self.endia
+0000b5c0: 6e20 3d20 2221 2220 2023 2057 696c 6c20  n = "!"  # Will 
+0000b5d0: 6265 206f 7665 7277 7269 7474 656e 2062  be overwritten b
+0000b5e0: 7920 6669 7273 7420 5348 420a 0a20 2020  y first SHB..   
+0000b5f0: 2020 2020 2069 6620 6d61 6769 6320 213d       if magic !=
+0000b600: 2062 225c 7830 615c 7830 645c 7830 645c   b"\x0a\x0d\x0d\
+0000b610: 7830 6122 3a20 2023 2050 6361 704e 673a  x0a":  # PcapNg:
+0000b620: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+0000b630: 7365 2053 6361 7079 5f45 7863 6570 7469  se Scapy_Excepti
+0000b640: 6f6e 280a 2020 2020 2020 2020 2020 2020  on(.            
+0000b650: 2020 2020 224e 6f74 2061 2070 6361 706e      "Not a pcapn
+0000b660: 6720 6361 7074 7572 6520 6669 6c65 2028  g capture file (
+0000b670: 6261 6420 6d61 6769 633a 2025 7229 2220  bad magic: %r)" 
+0000b680: 2520 6d61 6769 630a 2020 2020 2020 2020  % magic.        
+0000b690: 2020 2020 290a 0a20 2020 2020 2020 2074      )..        t
+0000b6a0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+0000b6b0: 7365 6c66 2e5f 7265 6164 5f62 6c6f 636b  self._read_block
+0000b6c0: 5f73 6862 2829 0a20 2020 2020 2020 2065  _shb().        e
+0000b6d0: 7863 6570 7420 454f 4645 7272 6f72 3a0a  xcept EOFError:.
+0000b6e0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000b6f0: 6520 5363 6170 795f 4578 6365 7074 696f  e Scapy_Exceptio
+0000b700: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+0000b710: 2020 2022 5468 6520 6669 7273 7420 5348     "The first SH
+0000b720: 4220 6f66 2074 6865 2070 6361 706e 6720  B of the pcapng 
+0000b730: 6669 6c65 2069 7320 6d61 6c66 6f72 6d65  file is malforme
+0000b740: 6420 2122 0a20 2020 2020 2020 2020 2020  d !".           
+0000b750: 2029 0a0a 2020 2020 6465 6620 5f72 6561   )..    def _rea
+0000b760: 645f 626c 6f63 6b28 7365 6c66 2c20 7369  d_block(self, si
+0000b770: 7a65 3d4d 5455 293a 0a20 2020 2020 2020  ze=MTU):.       
+0000b780: 2023 2074 7970 653a 2028 696e 7429 202d   # type: (int) -
+0000b790: 3e20 4f70 7469 6f6e 616c 5b54 7570 6c65  > Optional[Tuple
+0000b7a0: 5b62 7974 6573 2c20 5261 7750 6361 704e  [bytes, RawPcapN
+0000b7b0: 6752 6561 6465 722e 5061 636b 6574 4d65  gReader.PacketMe
+0000b7c0: 7461 6461 7461 5d5d 2020 2320 6e6f 7161  tadata]]  # noqa
+0000b7d0: 3a20 4535 3031 0a20 2020 2020 2020 2074  : E501.        t
+0000b7e0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+0000b7f0: 626c 6f63 6b74 7970 6520 3d20 7374 7275  blocktype = stru
+0000b800: 6374 2e75 6e70 6163 6b28 7365 6c66 2e65  ct.unpack(self.e
+0000b810: 6e64 6961 6e20 2b20 2249 222c 2073 656c  ndian + "I", sel
+0000b820: 662e 662e 7265 6164 2834 2929 5b30 5d0a  f.f.read(4))[0].
+0000b830: 2020 2020 2020 2020 6578 6365 7074 2073          except s
+0000b840: 7472 7563 742e 6572 726f 723a 0a20 2020  truct.error:.   
+0000b850: 2020 2020 2020 2020 2072 6169 7365 2045           raise E
+0000b860: 4f46 4572 726f 720a 2020 2020 2020 2020  OFError.        
+0000b870: 6966 2062 6c6f 636b 7479 7065 203d 3d20  if blocktype == 
+0000b880: 3078 3041 3044 3044 3041 3a0a 2020 2020  0x0A0D0D0A:.    
+0000b890: 2020 2020 2020 2020 2320 5468 6973 2066          # This f
+0000b8a0: 756e 6374 696f 6e20 7570 6461 7465 7320  unction updates 
+0000b8b0: 7468 6520 656e 6469 616e 6e65 7373 2062  the endianness b
+0000b8c0: 6173 6564 206f 6e20 7468 6520 626c 6f63  ased on the bloc
+0000b8d0: 6b20 636f 6e74 656e 742e 0a20 2020 2020  k content..     
+0000b8e0: 2020 2020 2020 2073 656c 662e 5f72 6561         self._rea
+0000b8f0: 645f 626c 6f63 6b5f 7368 6228 290a 2020  d_block_shb().  
+0000b900: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000b910: 204e 6f6e 650a 2020 2020 2020 2020 7472   None.        tr
+0000b920: 793a 0a20 2020 2020 2020 2020 2020 2062  y:.            b
+0000b930: 6c6f 636b 6c65 6e20 3d20 7374 7275 6374  locklen = struct
+0000b940: 2e75 6e70 6163 6b28 7365 6c66 2e65 6e64  .unpack(self.end
+0000b950: 6961 6e20 2b20 2249 222c 2073 656c 662e  ian + "I", self.
+0000b960: 662e 7265 6164 2834 2929 5b30 5d0a 2020  f.read(4))[0].  
+0000b970: 2020 2020 2020 6578 6365 7074 2073 7472        except str
+0000b980: 7563 742e 6572 726f 723a 0a20 2020 2020  uct.error:.     
+0000b990: 2020 2020 2020 2077 6172 6e69 6e67 2822         warning("
+0000b9a0: 5063 6170 4e67 3a20 4572 726f 7220 7265  PcapNg: Error re
+0000b9b0: 6164 696e 6720 626c 6f63 6b6c 656e 2062  ading blocklen b
+0000b9c0: 6566 6f72 6520 626c 6f63 6b20 626f 6479  efore block body
+0000b9d0: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+0000b9e0: 6169 7365 2045 4f46 4572 726f 720a 2020  aise EOFError.  
+0000b9f0: 2020 2020 2020 6966 2062 6c6f 636b 6c65        if blockle
+0000ba00: 6e20 3c20 3132 3a0a 2020 2020 2020 2020  n < 12:.        
+0000ba10: 2020 2020 7761 726e 696e 6728 2249 6e76      warning("Inv
+0000ba20: 616c 6964 2062 6c6f 636b 206c 656e 6774  alid block lengt
+0000ba30: 6820 2122 290a 2020 2020 2020 2020 2020  h !").          
+0000ba40: 2020 7261 6973 6520 454f 4645 7272 6f72    raise EOFError
+0000ba50: 0a20 2020 2020 2020 2062 6c6f 636b 203d  .        block =
+0000ba60: 2073 656c 662e 662e 7265 6164 2862 6c6f   self.f.read(blo
+0000ba70: 636b 6c65 6e20 2d20 3132 290a 2020 2020  cklen - 12).    
+0000ba80: 2020 2020 7365 6c66 2e5f 7265 6164 5f62      self._read_b
+0000ba90: 6c6f 636b 5f74 6169 6c28 626c 6f63 6b6c  lock_tail(blockl
+0000baa0: 656e 290a 2020 2020 2020 2020 6966 2062  en).        if b
+0000bab0: 6c6f 636b 7479 7065 2069 6e20 7365 6c66  locktype in self
+0000bac0: 2e62 6c6f 636b 7479 7065 733a 0a20 2020  .blocktypes:.   
+0000bad0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000bae0: 7365 6c66 2e62 6c6f 636b 7479 7065 735b  self.blocktypes[
+0000baf0: 626c 6f63 6b74 7970 655d 2862 6c6f 636b  blocktype](block
+0000bb00: 2c20 7369 7a65 290a 2020 2020 2020 2020  , size).        
+0000bb10: 7265 7475 726e 204e 6f6e 650a 0a20 2020  return None..   
+0000bb20: 2064 6566 205f 7265 6164 5f62 6c6f 636b   def _read_block
+0000bb30: 5f74 6169 6c28 7365 6c66 2c20 626c 6f63  _tail(self, bloc
+0000bb40: 6b6c 656e 293a 0a20 2020 2020 2020 2023  klen):.        #
+0000bb50: 2074 7970 653a 2028 696e 7429 202d 3e20   type: (int) -> 
+0000bb60: 4e6f 6e65 0a20 2020 2020 2020 2069 6620  None.        if 
+0000bb70: 626c 6f63 6b6c 656e 2025 2034 3a0a 2020  blocklen % 4:.  
+0000bb80: 2020 2020 2020 2020 2020 7061 6420 3d20            pad = 
+0000bb90: 7365 6c66 2e66 2e72 6561 6428 2d62 6c6f  self.f.read(-blo
+0000bba0: 636b 6c65 6e20 2520 3429 0a20 2020 2020  cklen % 4).     
+0000bbb0: 2020 2020 2020 2077 6172 6e69 6e67 2822         warning("
+0000bbc0: 5063 6170 4e67 3a20 6261 6420 626c 6f63  PcapNg: bad bloc
+0000bbd0: 6b6c 656e 2025 6420 284d 5553 5420 6265  klen %d (MUST be
+0000bbe0: 2061 206d 756c 7469 706c 6520 6f66 2034   a multiple of 4
+0000bbf0: 2e20 220a 2020 2020 2020 2020 2020 2020  . ".            
+0000bc00: 2020 2020 2020 2020 2249 676e 6f72 6564          "Ignored
+0000bc10: 2070 6164 6469 6e67 2025 7222 2025 2028   padding %r" % (
+0000bc20: 626c 6f63 6b6c 656e 2c20 7061 6429 290a  blocklen, pad)).
+0000bc30: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+0000bc40: 2020 2020 2020 2020 2069 6620 626c 6f63           if bloc
+0000bc50: 6b6c 656e 2021 3d20 7374 7275 6374 2e75  klen != struct.u
+0000bc60: 6e70 6163 6b28 7365 6c66 2e65 6e64 6961  npack(self.endia
+0000bc70: 6e20 2b20 2749 272c 0a20 2020 2020 2020  n + 'I',.       
+0000bc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bca0: 2020 7365 6c66 2e66 2e72 6561 6428 3429    self.f.read(4)
+0000bcb0: 295b 305d 3a0a 2020 2020 2020 2020 2020  )[0]:.          
+0000bcc0: 2020 2020 2020 7261 6973 6520 454f 4645        raise EOFE
+0000bcd0: 7272 6f72 2822 5063 6170 4e67 3a20 496e  rror("PcapNg: In
+0000bce0: 7661 6c69 6420 7063 6170 6e67 2062 6c6f  valid pcapng blo
+0000bcf0: 636b 2028 6261 6420 626c 6f63 6b6c 656e  ck (bad blocklen
+0000bd00: 2922 290a 2020 2020 2020 2020 6578 6365  )").        exce
+0000bd10: 7074 2073 7472 7563 742e 6572 726f 723a  pt struct.error:
+0000bd20: 0a20 2020 2020 2020 2020 2020 2077 6172  .            war
+0000bd30: 6e69 6e67 2822 5063 6170 4e67 3a20 436f  ning("PcapNg: Co
+0000bd40: 756c 6420 6e6f 7420 7265 6164 2062 6c6f  uld not read blo
+0000bd50: 636b 6c65 6e20 6166 7465 7220 626c 6f63  cklen after bloc
+0000bd60: 6b20 626f 6479 2229 0a20 2020 2020 2020  k body").       
+0000bd70: 2020 2020 2072 6169 7365 2045 4f46 4572       raise EOFEr
+0000bd80: 726f 720a 0a20 2020 2064 6566 205f 7265  ror..    def _re
+0000bd90: 6164 5f62 6c6f 636b 5f73 6862 2873 656c  ad_block_shb(sel
+0000bda0: 6629 3a0a 2020 2020 2020 2020 2320 7479  f):.        # ty
+0000bdb0: 7065 3a20 2829 202d 3e20 4e6f 6e65 0a20  pe: () -> None. 
+0000bdc0: 2020 2020 2020 2022 2222 5365 6374 696f         """Sectio
+0000bdd0: 6e20 4865 6164 6572 2042 6c6f 636b 2222  n Header Block""
+0000bde0: 220a 2020 2020 2020 2020 5f62 6c6f 636b  ".        _block
+0000bdf0: 6c65 6e20 3d20 7365 6c66 2e66 2e72 6561  len = self.f.rea
+0000be00: 6428 3429 0a20 2020 2020 2020 2065 6e64  d(4).        end
+0000be10: 6961 6e20 3d20 7365 6c66 2e66 2e72 6561  ian = self.f.rea
+0000be20: 6428 3429 0a20 2020 2020 2020 2069 6620  d(4).        if 
+0000be30: 656e 6469 616e 203d 3d20 6222 5c78 3161  endian == b"\x1a
+0000be40: 5c78 3262 5c78 3363 5c78 3464 223a 0a20  \x2b\x3c\x4d":. 
+0000be50: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000be60: 656e 6469 616e 203d 2022 3e22 0a20 2020  endian = ">".   
+0000be70: 2020 2020 2065 6c69 6620 656e 6469 616e       elif endian
+0000be80: 203d 3d20 6222 5c78 3464 5c78 3363 5c78   == b"\x4d\x3c\x
+0000be90: 3262 5c78 3161 223a 0a20 2020 2020 2020  2b\x1a":.       
+0000bea0: 2020 2020 2073 656c 662e 656e 6469 616e       self.endian
+0000beb0: 203d 2022 3c22 0a20 2020 2020 2020 2065   = "<".        e
+0000bec0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000bed0: 2077 6172 6e69 6e67 2822 4261 6420 6d61   warning("Bad ma
+0000bee0: 6769 6320 696e 2053 6563 7469 6f6e 2048  gic in Section H
+0000bef0: 6561 6465 7220 626c 6f63 6b20 286e 6f74  eader block (not
+0000bf00: 2061 2070 6361 706e 6720 6669 6c65 3f29   a pcapng file?)
+0000bf10: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+0000bf20: 6169 7365 2045 4f46 4572 726f 720a 0a20  aise EOFError.. 
+0000bf30: 2020 2020 2020 2062 6c6f 636b 6c65 6e20         blocklen 
+0000bf40: 3d20 7374 7275 6374 2e75 6e70 6163 6b28  = struct.unpack(
+0000bf50: 7365 6c66 2e65 6e64 6961 6e20 2b20 2249  self.endian + "I
+0000bf60: 222c 205f 626c 6f63 6b6c 656e 295b 305d  ", _blocklen)[0]
+0000bf70: 0a20 2020 2020 2020 2069 6620 626c 6f63  .        if bloc
+0000bf80: 6b6c 656e 203c 2032 383a 0a20 2020 2020  klen < 28:.     
+0000bf90: 2020 2020 2020 2077 6172 6e69 6e67 2866         warning(f
+0000bfa0: 2249 6e76 616c 6964 2053 4842 2062 6c6f  "Invalid SHB blo
+0000bfb0: 636b 206c 656e 6774 6820 287b 626c 6f63  ck length ({bloc
+0000bfc0: 6b6c 656e 7d29 2122 290a 2020 2020 2020  klen})!").      
+0000bfd0: 2020 2020 2020 7261 6973 6520 454f 4645        raise EOFE
+0000bfe0: 7272 6f72 0a0a 2020 2020 2020 2020 2320  rror..        # 
+0000bff0: 4d61 6a6f 7220 7665 7273 696f 6e20 6d75  Major version mu
+0000c000: 7374 2062 6520 310a 2020 2020 2020 2020  st be 1.        
+0000c010: 5f6d 616a 6f72 203d 2073 656c 662e 662e  _major = self.f.
+0000c020: 7265 6164 2832 290a 2020 2020 2020 2020  read(2).        
+0000c030: 6d61 6a6f 7220 3d20 7374 7275 6374 2e75  major = struct.u
+0000c040: 6e70 6163 6b28 7365 6c66 2e65 6e64 6961  npack(self.endia
+0000c050: 6e20 2b20 2248 222c 205f 6d61 6a6f 7229  n + "H", _major)
+0000c060: 5b30 5d0a 2020 2020 2020 2020 6966 206d  [0].        if m
+0000c070: 616a 6f72 2021 3d20 313a 0a20 2020 2020  ajor != 1:.     
+0000c080: 2020 2020 2020 2077 6172 6e69 6e67 2866         warning(f
+0000c090: 2253 4842 204d 616a 6f72 2076 6572 7369  "SHB Major versi
+0000c0a0: 6f6e 207b 6d61 6a6f 727d 2075 6e73 7570  on {major} unsup
+0000c0b0: 706f 7274 6564 2021 2229 0a20 2020 2020  ported !").     
+0000c0c0: 2020 2020 2020 2072 6169 7365 2045 4f46         raise EOF
+0000c0d0: 4572 726f 720a 0a20 2020 2020 2020 2023  Error..        #
+0000c0e0: 2053 6b69 7020 6d69 6e6f 7220 7665 7273   Skip minor vers
+0000c0f0: 696f 6e20 2620 7365 6374 696f 6e20 6c65  ion & section le
+0000c100: 6e67 7468 0a20 2020 2020 2020 2073 656c  ngth.        sel
+0000c110: 662e 662e 7265 6164 2831 3029 0a0a 2020  f.f.read(10)..  
+0000c120: 2020 2020 2020 6f70 7469 6f6e 7320 3d20        options = 
+0000c130: 7365 6c66 2e66 2e72 6561 6428 626c 6f63  self.f.read(bloc
+0000c140: 6b6c 656e 202d 2032 3829 0a20 2020 2020  klen - 28).     
+0000c150: 2020 2073 656c 662e 5f72 6561 645f 626c     self._read_bl
+0000c160: 6f63 6b5f 7461 696c 2862 6c6f 636b 6c65  ock_tail(blockle
+0000c170: 6e29 0a20 2020 2020 2020 2073 656c 662e  n).        self.
+0000c180: 5f72 6561 645f 6f70 7469 6f6e 7328 6f70  _read_options(op
+0000c190: 7469 6f6e 7329 0a0a 2020 2020 6465 6620  tions)..    def 
+0000c1a0: 5f72 6561 645f 7061 636b 6574 2873 656c  _read_packet(sel
+0000c1b0: 662c 2073 697a 653d 4d54 5529 3a20 2023  f, size=MTU):  #
+0000c1c0: 2074 7970 653a 2069 676e 6f72 650a 2020   type: ignore.  
+0000c1d0: 2020 2020 2020 2320 7479 7065 3a20 2869        # type: (i
+0000c1e0: 6e74 2920 2d3e 2054 7570 6c65 5b62 7974  nt) -> Tuple[byt
+0000c1f0: 6573 2c20 5261 7750 6361 704e 6752 6561  es, RawPcapNgRea
+0000c200: 6465 722e 5061 636b 6574 4d65 7461 6461  der.PacketMetada
+0000c210: 7461 5d0a 2020 2020 2020 2020 2222 2252  ta].        """R
+0000c220: 6561 6420 626c 6f63 6b73 2075 6e74 696c  ead blocks until
+0000c230: 2069 7420 7265 6163 6865 7320 6569 7468   it reaches eith
+0000c240: 6572 2045 4f46 206f 7220 6120 7061 636b  er EOF or a pack
+0000c250: 6574 2c20 616e 640a 2020 2020 2020 2020  et, and.        
+0000c260: 7265 7475 726e 7320 4e6f 6e65 206f 7220  returns None or 
+0000c270: 2870 6163 6b65 742c 2028 6c69 6e6b 7479  (packet, (linkty
+0000c280: 7065 2c20 7365 632c 2075 7365 632c 2077  pe, sec, usec, w
+0000c290: 6972 656c 656e 2929 2c0a 2020 2020 2020  irelen)),.      
+0000c2a0: 2020 7768 6572 6520 7061 636b 6574 2069    where packet i
+0000c2b0: 7320 6120 7374 7269 6e67 2e0a 0a20 2020  s a string...   
+0000c2c0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000c2d0: 2077 6869 6c65 2054 7275 653a 0a20 2020   while True:.   
+0000c2e0: 2020 2020 2020 2020 2072 6573 203d 2073           res = s
+0000c2f0: 656c 662e 5f72 6561 645f 626c 6f63 6b28  elf._read_block(
+0000c300: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+0000c310: 2072 6573 2069 7320 6e6f 7420 4e6f 6e65   res is not None
+0000c320: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000c330: 2020 7265 7475 726e 2072 6573 0a0a 2020    return res..  
+0000c340: 2020 6465 6620 5f72 6561 645f 6f70 7469    def _read_opti
+0000c350: 6f6e 7328 7365 6c66 2c20 6f70 7469 6f6e  ons(self, option
+0000c360: 7329 3a0a 2020 2020 2020 2020 2320 7479  s):.        # ty
+0000c370: 7065 3a20 2862 7974 6573 2920 2d3e 2044  pe: (bytes) -> D
+0000c380: 6963 745b 696e 742c 2062 7974 6573 5d0a  ict[int, bytes].
+0000c390: 2020 2020 2020 2020 6f70 7473 203d 2064          opts = d
+0000c3a0: 6963 7428 290a 2020 2020 2020 2020 7768  ict().        wh
+0000c3b0: 696c 6520 6c65 6e28 6f70 7469 6f6e 7329  ile len(options)
+0000c3c0: 203e 3d20 343a 0a20 2020 2020 2020 2020   >= 4:.         
+0000c3d0: 2020 2063 6f64 652c 206c 656e 6774 6820     code, length 
+0000c3e0: 3d20 7374 7275 6374 2e75 6e70 6163 6b28  = struct.unpack(
+0000c3f0: 7365 6c66 2e65 6e64 6961 6e20 2b20 2248  self.endian + "H
+0000c400: 4822 2c20 6f70 7469 6f6e 735b 3a34 5d29  H", options[:4])
+0000c410: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000c420: 636f 6465 2021 3d20 3020 616e 6420 3420  code != 0 and 4 
+0000c430: 2b20 6c65 6e67 7468 203c 206c 656e 286f  + length < len(o
+0000c440: 7074 696f 6e73 293a 0a20 2020 2020 2020  ptions):.       
+0000c450: 2020 2020 2020 2020 206f 7074 735b 636f           opts[co
+0000c460: 6465 5d20 3d20 6f70 7469 6f6e 735b 343a  de] = options[4:
+0000c470: 3420 2b20 6c65 6e67 7468 5d0a 2020 2020  4 + length].    
+0000c480: 2020 2020 2020 2020 6966 2063 6f64 6520          if code 
+0000c490: 3d3d 2030 3a0a 2020 2020 2020 2020 2020  == 0:.          
+0000c4a0: 2020 2020 2020 6966 206c 656e 6774 6820        if length 
+0000c4b0: 213d 2030 3a0a 2020 2020 2020 2020 2020  != 0:.          
+0000c4c0: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
+0000c4d0: 6728 2250 6361 704e 673a 2069 6e76 616c  g("PcapNg: inval
+0000c4e0: 6964 206f 7074 696f 6e20 220a 2020 2020  id option ".    
 0000c4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c510: 2074 736c 6f77 3d4e 6f6e 652c 0a20 2020   tslow=None,.   
-0000c520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c500: 2020 2020 2020 2020 226c 656e 6774 6820          "length 
+0000c510: 2564 2066 6f72 2065 6e64 2d6f 662d 6f70  %d for end-of-op
+0000c520: 7469 6f6e 2220 2520 6c65 6e67 7468 290a  tion" % length).
 0000c530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c540: 2020 2020 2020 2020 2020 2020 7769 7265              wire
-0000c550: 6c65 6e3d 7769 7265 6c65 6e2c 0a20 2020  len=wirelen,.   
-0000c560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c580: 2020 2020 2020 2020 2020 2020 636f 6d6d              comm
-0000c590: 656e 743d 4e6f 6e65 2929 0a0a 2020 2020  ent=None))..    
-0000c5a0: 6465 6620 5f72 6561 645f 626c 6f63 6b5f  def _read_block_
-0000c5b0: 706b 7428 7365 6c66 2c20 626c 6f63 6b2c  pkt(self, block,
-0000c5c0: 2073 697a 6529 3a0a 2020 2020 2020 2020   size):.        
-0000c5d0: 2320 7479 7065 3a20 2862 7974 6573 2c20  # type: (bytes, 
-0000c5e0: 696e 7429 202d 3e20 5475 706c 655b 6279  int) -> Tuple[by
-0000c5f0: 7465 732c 2052 6177 5063 6170 4e67 5265  tes, RawPcapNgRe
-0000c600: 6164 6572 2e50 6163 6b65 744d 6574 6164  ader.PacketMetad
-0000c610: 6174 615d 0a20 2020 2020 2020 2022 2222  ata].        """
-0000c620: 284f 6273 6f6c 6574 6529 2050 6163 6b65  (Obsolete) Packe
-0000c630: 7420 426c 6f63 6b22 2222 0a20 2020 2020  t Block""".     
-0000c640: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-0000c650: 2020 2020 696e 7469 642c 2064 726f 7073      intid, drops
-0000c660: 2c20 7473 6869 6768 2c20 7473 6c6f 772c  , tshigh, tslow,
-0000c670: 2063 6170 6c65 6e2c 2077 6972 656c 656e   caplen, wirelen
-0000c680: 203d 2073 7472 7563 742e 756e 7061 636b   = struct.unpack
-0000c690: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000c6a0: 2020 7365 6c66 2e65 6e64 6961 6e20 2b20    self.endian + 
-0000c6b0: 2248 4834 4922 2c0a 2020 2020 2020 2020  "HH4I",.        
-0000c6c0: 2020 2020 2020 2020 626c 6f63 6b5b 3a32          block[:2
-0000c6d0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
-0000c6e0: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
-0000c6f0: 2073 7472 7563 742e 6572 726f 723a 0a20   struct.error:. 
-0000c700: 2020 2020 2020 2020 2020 2077 6172 6e69             warni
-0000c710: 6e67 2822 5063 6170 4e67 3a20 504b 5420  ng("PcapNg: PKT 
-0000c720: 6973 2074 6f6f 2073 6d61 6c6c 2025 642f  is too small %d/
-0000c730: 3230 2021 2220 2520 6c65 6e28 626c 6f63  20 !" % len(bloc
-0000c740: 6b29 290a 2020 2020 2020 2020 2020 2020  k)).            
-0000c750: 7261 6973 6520 454f 4645 7272 6f72 0a0a  raise EOFError..
-0000c760: 2020 2020 2020 2020 7365 6c66 2e5f 6368          self._ch
-0000c770: 6563 6b5f 696e 7465 7266 6163 655f 6964  eck_interface_id
-0000c780: 2869 6e74 6964 290a 2020 2020 2020 2020  (intid).        
-0000c790: 7265 7475 726e 2028 626c 6f63 6b5b 3230  return (block[20
-0000c7a0: 3a32 3020 2b20 6361 706c 656e 5d5b 3a73  :20 + caplen][:s
-0000c7b0: 697a 655d 2c0a 2020 2020 2020 2020 2020  ize],.          
-0000c7c0: 2020 2020 2020 5261 7750 6361 704e 6752        RawPcapNgR
-0000c7d0: 6561 6465 722e 5061 636b 6574 4d65 7461  eader.PacketMeta
-0000c7e0: 6461 7461 286c 696e 6b74 7970 653d 7365  data(linktype=se
-0000c7f0: 6c66 2e69 6e74 6572 6661 6365 735b 696e  lf.interfaces[in
-0000c800: 7469 645d 5b30 5d2c 2020 2320 6e6f 7161  tid][0],  # noqa
-0000c810: 3a20 4535 3031 0a20 2020 2020 2020 2020  : E501.         
+0000c540: 6272 6561 6b0a 2020 2020 2020 2020 2020  break.          
+0000c550: 2020 6966 206c 656e 6774 6820 2520 343a    if length % 4:
+0000c560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c570: 206c 656e 6774 6820 2b3d 2028 3420 2d20   length += (4 - 
+0000c580: 286c 656e 6774 6820 2520 3429 290a 2020  (length % 4)).  
+0000c590: 2020 2020 2020 2020 2020 6f70 7469 6f6e            option
+0000c5a0: 7320 3d20 6f70 7469 6f6e 735b 3420 2b20  s = options[4 + 
+0000c5b0: 6c65 6e67 7468 3a5d 0a20 2020 2020 2020  length:].       
+0000c5c0: 2072 6574 7572 6e20 6f70 7473 0a0a 2020   return opts..  
+0000c5d0: 2020 6465 6620 5f72 6561 645f 626c 6f63    def _read_bloc
+0000c5e0: 6b5f 6964 6228 7365 6c66 2c20 626c 6f63  k_idb(self, bloc
+0000c5f0: 6b2c 205f 293a 0a20 2020 2020 2020 2023  k, _):.        #
+0000c600: 2074 7970 653a 2028 6279 7465 732c 2069   type: (bytes, i
+0000c610: 6e74 2920 2d3e 204e 6f6e 650a 2020 2020  nt) -> None.    
+0000c620: 2020 2020 2222 2249 6e74 6572 6661 6365      """Interface
+0000c630: 2044 6573 6372 6970 7469 6f6e 2042 6c6f   Description Blo
+0000c640: 636b 2222 220a 2020 2020 2020 2020 2320  ck""".        # 
+0000c650: 3220 6279 7465 7320 4c69 6e6b 5479 7065  2 bytes LinkType
+0000c660: 202b 2032 2062 7974 6573 2052 6573 6572   + 2 bytes Reser
+0000c670: 7665 640a 2020 2020 2020 2020 2320 3420  ved.        # 4 
+0000c680: 6279 7465 7320 536e 6170 6c65 6e0a 2020  bytes Snaplen.  
+0000c690: 2020 2020 2020 6f70 7469 6f6e 735f 7261        options_ra
+0000c6a0: 7720 3d20 7365 6c66 2e5f 7265 6164 5f6f  w = self._read_o
+0000c6b0: 7074 696f 6e73 2862 6c6f 636b 5b38 3a5d  ptions(block[8:]
+0000c6c0: 290a 2020 2020 2020 2020 6f70 7469 6f6e  ).        option
+0000c6d0: 7320 3d20 7365 6c66 2e64 6566 6175 6c74  s = self.default
+0000c6e0: 5f6f 7074 696f 6e73 2e63 6f70 7928 2920  _options.copy() 
+0000c6f0: 2023 2074 7970 653a 2044 6963 745b 7374   # type: Dict[st
+0000c700: 722c 2041 6e79 5d0a 2020 2020 2020 2020  r, Any].        
+0000c710: 666f 7220 632c 2076 2069 6e20 6f70 7469  for c, v in opti
+0000c720: 6f6e 735f 7261 772e 6974 656d 7328 293a  ons_raw.items():
+0000c730: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000c740: 6320 3d3d 2039 3a0a 2020 2020 2020 2020  c == 9:.        
+0000c750: 2020 2020 2020 2020 6c65 6e67 7468 203d          length =
+0000c760: 206c 656e 2876 290a 2020 2020 2020 2020   len(v).        
+0000c770: 2020 2020 2020 2020 6966 206c 656e 6774          if lengt
+0000c780: 6820 3d3d 2031 3a0a 2020 2020 2020 2020  h == 1:.        
+0000c790: 2020 2020 2020 2020 2020 2020 7473 7265              tsre
+0000c7a0: 736f 6c20 3d20 6f72 6228 7629 0a20 2020  sol = orb(v).   
+0000c7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7c0: 206f 7074 696f 6e73 5b22 7473 7265 736f   options["tsreso
+0000c7d0: 6c22 5d20 3d20 2832 2069 6620 7473 7265  l"] = (2 if tsre
+0000c7e0: 736f 6c20 2620 3132 3820 656c 7365 2031  sol & 128 else 1
+0000c7f0: 3029 202a 2a20 280a 2020 2020 2020 2020  0) ** (.        
+0000c800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c810: 7473 7265 736f 6c20 2620 3132 370a 2020  tsresol & 127.  
 0000c820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c840: 2020 2020 2020 7473 7265 736f 6c3d 7365        tsresol=se
-0000c850: 6c66 2e69 6e74 6572 6661 6365 735b 696e  lf.interfaces[in
-0000c860: 7469 645d 5b32 5d2c 2020 2320 6e6f 7161  tid][2],  # noqa
-0000c870: 3a20 4535 3031 0a20 2020 2020 2020 2020  : E501.         
-0000c880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8a0: 2020 2020 2020 7473 6869 6768 3d74 7368        tshigh=tsh
-0000c8b0: 6967 682c 0a20 2020 2020 2020 2020 2020  igh,.           
-0000c8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8e0: 2020 2020 7473 6c6f 773d 7473 6c6f 772c      tslow=tslow,
-0000c8f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c920: 7769 7265 6c65 6e3d 7769 7265 6c65 6e2c  wirelen=wirelen,
-0000c930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c960: 636f 6d6d 656e 743d 4e6f 6e65 2929 0a0a  comment=None))..
-0000c970: 2020 2020 6465 6620 5f72 6561 645f 626c      def _read_bl
-0000c980: 6f63 6b5f 6473 6228 7365 6c66 2c20 626c  ock_dsb(self, bl
-0000c990: 6f63 6b2c 2073 697a 6529 3a0a 2020 2020  ock, size):.    
-0000c9a0: 2020 2020 2320 7479 7065 3a20 2862 7974      # type: (byt
-0000c9b0: 6573 2c20 696e 7429 202d 3e20 4e6f 6e65  es, int) -> None
-0000c9c0: 0a20 2020 2020 2020 2022 2222 4465 6372  .        """Decr
-0000c9d0: 7970 7469 6f6e 2053 6563 7265 7473 2042  yption Secrets B
-0000c9e0: 6c6f 636b 2222 220a 0a20 2020 2020 2020  lock"""..       
-0000c9f0: 2023 2050 6172 7365 2074 6865 2073 6563   # Parse the sec
-0000ca00: 7265 7473 2074 7970 6520 616e 6420 6c65  rets type and le
-0000ca10: 6e67 7468 2066 6965 6c64 730a 2020 2020  ngth fields.    
-0000ca20: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-0000ca30: 2020 2020 2073 6563 7265 7473 5f74 7970       secrets_typ
-0000ca40: 652c 2073 6563 7265 7473 5f6c 656e 6774  e, secrets_lengt
-0000ca50: 6820 3d20 7374 7275 6374 2e75 6e70 6163  h = struct.unpac
-0000ca60: 6b28 0a20 2020 2020 2020 2020 2020 2020  k(.             
-0000ca70: 2020 2073 656c 662e 656e 6469 616e 202b     self.endian +
-0000ca80: 2022 4949 222c 0a20 2020 2020 2020 2020   "II",.         
-0000ca90: 2020 2020 2020 2062 6c6f 636b 5b3a 385d         block[:8]
-0000caa0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
-0000cab0: 2020 2020 2020 2020 2020 2020 626c 6f63              bloc
-0000cac0: 6b20 3d20 626c 6f63 6b5b 383a 5d0a 2020  k = block[8:].  
-0000cad0: 2020 2020 2020 6578 6365 7074 2073 7472        except str
-0000cae0: 7563 742e 6572 726f 723a 0a20 2020 2020  uct.error:.     
-0000caf0: 2020 2020 2020 2077 6172 6e69 6e67 2822         warning("
-0000cb00: 5063 6170 4e67 3a20 4453 4220 6973 2074  PcapNg: DSB is t
-0000cb10: 6f6f 2073 6d61 6c6c 2025 6421 222c 206c  oo small %d!", l
-0000cb20: 656e 2862 6c6f 636b 2929 0a20 2020 2020  en(block)).     
-0000cb30: 2020 2020 2020 2072 6169 7365 2045 4f46         raise EOF
-0000cb40: 4572 726f 720a 0a20 2020 2020 2020 2023  Error..        #
-0000cb50: 2043 6f6d 7075 7465 2074 6865 2073 6563   Compute the sec
-0000cb60: 7265 7473 206c 656e 6774 6820 696e 636c  rets length incl
-0000cb70: 7564 696e 6720 7468 6520 7061 6464 696e  uding the paddin
-0000cb80: 670a 2020 2020 2020 2020 7061 6464 6564  g.        padded
-0000cb90: 5f73 6563 7265 7473 5f6c 656e 6774 6820  _secrets_length 
-0000cba0: 3d20 7365 6372 6574 735f 6c65 6e67 7468  = secrets_length
-0000cbb0: 202b 2028 2d73 6563 7265 7473 5f6c 656e   + (-secrets_len
-0000cbc0: 6774 6829 2025 2034 0a20 2020 2020 2020  gth) % 4.       
-0000cbd0: 2069 6620 6c65 6e28 626c 6f63 6b29 203c   if len(block) <
-0000cbe0: 2070 6164 6465 645f 7365 6372 6574 735f   padded_secrets_
-0000cbf0: 6c65 6e67 7468 3a0a 2020 2020 2020 2020  length:.        
-0000cc00: 2020 2020 7761 726e 696e 6728 2250 6361      warning("Pca
-0000cc10: 704e 673a 2069 6e76 616c 6964 2044 5342  pNg: invalid DSB
-0000cc20: 2073 6563 7265 7473 206c 656e 6774 6821   secrets length!
-0000cc30: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
-0000cc40: 6169 7365 2045 4f46 4572 726f 720a 0a20  aise EOFError.. 
-0000cc50: 2020 2020 2020 2023 2045 7874 7261 6374         # Extract
-0000cc60: 2073 6563 7265 7473 2064 6174 6120 616e   secrets data an
-0000cc70: 6420 6f70 7469 6f6e 730a 2020 2020 2020  d options.      
-0000cc80: 2020 7365 6372 6574 735f 6461 7461 203d    secrets_data =
-0000cc90: 2062 6c6f 636b 5b3a 7061 6464 6564 5f73   block[:padded_s
-0000cca0: 6563 7265 7473 5f6c 656e 6774 685d 5b3a  ecrets_length][:
-0000ccb0: 7365 6372 6574 735f 6c65 6e67 7468 5d0a  secrets_length].
-0000ccc0: 2020 2020 2020 2020 6966 2062 6c6f 636b          if block
-0000ccd0: 5b70 6164 6465 645f 7365 6372 6574 735f  [padded_secrets_
-0000cce0: 6c65 6e67 7468 3a5d 3a0a 2020 2020 2020  length:]:.      
-0000ccf0: 2020 2020 2020 7761 726e 696e 6728 2250        warning("P
-0000cd00: 6361 704e 673a 2044 5342 206f 7074 696f  capNg: DSB optio
-0000cd10: 6e73 2061 7265 206e 6f74 2073 7570 706f  ns are not suppo
-0000cd20: 7274 6564 2122 290a 0a20 2020 2020 2020  rted!")..       
-0000cd30: 2023 2054 4c53 204b 6579 204c 6f67 0a20   # TLS Key Log. 
-0000cd40: 2020 2020 2020 2069 6620 7365 6372 6574         if secret
-0000cd50: 735f 7479 7065 203d 3d20 3078 3534 3463  s_type == 0x544c
-0000cd60: 3533 3462 3a0a 2020 2020 2020 2020 2020  534b:.          
-0000cd70: 2020 6966 2067 6574 6174 7472 2863 6f6e    if getattr(con
-0000cd80: 662c 2022 746c 735f 6e73 735f 6b65 7973  f, "tls_nss_keys
-0000cd90: 222c 2046 616c 7365 2920 6973 2046 616c  ", False) is Fal
-0000cda0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000cdb0: 2020 2020 7761 726e 696e 6728 2250 6361      warning("Pca
-0000cdc0: 704e 673a 2054 4c53 204b 6579 204c 6f67  pNg: TLS Key Log
-0000cdd0: 2061 7661 696c 6162 6c65 2c20 6275 7420   available, but 
-0000cde0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000cdf0: 2020 2020 2020 2020 2020 2274 6865 2054            "the T
-0000ce00: 4c53 206c 6179 6572 2069 7320 6e6f 7420  LS layer is not 
-0000ce10: 6c6f 6164 6564 2120 5363 6170 7920 776f  loaded! Scapy wo
-0000ce20: 6e27 7420 6265 2061 626c 6520 220a 2020  n't be able ".  
-0000ce30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ce40: 2020 2020 2020 2274 6f20 6465 6372 7970        "to decryp
-0000ce50: 7420 7468 6520 7061 636b 6574 732e 2229  t the packets.")
-0000ce60: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-0000ce70: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000ce80: 2020 2066 726f 6d20 7363 6170 792e 6c61     from scapy.la
-0000ce90: 7965 7273 2e74 6c73 2e73 6573 7369 6f6e  yers.tls.session
-0000cea0: 2069 6d70 6f72 7420 6c6f 6164 5f6e 7373   import load_nss
-0000ceb0: 5f6b 6579 730a 0a20 2020 2020 2020 2020  _keys..         
-0000cec0: 2020 2020 2020 2023 2057 7269 7465 204b         # Write K
-0000ced0: 6579 204c 6f67 2074 6f20 6120 6669 6c65  ey Log to a file
-0000cee0: 2061 6e64 2070 6172 7365 2069 740a 2020   and parse it.  
-0000cef0: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-0000cf00: 6c65 6e61 6d65 203d 2067 6574 5f74 656d  lename = get_tem
-0000cf10: 705f 6669 6c65 2829 0a20 2020 2020 2020  p_file().       
-0000cf20: 2020 2020 2020 2020 2077 6974 6820 6f70           with op
-0000cf30: 656e 2866 696c 656e 616d 652c 2022 7762  en(filename, "wb
-0000cf40: 2229 2061 7320 6664 3a0a 2020 2020 2020  ") as fd:.      
-0000cf50: 2020 2020 2020 2020 2020 2020 2020 6664                fd
-0000cf60: 2e77 7269 7465 2873 6563 7265 7473 5f64  .write(secrets_d
-0000cf70: 6174 6129 0a20 2020 2020 2020 2020 2020  ata).           
-0000cf80: 2020 2020 2020 2020 2066 642e 636c 6f73           fd.clos
-0000cf90: 6528 290a 0a20 2020 2020 2020 2020 2020  e()..           
-0000cfa0: 2020 2020 206b 6579 7320 3d20 6c6f 6164       keys = load
-0000cfb0: 5f6e 7373 5f6b 6579 7328 6669 6c65 6e61  _nss_keys(filena
-0000cfc0: 6d65 290a 2020 2020 2020 2020 2020 2020  me).            
-0000cfd0: 2020 2020 6966 206e 6f74 206b 6579 733a      if not keys:
-0000cfe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cff0: 2020 2020 2077 6172 6e69 6e67 2822 5063       warning("Pc
-0000d000: 6170 4e67 3a20 696e 7661 6c69 6420 544c  apNg: invalid TL
-0000d010: 5320 4b65 7920 4c6f 6720 696e 2044 5342  S Key Log in DSB
-0000d020: 2122 290a 2020 2020 2020 2020 2020 2020  !").            
-0000d030: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000d040: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000d050: 4e6f 7465 3a20 7468 6573 6520 6174 7472  Note: these attr
-0000d060: 6962 7574 6573 2061 7265 206f 6e6c 7920  ibutes are only 
-0000d070: 6176 6169 6c61 626c 6520 7768 656e 2074  available when t
-0000d080: 6865 2054 4c53 0a20 2020 2020 2020 2020  he TLS.         
-0000d090: 2020 2020 2020 2020 2020 2023 2020 2020             #    
-0000d0a0: 2020 206c 6179 6572 2069 7320 6c6f 6164     layer is load
-0000d0b0: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
-0000d0c0: 2020 2020 2020 2020 636f 6e66 2e74 6c73          conf.tls
-0000d0d0: 5f6e 7373 5f6b 6579 7320 3d20 6b65 7973  _nss_keys = keys
-0000d0e0: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-0000d0f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d100: 2020 2020 2063 6f6e 662e 746c 735f 7365       conf.tls_se
-0000d110: 7373 696f 6e5f 656e 6162 6c65 203d 2054  ssion_enable = T
-0000d120: 7275 6520 2023 2074 7970 653a 2069 676e  rue  # type: ign
-0000d130: 6f72 650a 2020 2020 2020 2020 656c 7365  ore.        else
-0000d140: 3a0a 2020 2020 2020 2020 2020 2020 7761  :.            wa
-0000d150: 726e 696e 6728 2250 6361 704e 673a 2055  rning("PcapNg: U
-0000d160: 6e6b 6e6f 776e 2044 5342 2073 6563 7265  nknown DSB secre
-0000d170: 7473 2074 7970 6520 2830 7825 7829 2122  ts type (0x%x)!"
-0000d180: 2c20 7365 6372 6574 735f 7479 7065 290a  , secrets_type).
-0000d190: 0a0a 636c 6173 7320 5063 6170 4e67 5265  ..class PcapNgRe
-0000d1a0: 6164 6572 2852 6177 5063 6170 4e67 5265  ader(RawPcapNgRe
-0000d1b0: 6164 6572 2c20 5063 6170 5265 6164 6572  ader, PcapReader
-0000d1c0: 2c20 5f53 7570 6572 536f 636b 6574 293a  , _SuperSocket):
-0000d1d0: 0a0a 2020 2020 616c 7465 726e 6174 6976  ..    alternativ
-0000d1e0: 6520 3d20 5063 6170 5265 6164 6572 0a0a  e = PcapReader..
-0000d1f0: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-0000d200: 2873 656c 662c 2066 696c 656e 616d 652c  (self, filename,
-0000d210: 2066 6465 7363 3d4e 6f6e 652c 206d 6167   fdesc=None, mag
-0000d220: 6963 3d4e 6f6e 6529 3a20 2023 2074 7970  ic=None):  # typ
-0000d230: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
-0000d240: 2020 2320 7479 7065 3a20 2873 7472 2c20    # type: (str, 
-0000d250: 494f 5b62 7974 6573 5d2c 2062 7974 6573  IO[bytes], bytes
-0000d260: 2920 2d3e 204e 6f6e 650a 2020 2020 2020  ) -> None.      
-0000d270: 2020 5261 7750 6361 704e 6752 6561 6465    RawPcapNgReade
-0000d280: 722e 5f5f 696e 6974 5f5f 2873 656c 662c  r.__init__(self,
-0000d290: 2066 696c 656e 616d 652c 2066 6465 7363   filename, fdesc
-0000d2a0: 2c20 6d61 6769 6329 0a0a 2020 2020 6465  , magic)..    de
-0000d2b0: 6620 5f5f 656e 7465 725f 5f28 7365 6c66  f __enter__(self
-0000d2c0: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
-0000d2d0: 653a 2028 2920 2d3e 2050 6361 704e 6752  e: () -> PcapNgR
-0000d2e0: 6561 6465 720a 2020 2020 2020 2020 7265  eader.        re
-0000d2f0: 7475 726e 2073 656c 660a 0a20 2020 2064  turn self..    d
-0000d300: 6566 2072 6561 645f 7061 636b 6574 2873  ef read_packet(s
-0000d310: 656c 662c 2073 697a 653d 4d54 5529 3a0a  elf, size=MTU):.
-0000d320: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-0000d330: 2869 6e74 2920 2d3e 2050 6163 6b65 740a  (int) -> Packet.
-0000d340: 2020 2020 2020 2020 7270 203d 2073 7570          rp = sup
-0000d350: 6572 2850 6361 704e 6752 6561 6465 722c  er(PcapNgReader,
-0000d360: 2073 656c 6629 2e5f 7265 6164 5f70 6163   self)._read_pac
-0000d370: 6b65 7428 7369 7a65 3d73 697a 6529 0a20  ket(size=size). 
-0000d380: 2020 2020 2020 2069 6620 7270 2069 7320         if rp is 
-0000d390: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000d3a0: 2020 7261 6973 6520 454f 4645 7272 6f72    raise EOFError
-0000d3b0: 0a20 2020 2020 2020 2073 2c20 286c 696e  .        s, (lin
-0000d3c0: 6b74 7970 652c 2074 7372 6573 6f6c 2c20  ktype, tsresol, 
-0000d3d0: 7473 6869 6768 2c20 7473 6c6f 772c 2077  tshigh, tslow, w
-0000d3e0: 6972 656c 656e 2c20 636f 6d6d 656e 7429  irelen, comment)
-0000d3f0: 203d 2072 700a 2020 2020 2020 2020 7472   = rp.        tr
-0000d400: 793a 0a20 2020 2020 2020 2020 2020 2063  y:.            c
-0000d410: 6c73 203d 2063 6f6e 662e 6c32 7479 7065  ls = conf.l2type
-0000d420: 732e 6e75 6d32 6c61 7965 725b 6c69 6e6b  s.num2layer[link
-0000d430: 7479 7065 5d20 2023 2074 7970 653a 2054  type]  # type: T
-0000d440: 7970 655b 5061 636b 6574 5d0a 2020 2020  ype[Packet].    
-0000d450: 2020 2020 2020 2020 7020 3d20 636c 7328          p = cls(
-0000d460: 7329 2020 2320 7479 7065 3a20 5061 636b  s)  # type: Pack
-0000d470: 6574 0a20 2020 2020 2020 2065 7863 6570  et.        excep
-0000d480: 7420 4b65 7962 6f61 7264 496e 7465 7272  t KeyboardInterr
-0000d490: 7570 743a 0a20 2020 2020 2020 2020 2020  upt:.           
-0000d4a0: 2072 6169 7365 0a20 2020 2020 2020 2065   raise.        e
-0000d4b0: 7863 6570 7420 4578 6365 7074 696f 6e3a  xcept Exception:
-0000d4c0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000d4d0: 636f 6e66 2e64 6562 7567 5f64 6973 7365  conf.debug_disse
-0000d4e0: 6374 6f72 3a0a 2020 2020 2020 2020 2020  ctor:.          
-0000d4f0: 2020 2020 2020 7261 6973 650a 2020 2020        raise.    
-0000d500: 2020 2020 2020 2020 6966 2063 6f6e 662e          if conf.
-0000d510: 7261 775f 6c61 7965 7220 6973 204e 6f6e  raw_layer is Non
-0000d520: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000d530: 2020 2023 2063 6f6e 662e 7261 775f 6c61     # conf.raw_la
-0000d540: 7965 7220 6973 2073 6574 206f 6e20 696d  yer is set on im
-0000d550: 706f 7274 0a20 2020 2020 2020 2020 2020  port.           
-0000d560: 2020 2020 2069 6d70 6f72 7420 7363 6170       import scap
-0000d570: 792e 7061 636b 6574 2020 2320 6e6f 7161  y.packet  # noqa
-0000d580: 3a20 4634 3031 0a20 2020 2020 2020 2020  : F401.         
-0000d590: 2020 2070 203d 2063 6f6e 662e 7261 775f     p = conf.raw_
-0000d5a0: 6c61 7965 7228 7329 0a20 2020 2020 2020  layer(s).       
-0000d5b0: 2069 6620 7473 6869 6768 2069 7320 6e6f   if tshigh is no
-0000d5c0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-0000d5d0: 2020 2020 702e 7469 6d65 203d 2045 4465      p.time = EDe
-0000d5e0: 6369 6d61 6c28 2874 7368 6967 6820 3c3c  cimal((tshigh <<
-0000d5f0: 2033 3229 202b 2074 736c 6f77 2920 2f20   32) + tslow) / 
-0000d600: 7473 7265 736f 6c0a 2020 2020 2020 2020  tsresol.        
-0000d610: 702e 7769 7265 6c65 6e20 3d20 7769 7265  p.wirelen = wire
-0000d620: 6c65 6e0a 2020 2020 2020 2020 702e 636f  len.        p.co
-0000d630: 6d6d 656e 7420 3d20 636f 6d6d 656e 740a  mment = comment.
-0000d640: 2020 2020 2020 2020 7265 7475 726e 2070          return p
-0000d650: 0a0a 2020 2020 6465 6620 7265 6376 2873  ..    def recv(s
-0000d660: 656c 662c 2073 697a 653d 4d54 5529 3a0a  elf, size=MTU):.
-0000d670: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-0000d680: 2869 6e74 2920 2d3e 2050 6163 6b65 740a  (int) -> Packet.
-0000d690: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0000d6a0: 656c 662e 7265 6164 5f70 6163 6b65 7428  elf.read_packet(
-0000d6b0: 290a 0a0a 636c 6173 7320 4765 6e65 7269  )...class Generi
-0000d6c0: 6350 6361 7057 7269 7465 7228 6f62 6a65  cPcapWriter(obje
-0000d6d0: 6374 293a 0a20 2020 206e 616e 6f20 3d20  ct):.    nano = 
-0000d6e0: 4661 6c73 650a 2020 2020 6c69 6e6b 7479  False.    linkty
-0000d6f0: 7065 203d 204e 6f6e 6520 2023 2074 7970  pe = None  # typ
-0000d700: 653a 204f 7074 696f 6e61 6c5b 696e 745d  e: Optional[int]
-0000d710: 0a0a 2020 2020 6465 6620 5f77 7269 7465  ..    def _write
-0000d720: 5f68 6561 6465 7228 7365 6c66 2c20 706b  _header(self, pk
-0000d730: 7429 3a0a 2020 2020 2020 2020 2320 7479  t):.        # ty
-0000d740: 7065 3a20 284f 7074 696f 6e61 6c5b 556e  pe: (Optional[Un
-0000d750: 696f 6e5b 5061 636b 6574 2c20 6279 7465  ion[Packet, byte
-0000d760: 735d 5d29 202d 3e20 4e6f 6e65 0a20 2020  s]]) -> None.   
-0000d770: 2020 2020 2072 6169 7365 204e 6f74 496d       raise NotIm
-0000d780: 706c 656d 656e 7465 6445 7272 6f72 0a0a  plementedError..
-0000d790: 2020 2020 6465 6620 5f77 7269 7465 5f70      def _write_p
-0000d7a0: 6163 6b65 7428 7365 6c66 2c0a 2020 2020  acket(self,.    
+0000c830: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000c840: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000c850: 2020 2020 2020 2020 2020 2020 2020 7761                wa
+0000c860: 726e 696e 6728 2250 6361 704e 673a 2069  rning("PcapNg: i
+0000c870: 6e76 616c 6964 206f 7074 696f 6e73 2022  nvalid options "
+0000c880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c890: 2020 2020 2020 2020 2020 2020 2022 6c65               "le
+0000c8a0: 6e67 7468 2025 6420 666f 7220 4944 4220  ngth %d for IDB 
+0000c8b0: 7473 7265 736f 6c22 2025 206c 656e 6774  tsresol" % lengt
+0000c8c0: 6829 0a20 2020 2020 2020 2020 2020 2065  h).            e
+0000c8d0: 6c69 6620 6320 3d3d 2032 3a0a 2020 2020  lif c == 2:.    
+0000c8e0: 2020 2020 2020 2020 2020 2020 6f70 7469              opti
+0000c8f0: 6f6e 735b 226e 616d 6522 5d20 3d20 760a  ons["name"] = v.
+0000c900: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+0000c910: 2063 203d 3d20 313a 0a20 2020 2020 2020   c == 1:.       
+0000c920: 2020 2020 2020 2020 206f 7074 696f 6e73           options
+0000c930: 5b22 636f 6d6d 656e 7422 5d20 3d20 760a  ["comment"] = v.
+0000c940: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+0000c950: 2020 2020 2020 2020 2069 6e74 6572 6661           interfa
+0000c960: 6365 3a20 5475 706c 655b 696e 742c 2069  ce: Tuple[int, i
+0000c970: 6e74 2c20 4469 6374 5b73 7472 2c20 416e  nt, Dict[str, An
+0000c980: 795d 5d20 3d20 7374 7275 6374 2e75 6e70  y]] = struct.unp
+0000c990: 6163 6b28 0a20 2020 2020 2020 2020 2020  ack(.           
+0000c9a0: 2020 2020 2073 656c 662e 656e 6469 616e       self.endian
+0000c9b0: 202b 2022 4878 7849 222c 0a20 2020 2020   + "HxxI",.     
+0000c9c0: 2020 2020 2020 2020 2020 2062 6c6f 636b             block
+0000c9d0: 5b3a 385d 0a20 2020 2020 2020 2020 2020  [:8].           
+0000c9e0: 2029 202b 2028 6f70 7469 6f6e 732c 290a   ) + (options,).
+0000c9f0: 2020 2020 2020 2020 6578 6365 7074 2073          except s
+0000ca00: 7472 7563 742e 6572 726f 723a 0a20 2020  truct.error:.   
+0000ca10: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
+0000ca20: 2822 5063 6170 4e67 3a20 4944 4220 6973  ("PcapNg: IDB is
+0000ca30: 2074 6f6f 2073 6d61 6c6c 2025 642f 3820   too small %d/8 
+0000ca40: 2122 2025 206c 656e 2862 6c6f 636b 2929  !" % len(block))
+0000ca50: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+0000ca60: 7365 2045 4f46 4572 726f 720a 2020 2020  se EOFError.    
+0000ca70: 2020 2020 7365 6c66 2e69 6e74 6572 6661      self.interfa
+0000ca80: 6365 732e 6170 7065 6e64 2869 6e74 6572  ces.append(inter
+0000ca90: 6661 6365 290a 0a20 2020 2064 6566 205f  face)..    def _
+0000caa0: 6368 6563 6b5f 696e 7465 7266 6163 655f  check_interface_
+0000cab0: 6964 2873 656c 662c 2069 6e74 6964 293a  id(self, intid):
+0000cac0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+0000cad0: 2028 696e 7429 202d 3e20 4e6f 6e65 0a20   (int) -> None. 
+0000cae0: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
+0000caf0: 7468 6520 696e 7465 7266 6163 6520 6964  the interface id
+0000cb00: 2076 616c 7565 2061 6e64 2072 6169 7365   value and raise
+0000cb10: 2045 4f46 4572 726f 7220 6966 2069 6e76   EOFError if inv
+0000cb20: 616c 6964 2e22 2222 0a20 2020 2020 2020  alid.""".       
+0000cb30: 2074 6d70 5f6c 656e 203d 206c 656e 2873   tmp_len = len(s
+0000cb40: 656c 662e 696e 7465 7266 6163 6573 290a  elf.interfaces).
+0000cb50: 2020 2020 2020 2020 6966 2069 6e74 6964          if intid
+0000cb60: 203e 3d20 746d 705f 6c65 6e3a 0a20 2020   >= tmp_len:.   
+0000cb70: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
+0000cb80: 2822 5063 6170 4e67 3a20 696e 7661 6c69  ("PcapNg: invali
+0000cb90: 6420 696e 7465 7266 6163 6520 6964 2025  d interface id %
+0000cba0: 642f 2564 2220 2520 2869 6e74 6964 2c20  d/%d" % (intid, 
+0000cbb0: 746d 705f 6c65 6e29 290a 2020 2020 2020  tmp_len)).      
+0000cbc0: 2020 2020 2020 7261 6973 6520 454f 4645        raise EOFE
+0000cbd0: 7272 6f72 0a0a 2020 2020 6465 6620 5f72  rror..    def _r
+0000cbe0: 6561 645f 626c 6f63 6b5f 6570 6228 7365  ead_block_epb(se
+0000cbf0: 6c66 2c20 626c 6f63 6b2c 2073 697a 6529  lf, block, size)
+0000cc00: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
+0000cc10: 3a20 2862 7974 6573 2c20 696e 7429 202d  : (bytes, int) -
+0000cc20: 3e20 5475 706c 655b 6279 7465 732c 2052  > Tuple[bytes, R
+0000cc30: 6177 5063 6170 4e67 5265 6164 6572 2e50  awPcapNgReader.P
+0000cc40: 6163 6b65 744d 6574 6164 6174 615d 0a20  acketMetadata]. 
+0000cc50: 2020 2020 2020 2022 2222 456e 6861 6e63         """Enhanc
+0000cc60: 6564 2050 6163 6b65 7420 426c 6f63 6b22  ed Packet Block"
+0000cc70: 2222 0a20 2020 2020 2020 2074 7279 3a0a  "".        try:.
+0000cc80: 2020 2020 2020 2020 2020 2020 696e 7469              inti
+0000cc90: 642c 2074 7368 6967 682c 2074 736c 6f77  d, tshigh, tslow
+0000cca0: 2c20 6361 706c 656e 2c20 7769 7265 6c65  , caplen, wirele
+0000ccb0: 6e20 3d20 7374 7275 6374 2e75 6e70 6163  n = struct.unpac
+0000ccc0: 6b28 0a20 2020 2020 2020 2020 2020 2020  k(.             
+0000ccd0: 2020 2073 656c 662e 656e 6469 616e 202b     self.endian +
+0000cce0: 2022 3549 222c 0a20 2020 2020 2020 2020   "5I",.         
+0000ccf0: 2020 2020 2020 2062 6c6f 636b 5b3a 3230         block[:20
+0000cd00: 5d2c 0a20 2020 2020 2020 2020 2020 2029  ],.            )
+0000cd10: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+0000cd20: 7374 7275 6374 2e65 7272 6f72 3a0a 2020  struct.error:.  
+0000cd30: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
+0000cd40: 6728 2250 6361 704e 673a 2045 5042 2069  g("PcapNg: EPB i
+0000cd50: 7320 746f 6f20 736d 616c 6c20 2564 2f32  s too small %d/2
+0000cd60: 3020 2122 2025 206c 656e 2862 6c6f 636b  0 !" % len(block
+0000cd70: 2929 0a20 2020 2020 2020 2020 2020 2072  )).            r
+0000cd80: 6169 7365 2045 4f46 4572 726f 720a 0a20  aise EOFError.. 
+0000cd90: 2020 2020 2020 2023 2043 6f6d 7075 7465         # Compute
+0000cda0: 2074 6865 206f 7074 696f 6e73 206f 6666   the options off
+0000cdb0: 7365 7420 7461 6b69 6e67 2070 6164 6469  set taking paddi
+0000cdc0: 6e67 2069 6e74 6f20 6163 636f 756e 740a  ng into account.
+0000cdd0: 2020 2020 2020 2020 6966 2063 6170 6c65          if caple
+0000cde0: 6e20 2520 343a 0a20 2020 2020 2020 2020  n % 4:.         
+0000cdf0: 2020 206f 7074 5f6f 6666 7365 7420 3d20     opt_offset = 
+0000ce00: 3230 202b 2063 6170 6c65 6e20 2b20 282d  20 + caplen + (-
+0000ce10: 6361 706c 656e 2920 2520 340a 2020 2020  caplen) % 4.    
+0000ce20: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000ce30: 2020 2020 2020 6f70 745f 6f66 6673 6574        opt_offset
+0000ce40: 203d 2032 3020 2b20 6361 706c 656e 0a0a   = 20 + caplen..
+0000ce50: 2020 2020 2020 2020 2320 5061 7273 6520          # Parse 
+0000ce60: 6f70 7469 6f6e 730a 2020 2020 2020 2020  options.        
+0000ce70: 6f70 7469 6f6e 7320 3d20 7365 6c66 2e5f  options = self._
+0000ce80: 7265 6164 5f6f 7074 696f 6e73 2862 6c6f  read_options(blo
+0000ce90: 636b 5b6f 7074 5f6f 6666 7365 743a 5d29  ck[opt_offset:])
+0000cea0: 0a20 2020 2020 2020 2063 6f6d 6d65 6e74  .        comment
+0000ceb0: 203d 206f 7074 696f 6e73 2e67 6574 2831   = options.get(1
+0000cec0: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+0000ced0: 6570 625f 666c 6167 735f 7261 7720 3d20  epb_flags_raw = 
+0000cee0: 6f70 7469 6f6e 732e 6765 7428 322c 204e  options.get(2, N
+0000cef0: 6f6e 6529 0a20 2020 2020 2020 2069 6620  one).        if 
+0000cf00: 6570 625f 666c 6167 735f 7261 773a 0a20  epb_flags_raw:. 
+0000cf10: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
+0000cf20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf30: 6570 625f 666c 6167 732c 203d 2073 7472  epb_flags, = str
+0000cf40: 7563 742e 756e 7061 636b 2873 656c 662e  uct.unpack(self.
+0000cf50: 656e 6469 616e 202b 2022 4922 2c20 6570  endian + "I", ep
+0000cf60: 625f 666c 6167 735f 7261 7729 0a20 2020  b_flags_raw).   
+0000cf70: 2020 2020 2020 2020 2065 7863 6570 7420           except 
+0000cf80: 7374 7275 6374 2e65 7272 6f72 3a0a 2020  struct.error:.  
+0000cf90: 2020 2020 2020 2020 2020 2020 2020 7761                wa
+0000cfa0: 726e 696e 6728 2250 6361 704e 673a 2045  rning("PcapNg: E
+0000cfb0: 5042 2069 6e76 616c 6964 2066 6c61 6773  PB invalid flags
+0000cfc0: 2073 697a 6522 0a20 2020 2020 2020 2020   size".         
+0000cfd0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000cfe0: 2865 7870 6563 7465 6420 3420 6279 7465  (expected 4 byte
+0000cff0: 732c 2067 6f74 2025 6429 2021 2220 2520  s, got %d) !" % 
+0000d000: 6c65 6e28 6570 625f 666c 6167 735f 7261  len(epb_flags_ra
+0000d010: 7729 290a 2020 2020 2020 2020 2020 2020  w)).            
+0000d020: 2020 2020 7261 6973 6520 454f 4645 7272      raise EOFErr
+0000d030: 6f72 0a20 2020 2020 2020 2020 2020 2064  or.            d
+0000d040: 6972 6563 7469 6f6e 203d 2065 7062 5f66  irection = epb_f
+0000d050: 6c61 6773 2026 2033 0a0a 2020 2020 2020  lags & 3..      
+0000d060: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000d070: 2020 2020 6469 7265 6374 696f 6e20 3d20      direction = 
+0000d080: 4e6f 6e65 0a0a 2020 2020 2020 2020 7365  None..        se
+0000d090: 6c66 2e5f 6368 6563 6b5f 696e 7465 7266  lf._check_interf
+0000d0a0: 6163 655f 6964 2869 6e74 6964 290a 2020  ace_id(intid).  
+0000d0b0: 2020 2020 2020 6966 6e61 6d65 203d 2073        ifname = s
+0000d0c0: 656c 662e 696e 7465 7266 6163 6573 5b69  elf.interfaces[i
+0000d0d0: 6e74 6964 5d5b 325d 2e67 6574 2827 6e61  ntid][2].get('na
+0000d0e0: 6d65 272c 204e 6f6e 6529 0a20 2020 2020  me', None).     
+0000d0f0: 2020 2072 6574 7572 6e20 2862 6c6f 636b     return (block
+0000d100: 5b32 303a 3230 202b 2063 6170 6c65 6e5d  [20:20 + caplen]
+0000d110: 5b3a 7369 7a65 5d2c 0a20 2020 2020 2020  [:size],.       
+0000d120: 2020 2020 2020 2020 2052 6177 5063 6170           RawPcap
+0000d130: 4e67 5265 6164 6572 2e50 6163 6b65 744d  NgReader.PacketM
+0000d140: 6574 6164 6174 6128 6c69 6e6b 7479 7065  etadata(linktype
+0000d150: 3d73 656c 662e 696e 7465 7266 6163 6573  =self.interfaces
+0000d160: 5b69 6e74 6964 5d5b 305d 2c20 2023 206e  [intid][0],  # n
+0000d170: 6f71 613a 2045 3530 310a 2020 2020 2020  oqa: E501.      
+0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d1a0: 2020 2020 2020 2020 2074 7372 6573 6f6c           tsresol
+0000d1b0: 3d73 656c 662e 696e 7465 7266 6163 6573  =self.interfaces
+0000d1c0: 5b69 6e74 6964 5d5b 325d 5b27 7473 7265  [intid][2]['tsre
+0000d1d0: 736f 6c27 5d2c 2020 2320 6e6f 7161 3a20  sol'],  # noqa: 
+0000d1e0: 4535 3031 0a20 2020 2020 2020 2020 2020  E501.           
+0000d1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d210: 2020 2020 7473 6869 6768 3d74 7368 6967      tshigh=tshig
+0000d220: 682c 0a20 2020 2020 2020 2020 2020 2020  h,.             
+0000d230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d250: 2020 7473 6c6f 773d 7473 6c6f 772c 0a20    tslow=tslow,. 
+0000d260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d280: 2020 2020 2020 2020 2020 2020 2020 7769                wi
+0000d290: 7265 6c65 6e3d 7769 7265 6c65 6e2c 0a20  relen=wirelen,. 
+0000d2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2c0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0000d2d0: 6d6d 656e 743d 636f 6d6d 656e 742c 0a20  mment=comment,. 
+0000d2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d300: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000d310: 6e61 6d65 3d69 666e 616d 652c 0a20 2020  name=ifname,.   
+0000d320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d340: 2020 2020 2020 2020 2020 2020 6469 7265              dire
+0000d350: 6374 696f 6e3d 6469 7265 6374 696f 6e29  ction=direction)
+0000d360: 290a 0a20 2020 2064 6566 205f 7265 6164  )..    def _read
+0000d370: 5f62 6c6f 636b 5f73 7062 2873 656c 662c  _block_spb(self,
+0000d380: 2062 6c6f 636b 2c20 7369 7a65 293a 0a20   block, size):. 
+0000d390: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+0000d3a0: 6279 7465 732c 2069 6e74 2920 2d3e 2054  bytes, int) -> T
+0000d3b0: 7570 6c65 5b62 7974 6573 2c20 5261 7750  uple[bytes, RawP
+0000d3c0: 6361 704e 6752 6561 6465 722e 5061 636b  capNgReader.Pack
+0000d3d0: 6574 4d65 7461 6461 7461 5d0a 2020 2020  etMetadata].    
+0000d3e0: 2020 2020 2222 2253 696d 706c 6520 5061      """Simple Pa
+0000d3f0: 636b 6574 2042 6c6f 636b 2222 220a 2020  cket Block""".  
+0000d400: 2020 2020 2020 2320 2269 7420 4d55 5354        # "it MUST
+0000d410: 2062 6520 6173 7375 6d65 6420 7468 6174   be assumed that
+0000d420: 2061 6c6c 2074 6865 2053 696d 706c 6520   all the Simple 
+0000d430: 5061 636b 6574 2042 6c6f 636b 7320 6861  Packet Blocks ha
+0000d440: 7665 0a20 2020 2020 2020 2023 2062 6565  ve.        # bee
+0000d450: 6e20 6361 7074 7572 6564 206f 6e20 7468  n captured on th
+0000d460: 6520 696e 7465 7266 6163 6520 7072 6576  e interface prev
+0000d470: 696f 7573 6c79 2073 7065 6369 6669 6564  iously specified
+0000d480: 2069 6e20 7468 650a 2020 2020 2020 2020   in the.        
+0000d490: 2320 6669 7273 7420 496e 7465 7266 6163  # first Interfac
+0000d4a0: 6520 4465 7363 7269 7074 696f 6e20 426c  e Description Bl
+0000d4b0: 6f63 6b2e 220a 2020 2020 2020 2020 696e  ock.".        in
+0000d4c0: 7469 6420 3d20 300a 2020 2020 2020 2020  tid = 0.        
+0000d4d0: 7365 6c66 2e5f 6368 6563 6b5f 696e 7465  self._check_inte
+0000d4e0: 7266 6163 655f 6964 2869 6e74 6964 290a  rface_id(intid).
+0000d4f0: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
+0000d500: 2020 2020 2020 2020 2020 7769 7265 6c65            wirele
+0000d510: 6e2c 203d 2073 7472 7563 742e 756e 7061  n, = struct.unpa
+0000d520: 636b 2873 656c 662e 656e 6469 616e 202b  ck(self.endian +
+0000d530: 2022 4922 2c20 626c 6f63 6b5b 3a34 5d29   "I", block[:4])
+0000d540: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+0000d550: 7374 7275 6374 2e65 7272 6f72 3a0a 2020  struct.error:.  
+0000d560: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
+0000d570: 6728 2250 6361 704e 673a 2053 5042 2069  g("PcapNg: SPB i
+0000d580: 7320 746f 6f20 736d 616c 6c20 2564 2f34  s too small %d/4
+0000d590: 2021 2220 2520 6c65 6e28 626c 6f63 6b29   !" % len(block)
+0000d5a0: 290a 2020 2020 2020 2020 2020 2020 7261  ).            ra
+0000d5b0: 6973 6520 454f 4645 7272 6f72 0a0a 2020  ise EOFError..  
+0000d5c0: 2020 2020 2020 6361 706c 656e 203d 206d        caplen = m
+0000d5d0: 696e 2877 6972 656c 656e 2c20 7365 6c66  in(wirelen, self
+0000d5e0: 2e69 6e74 6572 6661 6365 735b 696e 7469  .interfaces[inti
+0000d5f0: 645d 5b31 5d29 0a20 2020 2020 2020 2072  d][1]).        r
+0000d600: 6574 7572 6e20 2862 6c6f 636b 5b34 3a34  eturn (block[4:4
+0000d610: 202b 2063 6170 6c65 6e5d 5b3a 7369 7a65   + caplen][:size
+0000d620: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0000d630: 2020 2052 6177 5063 6170 4e67 5265 6164     RawPcapNgRead
+0000d640: 6572 2e50 6163 6b65 744d 6574 6164 6174  er.PacketMetadat
+0000d650: 6128 6c69 6e6b 7479 7065 3d73 656c 662e  a(linktype=self.
+0000d660: 696e 7465 7266 6163 6573 5b69 6e74 6964  interfaces[intid
+0000d670: 5d5b 305d 2c20 2023 206e 6f71 613a 2045  ][0],  # noqa: E
+0000d680: 3530 310a 2020 2020 2020 2020 2020 2020  501.            
+0000d690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6b0: 2020 2074 7372 6573 6f6c 3d73 656c 662e     tsresol=self.
+0000d6c0: 696e 7465 7266 6163 6573 5b69 6e74 6964  interfaces[intid
+0000d6d0: 5d5b 325d 5b27 7473 7265 736f 6c27 5d2c  ][2]['tsresol'],
+0000d6e0: 2020 2320 6e6f 7161 3a20 4535 3031 0a20    # noqa: E501. 
+0000d6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d710: 2020 2020 2020 2020 2020 2020 2020 7473                ts
+0000d720: 6869 6768 3d4e 6f6e 652c 0a20 2020 2020  high=None,.     
+0000d730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d750: 2020 2020 2020 2020 2020 7473 6c6f 773d            tslow=
+0000d760: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
+0000d770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d790: 2020 2020 2077 6972 656c 656e 3d77 6972       wirelen=wir
+0000d7a0: 656c 656e 2c0a 2020 2020 2020 2020 2020  elen,.          
 0000d7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d7c0: 2020 7061 636b 6574 2c20 2023 2074 7970    packet,  # typ
-0000d7d0: 653a 2055 6e69 6f6e 5b62 7974 6573 2c20  e: Union[bytes, 
-0000d7e0: 5061 636b 6574 5d0a 2020 2020 2020 2020  Packet].        
-0000d7f0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000d800: 633d 4e6f 6e65 2c20 2023 2074 7970 653a  c=None,  # type:
-0000d810: 204f 7074 696f 6e61 6c5b 666c 6f61 745d   Optional[float]
-0000d820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d830: 2020 2020 2020 2075 7365 633d 4e6f 6e65         usec=None
-0000d840: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-0000d850: 6e61 6c5b 696e 745d 0a20 2020 2020 2020  nal[int].       
-0000d860: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0000d870: 6170 6c65 6e3d 4e6f 6e65 2c20 2023 2074  aplen=None,  # t
-0000d880: 7970 653a 204f 7074 696f 6e61 6c5b 696e  ype: Optional[in
-0000d890: 745d 0a20 2020 2020 2020 2020 2020 2020  t].             
-0000d8a0: 2020 2020 2020 2020 2077 6972 656c 656e           wirelen
-0000d8b0: 3d4e 6f6e 652c 2020 2320 7479 7065 3a20  =None,  # type: 
-0000d8c0: 4f70 7469 6f6e 616c 5b69 6e74 5d0a 2020  Optional[int].  
-0000d8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d8e0: 2020 2020 636f 6d6d 656e 743d 4e6f 6e65      comment=None
-0000d8f0: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-0000d900: 616c 5b62 7974 6573 5d0a 2020 2020 2020  al[bytes].      
-0000d910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d920: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
-0000d930: 653a 2028 2e2e 2e29 202d 3e20 4e6f 6e65  e: (...) -> None
-0000d940: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
-0000d950: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
-0000d960: 6f72 0a0a 2020 2020 6465 6620 5f67 6574  or..    def _get
-0000d970: 5f74 696d 6528 7365 6c66 2c0a 2020 2020  _time(self,.    
-0000d980: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-0000d990: 636b 6574 2c20 2023 2074 7970 653a 2055  cket,  # type: U
-0000d9a0: 6e69 6f6e 5b62 7974 6573 2c20 5061 636b  nion[bytes, Pack
-0000d9b0: 6574 5d0a 2020 2020 2020 2020 2020 2020  et].            
-0000d9c0: 2020 2020 2020 7365 632c 2020 2320 7479        sec,  # ty
-0000d9d0: 7065 3a20 4f70 7469 6f6e 616c 5b66 6c6f  pe: Optional[flo
-0000d9e0: 6174 5d0a 2020 2020 2020 2020 2020 2020  at].            
-0000d9f0: 2020 2020 2020 7573 6563 2020 2320 7479        usec  # ty
-0000da00: 7065 3a20 4f70 7469 6f6e 616c 5b69 6e74  pe: Optional[int
-0000da10: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0000da20: 2020 2020 293a 0a20 2020 2020 2020 2023      ):.        #
-0000da30: 2074 7970 653a 2028 2e2e 2e29 202d 3e20   type: (...) -> 
-0000da40: 5475 706c 655b 666c 6f61 742c 2069 6e74  Tuple[float, int
-0000da50: 5d0a 2020 2020 2020 2020 6966 2068 6173  ].        if has
-0000da60: 6174 7472 2870 6163 6b65 742c 2022 7469  attr(packet, "ti
-0000da70: 6d65 2229 3a0a 2020 2020 2020 2020 2020  me"):.          
-0000da80: 2020 6966 2073 6563 2069 7320 4e6f 6e65    if sec is None
-0000da90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000daa0: 2020 7061 636b 6574 5f74 696d 6520 3d20    packet_time = 
-0000dab0: 7061 636b 6574 2e74 696d 6520 2023 2074  packet.time  # t
-0000dac0: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
-0000dad0: 2020 2020 2020 2020 2020 2020 746d 7020              tmp 
-0000dae0: 3d20 696e 7428 7061 636b 6574 5f74 696d  = int(packet_tim
-0000daf0: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-0000db00: 2020 2075 7365 6320 3d20 696e 7428 726f     usec = int(ro
-0000db10: 756e 6428 2870 6163 6b65 745f 7469 6d65  und((packet_time
-0000db20: 202d 2074 6d70 2920 2a0a 2020 2020 2020   - tmp) *.      
-0000db30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000db40: 2020 2020 2028 3130 3030 3030 3030 3030       (1000000000
-0000db50: 2069 6620 7365 6c66 2e6e 616e 6f20 656c   if self.nano el
-0000db60: 7365 2031 3030 3030 3030 2929 290a 2020  se 1000000))).  
-0000db70: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000db80: 6320 3d20 666c 6f61 7428 7061 636b 6574  c = float(packet
-0000db90: 5f74 696d 6529 0a20 2020 2020 2020 2069  _time).        i
-0000dba0: 6620 7365 6320 6973 206e 6f74 204e 6f6e  f sec is not Non
-0000dbb0: 6520 616e 6420 7573 6563 2069 7320 4e6f  e and usec is No
-0000dbc0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0000dbd0: 7573 6563 203d 2030 0a20 2020 2020 2020  usec = 0.       
-0000dbe0: 2072 6574 7572 6e20 7365 632c 2075 7365   return sec, use
-0000dbf0: 6320 2023 2074 7970 653a 2069 676e 6f72  c  # type: ignor
-0000dc00: 650a 0a20 2020 2064 6566 2077 7269 7465  e..    def write
-0000dc10: 5f68 6561 6465 7228 7365 6c66 2c20 706b  _header(self, pk
-0000dc20: 7429 3a0a 2020 2020 2020 2020 2320 7479  t):.        # ty
-0000dc30: 7065 3a20 284f 7074 696f 6e61 6c5b 556e  pe: (Optional[Un
-0000dc40: 696f 6e5b 5061 636b 6574 2c20 6279 7465  ion[Packet, byte
-0000dc50: 735d 5d29 202d 3e20 4e6f 6e65 0a20 2020  s]]) -> None.   
-0000dc60: 2020 2020 2069 6620 7365 6c66 2e6c 696e       if self.lin
-0000dc70: 6b74 7970 6520 6973 204e 6f6e 653a 0a20  ktype is None:. 
-0000dc80: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
+0000d7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7d0: 2020 2020 2063 6f6d 6d65 6e74 3d4e 6f6e       comment=Non
+0000d7e0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0000d7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d810: 2020 6966 6e61 6d65 3d4e 6f6e 652c 0a20    ifname=None,. 
+0000d820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d840: 2020 2020 2020 2020 2020 2020 2020 6469                di
+0000d850: 7265 6374 696f 6e3d 4e6f 6e65 2929 0a0a  rection=None))..
+0000d860: 2020 2020 6465 6620 5f72 6561 645f 626c      def _read_bl
+0000d870: 6f63 6b5f 706b 7428 7365 6c66 2c20 626c  ock_pkt(self, bl
+0000d880: 6f63 6b2c 2073 697a 6529 3a0a 2020 2020  ock, size):.    
+0000d890: 2020 2020 2320 7479 7065 3a20 2862 7974      # type: (byt
+0000d8a0: 6573 2c20 696e 7429 202d 3e20 5475 706c  es, int) -> Tupl
+0000d8b0: 655b 6279 7465 732c 2052 6177 5063 6170  e[bytes, RawPcap
+0000d8c0: 4e67 5265 6164 6572 2e50 6163 6b65 744d  NgReader.PacketM
+0000d8d0: 6574 6164 6174 615d 0a20 2020 2020 2020  etadata].       
+0000d8e0: 2022 2222 284f 6273 6f6c 6574 6529 2050   """(Obsolete) P
+0000d8f0: 6163 6b65 7420 426c 6f63 6b22 2222 0a20  acket Block""". 
+0000d900: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+0000d910: 2020 2020 2020 2020 696e 7469 642c 2064          intid, d
+0000d920: 726f 7073 2c20 7473 6869 6768 2c20 7473  rops, tshigh, ts
+0000d930: 6c6f 772c 2063 6170 6c65 6e2c 2077 6972  low, caplen, wir
+0000d940: 656c 656e 203d 2073 7472 7563 742e 756e  elen = struct.un
+0000d950: 7061 636b 280a 2020 2020 2020 2020 2020  pack(.          
+0000d960: 2020 2020 2020 7365 6c66 2e65 6e64 6961        self.endia
+0000d970: 6e20 2b20 2248 4834 4922 2c0a 2020 2020  n + "HH4I",.    
+0000d980: 2020 2020 2020 2020 2020 2020 626c 6f63              bloc
+0000d990: 6b5b 3a32 305d 2c0a 2020 2020 2020 2020  k[:20],.        
+0000d9a0: 2020 2020 290a 2020 2020 2020 2020 6578      ).        ex
+0000d9b0: 6365 7074 2073 7472 7563 742e 6572 726f  cept struct.erro
+0000d9c0: 723a 0a20 2020 2020 2020 2020 2020 2077  r:.            w
+0000d9d0: 6172 6e69 6e67 2822 5063 6170 4e67 3a20  arning("PcapNg: 
+0000d9e0: 504b 5420 6973 2074 6f6f 2073 6d61 6c6c  PKT is too small
+0000d9f0: 2025 642f 3230 2021 2220 2520 6c65 6e28   %d/20 !" % len(
+0000da00: 626c 6f63 6b29 290a 2020 2020 2020 2020  block)).        
+0000da10: 2020 2020 7261 6973 6520 454f 4645 7272      raise EOFErr
+0000da20: 6f72 0a0a 2020 2020 2020 2020 7365 6c66  or..        self
+0000da30: 2e5f 6368 6563 6b5f 696e 7465 7266 6163  ._check_interfac
+0000da40: 655f 6964 2869 6e74 6964 290a 2020 2020  e_id(intid).    
+0000da50: 2020 2020 7265 7475 726e 2028 626c 6f63      return (bloc
+0000da60: 6b5b 3230 3a32 3020 2b20 6361 706c 656e  k[20:20 + caplen
+0000da70: 5d5b 3a73 697a 655d 2c0a 2020 2020 2020  ][:size],.      
+0000da80: 2020 2020 2020 2020 2020 5261 7750 6361            RawPca
+0000da90: 704e 6752 6561 6465 722e 5061 636b 6574  pNgReader.Packet
+0000daa0: 4d65 7461 6461 7461 286c 696e 6b74 7970  Metadata(linktyp
+0000dab0: 653d 7365 6c66 2e69 6e74 6572 6661 6365  e=self.interface
+0000dac0: 735b 696e 7469 645d 5b30 5d2c 2020 2320  s[intid][0],  # 
+0000dad0: 6e6f 7161 3a20 4535 3031 0a20 2020 2020  noqa: E501.     
+0000dae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000daf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db00: 2020 2020 2020 2020 2020 7473 7265 736f            tsreso
+0000db10: 6c3d 7365 6c66 2e69 6e74 6572 6661 6365  l=self.interface
+0000db20: 735b 696e 7469 645d 5b32 5d5b 2774 7372  s[intid][2]['tsr
+0000db30: 6573 6f6c 275d 2c20 2023 206e 6f71 613a  esol'],  # noqa:
+0000db40: 2045 3530 310a 2020 2020 2020 2020 2020   E501.          
+0000db50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db70: 2020 2020 2074 7368 6967 683d 7473 6869       tshigh=tshi
+0000db80: 6768 2c0a 2020 2020 2020 2020 2020 2020  gh,.            
+0000db90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbb0: 2020 2074 736c 6f77 3d74 736c 6f77 2c0a     tslow=tslow,.
+0000dbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbe0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+0000dbf0: 6972 656c 656e 3d77 6972 656c 656e 2c0a  irelen=wirelen,.
+0000dc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc20: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000dc30: 6f6d 6d65 6e74 3d4e 6f6e 652c 0a20 2020  omment=None,.   
+0000dc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc60: 2020 2020 2020 2020 2020 2020 6966 6e61              ifna
+0000dc70: 6d65 3d4e 6f6e 652c 0a20 2020 2020 2020  me=None,.       
+0000dc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000dc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dca0: 6966 2070 6b74 2069 7320 4e6f 6e65 206f  if pkt is None o
-0000dcb0: 7220 6973 696e 7374 616e 6365 2870 6b74  r isinstance(pkt
-0000dcc0: 2c20 6279 7465 7329 3a0a 2020 2020 2020  , bytes):.      
-0000dcd0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000dce0: 4361 6e27 7420 6775 6573 7320 4c4c 0a20  Can't guess LL. 
-0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd00: 2020 2072 6169 7365 204b 6579 4572 726f     raise KeyErro
-0000dd10: 720a 2020 2020 2020 2020 2020 2020 2020  r.              
-0000dd20: 2020 7365 6c66 2e6c 696e 6b74 7970 6520    self.linktype 
-0000dd30: 3d20 636f 6e66 2e6c 3274 7970 6573 2e6c  = conf.l2types.l
-0000dd40: 6179 6572 326e 756d 5b0a 2020 2020 2020  ayer2num[.      
-0000dd50: 2020 2020 2020 2020 2020 2020 2020 706b                pk
-0000dd60: 742e 5f5f 636c 6173 735f 5f0a 2020 2020  t.__class__.    
-0000dd70: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
-0000dd80: 2020 2020 2020 2020 2020 6578 6365 7074            except
-0000dd90: 204b 6579 4572 726f 723a 0a20 2020 2020   KeyError:.     
-0000dda0: 2020 2020 2020 2020 2020 206d 7367 203d             msg =
-0000ddb0: 2022 2573 3a20 756e 6b6e 6f77 6e20 4c4c   "%s: unknown LL
-0000ddc0: 2074 7970 6520 666f 7220 2573 2e20 5573   type for %s. Us
-0000ddd0: 696e 6720 7479 7065 2031 2028 4574 6865  ing type 1 (Ethe
-0000dde0: 726e 6574 2922 0a20 2020 2020 2020 2020  rnet)".         
-0000ddf0: 2020 2020 2020 2077 6172 6e69 6e67 286d         warning(m
-0000de00: 7367 2c20 7365 6c66 2e5f 5f63 6c61 7373  sg, self.__class
-0000de10: 5f5f 2e5f 5f6e 616d 655f 5f2c 2070 6b74  __.__name__, pkt
-0000de20: 2e5f 5f63 6c61 7373 5f5f 2e5f 5f6e 616d  .__class__.__nam
-0000de30: 655f 5f29 0a20 2020 2020 2020 2020 2020  e__).           
-0000de40: 2020 2020 2073 656c 662e 6c69 6e6b 7479       self.linkty
-0000de50: 7065 203d 2044 4c54 5f45 4e31 304d 420a  pe = DLT_EN10MB.
-0000de60: 2020 2020 2020 2020 7365 6c66 2e5f 7772          self._wr
-0000de70: 6974 655f 6865 6164 6572 2870 6b74 290a  ite_header(pkt).
-0000de80: 0a20 2020 2064 6566 2077 7269 7465 5f70  .    def write_p
-0000de90: 6163 6b65 7428 7365 6c66 2c0a 2020 2020  acket(self,.    
-0000dea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000deb0: 2070 6163 6b65 742c 2020 2320 7479 7065   packet,  # type
-0000dec0: 3a20 556e 696f 6e5b 6279 7465 732c 2050  : Union[bytes, P
-0000ded0: 6163 6b65 745d 0a20 2020 2020 2020 2020  acket].         
-0000dee0: 2020 2020 2020 2020 2020 2020 7365 633d              sec=
-0000def0: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
-0000df00: 7074 696f 6e61 6c5b 666c 6f61 745d 0a20  ptional[float]. 
-0000df10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df20: 2020 2020 7573 6563 3d4e 6f6e 652c 2020      usec=None,  
-0000df30: 2320 7479 7065 3a20 4f70 7469 6f6e 616c  # type: Optional
-0000df40: 5b69 6e74 5d0a 2020 2020 2020 2020 2020  [int].          
-0000df50: 2020 2020 2020 2020 2020 2063 6170 6c65             caple
-0000df60: 6e3d 4e6f 6e65 2c20 2023 2074 7970 653a  n=None,  # type:
-0000df70: 204f 7074 696f 6e61 6c5b 696e 745d 0a20   Optional[int]. 
-0000df80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df90: 2020 2020 7769 7265 6c65 6e3d 4e6f 6e65      wirelen=None
-0000dfa0: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-0000dfb0: 6e61 6c5b 696e 745d 0a20 2020 2020 2020  nal[int].       
-0000dfc0: 2020 2020 2020 2020 2020 2020 2020 293a                ):
-0000dfd0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-0000dfe0: 2028 2e2e 2e29 202d 3e20 4e6f 6e65 0a20   (...) -> None. 
-0000dff0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000e000: 2020 2057 7269 7465 7320 6120 7369 6e67     Writes a sing
-0000e010: 6c65 2070 6163 6b65 7420 746f 2074 6865  le packet to the
-0000e020: 2070 6361 7020 6669 6c65 2e0a 0a20 2020   pcap file...   
-0000e030: 2020 2020 203a 7061 7261 6d20 7061 636b       :param pack
-0000e040: 6574 3a20 5061 636b 6574 2c20 6f72 2062  et: Packet, or b
-0000e050: 7974 6573 2066 6f72 2061 2073 696e 676c  ytes for a singl
-0000e060: 6520 7061 636b 6574 0a20 2020 2020 2020  e packet.       
-0000e070: 203a 7479 7065 2070 6163 6b65 743a 2073   :type packet: s
-0000e080: 6361 7079 2e70 6163 6b65 742e 5061 636b  capy.packet.Pack
-0000e090: 6574 206f 7220 6279 7465 730a 2020 2020  et or bytes.    
-0000e0a0: 2020 2020 3a70 6172 616d 2073 6563 3a20      :param sec: 
-0000e0b0: 7469 6d65 2074 6865 2070 6163 6b65 7420  time the packet 
-0000e0c0: 7761 7320 6361 7074 7572 6564 2c20 696e  was captured, in
-0000e0d0: 2073 6563 6f6e 6473 2073 696e 6365 2065   seconds since e
-0000e0e0: 706f 6368 2e20 4966 0a20 2020 2020 2020  poch. If.       
-0000e0f0: 2020 2020 2020 2020 2020 2020 206e 6f74               not
-0000e100: 2073 7570 706c 6965 642c 2064 6566 6175   supplied, defau
-0000e110: 6c74 7320 746f 206e 6f77 2e0a 2020 2020  lts to now..    
-0000e120: 2020 2020 3a74 7970 6520 7365 633a 2066      :type sec: f
-0000e130: 6c6f 6174 0a20 2020 2020 2020 203a 7061  loat.        :pa
-0000e140: 7261 6d20 7573 6563 3a20 4966 2060 606e  ram usec: If ``n
-0000e150: 616e 6f3d 5472 7565 6060 2c20 7468 656e  ano=True``, then
-0000e160: 206e 756d 6265 7220 6f66 206e 616e 6f73   number of nanos
-0000e170: 6563 6f6e 6473 2061 6674 6572 2074 6865  econds after the
-0000e180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e190: 2020 2020 2020 7365 636f 6e64 2074 6861        second tha
-0000e1a0: 7420 7468 6520 7061 636b 6574 2077 6173  t the packet was
-0000e1b0: 2063 6170 7475 7265 642e 2049 6620 6060   captured. If ``
-0000e1c0: 6e61 6e6f 3d46 616c 7365 6060 2c0a 2020  nano=False``,.  
-0000e1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1e0: 2020 2074 6865 6e20 7468 6520 6e75 6d62     then the numb
-0000e1f0: 6572 206f 6620 6d69 6372 6f73 6563 6f6e  er of microsecon
-0000e200: 6473 2061 6674 6572 2074 6865 2073 6563  ds after the sec
-0000e210: 6f6e 6420 7468 650a 2020 2020 2020 2020  ond the.        
-0000e220: 2020 2020 2020 2020 2020 2020 2070 6163               pac
-0000e230: 6b65 7420 7761 7320 6361 7074 7572 6564  ket was captured
-0000e240: 2e20 4966 2060 6073 6563 6060 2069 7320  . If ``sec`` is 
-0000e250: 6e6f 7420 7370 6563 6966 6965 642c 0a20  not specified,. 
-0000e260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e270: 2020 2020 7468 6973 2076 616c 7565 2069      this value i
-0000e280: 7320 6967 6e6f 7265 642e 0a20 2020 2020  s ignored..     
-0000e290: 2020 203a 7479 7065 2075 7365 633a 2069     :type usec: i
-0000e2a0: 6e74 206f 7220 6c6f 6e67 0a20 2020 2020  nt or long.     
-0000e2b0: 2020 203a 7061 7261 6d20 6361 706c 656e     :param caplen
-0000e2c0: 3a20 5468 6520 6c65 6e67 7468 206f 6620  : The length of 
-0000e2d0: 7468 6520 7061 636b 6574 2069 6e20 7468  the packet in th
-0000e2e0: 6520 6361 7074 7572 6520 6669 6c65 2e20  e capture file. 
-0000e2f0: 4966 206e 6f74 0a20 2020 2020 2020 2020  If not.         
-0000e300: 2020 2020 2020 2020 2020 2020 2020 7370                sp
-0000e310: 6563 6966 6965 642c 2075 7365 7320 6060  ecified, uses ``
-0000e320: 6c65 6e28 7261 7728 7061 636b 6574 2929  len(raw(packet))
-0000e330: 6060 2e0a 2020 2020 2020 2020 3a74 7970  ``..        :typ
-0000e340: 6520 6361 706c 656e 3a20 696e 740a 2020  e caplen: int.  
-0000e350: 2020 2020 2020 3a70 6172 616d 2077 6972        :param wir
-0000e360: 656c 656e 3a20 5468 6520 6c65 6e67 7468  elen: The length
-0000e370: 206f 6620 7468 6520 7061 636b 6574 206f   of the packet o
-0000e380: 6e20 7468 6520 7769 7265 2e20 4966 206e  n the wire. If n
-0000e390: 6f74 0a20 2020 2020 2020 2020 2020 2020  ot.             
-0000e3a0: 2020 2020 2020 2020 2020 2073 7065 6369             speci
-0000e3b0: 6669 6564 2c20 7472 6965 7320 6060 7061  fied, tries ``pa
-0000e3c0: 636b 6574 2e77 6972 656c 656e 6060 2c20  cket.wirelen``, 
-0000e3d0: 6f74 6865 7277 6973 6520 7573 6573 0a20  otherwise uses. 
-0000e3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e3f0: 2020 2020 2020 2060 6063 6170 6c65 6e60         ``caplen`
-0000e400: 602e 0a20 2020 2020 2020 203a 7479 7065  `..        :type
-0000e410: 2077 6972 656c 656e 3a20 696e 740a 2020   wirelen: int.  
-0000e420: 2020 2020 2020 3a72 6574 7572 6e3a 204e        :return: N
-0000e430: 6f6e 650a 2020 2020 2020 2020 3a72 7479  one.        :rty
-0000e440: 7065 3a20 4e6f 6e65 0a20 2020 2020 2020  pe: None.       
-0000e450: 2022 2222 0a20 2020 2020 2020 2066 5f73   """.        f_s
-0000e460: 6563 2c20 7573 6563 203d 2073 656c 662e  ec, usec = self.
-0000e470: 5f67 6574 5f74 696d 6528 7061 636b 6574  _get_time(packet
-0000e480: 2c20 7365 632c 2075 7365 6329 0a0a 2020  , sec, usec)..  
-0000e490: 2020 2020 2020 7261 7770 6b74 203d 2062        rawpkt = b
-0000e4a0: 7974 6573 5f65 6e63 6f64 6528 7061 636b  ytes_encode(pack
-0000e4b0: 6574 290a 2020 2020 2020 2020 6361 706c  et).        capl
-0000e4c0: 656e 203d 206c 656e 2872 6177 706b 7429  en = len(rawpkt)
-0000e4d0: 2069 6620 6361 706c 656e 2069 7320 4e6f   if caplen is No
-0000e4e0: 6e65 2065 6c73 6520 6361 706c 656e 0a0a  ne else caplen..
-0000e4f0: 2020 2020 2020 2020 6966 2077 6972 656c          if wirel
-0000e500: 656e 2069 7320 4e6f 6e65 3a0a 2020 2020  en is None:.    
-0000e510: 2020 2020 2020 2020 6966 2068 6173 6174          if hasat
-0000e520: 7472 2870 6163 6b65 742c 2022 7769 7265  tr(packet, "wire
-0000e530: 6c65 6e22 293a 0a20 2020 2020 2020 2020  len"):.         
-0000e540: 2020 2020 2020 2077 6972 656c 656e 203d         wirelen =
-0000e550: 2070 6163 6b65 742e 7769 7265 6c65 6e20   packet.wirelen 
-0000e560: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
-0000e570: 2020 2020 2020 2020 6966 2077 6972 656c          if wirel
-0000e580: 656e 2069 7320 4e6f 6e65 3a0a 2020 2020  en is None:.    
-0000e590: 2020 2020 2020 2020 7769 7265 6c65 6e20          wirelen 
-0000e5a0: 3d20 6361 706c 656e 0a0a 2020 2020 2020  = caplen..      
-0000e5b0: 2020 636f 6d6d 656e 7420 3d20 6765 7461    comment = geta
-0000e5c0: 7474 7228 7061 636b 6574 2c20 2263 6f6d  ttr(packet, "com
-0000e5d0: 6d65 6e74 222c 204e 6f6e 6529 0a0a 2020  ment", None)..  
-0000e5e0: 2020 2020 2020 7365 6c66 2e5f 7772 6974        self._writ
-0000e5f0: 655f 7061 636b 6574 280a 2020 2020 2020  e_packet(.      
-0000e600: 2020 2020 2020 7261 7770 6b74 2c0a 2020        rawpkt,.  
-0000e610: 2020 2020 2020 2020 2020 7365 633d 665f            sec=f_
-0000e620: 7365 632c 2075 7365 633d 7573 6563 2c0a  sec, usec=usec,.
-0000e630: 2020 2020 2020 2020 2020 2020 6361 706c              capl
-0000e640: 656e 3d63 6170 6c65 6e2c 2077 6972 656c  en=caplen, wirel
-0000e650: 656e 3d77 6972 656c 656e 2c0a 2020 2020  en=wirelen,.    
-0000e660: 2020 2020 2020 2020 636f 6d6d 656e 743d          comment=
-0000e670: 636f 6d6d 656e 740a 2020 2020 2020 2020  comment.        
-0000e680: 290a 0a0a 636c 6173 7320 4765 6e65 7269  )...class Generi
-0000e690: 6352 6177 5063 6170 5772 6974 6572 2847  cRawPcapWriter(G
-0000e6a0: 656e 6572 6963 5063 6170 5772 6974 6572  enericPcapWriter
-0000e6b0: 293a 0a20 2020 2068 6561 6465 725f 7072  ):.    header_pr
-0000e6c0: 6573 656e 7420 3d20 4661 6c73 650a 2020  esent = False.  
-0000e6d0: 2020 6e61 6e6f 203d 2046 616c 7365 0a20    nano = False. 
-0000e6e0: 2020 2073 796e 6320 3d20 4661 6c73 650a     sync = False.
-0000e6f0: 2020 2020 6620 3d20 4e6f 6e65 2020 2320      f = None  # 
-0000e700: 7479 7065 3a20 556e 696f 6e5b 494f 5b62  type: Union[IO[b
-0000e710: 7974 6573 5d2c 2067 7a69 702e 477a 6970  ytes], gzip.Gzip
-0000e720: 4669 6c65 5d0a 0a20 2020 2064 6566 2066  File]..    def f
-0000e730: 696c 656e 6f28 7365 6c66 293a 0a20 2020  ileno(self):.   
-0000e740: 2020 2020 2023 2074 7970 653a 2028 2920       # type: () 
-0000e750: 2d3e 2069 6e74 0a20 2020 2020 2020 2072  -> int.        r
-0000e760: 6574 7572 6e20 2d31 2069 6620 5749 4e44  eturn -1 if WIND
-0000e770: 4f57 5320 656c 7365 2073 656c 662e 662e  OWS else self.f.
-0000e780: 6669 6c65 6e6f 2829 0a0a 2020 2020 6465  fileno()..    de
-0000e790: 6620 666c 7573 6828 7365 6c66 293a 0a20  f flush(self):. 
-0000e7a0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-0000e7b0: 2920 2d3e 204f 7074 696f 6e61 6c5b 416e  ) -> Optional[An
-0000e7c0: 795d 0a20 2020 2020 2020 2072 6574 7572  y].        retur
-0000e7d0: 6e20 7365 6c66 2e66 2e66 6c75 7368 2829  n self.f.flush()
-0000e7e0: 0a0a 2020 2020 6465 6620 636c 6f73 6528  ..    def close(
-0000e7f0: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
-0000e800: 2074 7970 653a 2028 2920 2d3e 204f 7074   type: () -> Opt
-0000e810: 696f 6e61 6c5b 416e 795d 0a20 2020 2020  ional[Any].     
-0000e820: 2020 2069 6620 6e6f 7420 7365 6c66 2e68     if not self.h
-0000e830: 6561 6465 725f 7072 6573 656e 743a 0a20  eader_present:. 
-0000e840: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000e850: 7772 6974 655f 6865 6164 6572 284e 6f6e  write_header(Non
-0000e860: 6529 0a20 2020 2020 2020 2072 6574 7572  e).        retur
-0000e870: 6e20 7365 6c66 2e66 2e63 6c6f 7365 2829  n self.f.close()
-0000e880: 0a0a 2020 2020 6465 6620 5f5f 656e 7465  ..    def __ente
-0000e890: 725f 5f28 7365 6c66 293a 0a20 2020 2020  r__(self):.     
-0000e8a0: 2020 2023 2074 7970 653a 2028 2920 2d3e     # type: () ->
-0000e8b0: 2047 656e 6572 6963 5261 7750 6361 7057   GenericRawPcapW
-0000e8c0: 7269 7465 720a 2020 2020 2020 2020 7265  riter.        re
-0000e8d0: 7475 726e 2073 656c 660a 0a20 2020 2064  turn self..    d
-0000e8e0: 6566 205f 5f65 7869 745f 5f28 7365 6c66  ef __exit__(self
-0000e8f0: 2c20 6578 635f 7479 7065 2c20 6578 635f  , exc_type, exc_
-0000e900: 7661 6c75 652c 2074 7261 6362 6163 6b29  value, tracback)
-0000e910: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-0000e920: 3a20 284f 7074 696f 6e61 6c5b 416e 795d  : (Optional[Any]
-0000e930: 2c20 4f70 7469 6f6e 616c 5b41 6e79 5d2c  , Optional[Any],
-0000e940: 204f 7074 696f 6e61 6c5b 416e 795d 2920   Optional[Any]) 
-0000e950: 2d3e 204e 6f6e 650a 2020 2020 2020 2020  -> None.        
-0000e960: 7365 6c66 2e66 6c75 7368 2829 0a20 2020  self.flush().   
-0000e970: 2020 2020 2073 656c 662e 636c 6f73 6528       self.close(
-0000e980: 290a 0a20 2020 2064 6566 2077 7269 7465  )..    def write
-0000e990: 2873 656c 662c 2070 6b74 293a 0a20 2020  (self, pkt):.   
-0000e9a0: 2020 2020 2023 2074 7970 653a 2028 556e       # type: (Un
-0000e9b0: 696f 6e5b 5f50 6163 6b65 7449 7465 7261  ion[_PacketItera
-0000e9c0: 626c 652c 2062 7974 6573 5d29 202d 3e20  ble, bytes]) -> 
-0000e9d0: 4e6f 6e65 0a20 2020 2020 2020 2022 2222  None.        """
-0000e9e0: 0a20 2020 2020 2020 2057 7269 7465 7320  .        Writes 
-0000e9f0: 6120 5061 636b 6574 2c20 6120 536e 6452  a Packet, a SndR
-0000ea00: 6376 4c69 7374 206f 626a 6563 742c 206f  cvList object, o
-0000ea10: 7220 6279 7465 7320 746f 2061 2070 6361  r bytes to a pca
-0000ea20: 7020 6669 6c65 2e0a 0a20 2020 2020 2020  p file...       
-0000ea30: 203a 7061 7261 6d20 706b 743a 2050 6163   :param pkt: Pac
-0000ea40: 6b65 7428 7329 2074 6f20 7772 6974 6520  ket(s) to write 
-0000ea50: 286f 6e65 2072 6563 6f72 6420 666f 7220  (one record for 
-0000ea60: 6561 6368 2050 6163 6b65 7429 2c20 6f72  each Packet), or
-0000ea70: 2072 6177 0a20 2020 2020 2020 2020 2020   raw.           
-0000ea80: 2020 2020 2020 2020 2062 7974 6573 2074           bytes t
-0000ea90: 6f20 7772 6974 6520 2861 7320 6f6e 6520  o write (as one 
-0000eaa0: 7265 636f 7264 292e 0a20 2020 2020 2020  record)..       
-0000eab0: 203a 7479 7065 2070 6b74 3a20 6974 6572   :type pkt: iter
-0000eac0: 6162 6c65 5b73 6361 7079 2e70 6163 6b65  able[scapy.packe
-0000ead0: 742e 5061 636b 6574 5d2c 2073 6361 7079  t.Packet], scapy
-0000eae0: 2e70 6163 6b65 742e 5061 636b 6574 206f  .packet.Packet o
-0000eaf0: 7220 6279 7465 730a 2020 2020 2020 2020  r bytes.        
-0000eb00: 2222 220a 2020 2020 2020 2020 6966 2069  """.        if i
-0000eb10: 7369 6e73 7461 6e63 6528 706b 742c 2062  sinstance(pkt, b
-0000eb20: 7974 6573 293a 0a20 2020 2020 2020 2020  ytes):.         
-0000eb30: 2020 2069 6620 6e6f 7420 7365 6c66 2e68     if not self.h
-0000eb40: 6561 6465 725f 7072 6573 656e 743a 0a20  eader_present:. 
-0000eb50: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000eb60: 656c 662e 7772 6974 655f 6865 6164 6572  elf.write_header
-0000eb70: 2870 6b74 290a 2020 2020 2020 2020 2020  (pkt).          
-0000eb80: 2020 7365 6c66 2e77 7269 7465 5f70 6163    self.write_pac
-0000eb90: 6b65 7428 706b 7429 0a20 2020 2020 2020  ket(pkt).       
-0000eba0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000ebb0: 2020 2023 2049 6d70 6f72 7420 6865 7265     # Import here
-0000ebc0: 2074 6f20 6176 6f69 6420 6369 7263 756c   to avoid circul
-0000ebd0: 6172 2064 6570 656e 6465 6e63 790a 2020  ar dependency.  
-0000ebe0: 2020 2020 2020 2020 2020 6672 6f6d 2073            from s
-0000ebf0: 6361 7079 2e73 7570 6572 736f 636b 6574  capy.supersocket
-0000ec00: 2069 6d70 6f72 7420 4974 6572 536f 636b   import IterSock
-0000ec10: 6574 0a20 2020 2020 2020 2020 2020 2066  et.            f
-0000ec20: 6f72 2070 2069 6e20 4974 6572 536f 636b  or p in IterSock
-0000ec30: 6574 2870 6b74 292e 6974 6572 3a0a 2020  et(pkt).iter:.  
-0000ec40: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000ec50: 206e 6f74 2073 656c 662e 6865 6164 6572   not self.header
-0000ec60: 5f70 7265 7365 6e74 3a0a 2020 2020 2020  _present:.      
-0000ec70: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000ec80: 6c66 2e77 7269 7465 5f68 6561 6465 7228  lf.write_header(
-0000ec90: 7029 0a0a 2020 2020 2020 2020 2020 2020  p)..            
-0000eca0: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
-0000ecb0: 7461 6e63 6528 702c 2062 7974 6573 2920  tance(p, bytes) 
-0000ecc0: 616e 6420 5c0a 2020 2020 2020 2020 2020  and \.          
-0000ecd0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000ece0: 6c66 2e6c 696e 6b74 7970 6520 213d 2063  lf.linktype != c
-0000ecf0: 6f6e 662e 6c32 7479 7065 732e 6765 7428  onf.l2types.get(
-0000ed00: 7479 7065 2870 292c 204e 6f6e 6529 3a0a  type(p), None):.
-0000ed10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed20: 2020 2020 7761 726e 696e 6728 2249 6e63      warning("Inc
-0000ed30: 6f6e 7369 7374 656e 7420 6c69 6e6b 7479  onsistent linkty
-0000ed40: 7065 7320 6465 7465 6374 6564 2122 0a20  pes detected!". 
-0000ed50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed60: 2020 2020 2020 2020 2020 2022 2054 6865             " The
-0000ed70: 2072 6573 756c 7469 6e67 2066 696c 6520   resulting file 
-0000ed80: 6d69 6768 7420 636f 6e74 6169 6e22 0a20  might contain". 
-0000ed90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eda0: 2020 2020 2020 2020 2020 2022 2069 6e76             " inv
-0000edb0: 616c 6964 2070 6163 6b65 7473 2e22 0a20  alid packets.". 
-0000edc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000edd0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-0000ede0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000edf0: 6c66 2e77 7269 7465 5f70 6163 6b65 7428  lf.write_packet(
-0000ee00: 7029 0a0a 0a63 6c61 7373 2052 6177 5063  p)...class RawPc
-0000ee10: 6170 5772 6974 6572 2847 656e 6572 6963  apWriter(Generic
-0000ee20: 5261 7750 6361 7057 7269 7465 7229 3a0a  RawPcapWriter):.
-0000ee30: 2020 2020 2222 2241 2073 7472 6561 6d20      """A stream 
-0000ee40: 5043 4150 2077 7269 7465 7220 7769 7468  PCAP writer with
-0000ee50: 206d 6f72 6520 636f 6e74 726f 6c20 7468   more control th
-0000ee60: 616e 2077 7270 6361 7028 2922 2222 0a0a  an wrpcap()"""..
-0000ee70: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-0000ee80: 2873 656c 662c 0a20 2020 2020 2020 2020  (self,.         
-0000ee90: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
-0000eea0: 2c20 2023 2074 7970 653a 2055 6e69 6f6e  ,  # type: Union
-0000eeb0: 5b49 4f5b 6279 7465 735d 2c20 7374 725d  [IO[bytes], str]
-0000eec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000eed0: 2020 6c69 6e6b 7479 7065 3d4e 6f6e 652c    linktype=None,
-0000eee0: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-0000eef0: 616c 5b69 6e74 5d0a 2020 2020 2020 2020  al[int].        
-0000ef00: 2020 2020 2020 2020 2067 7a3d 4661 6c73           gz=Fals
-0000ef10: 652c 2020 2320 7479 7065 3a20 626f 6f6c  e,  # type: bool
-0000ef20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ef30: 2020 656e 6469 616e 6e65 7373 3d22 222c    endianness="",
-0000ef40: 2020 2320 7479 7065 3a20 7374 720a 2020    # type: str.  
-0000ef50: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000ef60: 7070 656e 643d 4661 6c73 652c 2020 2320  ppend=False,  # 
-0000ef70: 7479 7065 3a20 626f 6f6c 0a20 2020 2020  type: bool.     
-0000ef80: 2020 2020 2020 2020 2020 2020 7379 6e63              sync
-0000ef90: 3d46 616c 7365 2c20 2023 2074 7970 653a  =False,  # type:
-0000efa0: 2062 6f6f 6c0a 2020 2020 2020 2020 2020   bool.          
-0000efb0: 2020 2020 2020 206e 616e 6f3d 4661 6c73         nano=Fals
-0000efc0: 652c 2020 2320 7479 7065 3a20 626f 6f6c  e,  # type: bool
-0000efd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000efe0: 2020 736e 6170 6c65 6e3d 4d54 552c 2020    snaplen=MTU,  
-0000eff0: 2320 7479 7065 3a20 696e 740a 2020 2020  # type: int.    
-0000f000: 2020 2020 2020 2020 2020 2020 2029 3a0a               ):.
-0000f010: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
-0000f020: 282e 2e2e 2920 2d3e 204e 6f6e 650a 2020  (...) -> None.  
-0000f030: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000f040: 2020 3a70 6172 616d 2066 696c 656e 616d    :param filenam
-0000f050: 653a 2074 6865 206e 616d 6520 6f66 2074  e: the name of t
-0000f060: 6865 2066 696c 6520 746f 2077 7269 7465  he file to write
-0000f070: 2070 6163 6b65 7473 2074 6f2c 206f 7220   packets to, or 
-0000f080: 616e 206f 7065 6e2c 0a20 2020 2020 2020  an open,.       
-0000f090: 2020 2020 2077 7269 7461 626c 6520 6669       writable fi
-0000f0a0: 6c65 2d6c 696b 6520 6f62 6a65 6374 2e0a  le-like object..
-0000f0b0: 2020 2020 2020 2020 3a70 6172 616d 206c          :param l
-0000f0c0: 696e 6b74 7970 653a 2066 6f72 6365 206c  inktype: force l
-0000f0d0: 696e 6b74 7970 6520 746f 2061 2067 6976  inktype to a giv
-0000f0e0: 656e 2076 616c 7565 2e20 4966 204e 6f6e  en value. If Non
-0000f0f0: 652c 206c 696e 6b74 7970 6520 6973 0a20  e, linktype is. 
-0000f100: 2020 2020 2020 2020 2020 2074 616b 656e             taken
-0000f110: 2066 726f 6d20 7468 6520 6669 7273 7420   from the first 
-0000f120: 7772 6974 6572 2070 6163 6b65 740a 2020  writer packet.  
-0000f130: 2020 2020 2020 3a70 6172 616d 2067 7a3a        :param gz:
-0000f140: 2063 6f6d 7072 6573 7320 7468 6520 6361   compress the ca
-0000f150: 7074 7572 6520 6f6e 2074 6865 2066 6c79  pture on the fly
-0000f160: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
-0000f170: 656e 6469 616e 6e65 7373 3a20 666f 7263  endianness: forc
-0000f180: 6520 616e 2065 6e64 6961 6e6e 6573 7320  e an endianness 
-0000f190: 286c 6974 746c 653a 223c 222c 2062 6967  (little:"<", big
-0000f1a0: 3a22 3e22 292e 0a20 2020 2020 2020 2020  :">")..         
-0000f1b0: 2020 2044 6566 6175 6c74 2069 7320 6e61     Default is na
-0000f1c0: 7469 7665 0a20 2020 2020 2020 203a 7061  tive.        :pa
-0000f1d0: 7261 6d20 6170 7065 6e64 3a20 6170 7065  ram append: appe
-0000f1e0: 6e64 2070 6163 6b65 7473 2074 6f20 7468  nd packets to th
-0000f1f0: 6520 6361 7074 7572 6520 6669 6c65 2069  e capture file i
-0000f200: 6e73 7465 6164 206f 660a 2020 2020 2020  nstead of.      
-0000f210: 2020 2020 2020 7472 756e 6361 7469 6e67        truncating
-0000f220: 2069 740a 2020 2020 2020 2020 3a70 6172   it.        :par
-0000f230: 616d 2073 796e 633a 2064 6f20 6e6f 7420  am sync: do not 
-0000f240: 6275 6666 6572 697a 6520 7772 6974 6573  bufferize writes
-0000f250: 2074 6f20 7468 6520 6361 7074 7572 6520   to the capture 
-0000f260: 6669 6c65 0a20 2020 2020 2020 203a 7061  file.        :pa
-0000f270: 7261 6d20 6e61 6e6f 3a20 7573 6520 6e61  ram nano: use na
-0000f280: 6e6f 7365 636f 6e64 2d70 7265 6369 7369  nosecond-precisi
-0000f290: 6f6e 2028 7265 7175 6972 6573 206c 6962  on (requires lib
-0000f2a0: 7063 6170 203e 3d20 312e 352e 3029 0a0a  pcap >= 1.5.0)..
-0000f2b0: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
-0000f2c0: 2020 2020 2073 656c 662e 6c69 6e6b 7479       self.linkty
-0000f2d0: 7065 203d 206c 696e 6b74 7970 650a 2020  pe = linktype.  
-0000f2e0: 2020 2020 2020 7365 6c66 2e73 6e61 706c        self.snapl
-0000f2f0: 656e 203d 2073 6e61 706c 656e 0a20 2020  en = snaplen.   
-0000f300: 2020 2020 2073 656c 662e 6170 7065 6e64       self.append
-0000f310: 203d 2061 7070 656e 640a 2020 2020 2020   = append.      
-0000f320: 2020 7365 6c66 2e67 7a20 3d20 677a 0a20    self.gz = gz. 
-0000f330: 2020 2020 2020 2073 656c 662e 656e 6469         self.endi
-0000f340: 616e 203d 2065 6e64 6961 6e6e 6573 730a  an = endianness.
-0000f350: 2020 2020 2020 2020 7365 6c66 2e73 796e          self.syn
-0000f360: 6320 3d20 7379 6e63 0a20 2020 2020 2020  c = sync.       
-0000f370: 2073 656c 662e 6e61 6e6f 203d 206e 616e   self.nano = nan
-0000f380: 6f0a 2020 2020 2020 2020 6275 6673 7a20  o.        bufsz 
-0000f390: 3d20 3430 3936 0a20 2020 2020 2020 2069  = 4096.        i
-0000f3a0: 6620 7379 6e63 3a0a 2020 2020 2020 2020  f sync:.        
-0000f3b0: 2020 2020 6275 6673 7a20 3d20 300a 0a20      bufsz = 0.. 
-0000f3c0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-0000f3d0: 616e 6365 2866 696c 656e 616d 652c 2073  ance(filename, s
-0000f3e0: 7472 293a 0a20 2020 2020 2020 2020 2020  tr):.           
-0000f3f0: 2073 656c 662e 6669 6c65 6e61 6d65 203d   self.filename =
-0000f400: 2066 696c 656e 616d 650a 2020 2020 2020   filename.      
-0000f410: 2020 2020 2020 6966 2067 7a3a 0a20 2020        if gz:.   
-0000f420: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000f430: 662e 6620 3d20 6361 7374 285f 4279 7465  f.f = cast(_Byte
-0000f440: 5374 7265 616d 2c20 677a 6970 2e6f 7065  Stream, gzip.ope
-0000f450: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
-0000f460: 2020 2020 2020 2066 696c 656e 616d 652c         filename,
-0000f470: 2061 7070 656e 6420 616e 6420 2261 6222   append and "ab"
-0000f480: 206f 7220 2277 6222 2c20 390a 2020 2020   or "wb", 9.    
-0000f490: 2020 2020 2020 2020 2020 2020 2929 0a20              )). 
-0000f4a0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000f4b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f4c0: 2073 656c 662e 6620 3d20 6f70 656e 2866   self.f = open(f
-0000f4d0: 696c 656e 616d 652c 2061 7070 656e 6420  ilename, append 
-0000f4e0: 616e 6420 2261 6222 206f 7220 2277 6222  and "ab" or "wb"
-0000f4f0: 2c20 6275 6673 7a29 0a20 2020 2020 2020  , bufsz).       
-0000f500: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000f510: 2020 2073 656c 662e 6620 3d20 6669 6c65     self.f = file
-0000f520: 6e61 6d65 0a20 2020 2020 2020 2020 2020  name.           
-0000f530: 2073 656c 662e 6669 6c65 6e61 6d65 203d   self.filename =
-0000f540: 2067 6574 6174 7472 2866 696c 656e 616d   getattr(filenam
-0000f550: 652c 2022 6e61 6d65 222c 2022 4e6f 206e  e, "name", "No n
-0000f560: 616d 6522 290a 0a20 2020 2064 6566 205f  ame")..    def _
-0000f570: 7772 6974 655f 6865 6164 6572 2873 656c  write_header(sel
-0000f580: 662c 2070 6b74 293a 0a20 2020 2020 2020  f, pkt):.       
-0000f590: 2023 2074 7970 653a 2028 4f70 7469 6f6e   # type: (Option
-0000f5a0: 616c 5b55 6e69 6f6e 5b50 6163 6b65 742c  al[Union[Packet,
-0000f5b0: 2062 7974 6573 5d5d 2920 2d3e 204e 6f6e   bytes]]) -> Non
-0000f5c0: 650a 2020 2020 2020 2020 7365 6c66 2e68  e.        self.h
-0000f5d0: 6561 6465 725f 7072 6573 656e 7420 3d20  eader_present = 
-0000f5e0: 5472 7565 0a0a 2020 2020 2020 2020 6966  True..        if
-0000f5f0: 2073 656c 662e 6170 7065 6e64 3a0a 2020   self.append:.  
-0000f600: 2020 2020 2020 2020 2020 2320 4576 656e            # Even
-0000f610: 2069 6620 7072 6f6e 6520 746f 2072 6163   if prone to rac
-0000f620: 6520 636f 6e64 6974 696f 6e73 2c20 7468  e conditions, th
-0000f630: 6973 2073 6565 6d73 2074 6f20 6265 0a20  is seems to be. 
-0000f640: 2020 2020 2020 2020 2020 2023 2073 6166             # saf
-0000f650: 6573 7420 7761 7920 746f 2074 656c 6c20  est way to tell 
-0000f660: 7768 6574 6865 7220 7468 6520 6865 6164  whether the head
-0000f670: 6572 2069 7320 616c 7265 6164 7920 7072  er is already pr
-0000f680: 6573 656e 740a 2020 2020 2020 2020 2020  esent.          
-0000f690: 2020 2320 6265 6361 7573 6520 7765 2068    # because we h
-0000f6a0: 6176 6520 746f 2068 616e 646c 6520 636f  ave to handle co
-0000f6b0: 6d70 7265 7373 6564 2073 7472 6561 6d73  mpressed streams
-0000f6c0: 2074 6861 740a 2020 2020 2020 2020 2020   that.          
-0000f6d0: 2020 2320 6172 6520 6e6f 7420 6173 2066    # are not as f
-0000f6e0: 6c65 7869 626c 6520 6173 2062 6173 6963  lexible as basic
-0000f6f0: 2066 696c 6573 0a20 2020 2020 2020 2020   files.         
-0000f700: 2020 2069 6620 7365 6c66 2e67 7a3a 0a20     if self.gz:. 
-0000f710: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0000f720: 203d 2067 7a69 702e 6f70 656e 2873 656c   = gzip.open(sel
-0000f730: 662e 6669 6c65 6e61 6d65 2c20 2272 6222  f.filename, "rb"
-0000f740: 2920 2023 2074 7970 653a 205f 4279 7465  )  # type: _Byte
-0000f750: 5374 7265 616d 0a20 2020 2020 2020 2020  Stream.         
-0000f760: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000f770: 2020 2020 2020 2020 2067 203d 206f 7065           g = ope
-0000f780: 6e28 7365 6c66 2e66 696c 656e 616d 652c  n(self.filename,
-0000f790: 2022 7262 2229 0a20 2020 2020 2020 2020   "rb").         
-0000f7a0: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-0000f7b0: 2020 2020 2020 2020 6966 2067 2e72 6561          if g.rea
-0000f7c0: 6428 3136 293a 0a20 2020 2020 2020 2020  d(16):.         
-0000f7d0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000f7e0: 6e0a 2020 2020 2020 2020 2020 2020 6669  n.            fi
-0000f7f0: 6e61 6c6c 793a 0a20 2020 2020 2020 2020  nally:.         
-0000f800: 2020 2020 2020 2067 2e63 6c6f 7365 2829         g.close()
-0000f810: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-0000f820: 662e 6c69 6e6b 7479 7065 2069 7320 4e6f  f.linktype is No
-0000f830: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0000f840: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-0000f850: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000f860: 2020 226c 696e 6b74 7970 6520 636f 756c    "linktype coul
-0000f870: 6420 6e6f 7420 6265 2067 7565 7373 6564  d not be guessed
-0000f880: 2e20 220a 2020 2020 2020 2020 2020 2020  . ".            
-0000f890: 2020 2020 2250 6c65 6173 6520 7061 7373      "Please pass
-0000f8a0: 2061 206c 696e 6b74 7970 6520 7768 696c   a linktype whil
-0000f8b0: 6520 6372 6561 7469 6e67 2074 6865 2077  e creating the w
-0000f8c0: 7269 7465 7222 0a20 2020 2020 2020 2020  riter".         
-0000f8d0: 2020 2029 0a0a 2020 2020 2020 2020 7365     )..        se
-0000f8e0: 6c66 2e66 2e77 7269 7465 2873 7472 7563  lf.f.write(struc
-0000f8f0: 742e 7061 636b 2873 656c 662e 656e 6469  t.pack(self.endi
-0000f900: 616e 202b 2022 4948 4849 4949 4922 2c20  an + "IHHIIII", 
-0000f910: 3078 6131 6232 3363 3464 2069 6620 7365  0xa1b23c4d if se
-0000f920: 6c66 2e6e 616e 6f20 656c 7365 2030 7861  lf.nano else 0xa
-0000f930: 3162 3263 3364 342c 2020 2320 6e6f 7161  1b2c3d4,  # noqa
-0000f940: 3a20 4535 3031 0a20 2020 2020 2020 2020  : E501.         
-0000f950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f960: 2020 2020 2020 2020 322c 2034 2c20 302c          2, 4, 0,
-0000f970: 2030 2c20 7365 6c66 2e73 6e61 706c 656e   0, self.snaplen
-0000f980: 2c20 7365 6c66 2e6c 696e 6b74 7970 6529  , self.linktype)
-0000f990: 290a 2020 2020 2020 2020 7365 6c66 2e66  ).        self.f
-0000f9a0: 2e66 6c75 7368 2829 0a0a 2020 2020 6465  .flush()..    de
-0000f9b0: 6620 5f77 7269 7465 5f70 6163 6b65 7428  f _write_packet(
-0000f9c0: 7365 6c66 2c0a 2020 2020 2020 2020 2020  self,.          
-0000f9d0: 2020 2020 2020 2020 2020 2020 7061 636b              pack
-0000f9e0: 6574 2c20 2023 2074 7970 653a 2055 6e69  et,  # type: Uni
-0000f9f0: 6f6e 5b62 7974 6573 2c20 5061 636b 6574  on[bytes, Packet
-0000fa00: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0000fa10: 2020 2020 2020 2020 7365 633d 4e6f 6e65          sec=None
-0000fa20: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-0000fa30: 6e61 6c5b 666c 6f61 745d 0a20 2020 2020  nal[float].     
-0000fa40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fa50: 2075 7365 633d 4e6f 6e65 2c20 2023 2074   usec=None,  # t
-0000fa60: 7970 653a 204f 7074 696f 6e61 6c5b 696e  ype: Optional[in
-0000fa70: 745d 0a20 2020 2020 2020 2020 2020 2020  t].             
-0000fa80: 2020 2020 2020 2020 2063 6170 6c65 6e3d           caplen=
-0000fa90: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
-0000faa0: 7074 696f 6e61 6c5b 696e 745d 0a20 2020  ptional[int].   
-0000fab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fac0: 2020 2077 6972 656c 656e 3d4e 6f6e 652c     wirelen=None,
-0000fad0: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-0000fae0: 616c 5b69 6e74 5d0a 2020 2020 2020 2020  al[int].        
-0000faf0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0000fb00: 6d6d 656e 743d 4e6f 6e65 2020 2320 7479  mment=None  # ty
-0000fb10: 7065 3a20 4f70 7469 6f6e 616c 5b62 7974  pe: Optional[byt
-0000fb20: 6573 5d0a 2020 2020 2020 2020 2020 2020  es].            
-0000fb30: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-0000fb40: 2020 2020 2023 2074 7970 653a 2028 2e2e       # type: (..
-0000fb50: 2e29 202d 3e20 4e6f 6e65 0a20 2020 2020  .) -> None.     
-0000fb60: 2020 2022 2222 0a20 2020 2020 2020 2057     """.        W
-0000fb70: 7269 7465 7320 6120 7369 6e67 6c65 2070  rites a single p
-0000fb80: 6163 6b65 7420 746f 2074 6865 2070 6361  acket to the pca
-0000fb90: 7020 6669 6c65 2e0a 0a20 2020 2020 2020  p file...       
-0000fba0: 203a 7061 7261 6d20 7061 636b 6574 3a20   :param packet: 
-0000fbb0: 6279 7465 7320 666f 7220 6120 7369 6e67  bytes for a sing
-0000fbc0: 6c65 2070 6163 6b65 740a 2020 2020 2020  le packet.      
-0000fbd0: 2020 3a74 7970 6520 7061 636b 6574 3a20    :type packet: 
-0000fbe0: 6279 7465 730a 2020 2020 2020 2020 3a70  bytes.        :p
-0000fbf0: 6172 616d 2073 6563 3a20 7469 6d65 2074  aram sec: time t
-0000fc00: 6865 2070 6163 6b65 7420 7761 7320 6361  he packet was ca
-0000fc10: 7074 7572 6564 2c20 696e 2073 6563 6f6e  ptured, in secon
-0000fc20: 6473 2073 696e 6365 2065 706f 6368 2e20  ds since epoch. 
-0000fc30: 4966 0a20 2020 2020 2020 2020 2020 2020  If.             
-0000fc40: 2020 2020 2020 206e 6f74 2073 7570 706c         not suppl
-0000fc50: 6965 642c 2064 6566 6175 6c74 7320 746f  ied, defaults to
-0000fc60: 206e 6f77 2e0a 2020 2020 2020 2020 3a74   now..        :t
-0000fc70: 7970 6520 7365 633a 2066 6c6f 6174 0a20  ype sec: float. 
-0000fc80: 2020 2020 2020 203a 7061 7261 6d20 7573         :param us
-0000fc90: 6563 3a20 6e6f 7420 7573 6564 2077 6974  ec: not used wit
-0000fca0: 6820 7063 6170 6e67 0a20 2020 2020 2020  h pcapng.       
-0000fcb0: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-0000fcc0: 636b 6574 2077 6173 2063 6170 7475 7265  cket was capture
-0000fcd0: 640a 2020 2020 2020 2020 3a74 7970 6520  d.        :type 
-0000fce0: 7573 6563 3a20 696e 7420 6f72 206c 6f6e  usec: int or lon
-0000fcf0: 670a 2020 2020 2020 2020 3a70 6172 616d  g.        :param
-0000fd00: 2063 6170 6c65 6e3a 2054 6865 206c 656e   caplen: The len
-0000fd10: 6774 6820 6f66 2074 6865 2070 6163 6b65  gth of the packe
-0000fd20: 7420 696e 2074 6865 2063 6170 7475 7265  t in the capture
-0000fd30: 2066 696c 652e 2049 6620 6e6f 740a 2020   file. If not.  
-0000fd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fd50: 2020 2020 2073 7065 6369 6669 6564 2c20       specified, 
-0000fd60: 7573 6573 2060 606c 656e 2870 6163 6b65  uses ``len(packe
-0000fd70: 7429 6060 2e0a 2020 2020 2020 2020 3a74  t)``..        :t
-0000fd80: 7970 6520 6361 706c 656e 3a20 696e 740a  ype caplen: int.
-0000fd90: 2020 2020 2020 2020 3a70 6172 616d 2077          :param w
-0000fda0: 6972 656c 656e 3a20 5468 6520 6c65 6e67  irelen: The leng
-0000fdb0: 7468 206f 6620 7468 6520 7061 636b 6574  th of the packet
-0000fdc0: 206f 6e20 7468 6520 7769 7265 2e20 4966   on the wire. If
-0000fdd0: 206e 6f74 0a20 2020 2020 2020 2020 2020   not.           
-0000fde0: 2020 2020 2020 2020 2020 2020 2073 7065               spe
-0000fdf0: 6369 6669 6564 2c20 7573 6573 2060 6063  cified, uses ``c
-0000fe00: 6170 6c65 6e60 602e 0a20 2020 2020 2020  aplen``..       
-0000fe10: 203a 7479 7065 2077 6972 656c 656e 3a20   :type wirelen: 
-0000fe20: 696e 740a 2020 2020 2020 2020 3a72 6574  int.        :ret
-0000fe30: 7572 6e3a 204e 6f6e 650a 2020 2020 2020  urn: None.      
-0000fe40: 2020 3a72 7479 7065 3a20 4e6f 6e65 0a20    :rtype: None. 
-0000fe50: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000fe60: 2020 2069 6620 6361 706c 656e 2069 7320     if caplen is 
-0000fe70: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000fe80: 2020 6361 706c 656e 203d 206c 656e 2870    caplen = len(p
-0000fe90: 6163 6b65 7429 0a20 2020 2020 2020 2069  acket).        i
-0000fea0: 6620 7769 7265 6c65 6e20 6973 204e 6f6e  f wirelen is Non
-0000feb0: 653a 0a20 2020 2020 2020 2020 2020 2077  e:.            w
-0000fec0: 6972 656c 656e 203d 2063 6170 6c65 6e0a  irelen = caplen.
-0000fed0: 2020 2020 2020 2020 6966 2073 6563 2069          if sec i
-0000fee0: 7320 4e6f 6e65 206f 7220 7573 6563 2069  s None or usec i
-0000fef0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0000ff00: 2020 2020 7420 3d20 7469 6d65 2e74 696d      t = time.tim
-0000ff10: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
-0000ff20: 6974 203d 2069 6e74 2874 290a 2020 2020  it = int(t).    
-0000ff30: 2020 2020 2020 2020 6966 2073 6563 2069          if sec i
-0000ff40: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0000ff50: 2020 2020 2020 2020 7365 6320 3d20 6974          sec = it
-0000ff60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ff70: 2075 7365 6320 3d20 696e 7428 726f 756e   usec = int(roun
-0000ff80: 6428 2874 202d 2069 7429 202a 0a20 2020  d((t - it) *.   
-0000ff90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ffa0: 2020 2020 2020 2020 2020 2020 2020 2831                (1
-0000ffb0: 3030 3030 3030 3030 3020 6966 2073 656c  000000000 if sel
-0000ffc0: 662e 6e61 6e6f 2065 6c73 6520 3130 3030  f.nano else 1000
-0000ffd0: 3030 3029 2929 0a20 2020 2020 2020 2020  000))).         
-0000ffe0: 2020 2065 6c69 6620 7573 6563 2069 7320     elif usec is 
-0000fff0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-00010000: 2020 2020 2020 7573 6563 203d 2030 0a0a        usec = 0..
-00010010: 2020 2020 2020 2020 7365 6c66 2e66 2e77          self.f.w
-00010020: 7269 7465 2873 7472 7563 742e 7061 636b  rite(struct.pack
-00010030: 2873 656c 662e 656e 6469 616e 202b 2022  (self.endian + "
-00010040: 4949 4949 222c 0a20 2020 2020 2020 2020  IIII",.         
-00010050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010060: 2020 2020 2020 2020 696e 7428 7365 6329          int(sec)
-00010070: 2c20 7573 6563 2c20 6361 706c 656e 2c20  , usec, caplen, 
-00010080: 7769 7265 6c65 6e29 290a 2020 2020 2020  wirelen)).      
-00010090: 2020 7365 6c66 2e66 2e77 7269 7465 2870    self.f.write(p
-000100a0: 6163 6b65 7429 0a20 2020 2020 2020 2069  acket).        i
-000100b0: 6620 7365 6c66 2e73 796e 633a 0a20 2020  f self.sync:.   
-000100c0: 2020 2020 2020 2020 2073 656c 662e 662e           self.f.
-000100d0: 666c 7573 6828 290a 0a0a 636c 6173 7320  flush()...class 
-000100e0: 5261 7750 6361 704e 6757 7269 7465 7228  RawPcapNgWriter(
-000100f0: 4765 6e65 7269 6352 6177 5063 6170 5772  GenericRawPcapWr
-00010100: 6974 6572 293a 0a20 2020 2022 2222 4120  iter):.    """A 
-00010110: 7374 7265 616d 2070 6361 706e 6720 7772  stream pcapng wr
-00010120: 6974 6572 2077 6974 6820 6d6f 7265 2063  iter with more c
-00010130: 6f6e 7472 6f6c 2074 6861 6e20 7772 7063  ontrol than wrpc
-00010140: 6170 6e67 2829 2222 220a 0a20 2020 2064  apng()"""..    d
-00010150: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
-00010160: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00010170: 2020 2066 696c 656e 616d 652c 2020 2320     filename,  # 
-00010180: 7479 7065 3a20 7374 720a 2020 2020 2020  type: str.      
-00010190: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-000101a0: 2020 2020 2020 2320 7479 7065 3a20 282e        # type: (.
-000101b0: 2e2e 2920 2d3e 204e 6f6e 650a 0a20 2020  ..) -> None..   
-000101c0: 2020 2020 2073 656c 662e 6865 6164 6572       self.header
-000101d0: 5f70 7265 7365 6e74 203d 2046 616c 7365  _present = False
-000101e0: 0a20 2020 2020 2020 2073 656c 662e 7473  .        self.ts
-000101f0: 7265 736f 6c20 3d20 3130 3030 3030 300a  resol = 1000000.
-00010200: 2020 2020 2020 2020 7365 6c66 2e6c 696e          self.lin
-00010210: 6b74 7970 6520 3d20 444c 545f 454e 3130  ktype = DLT_EN10
-00010220: 4d42 0a0a 2020 2020 2020 2020 2320 7463  MB..        # tc
-00010230: 7064 756d 7020 6f6e 6c79 2073 7570 706f  pdump only suppo
-00010240: 7274 206c 6974 746c 652d 656e 6469 616e  rt little-endian
-00010250: 2069 6e20 5043 4150 6e67 2066 696c 6573   in PCAPng files
-00010260: 0a20 2020 2020 2020 2073 656c 662e 656e  .        self.en
-00010270: 6469 616e 203d 2022 3c22 0a20 2020 2020  dian = "<".     
-00010280: 2020 2073 656c 662e 656e 6469 616e 5f6d     self.endian_m
-00010290: 6167 6963 203d 2062 225c 7834 645c 7833  agic = b"\x4d\x3
-000102a0: 635c 7832 625c 7831 6122 0a0a 2020 2020  c\x2b\x1a"..    
-000102b0: 2020 2020 7365 6c66 2e66 696c 656e 616d      self.filenam
-000102c0: 6520 3d20 6669 6c65 6e61 6d65 0a20 2020  e = filename.   
-000102d0: 2020 2020 2073 656c 662e 6620 3d20 6f70       self.f = op
-000102e0: 656e 2866 696c 656e 616d 652c 2022 7762  en(filename, "wb
-000102f0: 222c 2034 3039 3629 0a0a 2020 2020 6465  ", 4096)..    de
-00010300: 6620 5f67 6574 5f74 696d 6528 7365 6c66  f _get_time(self
-00010310: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00010320: 2020 2020 7061 636b 6574 2c20 2023 2074      packet,  # t
-00010330: 7970 653a 2055 6e69 6f6e 5b62 7974 6573  ype: Union[bytes
-00010340: 2c20 5061 636b 6574 5d0a 2020 2020 2020  , Packet].      
-00010350: 2020 2020 2020 2020 2020 2020 7365 632c              sec,
-00010360: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-00010370: 616c 5b66 6c6f 6174 5d0a 2020 2020 2020  al[float].      
-00010380: 2020 2020 2020 2020 2020 2020 7573 6563              usec
-00010390: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-000103a0: 616c 5b69 6e74 5d0a 2020 2020 2020 2020  al[int].        
-000103b0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-000103c0: 2020 2020 2023 2074 7970 653a 2028 2e2e       # type: (..
-000103d0: 2e29 202d 3e20 5475 706c 655b 666c 6f61  .) -> Tuple[floa
-000103e0: 742c 2069 6e74 5d0a 2020 2020 2020 2020  t, int].        
-000103f0: 6966 2068 6173 6174 7472 2870 6163 6b65  if hasattr(packe
-00010400: 742c 2022 7469 6d65 2229 3a0a 2020 2020  t, "time"):.    
-00010410: 2020 2020 2020 2020 6966 2073 6563 2069          if sec i
-00010420: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-00010430: 2020 2020 2020 2020 7365 6320 3d20 666c          sec = fl
-00010440: 6f61 7428 7061 636b 6574 2e74 696d 6529  oat(packet.time)
-00010450: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00010460: 0a0a 2020 2020 2020 2020 6966 2075 7365  ..        if use
-00010470: 6320 6973 204e 6f6e 653a 0a20 2020 2020  c is None:.     
-00010480: 2020 2020 2020 2075 7365 6320 3d20 300a         usec = 0.
-00010490: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000104a0: 7365 632c 2075 7365 6320 2023 2074 7970  sec, usec  # typ
-000104b0: 653a 2069 676e 6f72 650a 0a20 2020 2064  e: ignore..    d
-000104c0: 6566 205f 6164 645f 7061 6464 696e 6728  ef _add_padding(
-000104d0: 7365 6c66 2c20 7261 775f 6461 7461 293a  self, raw_data):
-000104e0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-000104f0: 2028 6279 7465 7329 202d 3e20 6279 7465   (bytes) -> byte
-00010500: 730a 2020 2020 2020 2020 7261 775f 6461  s.        raw_da
-00010510: 7461 202b 3d20 2828 2d6c 656e 2872 6177  ta += ((-len(raw
-00010520: 5f64 6174 6129 2920 2520 3429 202a 2062  _data)) % 4) * b
-00010530: 225c 7830 3022 0a20 2020 2020 2020 2072  "\x00".        r
-00010540: 6574 7572 6e20 7261 775f 6461 7461 0a0a  eturn raw_data..
-00010550: 2020 2020 6465 6620 6275 696c 645f 626c      def build_bl
-00010560: 6f63 6b28 7365 6c66 2c20 626c 6f63 6b5f  ock(self, block_
-00010570: 7479 7065 2c20 626c 6f63 6b5f 626f 6479  type, block_body
-00010580: 2c20 6f70 7469 6f6e 733d 4e6f 6e65 293a  , options=None):
-00010590: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-000105a0: 2028 6279 7465 732c 2062 7974 6573 2c20   (bytes, bytes, 
-000105b0: 4f70 7469 6f6e 616c 5b62 7974 6573 5d29  Optional[bytes])
-000105c0: 202d 3e20 6279 7465 730a 0a20 2020 2020   -> bytes..     
-000105d0: 2020 2023 2050 6164 2042 6c6f 636b 2042     # Pad Block B
-000105e0: 6f64 7920 746f 2033 3220 6269 7473 0a20  ody to 32 bits. 
-000105f0: 2020 2020 2020 2062 6c6f 636b 5f62 6f64         block_bod
-00010600: 7920 3d20 7365 6c66 2e5f 6164 645f 7061  y = self._add_pa
-00010610: 6464 696e 6728 626c 6f63 6b5f 626f 6479  dding(block_body
-00010620: 290a 0a20 2020 2020 2020 2069 6620 6f70  )..        if op
-00010630: 7469 6f6e 733a 0a20 2020 2020 2020 2020  tions:.         
-00010640: 2020 2062 6c6f 636b 5f62 6f64 7920 2b3d     block_body +=
-00010650: 206f 7074 696f 6e73 0a0a 2020 2020 2020   options..      
-00010660: 2020 2320 416e 2065 6d70 7479 2062 6c6f    # An empty blo
-00010670: 636b 2069 7320 3132 2062 7974 6573 206c  ck is 12 bytes l
-00010680: 6f6e 670a 2020 2020 2020 2020 626c 6f63  ong.        bloc
-00010690: 6b5f 746f 7461 6c5f 6c65 6e67 7468 203d  k_total_length =
-000106a0: 2031 3220 2b20 6c65 6e28 626c 6f63 6b5f   12 + len(block_
-000106b0: 626f 6479 290a 0a20 2020 2020 2020 2023  body)..        #
-000106c0: 2042 6c6f 636b 2054 7970 650a 2020 2020   Block Type.    
-000106d0: 2020 2020 626c 6f63 6b20 3d20 626c 6f63      block = bloc
-000106e0: 6b5f 7479 7065 0a20 2020 2020 2020 2023  k_type.        #
-000106f0: 2042 6c6f 636b 2054 6f74 616c 204c 656e   Block Total Len
-00010700: 6774 6824 0a20 2020 2020 2020 2062 6c6f  gth$.        blo
-00010710: 636b 202b 3d20 7374 7275 6374 2e70 6163  ck += struct.pac
-00010720: 6b28 7365 6c66 2e65 6e64 6961 6e20 2b20  k(self.endian + 
-00010730: 2249 222c 2062 6c6f 636b 5f74 6f74 616c  "I", block_total
-00010740: 5f6c 656e 6774 6829 0a20 2020 2020 2020  _length).       
-00010750: 2023 2042 6c6f 636b 2042 6f64 790a 2020   # Block Body.  
-00010760: 2020 2020 2020 626c 6f63 6b20 2b3d 2062        block += b
-00010770: 6c6f 636b 5f62 6f64 790a 2020 2020 2020  lock_body.      
-00010780: 2020 2320 426c 6f63 6b20 546f 7461 6c20    # Block Total 
-00010790: 4c65 6e67 7468 240a 2020 2020 2020 2020  Length$.        
-000107a0: 626c 6f63 6b20 2b3d 2073 7472 7563 742e  block += struct.
-000107b0: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-000107c0: 202b 2022 4922 2c20 626c 6f63 6b5f 746f   + "I", block_to
-000107d0: 7461 6c5f 6c65 6e67 7468 290a 0a20 2020  tal_length)..   
-000107e0: 2020 2020 2072 6574 7572 6e20 626c 6f63       return bloc
-000107f0: 6b0a 0a20 2020 2064 6566 205f 7772 6974  k..    def _writ
-00010800: 655f 6865 6164 6572 2873 656c 662c 2070  e_header(self, p
-00010810: 6b74 293a 0a20 2020 2020 2020 2023 2074  kt):.        # t
-00010820: 7970 653a 2028 4f70 7469 6f6e 616c 5b55  ype: (Optional[U
-00010830: 6e69 6f6e 5b50 6163 6b65 742c 2062 7974  nion[Packet, byt
-00010840: 6573 5d5d 2920 2d3e 204e 6f6e 650a 2020  es]]) -> None.  
-00010850: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-00010860: 662e 6865 6164 6572 5f70 7265 7365 6e74  f.header_present
-00010870: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00010880: 6c66 2e68 6561 6465 725f 7072 6573 656e  lf.header_presen
-00010890: 7420 3d20 5472 7565 0a20 2020 2020 2020  t = True.       
-000108a0: 2020 2020 2073 656c 662e 5f77 7269 7465       self._write
-000108b0: 5f62 6c6f 636b 5f73 6862 2829 0a20 2020  _block_shb().   
-000108c0: 2020 2020 2020 2020 2073 656c 662e 5f77           self._w
-000108d0: 7269 7465 5f62 6c6f 636b 5f69 6462 2829  rite_block_idb()
-000108e0: 0a0a 2020 2020 6465 6620 5f77 7269 7465  ..    def _write
-000108f0: 5f62 6c6f 636b 5f73 6862 2873 656c 6629  _block_shb(self)
-00010900: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
-00010910: 3a20 2829 202d 3e20 4e6f 6e65 0a0a 2020  : () -> None..  
-00010920: 2020 2020 2020 2320 426c 6f63 6b20 5479        # Block Ty
-00010930: 7065 0a20 2020 2020 2020 2062 6c6f 636b  pe.        block
-00010940: 5f74 7970 6520 3d20 6222 5c78 3041 5c78  _type = b"\x0A\x
-00010950: 3044 5c78 3044 5c78 3041 220a 2020 2020  0D\x0D\x0A".    
-00010960: 2020 2020 2320 4279 7465 2d4f 7264 6572      # Byte-Order
-00010970: 204d 6167 6963 0a20 2020 2020 2020 2062   Magic.        b
-00010980: 6c6f 636b 5f73 6862 203d 2073 656c 662e  lock_shb = self.
-00010990: 656e 6469 616e 5f6d 6167 6963 0a20 2020  endian_magic.   
-000109a0: 2020 2020 2023 204d 616a 6f72 2056 6572       # Major Ver
-000109b0: 7369 6f6e 0a20 2020 2020 2020 2062 6c6f  sion.        blo
-000109c0: 636b 5f73 6862 202b 3d20 7374 7275 6374  ck_shb += struct
-000109d0: 2e70 6163 6b28 7365 6c66 2e65 6e64 6961  .pack(self.endia
-000109e0: 6e20 2b20 2248 222c 2031 290a 2020 2020  n + "H", 1).    
-000109f0: 2020 2020 2320 4d69 6e6f 7220 5665 7273      # Minor Vers
-00010a00: 696f 6e0a 2020 2020 2020 2020 626c 6f63  ion.        bloc
-00010a10: 6b5f 7368 6220 2b3d 2073 7472 7563 742e  k_shb += struct.
-00010a20: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-00010a30: 202b 2022 4822 2c20 3029 0a20 2020 2020   + "H", 0).     
-00010a40: 2020 2023 2053 6563 7469 6f6e 204c 656e     # Section Len
-00010a50: 6774 680a 2020 2020 2020 2020 626c 6f63  gth.        bloc
-00010a60: 6b5f 7368 6220 2b3d 2073 7472 7563 742e  k_shb += struct.
-00010a70: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-00010a80: 202b 2022 5122 2c20 3029 0a0a 2020 2020   + "Q", 0)..    
-00010a90: 2020 2020 7365 6c66 2e66 2e77 7269 7465      self.f.write
-00010aa0: 2873 656c 662e 6275 696c 645f 626c 6f63  (self.build_bloc
-00010ab0: 6b28 626c 6f63 6b5f 7479 7065 2c20 626c  k(block_type, bl
-00010ac0: 6f63 6b5f 7368 6229 290a 0a20 2020 2064  ock_shb))..    d
-00010ad0: 6566 205f 7772 6974 655f 626c 6f63 6b5f  ef _write_block_
-00010ae0: 6964 6228 7365 6c66 293a 0a20 2020 2020  idb(self):.     
-00010af0: 2020 2023 2074 7970 653a 2028 2920 2d3e     # type: () ->
-00010b00: 204e 6f6e 650a 0a20 2020 2020 2020 2023   None..        #
-00010b10: 2042 6c6f 636b 2054 7970 650a 2020 2020   Block Type.    
-00010b20: 2020 2020 626c 6f63 6b5f 7479 7065 203d      block_type =
-00010b30: 2073 7472 7563 742e 7061 636b 2873 656c   struct.pack(sel
-00010b40: 662e 656e 6469 616e 202b 2022 4922 2c20  f.endian + "I", 
-00010b50: 3129 0a20 2020 2020 2020 2023 204c 696e  1).        # Lin
-00010b60: 6b54 7970 650a 2020 2020 2020 2020 626c  kType.        bl
-00010b70: 6f63 6b5f 6964 6220 3d20 7374 7275 6374  ock_idb = struct
-00010b80: 2e70 6163 6b28 7365 6c66 2e65 6e64 6961  .pack(self.endia
-00010b90: 6e20 2b20 2248 222c 2073 656c 662e 6c69  n + "H", self.li
-00010ba0: 6e6b 7479 7065 290a 2020 2020 2020 2020  nktype).        
-00010bb0: 2320 5265 7365 7276 6564 0a20 2020 2020  # Reserved.     
-00010bc0: 2020 2062 6c6f 636b 5f69 6462 202b 3d20     block_idb += 
-00010bd0: 7374 7275 6374 2e70 6163 6b28 7365 6c66  struct.pack(self
-00010be0: 2e65 6e64 6961 6e20 2b20 2248 222c 2030  .endian + "H", 0
-00010bf0: 290a 2020 2020 2020 2020 2320 536e 6170  ).        # Snap
-00010c00: 4c65 6e0a 2020 2020 2020 2020 626c 6f63  Len.        bloc
-00010c10: 6b5f 6964 6220 2b3d 2073 7472 7563 742e  k_idb += struct.
-00010c20: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-00010c30: 202b 2022 4922 2c20 3236 3231 3434 290a   + "I", 262144).
-00010c40: 0a20 2020 2020 2020 2073 656c 662e 662e  .        self.f.
-00010c50: 7772 6974 6528 7365 6c66 2e62 7569 6c64  write(self.build
-00010c60: 5f62 6c6f 636b 2862 6c6f 636b 5f74 7970  _block(block_typ
-00010c70: 652c 2062 6c6f 636b 5f69 6462 2929 0a0a  e, block_idb))..
-00010c80: 2020 2020 6465 6620 5f77 7269 7465 5f62      def _write_b
-00010c90: 6c6f 636b 5f73 7062 2873 656c 662c 2072  lock_spb(self, r
-00010ca0: 6177 5f70 6b74 293a 0a20 2020 2020 2020  aw_pkt):.       
-00010cb0: 2023 2074 7970 653a 2028 6279 7465 7329   # type: (bytes)
-00010cc0: 202d 3e20 4e6f 6e65 0a0a 2020 2020 2020   -> None..      
-00010cd0: 2020 2320 426c 6f63 6b20 5479 7065 0a20    # Block Type. 
-00010ce0: 2020 2020 2020 2062 6c6f 636b 5f74 7970         block_typ
-00010cf0: 6520 3d20 7374 7275 6374 2e70 6163 6b28  e = struct.pack(
-00010d00: 7365 6c66 2e65 6e64 6961 6e20 2b20 2249  self.endian + "I
-00010d10: 222c 2033 290a 2020 2020 2020 2020 2320  ", 3).        # 
-00010d20: 4f72 6967 696e 616c 2050 6163 6b65 7420  Original Packet 
-00010d30: 4c65 6e67 7468 0a20 2020 2020 2020 2062  Length.        b
-00010d40: 6c6f 636b 5f73 7062 203d 2073 7472 7563  lock_spb = struc
-00010d50: 742e 7061 636b 2873 656c 662e 656e 6469  t.pack(self.endi
-00010d60: 616e 202b 2022 4922 2c20 6c65 6e28 7261  an + "I", len(ra
-00010d70: 775f 706b 7429 290a 2020 2020 2020 2020  w_pkt)).        
-00010d80: 2320 5061 636b 6574 2044 6174 610a 2020  # Packet Data.  
-00010d90: 2020 2020 2020 626c 6f63 6b5f 7370 6220        block_spb 
-00010da0: 2b3d 2072 6177 5f70 6b74 0a0a 2020 2020  += raw_pkt..    
-00010db0: 2020 2020 7365 6c66 2e66 2e77 7269 7465      self.f.write
-00010dc0: 2873 656c 662e 6275 696c 645f 626c 6f63  (self.build_bloc
-00010dd0: 6b28 626c 6f63 6b5f 7479 7065 2c20 626c  k(block_type, bl
-00010de0: 6f63 6b5f 7370 6229 290a 0a20 2020 2064  ock_spb))..    d
-00010df0: 6566 205f 7772 6974 655f 626c 6f63 6b5f  ef _write_block_
-00010e00: 6570 6228 7365 6c66 2c0a 2020 2020 2020  epb(self,.      
-00010e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e20: 2020 2072 6177 5f70 6b74 2c20 2023 2074     raw_pkt,  # t
-00010e30: 7970 653a 2062 7974 6573 0a20 2020 2020  ype: bytes.     
-00010e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e50: 2020 2020 7469 6d65 7374 616d 703d 4e6f      timestamp=No
-00010e60: 6e65 2c20 2023 2074 7970 653a 204f 7074  ne,  # type: Opt
-00010e70: 696f 6e61 6c5b 556e 696f 6e5b 4544 6563  ional[Union[EDec
-00010e80: 696d 616c 2c20 666c 6f61 745d 5d20 2023  imal, float]]  #
-00010e90: 206e 6f71 613a 2045 3530 310a 2020 2020   noqa: E501.    
-00010ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010eb0: 2020 2020 2063 6170 6c65 6e3d 4e6f 6e65       caplen=None
-00010ec0: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-00010ed0: 6e61 6c5b 696e 745d 0a20 2020 2020 2020  nal[int].       
-00010ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010ef0: 2020 6f72 676c 656e 3d4e 6f6e 652c 2020    orglen=None,  
-00010f00: 2320 7479 7065 3a20 4f70 7469 6f6e 616c  # type: Optional
-00010f10: 5b69 6e74 5d0a 2020 2020 2020 2020 2020  [int].          
-00010f20: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00010f30: 6f6d 6d65 6e74 3d4e 6f6e 6520 2023 2074  omment=None  # t
-00010f40: 7970 653a 204f 7074 696f 6e61 6c5b 6279  ype: Optional[by
-00010f50: 7465 735d 0a20 2020 2020 2020 2020 2020  tes].           
-00010f60: 2020 2020 2020 2020 2020 2020 2020 293a                ):
-00010f70: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-00010f80: 2028 2e2e 2e29 202d 3e20 4e6f 6e65 0a0a   (...) -> None..
-00010f90: 2020 2020 2020 2020 6966 2074 696d 6573          if times
-00010fa0: 7461 6d70 3a0a 2020 2020 2020 2020 2020  tamp:.          
-00010fb0: 2020 746d 705f 7473 203d 2069 6e74 2874    tmp_ts = int(t
-00010fc0: 696d 6573 7461 6d70 202a 2073 656c 662e  imestamp * self.
-00010fd0: 7473 7265 736f 6c29 0a20 2020 2020 2020  tsresol).       
-00010fe0: 2020 2020 2074 735f 6869 6768 203d 2074       ts_high = t
-00010ff0: 6d70 5f74 7320 3e3e 2033 320a 2020 2020  mp_ts >> 32.    
-00011000: 2020 2020 2020 2020 7473 5f6c 6f77 203d          ts_low =
-00011010: 2074 6d70 5f74 7320 2620 3078 4646 4646   tmp_ts & 0xFFFF
-00011020: 4646 4646 0a20 2020 2020 2020 2065 6c73  FFFF.        els
-00011030: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
-00011040: 735f 6869 6768 203d 2074 735f 6c6f 7720  s_high = ts_low 
-00011050: 3d20 300a 0a20 2020 2020 2020 2069 6620  = 0..        if 
-00011060: 6e6f 7420 6361 706c 656e 3a0a 2020 2020  not caplen:.    
-00011070: 2020 2020 2020 2020 6361 706c 656e 203d          caplen =
-00011080: 206c 656e 2872 6177 5f70 6b74 290a 0a20   len(raw_pkt).. 
-00011090: 2020 2020 2020 2069 6620 6e6f 7420 6f72         if not or
-000110a0: 676c 656e 3a0a 2020 2020 2020 2020 2020  glen:.          
-000110b0: 2020 6f72 676c 656e 203d 206c 656e 2872    orglen = len(r
-000110c0: 6177 5f70 6b74 290a 0a20 2020 2020 2020  aw_pkt)..       
-000110d0: 2023 2042 6c6f 636b 2054 7970 650a 2020   # Block Type.  
-000110e0: 2020 2020 2020 626c 6f63 6b5f 7479 7065        block_type
-000110f0: 203d 2073 7472 7563 742e 7061 636b 2873   = struct.pack(s
-00011100: 656c 662e 656e 6469 616e 202b 2022 4922  elf.endian + "I"
-00011110: 2c20 3629 0a20 2020 2020 2020 2023 2049  , 6).        # I
-00011120: 6e74 6572 6661 6365 2049 440a 2020 2020  nterface ID.    
-00011130: 2020 2020 626c 6f63 6b5f 6570 6220 3d20      block_epb = 
-00011140: 7374 7275 6374 2e70 6163 6b28 7365 6c66  struct.pack(self
-00011150: 2e65 6e64 6961 6e20 2b20 2249 222c 2030  .endian + "I", 0
-00011160: 290a 2020 2020 2020 2020 2320 5469 6d65  ).        # Time
-00011170: 7374 616d 7020 2848 6967 6829 0a20 2020  stamp (High).   
-00011180: 2020 2020 2062 6c6f 636b 5f65 7062 202b       block_epb +
-00011190: 3d20 7374 7275 6374 2e70 6163 6b28 7365  = struct.pack(se
-000111a0: 6c66 2e65 6e64 6961 6e20 2b20 2249 222c  lf.endian + "I",
-000111b0: 2074 735f 6869 6768 290a 2020 2020 2020   ts_high).      
-000111c0: 2020 2320 5469 6d65 7374 616d 7020 284c    # Timestamp (L
-000111d0: 6f77 290a 2020 2020 2020 2020 626c 6f63  ow).        bloc
-000111e0: 6b5f 6570 6220 2b3d 2073 7472 7563 742e  k_epb += struct.
-000111f0: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-00011200: 202b 2022 4922 2c20 7473 5f6c 6f77 290a   + "I", ts_low).
-00011210: 2020 2020 2020 2020 2320 4361 7074 7572          # Captur
-00011220: 6564 2050 6163 6b65 7420 4c65 6e67 7468  ed Packet Length
-00011230: 0a20 2020 2020 2020 2062 6c6f 636b 5f65  .        block_e
-00011240: 7062 202b 3d20 7374 7275 6374 2e70 6163  pb += struct.pac
-00011250: 6b28 7365 6c66 2e65 6e64 6961 6e20 2b20  k(self.endian + 
-00011260: 2249 222c 2063 6170 6c65 6e29 0a20 2020  "I", caplen).   
-00011270: 2020 2020 2023 204f 7269 6769 6e61 6c20       # Original 
-00011280: 5061 636b 6574 204c 656e 6774 680a 2020  Packet Length.  
-00011290: 2020 2020 2020 626c 6f63 6b5f 6570 6220        block_epb 
-000112a0: 2b3d 2073 7472 7563 742e 7061 636b 2873  += struct.pack(s
-000112b0: 656c 662e 656e 6469 616e 202b 2022 4922  elf.endian + "I"
-000112c0: 2c20 6f72 676c 656e 290a 2020 2020 2020  , orglen).      
-000112d0: 2020 2320 5061 636b 6574 2044 6174 610a    # Packet Data.
-000112e0: 2020 2020 2020 2020 626c 6f63 6b5f 6570          block_ep
-000112f0: 6220 2b3d 2072 6177 5f70 6b74 0a0a 2020  b += raw_pkt..  
-00011300: 2020 2020 2020 2320 436f 6d6d 656e 7420        # Comment 
-00011310: 6f70 7469 6f6e 0a20 2020 2020 2020 2063  option.        c
-00011320: 6f6d 6d65 6e74 5f6f 7074 203d 204e 6f6e  omment_opt = Non
-00011330: 650a 2020 2020 2020 2020 6966 2063 6f6d  e.        if com
-00011340: 6d65 6e74 3a0a 2020 2020 2020 2020 2020  ment:.          
-00011350: 2020 636f 6d6d 656e 7420 3d20 6279 7465    comment = byte
-00011360: 735f 656e 636f 6465 2863 6f6d 6d65 6e74  s_encode(comment
-00011370: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-00011380: 206e 6f74 2063 6f6d 6d65 6e74 2e65 6e64   not comment.end
-00011390: 7377 6974 6828 6222 5c6e 2229 3a0a 2020  swith(b"\n"):.  
-000113a0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-000113b0: 6d6d 656e 7420 2b3d 2062 225c 6e22 0a20  mment += b"\n". 
-000113c0: 2020 2020 2020 2020 2020 2063 6f6d 6d65             comme
-000113d0: 6e74 5f6f 7074 203d 2073 7472 7563 742e  nt_opt = struct.
-000113e0: 7061 636b 2873 656c 662e 656e 6469 616e  pack(self.endian
-000113f0: 202b 2022 4848 222c 2031 2c20 6c65 6e28   + "HH", 1, len(
-00011400: 636f 6d6d 656e 7429 290a 0a20 2020 2020  comment))..     
-00011410: 2020 2020 2020 2023 2050 6164 204f 7074         # Pad Opt
-00011420: 696f 6e20 5661 6c75 6520 746f 2033 3220  ion Value to 32 
-00011430: 6269 7473 0a20 2020 2020 2020 2020 2020  bits.           
-00011440: 2063 6f6d 6d65 6e74 5f6f 7074 202b 3d20   comment_opt += 
-00011450: 7365 6c66 2e5f 6164 645f 7061 6464 696e  self._add_paddin
-00011460: 6728 6279 7465 735f 656e 636f 6465 2863  g(bytes_encode(c
-00011470: 6f6d 6d65 6e74 2929 0a20 2020 2020 2020  omment)).       
-00011480: 2020 2020 2063 6f6d 6d65 6e74 5f6f 7074       comment_opt
-00011490: 202b 3d20 7374 7275 6374 2e70 6163 6b28   += struct.pack(
-000114a0: 7365 6c66 2e65 6e64 6961 6e20 2b20 2248  self.endian + "H
-000114b0: 4822 2c20 302c 2030 290a 0a20 2020 2020  H", 0, 0)..     
-000114c0: 2020 2073 656c 662e 662e 7772 6974 6528     self.f.write(
-000114d0: 7365 6c66 2e62 7569 6c64 5f62 6c6f 636b  self.build_block
-000114e0: 2862 6c6f 636b 5f74 7970 652c 2062 6c6f  (block_type, blo
-000114f0: 636b 5f65 7062 2c0a 2020 2020 2020 2020  ck_epb,.        
-00011500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011510: 2020 2020 2020 2020 2020 2020 2020 6f70                op
-00011520: 7469 6f6e 733d 636f 6d6d 656e 745f 6f70  tions=comment_op
-00011530: 7429 290a 0a20 2020 2064 6566 205f 7772  t))..    def _wr
-00011540: 6974 655f 7061 636b 6574 2873 656c 662c  ite_packet(self,
-00011550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011560: 2020 2020 2020 2070 6163 6b65 742c 2020         packet,  
-00011570: 2320 7479 7065 3a20 6279 7465 730a 2020  # type: bytes.  
-00011580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011590: 2020 2020 7365 633d 4e6f 6e65 2c20 2023      sec=None,  #
-000115a0: 2074 7970 653a 204f 7074 696f 6e61 6c5b   type: Optional[
-000115b0: 666c 6f61 745d 0a20 2020 2020 2020 2020  float].         
-000115c0: 2020 2020 2020 2020 2020 2020 2075 7365               use
-000115d0: 633d 4e6f 6e65 2c20 2023 2074 7970 653a  c=None,  # type:
-000115e0: 204f 7074 696f 6e61 6c5b 696e 745d 0a20   Optional[int]. 
-000115f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011600: 2020 2020 2063 6170 6c65 6e3d 4e6f 6e65       caplen=None
-00011610: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-00011620: 6e61 6c5b 696e 745d 0a20 2020 2020 2020  nal[int].       
-00011630: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-00011640: 6972 656c 656e 3d4e 6f6e 652c 2020 2320  irelen=None,  # 
-00011650: 7479 7065 3a20 4f70 7469 6f6e 616c 5b69  type: Optional[i
-00011660: 6e74 5d0a 2020 2020 2020 2020 2020 2020  nt].            
-00011670: 2020 2020 2020 2020 2020 636f 6d6d 656e            commen
-00011680: 743d 4e6f 6e65 2020 2320 7479 7065 3a20  t=None  # type: 
-00011690: 4f70 7469 6f6e 616c 5b62 7974 6573 5d0a  Optional[bytes].
-000116a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000116b0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
-000116c0: 2023 2074 7970 653a 2028 2e2e 2e29 202d   # type: (...) -
-000116d0: 3e20 4e6f 6e65 0a20 2020 2020 2020 2022  > None.        "
-000116e0: 2222 0a20 2020 2020 2020 2057 7269 7465  "".        Write
-000116f0: 7320 6120 7369 6e67 6c65 2070 6163 6b65  s a single packe
-00011700: 7420 746f 2074 6865 2070 6361 7020 6669  t to the pcap fi
-00011710: 6c65 2e0a 0a20 2020 2020 2020 203a 7061  le...        :pa
-00011720: 7261 6d20 7061 636b 6574 3a20 6279 7465  ram packet: byte
-00011730: 7320 666f 7220 6120 7369 6e67 6c65 2070  s for a single p
-00011740: 6163 6b65 740a 2020 2020 2020 2020 3a74  acket.        :t
-00011750: 7970 6520 7061 636b 6574 3a20 6279 7465  ype packet: byte
-00011760: 730a 2020 2020 2020 2020 3a70 6172 616d  s.        :param
-00011770: 2073 6563 3a20 7469 6d65 2074 6865 2070   sec: time the p
-00011780: 6163 6b65 7420 7761 7320 6361 7074 7572  acket was captur
-00011790: 6564 2c20 696e 2073 6563 6f6e 6473 2073  ed, in seconds s
-000117a0: 696e 6365 2065 706f 6368 2e20 4966 0a20  ince epoch. If. 
+0000dca0: 2020 2020 2020 2020 6469 7265 6374 696f          directio
+0000dcb0: 6e3d 4e6f 6e65 2929 0a0a 2020 2020 6465  n=None))..    de
+0000dcc0: 6620 5f72 6561 645f 626c 6f63 6b5f 6473  f _read_block_ds
+0000dcd0: 6228 7365 6c66 2c20 626c 6f63 6b2c 2073  b(self, block, s
+0000dce0: 697a 6529 3a0a 2020 2020 2020 2020 2320  ize):.        # 
+0000dcf0: 7479 7065 3a20 2862 7974 6573 2c20 696e  type: (bytes, in
+0000dd00: 7429 202d 3e20 4e6f 6e65 0a20 2020 2020  t) -> None.     
+0000dd10: 2020 2022 2222 4465 6372 7970 7469 6f6e     """Decryption
+0000dd20: 2053 6563 7265 7473 2042 6c6f 636b 2222   Secrets Block""
+0000dd30: 220a 0a20 2020 2020 2020 2023 2050 6172  "..        # Par
+0000dd40: 7365 2074 6865 2073 6563 7265 7473 2074  se the secrets t
+0000dd50: 7970 6520 616e 6420 6c65 6e67 7468 2066  ype and length f
+0000dd60: 6965 6c64 730a 2020 2020 2020 2020 7472  ields.        tr
+0000dd70: 793a 0a20 2020 2020 2020 2020 2020 2073  y:.            s
+0000dd80: 6563 7265 7473 5f74 7970 652c 2073 6563  ecrets_type, sec
+0000dd90: 7265 7473 5f6c 656e 6774 6820 3d20 7374  rets_length = st
+0000dda0: 7275 6374 2e75 6e70 6163 6b28 0a20 2020  ruct.unpack(.   
+0000ddb0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000ddc0: 662e 656e 6469 616e 202b 2022 4949 222c  f.endian + "II",
+0000ddd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000dde0: 2062 6c6f 636b 5b3a 385d 2c0a 2020 2020   block[:8],.    
+0000ddf0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000de00: 2020 2020 2020 626c 6f63 6b20 3d20 626c        block = bl
+0000de10: 6f63 6b5b 383a 5d0a 2020 2020 2020 2020  ock[8:].        
+0000de20: 6578 6365 7074 2073 7472 7563 742e 6572  except struct.er
+0000de30: 726f 723a 0a20 2020 2020 2020 2020 2020  ror:.           
+0000de40: 2077 6172 6e69 6e67 2822 5063 6170 4e67   warning("PcapNg
+0000de50: 3a20 4453 4220 6973 2074 6f6f 2073 6d61  : DSB is too sma
+0000de60: 6c6c 2025 6421 222c 206c 656e 2862 6c6f  ll %d!", len(blo
+0000de70: 636b 2929 0a20 2020 2020 2020 2020 2020  ck)).           
+0000de80: 2072 6169 7365 2045 4f46 4572 726f 720a   raise EOFError.
+0000de90: 0a20 2020 2020 2020 2023 2043 6f6d 7075  .        # Compu
+0000dea0: 7465 2074 6865 2073 6563 7265 7473 206c  te the secrets l
+0000deb0: 656e 6774 6820 696e 636c 7564 696e 6720  ength including 
+0000dec0: 7468 6520 7061 6464 696e 670a 2020 2020  the padding.    
+0000ded0: 2020 2020 7061 6464 6564 5f73 6563 7265      padded_secre
+0000dee0: 7473 5f6c 656e 6774 6820 3d20 7365 6372  ts_length = secr
+0000def0: 6574 735f 6c65 6e67 7468 202b 2028 2d73  ets_length + (-s
+0000df00: 6563 7265 7473 5f6c 656e 6774 6829 2025  ecrets_length) %
+0000df10: 2034 0a20 2020 2020 2020 2069 6620 6c65   4.        if le
+0000df20: 6e28 626c 6f63 6b29 203c 2070 6164 6465  n(block) < padde
+0000df30: 645f 7365 6372 6574 735f 6c65 6e67 7468  d_secrets_length
+0000df40: 3a0a 2020 2020 2020 2020 2020 2020 7761  :.            wa
+0000df50: 726e 696e 6728 2250 6361 704e 673a 2069  rning("PcapNg: i
+0000df60: 6e76 616c 6964 2044 5342 2073 6563 7265  nvalid DSB secre
+0000df70: 7473 206c 656e 6774 6821 2229 0a20 2020  ts length!").   
+0000df80: 2020 2020 2020 2020 2072 6169 7365 2045           raise E
+0000df90: 4f46 4572 726f 720a 0a20 2020 2020 2020  OFError..       
+0000dfa0: 2023 2045 7874 7261 6374 2073 6563 7265   # Extract secre
+0000dfb0: 7473 2064 6174 6120 616e 6420 6f70 7469  ts data and opti
+0000dfc0: 6f6e 730a 2020 2020 2020 2020 7365 6372  ons.        secr
+0000dfd0: 6574 735f 6461 7461 203d 2062 6c6f 636b  ets_data = block
+0000dfe0: 5b3a 7061 6464 6564 5f73 6563 7265 7473  [:padded_secrets
+0000dff0: 5f6c 656e 6774 685d 5b3a 7365 6372 6574  _length][:secret
+0000e000: 735f 6c65 6e67 7468 5d0a 2020 2020 2020  s_length].      
+0000e010: 2020 6966 2062 6c6f 636b 5b70 6164 6465    if block[padde
+0000e020: 645f 7365 6372 6574 735f 6c65 6e67 7468  d_secrets_length
+0000e030: 3a5d 3a0a 2020 2020 2020 2020 2020 2020  :]:.            
+0000e040: 7761 726e 696e 6728 2250 6361 704e 673a  warning("PcapNg:
+0000e050: 2044 5342 206f 7074 696f 6e73 2061 7265   DSB options are
+0000e060: 206e 6f74 2073 7570 706f 7274 6564 2122   not supported!"
+0000e070: 290a 0a20 2020 2020 2020 2023 2054 4c53  )..        # TLS
+0000e080: 204b 6579 204c 6f67 0a20 2020 2020 2020   Key Log.       
+0000e090: 2069 6620 7365 6372 6574 735f 7479 7065   if secrets_type
+0000e0a0: 203d 3d20 3078 3534 3463 3533 3462 3a0a   == 0x544c534b:.
+0000e0b0: 2020 2020 2020 2020 2020 2020 6966 2067              if g
+0000e0c0: 6574 6174 7472 2863 6f6e 662c 2022 746c  etattr(conf, "tl
+0000e0d0: 735f 7365 7373 696f 6e73 222c 2046 616c  s_sessions", Fal
+0000e0e0: 7365 2920 6973 2046 616c 7365 3a0a 2020  se) is False:.  
+0000e0f0: 2020 2020 2020 2020 2020 2020 2020 7761                wa
+0000e100: 726e 696e 6728 2250 6361 704e 673a 2054  rning("PcapNg: T
+0000e110: 4c53 204b 6579 204c 6f67 2061 7661 696c  LS Key Log avail
+0000e120: 6162 6c65 2c20 6275 7420 220a 2020 2020  able, but ".    
+0000e130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e140: 2020 2020 2274 6865 2054 4c53 206c 6179      "the TLS lay
+0000e150: 6572 2069 7320 6e6f 7420 6c6f 6164 6564  er is not loaded
+0000e160: 2120 5363 6170 7920 776f 6e27 7420 6265  ! Scapy won't be
+0000e170: 2061 626c 6520 220a 2020 2020 2020 2020   able ".        
+0000e180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e190: 2274 6f20 6465 6372 7970 7420 7468 6520  "to decrypt the 
+0000e1a0: 7061 636b 6574 732e 2229 0a20 2020 2020  packets.").     
+0000e1b0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000e1c0: 2020 2020 2020 2020 2020 2020 2066 726f               fro
+0000e1d0: 6d20 7363 6170 792e 6c61 7965 7273 2e74  m scapy.layers.t
+0000e1e0: 6c73 2e73 6573 7369 6f6e 2069 6d70 6f72  ls.session impor
+0000e1f0: 7420 6c6f 6164 5f6e 7373 5f6b 6579 730a  t load_nss_keys.
+0000e200: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e210: 2023 2057 7269 7465 204b 6579 204c 6f67   # Write Key Log
+0000e220: 2074 6f20 6120 6669 6c65 2061 6e64 2070   to a file and p
+0000e230: 6172 7365 2069 740a 2020 2020 2020 2020  arse it.        
+0000e240: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
+0000e250: 203d 2067 6574 5f74 656d 705f 6669 6c65   = get_temp_file
+0000e260: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+0000e270: 2020 2077 6974 6820 6f70 656e 2866 696c     with open(fil
+0000e280: 656e 616d 652c 2022 7762 2229 2061 7320  ename, "wb") as 
+0000e290: 6664 3a0a 2020 2020 2020 2020 2020 2020  fd:.            
+0000e2a0: 2020 2020 2020 2020 6664 2e77 7269 7465          fd.write
+0000e2b0: 2873 6563 7265 7473 5f64 6174 6129 0a20  (secrets_data). 
+0000e2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2d0: 2020 2066 642e 636c 6f73 6528 290a 0a20     fd.close().. 
+0000e2e0: 2020 2020 2020 2020 2020 2020 2020 206b                 k
+0000e2f0: 6579 7320 3d20 6c6f 6164 5f6e 7373 5f6b  eys = load_nss_k
+0000e300: 6579 7328 6669 6c65 6e61 6d65 290a 2020  eys(filename).  
+0000e310: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000e320: 206e 6f74 206b 6579 733a 0a20 2020 2020   not keys:.     
+0000e330: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+0000e340: 6172 6e69 6e67 2822 5063 6170 4e67 3a20  arning("PcapNg: 
+0000e350: 696e 7661 6c69 6420 544c 5320 4b65 7920  invalid TLS Key 
+0000e360: 4c6f 6720 696e 2044 5342 2122 290a 2020  Log in DSB!").  
+0000e370: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0000e380: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000e390: 2020 2020 2020 2020 2320 4e6f 7465 3a20          # Note: 
+0000e3a0: 7468 6573 6520 6174 7472 6962 7574 6573  these attributes
+0000e3b0: 2061 7265 206f 6e6c 7920 6176 6169 6c61   are only availa
+0000e3c0: 626c 6520 7768 656e 2074 6865 2054 4c53  ble when the TLS
+0000e3d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e3e0: 2020 2020 2023 2020 2020 2020 206c 6179       #       lay
+0000e3f0: 6572 2069 7320 6c6f 6164 6564 2e0a 2020  er is loaded..  
+0000e400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e410: 2020 636f 6e66 2e74 6c73 5f6e 7373 5f6b    conf.tls_nss_k
+0000e420: 6579 7320 3d20 6b65 7973 0a20 2020 2020  eys = keys.     
+0000e430: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000e440: 6f6e 662e 746c 735f 7365 7373 696f 6e5f  onf.tls_session_
+0000e450: 656e 6162 6c65 203d 2054 7275 650a 2020  enable = True.  
+0000e460: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000e470: 2020 2020 2020 2020 7761 726e 696e 6728          warning(
+0000e480: 2250 6361 704e 673a 2055 6e6b 6e6f 776e  "PcapNg: Unknown
+0000e490: 2044 5342 2073 6563 7265 7473 2074 7970   DSB secrets typ
+0000e4a0: 6520 2830 7825 7829 2122 2c20 7365 6372  e (0x%x)!", secr
+0000e4b0: 6574 735f 7479 7065 290a 0a0a 636c 6173  ets_type)...clas
+0000e4c0: 7320 5063 6170 4e67 5265 6164 6572 2852  s PcapNgReader(R
+0000e4d0: 6177 5063 6170 4e67 5265 6164 6572 2c20  awPcapNgReader, 
+0000e4e0: 5063 6170 5265 6164 6572 293a 0a0a 2020  PcapReader):..  
+0000e4f0: 2020 616c 7465 726e 6174 6976 6520 3d20    alternative = 
+0000e500: 5063 6170 5265 6164 6572 0a0a 2020 2020  PcapReader..    
+0000e510: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+0000e520: 662c 2066 696c 656e 616d 652c 2066 6465  f, filename, fde
+0000e530: 7363 3d4e 6f6e 652c 206d 6167 6963 3d4e  sc=None, magic=N
+0000e540: 6f6e 6529 3a20 2023 2074 7970 653a 2069  one):  # type: i
+0000e550: 676e 6f72 650a 2020 2020 2020 2020 2320  gnore.        # 
+0000e560: 7479 7065 3a20 2873 7472 2c20 494f 5b62  type: (str, IO[b
+0000e570: 7974 6573 5d2c 2062 7974 6573 2920 2d3e  ytes], bytes) ->
+0000e580: 204e 6f6e 650a 2020 2020 2020 2020 5261   None.        Ra
+0000e590: 7750 6361 704e 6752 6561 6465 722e 5f5f  wPcapNgReader.__
+0000e5a0: 696e 6974 5f5f 2873 656c 662c 2066 696c  init__(self, fil
+0000e5b0: 656e 616d 652c 2066 6465 7363 2c20 6d61  ename, fdesc, ma
+0000e5c0: 6769 6329 0a0a 2020 2020 6465 6620 5f5f  gic)..    def __
+0000e5d0: 656e 7465 725f 5f28 7365 6c66 293a 0a20  enter__(self):. 
+0000e5e0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+0000e5f0: 2920 2d3e 2050 6361 704e 6752 6561 6465  ) -> PcapNgReade
+0000e600: 720a 2020 2020 2020 2020 7265 7475 726e  r.        return
+0000e610: 2073 656c 660a 0a20 2020 2064 6566 2072   self..    def r
+0000e620: 6561 645f 7061 636b 6574 2873 656c 662c  ead_packet(self,
+0000e630: 2073 697a 653d 4d54 552c 202a 2a6b 7761   size=MTU, **kwa
+0000e640: 7267 7329 3a0a 2020 2020 2020 2020 2320  rgs):.        # 
+0000e650: 7479 7065 3a20 2869 6e74 2c20 2a2a 416e  type: (int, **An
+0000e660: 7929 202d 3e20 5061 636b 6574 0a20 2020  y) -> Packet.   
+0000e670: 2020 2020 2072 7020 3d20 7375 7065 7228       rp = super(
+0000e680: 5063 6170 4e67 5265 6164 6572 2c20 7365  PcapNgReader, se
+0000e690: 6c66 292e 5f72 6561 645f 7061 636b 6574  lf)._read_packet
+0000e6a0: 2873 697a 653d 7369 7a65 290a 2020 2020  (size=size).    
+0000e6b0: 2020 2020 6966 2072 7020 6973 204e 6f6e      if rp is Non
+0000e6c0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0000e6d0: 6169 7365 2045 4f46 4572 726f 720a 2020  aise EOFError.  
+0000e6e0: 2020 2020 2020 732c 2028 6c69 6e6b 7479        s, (linkty
+0000e6f0: 7065 2c20 7473 7265 736f 6c2c 2074 7368  pe, tsresol, tsh
+0000e700: 6967 682c 2074 736c 6f77 2c20 7769 7265  igh, tslow, wire
+0000e710: 6c65 6e2c 2063 6f6d 6d65 6e74 2c20 6966  len, comment, if
+0000e720: 6e61 6d65 2c20 6469 7265 6374 696f 6e29  name, direction)
+0000e730: 203d 2072 700a 2020 2020 2020 2020 7472   = rp.        tr
+0000e740: 793a 0a20 2020 2020 2020 2020 2020 2063  y:.            c
+0000e750: 6c73 203d 2063 6f6e 662e 6c32 7479 7065  ls = conf.l2type
+0000e760: 732e 6e75 6d32 6c61 7965 725b 6c69 6e6b  s.num2layer[link
+0000e770: 7479 7065 5d20 2023 2074 7970 653a 2054  type]  # type: T
+0000e780: 7970 655b 5061 636b 6574 5d0a 2020 2020  ype[Packet].    
+0000e790: 2020 2020 2020 2020 7020 3d20 636c 7328          p = cls(
+0000e7a0: 732c 202a 2a6b 7761 7267 7329 2020 2320  s, **kwargs)  # 
+0000e7b0: 7479 7065 3a20 5061 636b 6574 0a20 2020  type: Packet.   
+0000e7c0: 2020 2020 2065 7863 6570 7420 4b65 7962       except Keyb
+0000e7d0: 6f61 7264 496e 7465 7272 7570 743a 0a20  oardInterrupt:. 
+0000e7e0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0000e7f0: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+0000e800: 4578 6365 7074 696f 6e3a 0a20 2020 2020  Exception:.     
+0000e810: 2020 2020 2020 2069 6620 636f 6e66 2e64         if conf.d
+0000e820: 6562 7567 5f64 6973 7365 6374 6f72 3a0a  ebug_dissector:.
+0000e830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e840: 7261 6973 650a 2020 2020 2020 2020 2020  raise.          
+0000e850: 2020 6966 2063 6f6e 662e 7261 775f 6c61    if conf.raw_la
+0000e860: 7965 7220 6973 204e 6f6e 653a 0a20 2020  yer is None:.   
+0000e870: 2020 2020 2020 2020 2020 2020 2023 2063               # c
+0000e880: 6f6e 662e 7261 775f 6c61 7965 7220 6973  onf.raw_layer is
+0000e890: 2073 6574 206f 6e20 696d 706f 7274 0a20   set on import. 
+0000e8a0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000e8b0: 6d70 6f72 7420 7363 6170 792e 7061 636b  mport scapy.pack
+0000e8c0: 6574 2020 2320 6e6f 7161 3a20 4634 3031  et  # noqa: F401
+0000e8d0: 0a20 2020 2020 2020 2020 2020 2070 203d  .            p =
+0000e8e0: 2063 6f6e 662e 7261 775f 6c61 7965 7228   conf.raw_layer(
+0000e8f0: 7329 0a20 2020 2020 2020 2069 6620 7473  s).        if ts
+0000e900: 6869 6768 2069 7320 6e6f 7420 4e6f 6e65  high is not None
+0000e910: 3a0a 2020 2020 2020 2020 2020 2020 702e  :.            p.
+0000e920: 7469 6d65 203d 2045 4465 6369 6d61 6c28  time = EDecimal(
+0000e930: 2874 7368 6967 6820 3c3c 2033 3229 202b  (tshigh << 32) +
+0000e940: 2074 736c 6f77 2920 2f20 7473 7265 736f   tslow) / tsreso
+0000e950: 6c0a 2020 2020 2020 2020 702e 7769 7265  l.        p.wire
+0000e960: 6c65 6e20 3d20 7769 7265 6c65 6e0a 2020  len = wirelen.  
+0000e970: 2020 2020 2020 702e 636f 6d6d 656e 7420        p.comment 
+0000e980: 3d20 636f 6d6d 656e 740a 2020 2020 2020  = comment.      
+0000e990: 2020 702e 6469 7265 6374 696f 6e20 3d20    p.direction = 
+0000e9a0: 6469 7265 6374 696f 6e0a 2020 2020 2020  direction.      
+0000e9b0: 2020 6966 2069 666e 616d 6520 6973 206e    if ifname is n
+0000e9c0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+0000e9d0: 2020 2020 2070 2e73 6e69 6666 6564 5f6f       p.sniffed_o
+0000e9e0: 6e20 3d20 6966 6e61 6d65 2e64 6563 6f64  n = ifname.decod
+0000e9f0: 6528 2775 7466 2d38 2729 0a20 2020 2020  e('utf-8').     
+0000ea00: 2020 2072 6574 7572 6e20 700a 0a20 2020     return p..   
+0000ea10: 2064 6566 2072 6563 7628 7365 6c66 2c20   def recv(self, 
+0000ea20: 7369 7a65 3a20 696e 7420 3d20 4d54 552c  size: int = MTU,
+0000ea30: 202a 2a6b 7761 7267 733a 2041 6e79 2920   **kwargs: Any) 
+0000ea40: 2d3e 2027 5061 636b 6574 273a 2020 2320  -> 'Packet':  # 
+0000ea50: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+0000ea60: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000ea70: 2e72 6561 645f 7061 636b 6574 2873 697a  .read_packet(siz
+0000ea80: 653d 7369 7a65 2c20 2a2a 6b77 6172 6773  e=size, **kwargs
+0000ea90: 290a 0a0a 636c 6173 7320 4765 6e65 7269  )...class Generi
+0000eaa0: 6350 6361 7057 7269 7465 7228 6f62 6a65  cPcapWriter(obje
+0000eab0: 6374 293a 0a20 2020 206e 616e 6f20 3d20  ct):.    nano = 
+0000eac0: 4661 6c73 650a 2020 2020 6c69 6e6b 7479  False.    linkty
+0000ead0: 7065 3a20 696e 740a 0a20 2020 2064 6566  pe: int..    def
+0000eae0: 205f 7772 6974 655f 6865 6164 6572 2873   _write_header(s
+0000eaf0: 656c 662c 2070 6b74 293a 0a20 2020 2020  elf, pkt):.     
+0000eb00: 2020 2023 2074 7970 653a 2028 4f70 7469     # type: (Opti
+0000eb10: 6f6e 616c 5b55 6e69 6f6e 5b50 6163 6b65  onal[Union[Packe
+0000eb20: 742c 2062 7974 6573 5d5d 2920 2d3e 204e  t, bytes]]) -> N
+0000eb30: 6f6e 650a 2020 2020 2020 2020 7261 6973  one.        rais
+0000eb40: 6520 4e6f 7449 6d70 6c65 6d65 6e74 6564  e NotImplemented
+0000eb50: 4572 726f 720a 0a20 2020 2064 6566 205f  Error..    def _
+0000eb60: 7772 6974 655f 7061 636b 6574 2873 656c  write_packet(sel
+0000eb70: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
+0000eb80: 2020 2020 2020 2020 2070 6163 6b65 742c           packet,
+0000eb90: 2020 2320 7479 7065 3a20 556e 696f 6e5b    # type: Union[
+0000eba0: 6279 7465 732c 2050 6163 6b65 745d 0a20  bytes, Packet]. 
+0000ebb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebc0: 2020 2020 206c 696e 6b74 7970 652c 2020       linktype,  
+0000ebd0: 2320 7479 7065 3a20 696e 740a 2020 2020  # type: int.    
+0000ebe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebf0: 2020 7365 633d 4e6f 6e65 2c20 2023 2074    sec=None,  # t
+0000ec00: 7970 653a 204f 7074 696f 6e61 6c5b 666c  ype: Optional[fl
+0000ec10: 6f61 745d 0a20 2020 2020 2020 2020 2020  oat].           
+0000ec20: 2020 2020 2020 2020 2020 2075 7365 633d             usec=
+0000ec30: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
+0000ec40: 7074 696f 6e61 6c5b 696e 745d 0a20 2020  ptional[int].   
+0000ec50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec60: 2020 2063 6170 6c65 6e3d 4e6f 6e65 2c20     caplen=None, 
+0000ec70: 2023 2074 7970 653a 204f 7074 696f 6e61   # type: Optiona
+0000ec80: 6c5b 696e 745d 0a20 2020 2020 2020 2020  l[int].         
+0000ec90: 2020 2020 2020 2020 2020 2020 2077 6972               wir
+0000eca0: 656c 656e 3d4e 6f6e 652c 2020 2320 7479  elen=None,  # ty
+0000ecb0: 7065 3a20 4f70 7469 6f6e 616c 5b69 6e74  pe: Optional[int
+0000ecc0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000ecd0: 2020 2020 2020 2020 636f 6d6d 656e 743d          comment=
+0000ece0: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
+0000ecf0: 7074 696f 6e61 6c5b 6279 7465 735d 0a20  ptional[bytes]. 
+0000ed00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed10: 2020 2020 2069 666e 616d 653d 4e6f 6e65       ifname=None
+0000ed20: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
+0000ed30: 6e61 6c5b 6279 7465 735d 0a20 2020 2020  nal[bytes].     
+0000ed40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed50: 2064 6972 6563 7469 6f6e 3d4e 6f6e 652c   direction=None,
+0000ed60: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
+0000ed70: 616c 5b69 6e74 5d0a 2020 2020 2020 2020  al[int].        
+0000ed80: 2020 2020 2020 2020 2020 2020 2020 293a                ):
+0000ed90: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+0000eda0: 2028 2e2e 2e29 202d 3e20 4e6f 6e65 0a20   (...) -> None. 
+0000edb0: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
+0000edc0: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
+0000edd0: 0a0a 2020 2020 6465 6620 5f67 6574 5f74  ..    def _get_t
+0000ede0: 696d 6528 7365 6c66 2c0a 2020 2020 2020  ime(self,.      
+0000edf0: 2020 2020 2020 2020 2020 2020 7061 636b              pack
+0000ee00: 6574 2c20 2023 2074 7970 653a 2055 6e69  et,  # type: Uni
+0000ee10: 6f6e 5b62 7974 6573 2c20 5061 636b 6574  on[bytes, Packet
+0000ee20: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000ee30: 2020 2020 7365 632c 2020 2320 7479 7065      sec,  # type
+0000ee40: 3a20 4f70 7469 6f6e 616c 5b66 6c6f 6174  : Optional[float
+0000ee50: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000ee60: 2020 2020 7573 6563 2020 2320 7479 7065      usec  # type
+0000ee70: 3a20 4f70 7469 6f6e 616c 5b69 6e74 5d0a  : Optional[int].
+0000ee80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee90: 2020 293a 0a20 2020 2020 2020 2023 2074    ):.        # t
+0000eea0: 7970 653a 2028 2e2e 2e29 202d 3e20 5475  ype: (...) -> Tu
+0000eeb0: 706c 655b 666c 6f61 742c 2069 6e74 5d0a  ple[float, int].
+0000eec0: 2020 2020 2020 2020 6966 2068 6173 6174          if hasat
+0000eed0: 7472 2870 6163 6b65 742c 2022 7469 6d65  tr(packet, "time
+0000eee0: 2229 3a0a 2020 2020 2020 2020 2020 2020  "):.            
+0000eef0: 6966 2073 6563 2069 7320 4e6f 6e65 3a0a  if sec is None:.
+0000ef00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef10: 7061 636b 6574 5f74 696d 6520 3d20 7061  packet_time = pa
+0000ef20: 636b 6574 2e74 696d 650a 2020 2020 2020  cket.time.      
+0000ef30: 2020 2020 2020 2020 2020 746d 7020 3d20            tmp = 
+0000ef40: 696e 7428 7061 636b 6574 5f74 696d 6529  int(packet_time)
+0000ef50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ef60: 2075 7365 6320 3d20 696e 7428 726f 756e   usec = int(roun
+0000ef70: 6428 2870 6163 6b65 745f 7469 6d65 202d  d((packet_time -
+0000ef80: 2074 6d70 2920 2a0a 2020 2020 2020 2020   tmp) *.        
+0000ef90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000efa0: 2020 2028 3130 3030 3030 3030 3030 2069     (1000000000 i
+0000efb0: 6620 7365 6c66 2e6e 616e 6f20 656c 7365  f self.nano else
+0000efc0: 2031 3030 3030 3030 2929 290a 2020 2020   1000000))).    
+0000efd0: 2020 2020 2020 2020 2020 2020 7365 6320              sec 
+0000efe0: 3d20 666c 6f61 7428 7061 636b 6574 5f74  = float(packet_t
+0000eff0: 696d 6529 0a20 2020 2020 2020 2069 6620  ime).        if 
+0000f000: 7365 6320 6973 206e 6f74 204e 6f6e 6520  sec is not None 
+0000f010: 616e 6420 7573 6563 2069 7320 4e6f 6e65  and usec is None
+0000f020: 3a0a 2020 2020 2020 2020 2020 2020 7573  :.            us
+0000f030: 6563 203d 2030 0a20 2020 2020 2020 2072  ec = 0.        r
+0000f040: 6574 7572 6e20 7365 632c 2075 7365 6320  eturn sec, usec 
+0000f050: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
+0000f060: 0a20 2020 2064 6566 2077 7269 7465 5f68  .    def write_h
+0000f070: 6561 6465 7228 7365 6c66 2c20 706b 7429  eader(self, pkt)
+0000f080: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
+0000f090: 3a20 284f 7074 696f 6e61 6c5b 556e 696f  : (Optional[Unio
+0000f0a0: 6e5b 5061 636b 6574 2c20 6279 7465 735d  n[Packet, bytes]
+0000f0b0: 5d29 202d 3e20 4e6f 6e65 0a20 2020 2020  ]) -> None.     
+0000f0c0: 2020 2069 6620 6e6f 7420 6861 7361 7474     if not hasatt
+0000f0d0: 7228 7365 6c66 2c20 276c 696e 6b74 7970  r(self, 'linktyp
+0000f0e0: 6527 293a 0a20 2020 2020 2020 2020 2020  e'):.           
+0000f0f0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+0000f100: 2020 2020 2020 6966 2070 6b74 2069 7320        if pkt is 
+0000f110: 4e6f 6e65 206f 7220 6973 696e 7374 616e  None or isinstan
+0000f120: 6365 2870 6b74 2c20 6279 7465 7329 3a0a  ce(pkt, bytes):.
+0000f130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f140: 2020 2020 2320 4361 6e27 7420 6775 6573      # Can't gues
+0000f150: 7320 4c4c 0a20 2020 2020 2020 2020 2020  s LL.           
+0000f160: 2020 2020 2020 2020 2072 6169 7365 204b           raise K
+0000f170: 6579 4572 726f 720a 2020 2020 2020 2020  eyError.        
+0000f180: 2020 2020 2020 2020 7365 6c66 2e6c 696e          self.lin
+0000f190: 6b74 7970 6520 3d20 636f 6e66 2e6c 3274  ktype = conf.l2t
+0000f1a0: 7970 6573 2e6c 6179 6572 326e 756d 5b0a  ypes.layer2num[.
+0000f1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f1c0: 2020 2020 706b 742e 5f5f 636c 6173 735f      pkt.__class_
+0000f1d0: 5f0a 2020 2020 2020 2020 2020 2020 2020  _.              
+0000f1e0: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
+0000f1f0: 6578 6365 7074 204b 6579 4572 726f 723a  except KeyError:
+0000f200: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f210: 206d 7367 203d 2022 2573 3a20 756e 6b6e   msg = "%s: unkn
+0000f220: 6f77 6e20 4c4c 2074 7970 6520 666f 7220  own LL type for 
+0000f230: 2573 2e20 5573 696e 6720 7479 7065 2031  %s. Using type 1
+0000f240: 2028 4574 6865 726e 6574 2922 0a20 2020   (Ethernet)".   
+0000f250: 2020 2020 2020 2020 2020 2020 2077 6172               war
+0000f260: 6e69 6e67 286d 7367 2c20 7365 6c66 2e5f  ning(msg, self._
+0000f270: 5f63 6c61 7373 5f5f 2e5f 5f6e 616d 655f  _class__.__name_
+0000f280: 5f2c 2070 6b74 2e5f 5f63 6c61 7373 5f5f  _, pkt.__class__
+0000f290: 2e5f 5f6e 616d 655f 5f29 0a20 2020 2020  .__name__).     
+0000f2a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000f2b0: 6c69 6e6b 7479 7065 203d 2044 4c54 5f45  linktype = DLT_E
+0000f2c0: 4e31 304d 420a 2020 2020 2020 2020 7365  N10MB.        se
+0000f2d0: 6c66 2e5f 7772 6974 655f 6865 6164 6572  lf._write_header
+0000f2e0: 2870 6b74 290a 0a20 2020 2064 6566 2077  (pkt)..    def w
+0000f2f0: 7269 7465 5f70 6163 6b65 7428 7365 6c66  rite_packet(self
+0000f300: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000f310: 2020 2020 2020 2070 6163 6b65 742c 2020         packet,  
+0000f320: 2320 7479 7065 3a20 556e 696f 6e5b 6279  # type: Union[by
+0000f330: 7465 732c 2050 6163 6b65 745d 0a20 2020  tes, Packet].   
+0000f340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f350: 2020 7365 633d 4e6f 6e65 2c20 2023 2074    sec=None,  # t
+0000f360: 7970 653a 204f 7074 696f 6e61 6c5b 666c  ype: Optional[fl
+0000f370: 6f61 745d 0a20 2020 2020 2020 2020 2020  oat].           
+0000f380: 2020 2020 2020 2020 2020 7573 6563 3d4e            usec=N
+0000f390: 6f6e 652c 2020 2320 7479 7065 3a20 4f70  one,  # type: Op
+0000f3a0: 7469 6f6e 616c 5b69 6e74 5d0a 2020 2020  tional[int].    
+0000f3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f3c0: 2063 6170 6c65 6e3d 4e6f 6e65 2c20 2023   caplen=None,  #
+0000f3d0: 2074 7970 653a 204f 7074 696f 6e61 6c5b   type: Optional[
+0000f3e0: 696e 745d 0a20 2020 2020 2020 2020 2020  int].           
+0000f3f0: 2020 2020 2020 2020 2020 7769 7265 6c65            wirele
+0000f400: 6e3d 4e6f 6e65 2c20 2023 2074 7970 653a  n=None,  # type:
+0000f410: 204f 7074 696f 6e61 6c5b 696e 745d 0a20   Optional[int]. 
+0000f420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f430: 2020 2020 293a 0a20 2020 2020 2020 2023      ):.        #
+0000f440: 2074 7970 653a 2028 2e2e 2e29 202d 3e20   type: (...) -> 
+0000f450: 4e6f 6e65 0a20 2020 2020 2020 2022 2222  None.        """
+0000f460: 0a20 2020 2020 2020 2057 7269 7465 7320  .        Writes 
+0000f470: 6120 7369 6e67 6c65 2070 6163 6b65 7420  a single packet 
+0000f480: 746f 2074 6865 2070 6361 7020 6669 6c65  to the pcap file
+0000f490: 2e0a 0a20 2020 2020 2020 203a 7061 7261  ...        :para
+0000f4a0: 6d20 7061 636b 6574 3a20 5061 636b 6574  m packet: Packet
+0000f4b0: 2c20 6f72 2062 7974 6573 2066 6f72 2061  , or bytes for a
+0000f4c0: 2073 696e 676c 6520 7061 636b 6574 0a20   single packet. 
+0000f4d0: 2020 2020 2020 203a 7479 7065 2070 6163         :type pac
+0000f4e0: 6b65 743a 2073 6361 7079 2e70 6163 6b65  ket: scapy.packe
+0000f4f0: 742e 5061 636b 6574 206f 7220 6279 7465  t.Packet or byte
+0000f500: 730a 2020 2020 2020 2020 3a70 6172 616d  s.        :param
+0000f510: 2073 6563 3a20 7469 6d65 2074 6865 2070   sec: time the p
+0000f520: 6163 6b65 7420 7761 7320 6361 7074 7572  acket was captur
+0000f530: 6564 2c20 696e 2073 6563 6f6e 6473 2073  ed, in seconds s
+0000f540: 696e 6365 2065 706f 6368 2e20 4966 0a20  ince epoch. If. 
+0000f550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f560: 2020 206e 6f74 2073 7570 706c 6965 642c     not supplied,
+0000f570: 2064 6566 6175 6c74 7320 746f 206e 6f77   defaults to now
+0000f580: 2e0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
+0000f590: 7365 633a 2066 6c6f 6174 0a20 2020 2020  sec: float.     
+0000f5a0: 2020 203a 7061 7261 6d20 7573 6563 3a20     :param usec: 
+0000f5b0: 4966 2060 606e 616e 6f3d 5472 7565 6060  If ``nano=True``
+0000f5c0: 2c20 7468 656e 206e 756d 6265 7220 6f66  , then number of
+0000f5d0: 206e 616e 6f73 6563 6f6e 6473 2061 6674   nanoseconds aft
+0000f5e0: 6572 2074 6865 0a20 2020 2020 2020 2020  er the.         
+0000f5f0: 2020 2020 2020 2020 2020 2020 7365 636f              seco
+0000f600: 6e64 2074 6861 7420 7468 6520 7061 636b  nd that the pack
+0000f610: 6574 2077 6173 2063 6170 7475 7265 642e  et was captured.
+0000f620: 2049 6620 6060 6e61 6e6f 3d46 616c 7365   If ``nano=False
+0000f630: 6060 2c0a 2020 2020 2020 2020 2020 2020  ``,.            
+0000f640: 2020 2020 2020 2020 2074 6865 6e20 7468           then th
+0000f650: 6520 6e75 6d62 6572 206f 6620 6d69 6372  e number of micr
+0000f660: 6f73 6563 6f6e 6473 2061 6674 6572 2074  oseconds after t
+0000f670: 6865 2073 6563 6f6e 6420 7468 650a 2020  he second the.  
+0000f680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f690: 2020 2070 6163 6b65 7420 7761 7320 6361     packet was ca
+0000f6a0: 7074 7572 6564 2e20 4966 2060 6073 6563  ptured. If ``sec
+0000f6b0: 6060 2069 7320 6e6f 7420 7370 6563 6966  `` is not specif
+0000f6c0: 6965 642c 0a20 2020 2020 2020 2020 2020  ied,.           
+0000f6d0: 2020 2020 2020 2020 2020 7468 6973 2076            this v
+0000f6e0: 616c 7565 2069 7320 6967 6e6f 7265 642e  alue is ignored.
+0000f6f0: 0a20 2020 2020 2020 203a 7479 7065 2075  .        :type u
+0000f700: 7365 633a 2069 6e74 206f 7220 6c6f 6e67  sec: int or long
+0000f710: 0a20 2020 2020 2020 203a 7061 7261 6d20  .        :param 
+0000f720: 6361 706c 656e 3a20 5468 6520 6c65 6e67  caplen: The leng
+0000f730: 7468 206f 6620 7468 6520 7061 636b 6574  th of the packet
+0000f740: 2069 6e20 7468 6520 6361 7074 7572 6520   in the capture 
+0000f750: 6669 6c65 2e20 4966 206e 6f74 0a20 2020  file. If not.   
+0000f760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f770: 2020 2020 7370 6563 6966 6965 642c 2075      specified, u
+0000f780: 7365 7320 6060 6c65 6e28 7261 7728 7061  ses ``len(raw(pa
+0000f790: 636b 6574 2929 6060 2e0a 2020 2020 2020  cket))``..      
+0000f7a0: 2020 3a74 7970 6520 6361 706c 656e 3a20    :type caplen: 
+0000f7b0: 696e 740a 2020 2020 2020 2020 3a70 6172  int.        :par
+0000f7c0: 616d 2077 6972 656c 656e 3a20 5468 6520  am wirelen: The 
+0000f7d0: 6c65 6e67 7468 206f 6620 7468 6520 7061  length of the pa
+0000f7e0: 636b 6574 206f 6e20 7468 6520 7769 7265  cket on the wire
+0000f7f0: 2e20 4966 206e 6f74 0a20 2020 2020 2020  . If not.       
+0000f800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f810: 2073 7065 6369 6669 6564 2c20 7472 6965   specified, trie
+0000f820: 7320 6060 7061 636b 6574 2e77 6972 656c  s ``packet.wirel
+0000f830: 656e 6060 2c20 6f74 6865 7277 6973 6520  en``, otherwise 
+0000f840: 7573 6573 0a20 2020 2020 2020 2020 2020  uses.           
+0000f850: 2020 2020 2020 2020 2020 2020 2060 6063               ``c
+0000f860: 6170 6c65 6e60 602e 0a20 2020 2020 2020  aplen``..       
+0000f870: 203a 7479 7065 2077 6972 656c 656e 3a20   :type wirelen: 
+0000f880: 696e 740a 2020 2020 2020 2020 3a72 6574  int.        :ret
+0000f890: 7572 6e3a 204e 6f6e 650a 2020 2020 2020  urn: None.      
+0000f8a0: 2020 3a72 7479 7065 3a20 4e6f 6e65 0a20    :rtype: None. 
+0000f8b0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0000f8c0: 2020 2066 5f73 6563 2c20 7573 6563 203d     f_sec, usec =
+0000f8d0: 2073 656c 662e 5f67 6574 5f74 696d 6528   self._get_time(
+0000f8e0: 7061 636b 6574 2c20 7365 632c 2075 7365  packet, sec, use
+0000f8f0: 6329 0a0a 2020 2020 2020 2020 7261 7770  c)..        rawp
+0000f900: 6b74 203d 2062 7974 6573 5f65 6e63 6f64  kt = bytes_encod
+0000f910: 6528 7061 636b 6574 290a 2020 2020 2020  e(packet).      
+0000f920: 2020 6361 706c 656e 203d 206c 656e 2872    caplen = len(r
+0000f930: 6177 706b 7429 2069 6620 6361 706c 656e  awpkt) if caplen
+0000f940: 2069 7320 4e6f 6e65 2065 6c73 6520 6361   is None else ca
+0000f950: 706c 656e 0a0a 2020 2020 2020 2020 6966  plen..        if
+0000f960: 2077 6972 656c 656e 2069 7320 4e6f 6e65   wirelen is None
+0000f970: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000f980: 2068 6173 6174 7472 2870 6163 6b65 742c   hasattr(packet,
+0000f990: 2022 7769 7265 6c65 6e22 293a 0a20 2020   "wirelen"):.   
+0000f9a0: 2020 2020 2020 2020 2020 2020 2077 6972               wir
+0000f9b0: 656c 656e 203d 2070 6163 6b65 742e 7769  elen = packet.wi
+0000f9c0: 7265 6c65 6e0a 2020 2020 2020 2020 6966  relen.        if
+0000f9d0: 2077 6972 656c 656e 2069 7320 4e6f 6e65   wirelen is None
+0000f9e0: 3a0a 2020 2020 2020 2020 2020 2020 7769  :.            wi
+0000f9f0: 7265 6c65 6e20 3d20 6361 706c 656e 0a0a  relen = caplen..
+0000fa00: 2020 2020 2020 2020 636f 6d6d 656e 7420          comment 
+0000fa10: 3d20 6765 7461 7474 7228 7061 636b 6574  = getattr(packet
+0000fa20: 2c20 2263 6f6d 6d65 6e74 222c 204e 6f6e  , "comment", Non
+0000fa30: 6529 0a20 2020 2020 2020 2069 666e 616d  e).        ifnam
+0000fa40: 6520 3d20 6765 7461 7474 7228 7061 636b  e = getattr(pack
+0000fa50: 6574 2c20 2273 6e69 6666 6564 5f6f 6e22  et, "sniffed_on"
+0000fa60: 2c20 4e6f 6e65 290a 2020 2020 2020 2020  , None).        
+0000fa70: 6469 7265 6374 696f 6e20 3d20 6765 7461  direction = geta
+0000fa80: 7474 7228 7061 636b 6574 2c20 2264 6972  ttr(packet, "dir
+0000fa90: 6563 7469 6f6e 222c 204e 6f6e 6529 0a20  ection", None). 
+0000faa0: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+0000fab0: 696e 7374 616e 6365 2870 6163 6b65 742c  instance(packet,
+0000fac0: 2062 7974 6573 293a 0a20 2020 2020 2020   bytes):.       
+0000fad0: 2020 2020 206c 696e 6b74 7970 653a 2069       linktype: i
+0000fae0: 6e74 203d 2063 6f6e 662e 6c32 7479 7065  nt = conf.l2type
+0000faf0: 732e 6c61 7965 7232 6e75 6d5b 0a20 2020  s.layer2num[.   
+0000fb00: 2020 2020 2020 2020 2020 2020 2070 6163               pac
+0000fb10: 6b65 742e 5f5f 636c 6173 735f 5f0a 2020  ket.__class__.  
+0000fb20: 2020 2020 2020 2020 2020 5d0a 2020 2020            ].    
+0000fb30: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000fb40: 2020 2020 2020 6c69 6e6b 7479 7065 203d        linktype =
+0000fb50: 2073 656c 662e 6c69 6e6b 7479 7065 0a20   self.linktype. 
+0000fb60: 2020 2020 2020 2069 6620 6966 6e61 6d65         if ifname
+0000fb70: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0000fb80: 2020 2020 2020 2020 2020 6966 6e61 6d65            ifname
+0000fb90: 203d 2073 7472 2869 666e 616d 6529 2e65   = str(ifname).e
+0000fba0: 6e63 6f64 6528 2775 7466 2d38 2729 0a20  ncode('utf-8'). 
+0000fbb0: 2020 2020 2020 2073 656c 662e 5f77 7269         self._wri
+0000fbc0: 7465 5f70 6163 6b65 7428 0a20 2020 2020  te_packet(.     
+0000fbd0: 2020 2020 2020 2072 6177 706b 742c 0a20         rawpkt,. 
+0000fbe0: 2020 2020 2020 2020 2020 2073 6563 3d66             sec=f
+0000fbf0: 5f73 6563 2c20 7573 6563 3d75 7365 632c  _sec, usec=usec,
+0000fc00: 0a20 2020 2020 2020 2020 2020 2063 6170  .            cap
+0000fc10: 6c65 6e3d 6361 706c 656e 2c20 7769 7265  len=caplen, wire
+0000fc20: 6c65 6e3d 7769 7265 6c65 6e2c 0a20 2020  len=wirelen,.   
+0000fc30: 2020 2020 2020 2020 2063 6f6d 6d65 6e74           comment
+0000fc40: 3d63 6f6d 6d65 6e74 2c0a 2020 2020 2020  =comment,.      
+0000fc50: 2020 2020 2020 6966 6e61 6d65 3d69 666e        ifname=ifn
+0000fc60: 616d 652c 0a20 2020 2020 2020 2020 2020  ame,.           
+0000fc70: 2064 6972 6563 7469 6f6e 3d64 6972 6563   direction=direc
+0000fc80: 7469 6f6e 2c0a 2020 2020 2020 2020 2020  tion,.          
+0000fc90: 2020 6c69 6e6b 7479 7065 3d6c 696e 6b74    linktype=linkt
+0000fca0: 7970 650a 2020 2020 2020 2020 290a 0a0a  ype.        )...
+0000fcb0: 636c 6173 7320 4765 6e65 7269 6352 6177  class GenericRaw
+0000fcc0: 5063 6170 5772 6974 6572 2847 656e 6572  PcapWriter(Gener
+0000fcd0: 6963 5063 6170 5772 6974 6572 293a 0a20  icPcapWriter):. 
+0000fce0: 2020 2068 6561 6465 725f 7072 6573 656e     header_presen
+0000fcf0: 7420 3d20 4661 6c73 650a 2020 2020 6e61  t = False.    na
+0000fd00: 6e6f 203d 2046 616c 7365 0a20 2020 2073  no = False.    s
+0000fd10: 796e 6320 3d20 4661 6c73 650a 2020 2020  ync = False.    
+0000fd20: 6620 3d20 4e6f 6e65 2020 2320 7479 7065  f = None  # type
+0000fd30: 3a20 556e 696f 6e5b 494f 5b62 7974 6573  : Union[IO[bytes
+0000fd40: 5d2c 2067 7a69 702e 477a 6970 4669 6c65  ], gzip.GzipFile
+0000fd50: 5d0a 0a20 2020 2064 6566 2066 696c 656e  ]..    def filen
+0000fd60: 6f28 7365 6c66 293a 0a20 2020 2020 2020  o(self):.       
+0000fd70: 2023 2074 7970 653a 2028 2920 2d3e 2069   # type: () -> i
+0000fd80: 6e74 0a20 2020 2020 2020 2072 6574 7572  nt.        retur
+0000fd90: 6e20 2d31 2069 6620 5749 4e44 4f57 5320  n -1 if WINDOWS 
+0000fda0: 656c 7365 2073 656c 662e 662e 6669 6c65  else self.f.file
+0000fdb0: 6e6f 2829 0a0a 2020 2020 6465 6620 666c  no()..    def fl
+0000fdc0: 7573 6828 7365 6c66 293a 0a20 2020 2020  ush(self):.     
+0000fdd0: 2020 2023 2074 7970 653a 2028 2920 2d3e     # type: () ->
+0000fde0: 204f 7074 696f 6e61 6c5b 416e 795d 0a20   Optional[Any]. 
+0000fdf0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000fe00: 6c66 2e66 2e66 6c75 7368 2829 0a0a 2020  lf.f.flush()..  
+0000fe10: 2020 6465 6620 636c 6f73 6528 7365 6c66    def close(self
+0000fe20: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+0000fe30: 653a 2028 2920 2d3e 204f 7074 696f 6e61  e: () -> Optiona
+0000fe40: 6c5b 416e 795d 0a20 2020 2020 2020 2069  l[Any].        i
+0000fe50: 6620 6e6f 7420 7365 6c66 2e68 6561 6465  f not self.heade
+0000fe60: 725f 7072 6573 656e 743a 0a20 2020 2020  r_present:.     
+0000fe70: 2020 2020 2020 2073 656c 662e 7772 6974         self.writ
+0000fe80: 655f 6865 6164 6572 284e 6f6e 6529 0a20  e_header(None). 
+0000fe90: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000fea0: 6c66 2e66 2e63 6c6f 7365 2829 0a0a 2020  lf.f.close()..  
+0000feb0: 2020 6465 6620 5f5f 656e 7465 725f 5f28    def __enter__(
+0000fec0: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
+0000fed0: 2074 7970 653a 2028 2920 2d3e 2047 656e   type: () -> Gen
+0000fee0: 6572 6963 5261 7750 6361 7057 7269 7465  ericRawPcapWrite
+0000fef0: 720a 2020 2020 2020 2020 7265 7475 726e  r.        return
+0000ff00: 2073 656c 660a 0a20 2020 2064 6566 205f   self..    def _
+0000ff10: 5f65 7869 745f 5f28 7365 6c66 2c20 6578  _exit__(self, ex
+0000ff20: 635f 7479 7065 2c20 6578 635f 7661 6c75  c_type, exc_valu
+0000ff30: 652c 2074 7261 6362 6163 6b29 3a0a 2020  e, tracback):.  
+0000ff40: 2020 2020 2020 2320 7479 7065 3a20 284f        # type: (O
+0000ff50: 7074 696f 6e61 6c5b 416e 795d 2c20 4f70  ptional[Any], Op
+0000ff60: 7469 6f6e 616c 5b41 6e79 5d2c 204f 7074  tional[Any], Opt
+0000ff70: 696f 6e61 6c5b 416e 795d 2920 2d3e 204e  ional[Any]) -> N
+0000ff80: 6f6e 650a 2020 2020 2020 2020 7365 6c66  one.        self
+0000ff90: 2e66 6c75 7368 2829 0a20 2020 2020 2020  .flush().       
+0000ffa0: 2073 656c 662e 636c 6f73 6528 290a 0a20   self.close().. 
+0000ffb0: 2020 2064 6566 2077 7269 7465 2873 656c     def write(sel
+0000ffc0: 662c 2070 6b74 293a 0a20 2020 2020 2020  f, pkt):.       
+0000ffd0: 2023 2074 7970 653a 2028 556e 696f 6e5b   # type: (Union[
+0000ffe0: 5f50 6163 6b65 7449 7465 7261 626c 652c  _PacketIterable,
+0000fff0: 2062 7974 6573 5d29 202d 3e20 4e6f 6e65   bytes]) -> None
+00010000: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00010010: 2020 2020 2057 7269 7465 7320 6120 5061       Writes a Pa
+00010020: 636b 6574 2c20 6120 536e 6452 6376 4c69  cket, a SndRcvLi
+00010030: 7374 206f 626a 6563 742c 206f 7220 6279  st object, or by
+00010040: 7465 7320 746f 2061 2070 6361 7020 6669  tes to a pcap fi
+00010050: 6c65 2e0a 0a20 2020 2020 2020 203a 7061  le...        :pa
+00010060: 7261 6d20 706b 743a 2050 6163 6b65 7428  ram pkt: Packet(
+00010070: 7329 2074 6f20 7772 6974 6520 286f 6e65  s) to write (one
+00010080: 2072 6563 6f72 6420 666f 7220 6561 6368   record for each
+00010090: 2050 6163 6b65 7429 2c20 6f72 2072 6177   Packet), or raw
+000100a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000100b0: 2020 2020 2062 7974 6573 2074 6f20 7772       bytes to wr
+000100c0: 6974 6520 2861 7320 6f6e 6520 7265 636f  ite (as one reco
+000100d0: 7264 292e 0a20 2020 2020 2020 203a 7479  rd)..        :ty
+000100e0: 7065 2070 6b74 3a20 6974 6572 6162 6c65  pe pkt: iterable
+000100f0: 5b73 6361 7079 2e70 6163 6b65 742e 5061  [scapy.packet.Pa
+00010100: 636b 6574 5d2c 2073 6361 7079 2e70 6163  cket], scapy.pac
+00010110: 6b65 742e 5061 636b 6574 206f 7220 6279  ket.Packet or by
+00010120: 7465 730a 2020 2020 2020 2020 2222 220a  tes.        """.
+00010130: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00010140: 7461 6e63 6528 706b 742c 2062 7974 6573  tance(pkt, bytes
+00010150: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
+00010160: 6620 6e6f 7420 7365 6c66 2e68 6561 6465  f not self.heade
+00010170: 725f 7072 6573 656e 743a 0a20 2020 2020  r_present:.     
+00010180: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00010190: 7772 6974 655f 6865 6164 6572 2870 6b74  write_header(pkt
+000101a0: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+000101b0: 6c66 2e77 7269 7465 5f70 6163 6b65 7428  lf.write_packet(
+000101c0: 706b 7429 0a20 2020 2020 2020 2065 6c73  pkt).        els
+000101d0: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+000101e0: 2049 6d70 6f72 7420 6865 7265 2074 6f20   Import here to 
+000101f0: 6176 6f69 6420 6369 7263 756c 6172 2064  avoid circular d
+00010200: 6570 656e 6465 6e63 790a 2020 2020 2020  ependency.      
+00010210: 2020 2020 2020 6672 6f6d 2073 6361 7079        from scapy
+00010220: 2e73 7570 6572 736f 636b 6574 2069 6d70  .supersocket imp
+00010230: 6f72 7420 4974 6572 536f 636b 6574 0a20  ort IterSocket. 
+00010240: 2020 2020 2020 2020 2020 2066 6f72 2070             for p
+00010250: 2069 6e20 4974 6572 536f 636b 6574 2870   in IterSocket(p
+00010260: 6b74 292e 6974 6572 3a0a 2020 2020 2020  kt).iter:.      
+00010270: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+00010280: 2073 656c 662e 6865 6164 6572 5f70 7265   self.header_pre
+00010290: 7365 6e74 3a0a 2020 2020 2020 2020 2020  sent:.          
+000102a0: 2020 2020 2020 2020 2020 7365 6c66 2e77            self.w
+000102b0: 7269 7465 5f68 6561 6465 7228 7029 0a0a  rite_header(p)..
+000102c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000102d0: 6966 206e 6f74 2069 7369 6e73 7461 6e63  if not isinstanc
+000102e0: 6528 702c 2062 7974 6573 2920 616e 6420  e(p, bytes) and 
+000102f0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00010300: 2020 2020 2020 2020 2020 7365 6c66 2e6c            self.l
+00010310: 696e 6b74 7970 6520 213d 2063 6f6e 662e  inktype != conf.
+00010320: 6c32 7479 7065 732e 6765 7428 7479 7065  l2types.get(type
+00010330: 2870 292c 204e 6f6e 6529 3a0a 2020 2020  (p), None):.    
+00010340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010350: 7761 726e 696e 6728 2249 6e63 6f6e 7369  warning("Inconsi
+00010360: 7374 656e 7420 6c69 6e6b 7479 7065 7320  stent linktypes 
+00010370: 6465 7465 6374 6564 2122 0a20 2020 2020  detected!".     
+00010380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010390: 2020 2020 2020 2022 2054 6865 2072 6573         " The res
+000103a0: 756c 7469 6e67 2066 696c 6520 6d69 6768  ulting file migh
+000103b0: 7420 636f 6e74 6169 6e22 0a20 2020 2020  t contain".     
+000103c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000103d0: 2020 2020 2020 2022 2069 6e76 616c 6964         " invalid
+000103e0: 2070 6163 6b65 7473 2e22 0a20 2020 2020   packets.".     
+000103f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010400: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00010410: 2020 2020 2020 2020 2020 7365 6c66 2e77            self.w
+00010420: 7269 7465 5f70 6163 6b65 7428 7029 0a0a  rite_packet(p)..
+00010430: 0a63 6c61 7373 2052 6177 5063 6170 5772  .class RawPcapWr
+00010440: 6974 6572 2847 656e 6572 6963 5261 7750  iter(GenericRawP
+00010450: 6361 7057 7269 7465 7229 3a0a 2020 2020  capWriter):.    
+00010460: 2222 2241 2073 7472 6561 6d20 5043 4150  """A stream PCAP
+00010470: 2077 7269 7465 7220 7769 7468 206d 6f72   writer with mor
+00010480: 6520 636f 6e74 726f 6c20 7468 616e 2077  e control than w
+00010490: 7270 6361 7028 2922 2222 0a0a 2020 2020  rpcap()"""..    
+000104a0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+000104b0: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
+000104c0: 2020 2020 6669 6c65 6e61 6d65 2c20 2023      filename,  #
+000104d0: 2074 7970 653a 2055 6e69 6f6e 5b49 4f5b   type: Union[IO[
+000104e0: 6279 7465 735d 2c20 7374 725d 0a20 2020  bytes], str].   
+000104f0: 2020 2020 2020 2020 2020 2020 2020 6c69                li
+00010500: 6e6b 7479 7065 3d4e 6f6e 652c 2020 2320  nktype=None,  # 
+00010510: 7479 7065 3a20 4f70 7469 6f6e 616c 5b69  type: Optional[i
+00010520: 6e74 5d0a 2020 2020 2020 2020 2020 2020  nt].            
+00010530: 2020 2020 2067 7a3d 4661 6c73 652c 2020       gz=False,  
+00010540: 2320 7479 7065 3a20 626f 6f6c 0a20 2020  # type: bool.   
+00010550: 2020 2020 2020 2020 2020 2020 2020 656e                en
+00010560: 6469 616e 6e65 7373 3d22 222c 2020 2320  dianness="",  # 
+00010570: 7479 7065 3a20 7374 720a 2020 2020 2020  type: str.      
+00010580: 2020 2020 2020 2020 2020 2061 7070 656e             appen
+00010590: 643d 4661 6c73 652c 2020 2320 7479 7065  d=False,  # type
+000105a0: 3a20 626f 6f6c 0a20 2020 2020 2020 2020  : bool.         
+000105b0: 2020 2020 2020 2020 7379 6e63 3d46 616c          sync=Fal
+000105c0: 7365 2c20 2023 2074 7970 653a 2062 6f6f  se,  # type: boo
+000105d0: 6c0a 2020 2020 2020 2020 2020 2020 2020  l.              
+000105e0: 2020 206e 616e 6f3d 4661 6c73 652c 2020     nano=False,  
+000105f0: 2320 7479 7065 3a20 626f 6f6c 0a20 2020  # type: bool.   
+00010600: 2020 2020 2020 2020 2020 2020 2020 736e                sn
+00010610: 6170 6c65 6e3d 4d54 552c 2020 2320 7479  aplen=MTU,  # ty
+00010620: 7065 3a20 696e 740a 2020 2020 2020 2020  pe: int.        
+00010630: 2020 2020 2020 2020 2062 7566 737a 3d34           bufsz=4
+00010640: 3039 362c 2020 2320 7479 7065 3a20 696e  096,  # type: in
+00010650: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+00010660: 2020 2029 3a0a 2020 2020 2020 2020 2320     ):.        # 
+00010670: 7479 7065 3a20 282e 2e2e 2920 2d3e 204e  type: (...) -> N
+00010680: 6f6e 650a 2020 2020 2020 2020 2222 220a  one.        """.
+00010690: 2020 2020 2020 2020 3a70 6172 616d 2066          :param f
+000106a0: 696c 656e 616d 653a 2074 6865 206e 616d  ilename: the nam
+000106b0: 6520 6f66 2074 6865 2066 696c 6520 746f  e of the file to
+000106c0: 2077 7269 7465 2070 6163 6b65 7473 2074   write packets t
+000106d0: 6f2c 206f 7220 616e 206f 7065 6e2c 0a20  o, or an open,. 
+000106e0: 2020 2020 2020 2020 2020 2077 7269 7461             writa
+000106f0: 626c 6520 6669 6c65 2d6c 696b 6520 6f62  ble file-like ob
+00010700: 6a65 6374 2e0a 2020 2020 2020 2020 3a70  ject..        :p
+00010710: 6172 616d 206c 696e 6b74 7970 653a 2066  aram linktype: f
+00010720: 6f72 6365 206c 696e 6b74 7970 6520 746f  orce linktype to
+00010730: 2061 2067 6976 656e 2076 616c 7565 2e20   a given value. 
+00010740: 4966 204e 6f6e 652c 206c 696e 6b74 7970  If None, linktyp
+00010750: 6520 6973 0a20 2020 2020 2020 2020 2020  e is.           
+00010760: 2074 616b 656e 2066 726f 6d20 7468 6520   taken from the 
+00010770: 6669 7273 7420 7772 6974 6572 2070 6163  first writer pac
+00010780: 6b65 740a 2020 2020 2020 2020 3a70 6172  ket.        :par
+00010790: 616d 2067 7a3a 2063 6f6d 7072 6573 7320  am gz: compress 
+000107a0: 7468 6520 6361 7074 7572 6520 6f6e 2074  the capture on t
+000107b0: 6865 2066 6c79 0a20 2020 2020 2020 203a  he fly.        :
+000107c0: 7061 7261 6d20 656e 6469 616e 6e65 7373  param endianness
+000107d0: 3a20 666f 7263 6520 616e 2065 6e64 6961  : force an endia
+000107e0: 6e6e 6573 7320 286c 6974 746c 653a 223c  nness (little:"<
+000107f0: 222c 2062 6967 3a22 3e22 292e 0a20 2020  ", big:">")..   
+00010800: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+00010810: 2069 7320 6e61 7469 7665 0a20 2020 2020   is native.     
+00010820: 2020 203a 7061 7261 6d20 6170 7065 6e64     :param append
+00010830: 3a20 6170 7065 6e64 2070 6163 6b65 7473  : append packets
+00010840: 2074 6f20 7468 6520 6361 7074 7572 6520   to the capture 
+00010850: 6669 6c65 2069 6e73 7465 6164 206f 660a  file instead of.
+00010860: 2020 2020 2020 2020 2020 2020 7472 756e              trun
+00010870: 6361 7469 6e67 2069 740a 2020 2020 2020  cating it.      
+00010880: 2020 3a70 6172 616d 2073 796e 633a 2064    :param sync: d
+00010890: 6f20 6e6f 7420 6275 6666 6572 697a 6520  o not bufferize 
+000108a0: 7772 6974 6573 2074 6f20 7468 6520 6361  writes to the ca
+000108b0: 7074 7572 6520 6669 6c65 0a20 2020 2020  pture file.     
+000108c0: 2020 203a 7061 7261 6d20 6e61 6e6f 3a20     :param nano: 
+000108d0: 7573 6520 6e61 6e6f 7365 636f 6e64 2d70  use nanosecond-p
+000108e0: 7265 6369 7369 6f6e 2028 7265 7175 6972  recision (requir
+000108f0: 6573 206c 6962 7063 6170 203e 3d20 312e  es libpcap >= 1.
+00010900: 352e 3029 0a0a 2020 2020 2020 2020 2222  5.0)..        ""
+00010910: 220a 0a20 2020 2020 2020 2069 6620 6c69  "..        if li
+00010920: 6e6b 7479 7065 3a0a 2020 2020 2020 2020  nktype:.        
+00010930: 2020 2020 7365 6c66 2e6c 696e 6b74 7970      self.linktyp
+00010940: 6520 3d20 6c69 6e6b 7479 7065 0a20 2020  e = linktype.   
+00010950: 2020 2020 2073 656c 662e 736e 6170 6c65       self.snaple
+00010960: 6e20 3d20 736e 6170 6c65 6e0a 2020 2020  n = snaplen.    
+00010970: 2020 2020 7365 6c66 2e61 7070 656e 6420      self.append 
+00010980: 3d20 6170 7065 6e64 0a20 2020 2020 2020  = append.       
+00010990: 2073 656c 662e 677a 203d 2067 7a0a 2020   self.gz = gz.  
+000109a0: 2020 2020 2020 7365 6c66 2e65 6e64 6961        self.endia
+000109b0: 6e20 3d20 656e 6469 616e 6e65 7373 0a20  n = endianness. 
+000109c0: 2020 2020 2020 2073 656c 662e 7379 6e63         self.sync
+000109d0: 203d 2073 796e 630a 2020 2020 2020 2020   = sync.        
+000109e0: 7365 6c66 2e6e 616e 6f20 3d20 6e61 6e6f  self.nano = nano
+000109f0: 0a20 2020 2020 2020 2069 6620 7379 6e63  .        if sync
+00010a00: 3a0a 2020 2020 2020 2020 2020 2020 6275  :.            bu
+00010a10: 6673 7a20 3d20 300a 0a20 2020 2020 2020  fsz = 0..       
+00010a20: 2069 6620 6973 696e 7374 616e 6365 2866   if isinstance(f
+00010a30: 696c 656e 616d 652c 2073 7472 293a 0a20  ilename, str):. 
+00010a40: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00010a50: 6669 6c65 6e61 6d65 203d 2066 696c 656e  filename = filen
+00010a60: 616d 650a 2020 2020 2020 2020 2020 2020  ame.            
+00010a70: 6966 2067 7a3a 0a20 2020 2020 2020 2020  if gz:.         
+00010a80: 2020 2020 2020 2073 656c 662e 6620 3d20         self.f = 
+00010a90: 6361 7374 285f 4279 7465 5374 7265 616d  cast(_ByteStream
+00010aa0: 2c20 677a 6970 2e6f 7065 6e28 0a20 2020  , gzip.open(.   
+00010ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010ac0: 2066 696c 656e 616d 652c 2061 7070 656e   filename, appen
+00010ad0: 6420 616e 6420 2261 6222 206f 7220 2277  d and "ab" or "w
+00010ae0: 6222 2c20 390a 2020 2020 2020 2020 2020  b", 9.          
+00010af0: 2020 2020 2020 2929 0a20 2020 2020 2020        )).       
+00010b00: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00010b10: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00010b20: 6620 3d20 6f70 656e 2866 696c 656e 616d  f = open(filenam
+00010b30: 652c 2061 7070 656e 6420 616e 6420 2261  e, append and "a
+00010b40: 6222 206f 7220 2277 6222 2c20 6275 6673  b" or "wb", bufs
+00010b50: 7a29 0a20 2020 2020 2020 2065 6c73 653a  z).        else:
+00010b60: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00010b70: 662e 6620 3d20 6669 6c65 6e61 6d65 0a20  f.f = filename. 
+00010b80: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00010b90: 6669 6c65 6e61 6d65 203d 2067 6574 6174  filename = getat
+00010ba0: 7472 2866 696c 656e 616d 652c 2022 6e61  tr(filename, "na
+00010bb0: 6d65 222c 2022 4e6f 206e 616d 6522 290a  me", "No name").
+00010bc0: 0a20 2020 2064 6566 205f 7772 6974 655f  .    def _write_
+00010bd0: 6865 6164 6572 2873 656c 662c 2070 6b74  header(self, pkt
+00010be0: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+00010bf0: 653a 2028 4f70 7469 6f6e 616c 5b55 6e69  e: (Optional[Uni
+00010c00: 6f6e 5b50 6163 6b65 742c 2062 7974 6573  on[Packet, bytes
+00010c10: 5d5d 2920 2d3e 204e 6f6e 650a 2020 2020  ]]) -> None.    
+00010c20: 2020 2020 7365 6c66 2e68 6561 6465 725f      self.header_
+00010c30: 7072 6573 656e 7420 3d20 5472 7565 0a0a  present = True..
+00010c40: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00010c50: 6170 7065 6e64 3a0a 2020 2020 2020 2020  append:.        
+00010c60: 2020 2020 2320 4576 656e 2069 6620 7072      # Even if pr
+00010c70: 6f6e 6520 746f 2072 6163 6520 636f 6e64  one to race cond
+00010c80: 6974 696f 6e73 2c20 7468 6973 2073 6565  itions, this see
+00010c90: 6d73 2074 6f20 6265 0a20 2020 2020 2020  ms to be.       
+00010ca0: 2020 2020 2023 2073 6166 6573 7420 7761       # safest wa
+00010cb0: 7920 746f 2074 656c 6c20 7768 6574 6865  y to tell whethe
+00010cc0: 7220 7468 6520 6865 6164 6572 2069 7320  r the header is 
+00010cd0: 616c 7265 6164 7920 7072 6573 656e 740a  already present.
+00010ce0: 2020 2020 2020 2020 2020 2020 2320 6265              # be
+00010cf0: 6361 7573 6520 7765 2068 6176 6520 746f  cause we have to
+00010d00: 2068 616e 646c 6520 636f 6d70 7265 7373   handle compress
+00010d10: 6564 2073 7472 6561 6d73 2074 6861 740a  ed streams that.
+00010d20: 2020 2020 2020 2020 2020 2020 2320 6172              # ar
+00010d30: 6520 6e6f 7420 6173 2066 6c65 7869 626c  e not as flexibl
+00010d40: 6520 6173 2062 6173 6963 2066 696c 6573  e as basic files
+00010d50: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00010d60: 7365 6c66 2e67 7a3a 0a20 2020 2020 2020  self.gz:.       
+00010d70: 2020 2020 2020 2020 2067 203d 2067 7a69           g = gzi
+00010d80: 702e 6f70 656e 2873 656c 662e 6669 6c65  p.open(self.file
+00010d90: 6e61 6d65 2c20 2272 6222 2920 2023 2074  name, "rb")  # t
+00010da0: 7970 653a 205f 4279 7465 5374 7265 616d  ype: _ByteStream
+00010db0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+00010dc0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00010dd0: 2020 2067 203d 206f 7065 6e28 7365 6c66     g = open(self
+00010de0: 2e66 696c 656e 616d 652c 2022 7262 2229  .filename, "rb")
+00010df0: 0a20 2020 2020 2020 2020 2020 2074 7279  .            try
+00010e00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00010e10: 2020 6966 2067 2e72 6561 6428 3136 293a    if g.read(16):
+00010e20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010e30: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+00010e40: 2020 2020 2020 2020 6669 6e61 6c6c 793a          finally:
+00010e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010e60: 2067 2e63 6c6f 7365 2829 0a0a 2020 2020   g.close()..    
+00010e70: 2020 2020 6966 206e 6f74 2068 6173 6174      if not hasat
+00010e80: 7472 2873 656c 662c 2027 6c69 6e6b 7479  tr(self, 'linkty
+00010e90: 7065 2729 3a0a 2020 2020 2020 2020 2020  pe'):.          
+00010ea0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00010eb0: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
+00010ec0: 2020 2020 226c 696e 6b74 7970 6520 636f      "linktype co
+00010ed0: 756c 6420 6e6f 7420 6265 2067 7565 7373  uld not be guess
+00010ee0: 6564 2e20 220a 2020 2020 2020 2020 2020  ed. ".          
+00010ef0: 2020 2020 2020 2250 6c65 6173 6520 7061        "Please pa
+00010f00: 7373 2061 206c 696e 6b74 7970 6520 7768  ss a linktype wh
+00010f10: 696c 6520 6372 6561 7469 6e67 2074 6865  ile creating the
+00010f20: 2077 7269 7465 7222 0a20 2020 2020 2020   writer".       
+00010f30: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00010f40: 7365 6c66 2e66 2e77 7269 7465 2873 7472  self.f.write(str
+00010f50: 7563 742e 7061 636b 2873 656c 662e 656e  uct.pack(self.en
+00010f60: 6469 616e 202b 2022 4948 4849 4949 4922  dian + "IHHIIII"
+00010f70: 2c20 3078 6131 6232 3363 3464 2069 6620  , 0xa1b23c4d if 
+00010f80: 7365 6c66 2e6e 616e 6f20 656c 7365 2030  self.nano else 0
+00010f90: 7861 3162 3263 3364 342c 2020 2320 6e6f  xa1b2c3d4,  # no
+00010fa0: 7161 3a20 4535 3031 0a20 2020 2020 2020  qa: E501.       
+00010fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010fc0: 2020 2020 2020 2020 2020 322c 2034 2c20            2, 4, 
+00010fd0: 302c 2030 2c20 7365 6c66 2e73 6e61 706c  0, 0, self.snapl
+00010fe0: 656e 2c20 7365 6c66 2e6c 696e 6b74 7970  en, self.linktyp
+00010ff0: 6529 290a 2020 2020 2020 2020 7365 6c66  e)).        self
+00011000: 2e66 2e66 6c75 7368 2829 0a0a 2020 2020  .f.flush()..    
+00011010: 6465 6620 5f77 7269 7465 5f70 6163 6b65  def _write_packe
+00011020: 7428 7365 6c66 2c0a 2020 2020 2020 2020  t(self,.        
+00011030: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+00011040: 636b 6574 2c20 2023 2074 7970 653a 2055  cket,  # type: U
+00011050: 6e69 6f6e 5b62 7974 6573 2c20 5061 636b  nion[bytes, Pack
+00011060: 6574 5d0a 2020 2020 2020 2020 2020 2020  et].            
+00011070: 2020 2020 2020 2020 2020 6c69 6e6b 7479            linkty
+00011080: 7065 2c20 2023 2074 7970 653a 2069 6e74  pe,  # type: int
+00011090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000110a0: 2020 2020 2020 2073 6563 3d4e 6f6e 652c         sec=None,
+000110b0: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
+000110c0: 616c 5b66 6c6f 6174 5d0a 2020 2020 2020  al[float].      
+000110d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000110e0: 7573 6563 3d4e 6f6e 652c 2020 2320 7479  usec=None,  # ty
+000110f0: 7065 3a20 4f70 7469 6f6e 616c 5b69 6e74  pe: Optional[int
+00011100: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00011110: 2020 2020 2020 2020 6361 706c 656e 3d4e          caplen=N
+00011120: 6f6e 652c 2020 2320 7479 7065 3a20 4f70  one,  # type: Op
+00011130: 7469 6f6e 616c 5b69 6e74 5d0a 2020 2020  tional[int].    
+00011140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011150: 2020 7769 7265 6c65 6e3d 4e6f 6e65 2c20    wirelen=None, 
+00011160: 2023 2074 7970 653a 204f 7074 696f 6e61   # type: Optiona
+00011170: 6c5b 696e 745d 0a20 2020 2020 2020 2020  l[int].         
+00011180: 2020 2020 2020 2020 2020 2020 2063 6f6d               com
+00011190: 6d65 6e74 3d4e 6f6e 652c 2020 2320 7479  ment=None,  # ty
+000111a0: 7065 3a20 4f70 7469 6f6e 616c 5b62 7974  pe: Optional[byt
+000111b0: 6573 5d0a 2020 2020 2020 2020 2020 2020  es].            
+000111c0: 2020 2020 2020 2020 2020 6966 6e61 6d65            ifname
+000111d0: 3d4e 6f6e 652c 2020 2320 7479 7065 3a20  =None,  # type: 
+000111e0: 4f70 7469 6f6e 616c 5b62 7974 6573 5d0a  Optional[bytes].
+000111f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011200: 2020 2020 2020 6469 7265 6374 696f 6e3d        direction=
+00011210: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
+00011220: 7074 696f 6e61 6c5b 696e 745d 0a20 2020  ptional[int].   
+00011230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011240: 2020 2029 3a0a 2020 2020 2020 2020 2320     ):.        # 
+00011250: 7479 7065 3a20 282e 2e2e 2920 2d3e 204e  type: (...) -> N
+00011260: 6f6e 650a 2020 2020 2020 2020 2222 220a  one.        """.
+00011270: 2020 2020 2020 2020 5772 6974 6573 2061          Writes a
+00011280: 2073 696e 676c 6520 7061 636b 6574 2074   single packet t
+00011290: 6f20 7468 6520 7063 6170 2066 696c 652e  o the pcap file.
+000112a0: 0a0a 2020 2020 2020 2020 3a70 6172 616d  ..        :param
+000112b0: 2070 6163 6b65 743a 2062 7974 6573 2066   packet: bytes f
+000112c0: 6f72 2061 2073 696e 676c 6520 7061 636b  or a single pack
+000112d0: 6574 0a20 2020 2020 2020 203a 7479 7065  et.        :type
+000112e0: 2070 6163 6b65 743a 2062 7974 6573 0a20   packet: bytes. 
+000112f0: 2020 2020 2020 203a 7061 7261 6d20 6c69         :param li
+00011300: 6e6b 7479 7065 3a20 6c69 6e6b 7479 7065  nktype: linktype
+00011310: 2076 616c 7565 2061 7373 6f63 6961 7465   value associate
+00011320: 6420 7769 7468 2074 6865 2070 6163 6b65  d with the packe
+00011330: 740a 2020 2020 2020 2020 3a74 7970 6520  t.        :type 
+00011340: 6c69 6e6b 7479 7065 3a20 696e 740a 2020  linktype: int.  
+00011350: 2020 2020 2020 3a70 6172 616d 2073 6563        :param sec
+00011360: 3a20 7469 6d65 2074 6865 2070 6163 6b65  : time the packe
+00011370: 7420 7761 7320 6361 7074 7572 6564 2c20  t was captured, 
+00011380: 696e 2073 6563 6f6e 6473 2073 696e 6365  in seconds since
+00011390: 2065 706f 6368 2e20 4966 0a20 2020 2020   epoch. If.     
+000113a0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+000113b0: 6f74 2073 7570 706c 6965 642c 2064 6566  ot supplied, def
+000113c0: 6175 6c74 7320 746f 206e 6f77 2e0a 2020  aults to now..  
+000113d0: 2020 2020 2020 3a74 7970 6520 7365 633a        :type sec:
+000113e0: 2066 6c6f 6174 0a20 2020 2020 2020 203a   float.        :
+000113f0: 7061 7261 6d20 7573 6563 3a20 6e6f 7420  param usec: not 
+00011400: 7573 6564 2077 6974 6820 7063 6170 6e67  used with pcapng
+00011410: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011420: 2020 2020 2020 7061 636b 6574 2077 6173        packet was
+00011430: 2063 6170 7475 7265 640a 2020 2020 2020   captured.      
+00011440: 2020 3a74 7970 6520 7573 6563 3a20 696e    :type usec: in
+00011450: 7420 6f72 206c 6f6e 670a 2020 2020 2020  t or long.      
+00011460: 2020 3a70 6172 616d 2063 6170 6c65 6e3a    :param caplen:
+00011470: 2054 6865 206c 656e 6774 6820 6f66 2074   The length of t
+00011480: 6865 2070 6163 6b65 7420 696e 2074 6865  he packet in the
+00011490: 2063 6170 7475 7265 2066 696c 652e 2049   capture file. I
+000114a0: 6620 6e6f 740a 2020 2020 2020 2020 2020  f not.          
+000114b0: 2020 2020 2020 2020 2020 2020 2073 7065               spe
+000114c0: 6369 6669 6564 2c20 7573 6573 2060 606c  cified, uses ``l
+000114d0: 656e 2870 6163 6b65 7429 6060 2e0a 2020  en(packet)``..  
+000114e0: 2020 2020 2020 3a74 7970 6520 6361 706c        :type capl
+000114f0: 656e 3a20 696e 740a 2020 2020 2020 2020  en: int.        
+00011500: 3a70 6172 616d 2077 6972 656c 656e 3a20  :param wirelen: 
+00011510: 5468 6520 6c65 6e67 7468 206f 6620 7468  The length of th
+00011520: 6520 7061 636b 6574 206f 6e20 7468 6520  e packet on the 
+00011530: 7769 7265 2e20 4966 206e 6f74 0a20 2020  wire. If not.   
+00011540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011550: 2020 2020 2073 7065 6369 6669 6564 2c20       specified, 
+00011560: 7573 6573 2060 6063 6170 6c65 6e60 602e  uses ``caplen``.
+00011570: 0a20 2020 2020 2020 203a 7479 7065 2077  .        :type w
+00011580: 6972 656c 656e 3a20 696e 740a 2020 2020  irelen: int.    
+00011590: 2020 2020 3a72 6574 7572 6e3a 204e 6f6e      :return: Non
+000115a0: 650a 2020 2020 2020 2020 3a72 7479 7065  e.        :rtype
+000115b0: 3a20 4e6f 6e65 0a20 2020 2020 2020 2022  : None.        "
+000115c0: 2222 0a20 2020 2020 2020 2069 6620 6361  "".        if ca
+000115d0: 706c 656e 2069 7320 4e6f 6e65 3a0a 2020  plen is None:.  
+000115e0: 2020 2020 2020 2020 2020 6361 706c 656e            caplen
+000115f0: 203d 206c 656e 2870 6163 6b65 7429 0a20   = len(packet). 
+00011600: 2020 2020 2020 2069 6620 7769 7265 6c65         if wirele
+00011610: 6e20 6973 204e 6f6e 653a 0a20 2020 2020  n is None:.     
+00011620: 2020 2020 2020 2077 6972 656c 656e 203d         wirelen =
+00011630: 2063 6170 6c65 6e0a 2020 2020 2020 2020   caplen.        
+00011640: 6966 2073 6563 2069 7320 4e6f 6e65 206f  if sec is None o
+00011650: 7220 7573 6563 2069 7320 4e6f 6e65 3a0a  r usec is None:.
+00011660: 2020 2020 2020 2020 2020 2020 7420 3d20              t = 
+00011670: 7469 6d65 2e74 696d 6528 290a 2020 2020  time.time().    
+00011680: 2020 2020 2020 2020 6974 203d 2069 6e74          it = int
+00011690: 2874 290a 2020 2020 2020 2020 2020 2020  (t).            
+000116a0: 6966 2073 6563 2069 7320 4e6f 6e65 3a0a  if sec is None:.
+000116b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000116c0: 7365 6320 3d20 6974 0a20 2020 2020 2020  sec = it.       
+000116d0: 2020 2020 2020 2020 2075 7365 6320 3d20           usec = 
+000116e0: 696e 7428 726f 756e 6428 2874 202d 2069  int(round((t - i
+000116f0: 7429 202a 0a20 2020 2020 2020 2020 2020  t) *.           
+00011700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011710: 2020 2020 2020 2831 3030 3030 3030 3030        (100000000
+00011720: 3020 6966 2073 656c 662e 6e61 6e6f 2065  0 if self.nano e
+00011730: 6c73 6520 3130 3030 3030 3029 2929 0a20  lse 1000000))). 
+00011740: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+00011750: 7573 6563 2069 7320 4e6f 6e65 3a0a 2020  usec is None:.  
+00011760: 2020 2020 2020 2020 2020 2020 2020 7573                us
+00011770: 6563 203d 2030 0a0a 2020 2020 2020 2020  ec = 0..        
+00011780: 7365 6c66 2e66 2e77 7269 7465 2873 7472  self.f.write(str
+00011790: 7563 742e 7061 636b 2873 656c 662e 656e  uct.pack(self.en
+000117a0: 6469 616e 202b 2022 4949 4949 222c 0a20  dian + "IIII",. 
 000117b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000117c0: 2020 206e 6f74 2073 7570 706c 6965 642c     not supplied,
-000117d0: 2064 6566 6175 6c74 7320 746f 206e 6f77   defaults to now
-000117e0: 2e0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
-000117f0: 7365 633a 2066 6c6f 6174 0a20 2020 2020  sec: float.     
-00011800: 2020 203a 7061 7261 6d20 6361 706c 656e     :param caplen
-00011810: 3a20 5468 6520 6c65 6e67 7468 206f 6620  : The length of 
-00011820: 7468 6520 7061 636b 6574 2069 6e20 7468  the packet in th
-00011830: 6520 6361 7074 7572 6520 6669 6c65 2e20  e capture file. 
-00011840: 4966 206e 6f74 0a20 2020 2020 2020 2020  If not.         
-00011850: 2020 2020 2020 2020 2020 2020 2020 7370                sp
-00011860: 6563 6966 6965 642c 2075 7365 7320 6060  ecified, uses ``
-00011870: 6c65 6e28 7061 636b 6574 2960 602e 0a20  len(packet)``.. 
-00011880: 2020 2020 2020 203a 7479 7065 2063 6170         :type cap
-00011890: 6c65 6e3a 2069 6e74 0a20 2020 2020 2020  len: int.       
-000118a0: 203a 7061 7261 6d20 7769 7265 6c65 6e3a   :param wirelen:
-000118b0: 2054 6865 206c 656e 6774 6820 6f66 2074   The length of t
-000118c0: 6865 2070 6163 6b65 7420 6f6e 2074 6865  he packet on the
-000118d0: 2077 6972 652e 2049 6620 6e6f 740a 2020   wire. If not.  
-000118e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000118f0: 2020 2020 2020 7370 6563 6966 6965 642c        specified,
-00011900: 2075 7365 7320 6060 6361 706c 656e 6060   uses ``caplen``
-00011910: 2e0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
-00011920: 7769 7265 6c65 6e3a 2069 6e74 0a20 2020  wirelen: int.   
-00011930: 2020 2020 203a 7265 7475 726e 3a20 4e6f       :return: No
-00011940: 6e65 0a20 2020 2020 2020 203a 7274 7970  ne.        :rtyp
-00011950: 653a 204e 6f6e 650a 2020 2020 2020 2020  e: None.        
-00011960: 2222 220a 2020 2020 2020 2020 6966 2063  """.        if c
-00011970: 6170 6c65 6e20 6973 204e 6f6e 653a 0a20  aplen is None:. 
-00011980: 2020 2020 2020 2020 2020 2063 6170 6c65             caple
-00011990: 6e20 3d20 6c65 6e28 7061 636b 6574 290a  n = len(packet).
-000119a0: 2020 2020 2020 2020 6966 2077 6972 656c          if wirel
-000119b0: 656e 2069 7320 4e6f 6e65 3a0a 2020 2020  en is None:.    
-000119c0: 2020 2020 2020 2020 7769 7265 6c65 6e20          wirelen 
-000119d0: 3d20 6361 706c 656e 0a0a 2020 2020 2020  = caplen..      
-000119e0: 2020 7365 6c66 2e5f 7772 6974 655f 626c    self._write_bl
-000119f0: 6f63 6b5f 6570 6228 7061 636b 6574 2c20  ock_epb(packet, 
-00011a00: 7469 6d65 7374 616d 703d 7365 632c 2063  timestamp=sec, c
-00011a10: 6170 6c65 6e3d 6361 706c 656e 2c0a 2020  aplen=caplen,.  
-00011a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011a30: 2020 2020 2020 2020 2020 2020 6f72 676c              orgl
-00011a40: 656e 3d77 6972 656c 656e 2c20 636f 6d6d  en=wirelen, comm
-00011a50: 656e 743d 636f 6d6d 656e 7429 0a20 2020  ent=comment).   
-00011a60: 2020 2020 2069 6620 7365 6c66 2e73 796e       if self.syn
-00011a70: 633a 0a20 2020 2020 2020 2020 2020 2073  c:.            s
-00011a80: 656c 662e 662e 666c 7573 6828 290a 0a0a  elf.f.flush()...
-00011a90: 636c 6173 7320 5063 6170 5772 6974 6572  class PcapWriter
-00011aa0: 2852 6177 5063 6170 5772 6974 6572 293a  (RawPcapWriter):
-00011ab0: 0a20 2020 2022 2222 4120 7374 7265 616d  .    """A stream
-00011ac0: 2050 4341 5020 7772 6974 6572 2077 6974   PCAP writer wit
-00011ad0: 6820 6d6f 7265 2063 6f6e 7472 6f6c 2074  h more control t
-00011ae0: 6861 6e20 7772 7063 6170 2829 2222 220a  han wrpcap()""".
-00011af0: 2020 2020 7061 7373 0a0a 0a63 6c61 7373      pass...class
-00011b00: 2050 6361 704e 6757 7269 7465 7228 5261   PcapNgWriter(Ra
-00011b10: 7750 6361 704e 6757 7269 7465 7229 3a0a  wPcapNgWriter):.
-00011b20: 2020 2020 2222 2241 2073 7472 6561 6d20      """A stream 
-00011b30: 7063 6170 6e67 2077 7269 7465 7220 7769  pcapng writer wi
-00011b40: 7468 206d 6f72 6520 636f 6e74 726f 6c20  th more control 
-00011b50: 7468 616e 2077 7270 6361 706e 6728 2922  than wrpcapng()"
-00011b60: 2222 0a0a 2020 2020 6465 6620 5f67 6574  ""..    def _get
-00011b70: 5f74 696d 6528 7365 6c66 2c0a 2020 2020  _time(self,.    
-00011b80: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-00011b90: 636b 6574 2c20 2023 2074 7970 653a 2055  cket,  # type: U
-00011ba0: 6e69 6f6e 5b62 7974 6573 2c20 5061 636b  nion[bytes, Pack
-00011bb0: 6574 5d0a 2020 2020 2020 2020 2020 2020  et].            
-00011bc0: 2020 2020 2020 7365 632c 2020 2320 7479        sec,  # ty
-00011bd0: 7065 3a20 4f70 7469 6f6e 616c 5b66 6c6f  pe: Optional[flo
-00011be0: 6174 5d0a 2020 2020 2020 2020 2020 2020  at].            
-00011bf0: 2020 2020 2020 7573 6563 2020 2320 7479        usec  # ty
-00011c00: 7065 3a20 4f70 7469 6f6e 616c 5b69 6e74  pe: Optional[int
-00011c10: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00011c20: 2020 2020 293a 0a20 2020 2020 2020 2023      ):.        #
-00011c30: 2074 7970 653a 2028 2e2e 2e29 202d 3e20   type: (...) -> 
-00011c40: 5475 706c 655b 666c 6f61 742c 2069 6e74  Tuple[float, int
-00011c50: 5d0a 2020 2020 2020 2020 6966 2068 6173  ].        if has
-00011c60: 6174 7472 2870 6163 6b65 742c 2022 7469  attr(packet, "ti
-00011c70: 6d65 2229 3a0a 2020 2020 2020 2020 2020  me"):.          
-00011c80: 2020 6966 2073 6563 2069 7320 4e6f 6e65    if sec is None
-00011c90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00011ca0: 2020 7365 6320 3d20 666c 6f61 7428 7061    sec = float(pa
-00011cb0: 636b 6574 2e74 696d 6529 2020 2320 7479  cket.time)  # ty
-00011cc0: 7065 3a20 6967 6e6f 7265 0a0a 2020 2020  pe: ignore..    
-00011cd0: 2020 2020 6966 2075 7365 6320 6973 204e      if usec is N
-00011ce0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00011cf0: 2075 7365 6320 3d20 300a 0a20 2020 2020   usec = 0..     
-00011d00: 2020 2072 6574 7572 6e20 7365 632c 2075     return sec, u
-00011d10: 7365 6320 2023 2074 7970 653a 2069 676e  sec  # type: ign
-00011d20: 6f72 650a 0a0a 4063 6f6e 662e 636f 6d6d  ore...@conf.comm
-00011d30: 616e 6473 2e72 6567 6973 7465 720a 6465  ands.register.de
-00011d40: 6620 7264 6572 6628 6669 6c65 6e61 6d65  f rderf(filename
-00011d50: 2c20 636f 756e 743d 2d31 293a 0a20 2020  , count=-1):.   
-00011d60: 2023 2074 7970 653a 2028 556e 696f 6e5b   # type: (Union[
-00011d70: 494f 5b62 7974 6573 5d2c 2073 7472 5d2c  IO[bytes], str],
-00011d80: 2069 6e74 2920 2d3e 2050 6163 6b65 744c   int) -> PacketL
-00011d90: 6973 740a 2020 2020 2222 2252 6561 6420  ist.    """Read 
-00011da0: 6120 4552 4620 6669 6c65 2061 6e64 2072  a ERF file and r
-00011db0: 6574 7572 6e20 6120 7061 636b 6574 206c  eturn a packet l
-00011dc0: 6973 740a 0a20 2020 203a 7061 7261 6d20  ist..    :param 
-00011dd0: 636f 756e 743a 2072 6561 6420 6f6e 6c79  count: read only
-00011de0: 203c 636f 756e 743e 2070 6163 6b65 7473   <count> packets
-00011df0: 0a20 2020 2022 2222 0a20 2020 2077 6974  .    """.    wit
-00011e00: 6820 4552 4645 7468 6572 6e65 7452 6561  h ERFEthernetRea
-00011e10: 6465 7228 6669 6c65 6e61 6d65 2920 6173  der(filename) as
-00011e20: 2066 6465 7363 3a0a 2020 2020 2020 2020   fdesc:.        
-00011e30: 7265 7475 726e 2066 6465 7363 2e72 6561  return fdesc.rea
-00011e40: 645f 616c 6c28 636f 756e 743d 636f 756e  d_all(count=coun
-00011e50: 7429 0a0a 0a63 6c61 7373 2045 5246 4574  t)...class ERFEt
-00011e60: 6865 726e 6574 5265 6164 6572 5f6d 6574  hernetReader_met
-00011e70: 6163 6c61 7373 2850 6361 7052 6561 6465  aclass(PcapReade
-00011e80: 725f 6d65 7461 636c 6173 7329 3a0a 2020  r_metaclass):.  
-00011e90: 2020 6465 6620 5f5f 6361 6c6c 5f5f 2863    def __call__(c
-00011ea0: 6c73 2c20 6669 6c65 6e61 6d65 293a 2020  ls, filename):  
-00011eb0: 2320 7479 7065 3a20 6967 6e6f 7265 0a20  # type: ignore. 
-00011ec0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-00011ed0: 556e 696f 6e5b 494f 5b62 7974 6573 5d2c  Union[IO[bytes],
-00011ee0: 2073 7472 5d29 202d 3e20 416e 790a 2020   str]) -> Any.  
-00011ef0: 2020 2020 2020 6920 3d20 636c 732e 5f5f        i = cls.__
-00011f00: 6e65 775f 5f28 636c 732c 2063 6c73 2e5f  new__(cls, cls._
-00011f10: 5f6e 616d 655f 5f2c 2063 6c73 2e5f 5f62  _name__, cls.__b
-00011f20: 6173 6573 5f5f 2c20 636c 732e 5f5f 6469  ases__, cls.__di
-00011f30: 6374 5f5f 290a 2020 2020 2020 2020 6669  ct__).        fi
-00011f40: 6c65 6e61 6d65 2c20 6664 6573 6320 3d20  lename, fdesc = 
-00011f50: 636c 732e 6f70 656e 2866 696c 656e 616d  cls.open(filenam
-00011f60: 6529 0a20 2020 2020 2020 2074 7279 3a0a  e).        try:.
-00011f70: 2020 2020 2020 2020 2020 2020 692e 5f5f              i.__
-00011f80: 696e 6974 5f5f 2866 696c 656e 616d 652c  init__(filename,
-00011f90: 2066 6465 7363 290a 2020 2020 2020 2020   fdesc).        
-00011fa0: 2020 2020 7265 7475 726e 2069 0a20 2020      return i.   
-00011fb0: 2020 2020 2065 7863 6570 7420 2853 6361       except (Sca
-00011fc0: 7079 5f45 7863 6570 7469 6f6e 2c20 454f  py_Exception, EO
-00011fd0: 4645 7272 6f72 293a 0a20 2020 2020 2020  FError):.       
-00011fe0: 2020 2020 2070 6173 730a 0a20 2020 2020       pass..     
-00011ff0: 2020 2069 6620 2261 6c74 6572 6e61 7469     if "alternati
-00012000: 7665 2220 696e 2063 6c73 2e5f 5f64 6963  ve" in cls.__dic
-00012010: 745f 5f3a 0a20 2020 2020 2020 2020 2020  t__:.           
-00012020: 2063 6c73 203d 2063 6c73 2e5f 5f64 6963   cls = cls.__dic
-00012030: 745f 5f5b 2261 6c74 6572 6e61 7469 7665  t__["alternative
-00012040: 225d 0a20 2020 2020 2020 2020 2020 2069  "].            i
-00012050: 203d 2063 6c73 2e5f 5f6e 6577 5f5f 2863   = cls.__new__(c
-00012060: 6c73 2c20 636c 732e 5f5f 6e61 6d65 5f5f  ls, cls.__name__
-00012070: 2c20 636c 732e 5f5f 6261 7365 735f 5f2c  , cls.__bases__,
-00012080: 2063 6c73 2e5f 5f64 6963 745f 5f29 0a20   cls.__dict__). 
-00012090: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
-000120a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000120b0: 692e 5f5f 696e 6974 5f5f 2866 696c 656e  i.__init__(filen
-000120c0: 616d 652c 2066 6465 7363 290a 2020 2020  ame, fdesc).    
-000120d0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000120e0: 726e 2069 0a20 2020 2020 2020 2020 2020  rn i.           
-000120f0: 2065 7863 6570 7420 2853 6361 7079 5f45   except (Scapy_E
-00012100: 7863 6570 7469 6f6e 2c20 454f 4645 7272  xception, EOFErr
-00012110: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
-00012120: 2020 2020 2070 6173 730a 0a20 2020 2020       pass..     
-00012130: 2020 2072 6169 7365 2053 6361 7079 5f45     raise Scapy_E
-00012140: 7863 6570 7469 6f6e 2822 4e6f 7420 6120  xception("Not a 
-00012150: 7375 7070 6f72 7465 6420 6361 7074 7572  supported captur
-00012160: 6520 6669 6c65 2229 0a0a 2020 2020 4073  e file")..    @s
-00012170: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
-00012180: 6465 6620 6f70 656e 2866 6e61 6d65 2020  def open(fname  
-00012190: 2320 7479 7065 3a20 6967 6e6f 7265 0a20  # type: ignore. 
-000121a0: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
-000121b0: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-000121c0: 2e2e 2e29 202d 3e20 5475 706c 655b 7374  ...) -> Tuple[st
-000121d0: 722c 205f 4279 7465 5374 7265 616d 5d0a  r, _ByteStream].
-000121e0: 2020 2020 2020 2020 2222 224f 7065 6e20          """Open 
-000121f0: 2869 6620 6e65 6365 7373 6172 7929 2066  (if necessary) f
-00012200: 696c 656e 616d 6522 2222 0a20 2020 2020  ilename""".     
-00012210: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-00012220: 2866 6e61 6d65 2c20 7374 7229 3a0a 2020  (fname, str):.  
-00012230: 2020 2020 2020 2020 2020 6669 6c65 6e61            filena
-00012240: 6d65 203d 2066 6e61 6d65 0a20 2020 2020  me = fname.     
-00012250: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-00012260: 2020 2020 2020 2020 2020 2020 7769 7468              with
-00012270: 2067 7a69 702e 6f70 656e 2866 696c 656e   gzip.open(filen
-00012280: 616d 652c 2022 7262 2229 2061 7320 746d  ame, "rb") as tm
-00012290: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
-000122a0: 2020 2020 2020 2074 6d70 2e72 6561 6428         tmp.read(
-000122b0: 3129 0a20 2020 2020 2020 2020 2020 2020  1).             
-000122c0: 2020 2066 6465 7363 203d 2067 7a69 702e     fdesc = gzip.
-000122d0: 6f70 656e 2866 696c 656e 616d 652c 2022  open(filename, "
-000122e0: 7262 2229 2020 2320 7479 7065 3a20 5f42  rb")  # type: _B
-000122f0: 7974 6553 7472 6561 6d0a 2020 2020 2020  yteStream.      
-00012300: 2020 2020 2020 6578 6365 7074 2049 4f45        except IOE
-00012310: 7272 6f72 3a0a 2020 2020 2020 2020 2020  rror:.          
-00012320: 2020 2020 2020 6664 6573 6320 3d20 6f70        fdesc = op
-00012330: 656e 2866 696c 656e 616d 652c 2022 7262  en(filename, "rb
-00012340: 2229 0a0a 2020 2020 2020 2020 656c 7365  ")..        else
-00012350: 3a0a 2020 2020 2020 2020 2020 2020 6664  :.            fd
-00012360: 6573 6320 3d20 666e 616d 650a 2020 2020  esc = fname.    
-00012370: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
-00012380: 203d 2067 6574 6174 7472 2866 6465 7363   = getattr(fdesc
-00012390: 2c20 226e 616d 6522 2c20 224e 6f20 6e61  , "name", "No na
-000123a0: 6d65 2229 0a20 2020 2020 2020 2072 6574  me").        ret
-000123b0: 7572 6e20 6669 6c65 6e61 6d65 2c20 6664  urn filename, fd
-000123c0: 6573 630a 0a0a 4073 6978 2e61 6464 5f6d  esc...@six.add_m
-000123d0: 6574 6163 6c61 7373 2845 5246 4574 6865  etaclass(ERFEthe
-000123e0: 726e 6574 5265 6164 6572 5f6d 6574 6163  rnetReader_metac
-000123f0: 6c61 7373 290a 636c 6173 7320 4552 4645  lass).class ERFE
-00012400: 7468 6572 6e65 7452 6561 6465 7228 5063  thernetReader(Pc
-00012410: 6170 5265 6164 6572 293a 0a0a 2020 2020  apReader):..    
-00012420: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00012430: 662c 2066 696c 656e 616d 652c 2066 6465  f, filename, fde
-00012440: 7363 3d4e 6f6e 6529 3a20 2023 2074 7970  sc=None):  # typ
-00012450: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
-00012460: 2020 2320 7479 7065 3a20 2855 6e69 6f6e    # type: (Union
-00012470: 5b49 4f5b 6279 7465 735d 2c20 7374 725d  [IO[bytes], str]
-00012480: 2c20 494f 5b62 7974 6573 5d29 202d 3e20  , IO[bytes]) -> 
-00012490: 4e6f 6e65 0a20 2020 2020 2020 2073 656c  None.        sel
-000124a0: 662e 6669 6c65 6e61 6d65 203d 2066 696c  f.filename = fil
-000124b0: 656e 616d 6520 2023 2074 7970 653a 2069  ename  # type: i
-000124c0: 676e 6f72 650a 2020 2020 2020 2020 7365  gnore.        se
-000124d0: 6c66 2e66 203d 2066 6465 7363 0a20 2020  lf.f = fdesc.   
-000124e0: 2020 2020 2073 656c 662e 706f 7765 7220       self.power 
-000124f0: 3d20 4465 6369 6d61 6c28 3130 2920 2a2a  = Decimal(10) **
-00012500: 2044 6563 696d 616c 282d 3929 0a0a 2020   Decimal(-9)..  
-00012510: 2020 2320 7469 6d65 2069 7320 696e 2036    # time is in 6
-00012520: 342d 6269 7473 2045 6e64 6163 6527 7320  4-bits Endace's 
-00012530: 666f 726d 6174 2077 6869 6368 2063 616e  format which can
-00012540: 2062 6520 7365 6520 6865 7265 3a0a 2020   be see here:.  
-00012550: 2020 2320 6874 7470 733a 2f2f 7777 772e    # https://www.
-00012560: 656e 6461 6365 2e63 6f6d 2f65 7266 2d65  endace.com/erf-e
-00012570: 7874 656e 7369 626c 652d 7265 636f 7264  xtensible-record
-00012580: 2d66 6f72 6d61 742d 7479 7065 732e 7064  -format-types.pd
-00012590: 660a 2020 2020 6465 6620 5f63 6f6e 7665  f.    def _conve
-000125a0: 7274 5f65 7266 5f74 696d 6573 7461 6d70  rt_erf_timestamp
-000125b0: 2873 656c 662c 2074 293a 0a20 2020 2020  (self, t):.     
-000125c0: 2020 2023 2074 7970 653a 2028 696e 7429     # type: (int)
-000125d0: 202d 3e20 4544 6563 696d 616c 0a20 2020   -> EDecimal.   
-000125e0: 2020 2020 2073 6563 203d 2074 203e 3e20       sec = t >> 
-000125f0: 3332 0a20 2020 2020 2020 2066 7261 635f  32.        frac_
-00012600: 7365 6320 3d20 7420 2620 3078 6666 6666  sec = t & 0xffff
-00012610: 6666 6666 0a20 2020 2020 2020 2066 7261  ffff.        fra
-00012620: 635f 7365 6320 2a3d 2031 302a 2a39 0a20  c_sec *= 10**9. 
-00012630: 2020 2020 2020 2066 7261 635f 7365 6320         frac_sec 
-00012640: 2b3d 2028 6672 6163 5f73 6563 2026 2030  += (frac_sec & 0
-00012650: 7838 3030 3030 3030 3029 203c 3c20 310a  x80000000) << 1.
-00012660: 2020 2020 2020 2020 6672 6163 5f73 6563          frac_sec
-00012670: 203e 3e3d 2033 320a 2020 2020 2020 2020   >>= 32.        
-00012680: 7265 7475 726e 2045 4465 6369 6d61 6c28  return EDecimal(
-00012690: 7365 6320 2b20 7365 6c66 2e70 6f77 6572  sec + self.power
-000126a0: 202a 2066 7261 635f 7365 6329 0a0a 2020   * frac_sec)..  
-000126b0: 2020 2320 5468 6520 6465 7461 696c 7320    # The details 
-000126c0: 6f66 2045 5246 2050 6163 6b65 7420 666f  of ERF Packet fo
-000126d0: 726d 6174 2063 616e 2062 6520 7365 6520  rmat can be see 
-000126e0: 6865 7265 3a0a 2020 2020 2320 6874 7470  here:.    # http
-000126f0: 733a 2f2f 7777 772e 656e 6461 6365 2e63  s://www.endace.c
-00012700: 6f6d 2f65 7266 2d65 7874 656e 7369 626c  om/erf-extensibl
-00012710: 652d 7265 636f 7264 2d66 6f72 6d61 742d  e-record-format-
-00012720: 7479 7065 732e 7064 660a 2020 2020 6465  types.pdf.    de
-00012730: 6620 7265 6164 5f70 6163 6b65 7428 7365  f read_packet(se
-00012740: 6c66 2c20 7369 7a65 3d4d 5455 293a 0a20  lf, size=MTU):. 
-00012750: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
-00012760: 696e 7429 202d 3e20 5061 636b 6574 0a0a  int) -> Packet..
-00012770: 2020 2020 2020 2020 2320 4765 6e65 7261          # Genera
-00012780: 6c20 4552 4620 4865 6164 6572 2068 6176  l ERF Header hav
-00012790: 6520 6578 6163 746c 7920 3136 2062 7974  e exactly 16 byt
-000127a0: 6573 0a20 2020 2020 2020 2068 6472 203d  es.        hdr =
-000127b0: 2073 656c 662e 662e 7265 6164 2831 3629   self.f.read(16)
-000127c0: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
-000127d0: 6864 7229 203c 2031 363a 0a20 2020 2020  hdr) < 16:.     
-000127e0: 2020 2020 2020 2072 6169 7365 2045 4f46         raise EOF
-000127f0: 4572 726f 720a 0a20 2020 2020 2020 2023  Error..        #
-00012800: 2054 6865 2074 696d 6573 7461 6d70 2069   The timestamp i
-00012810: 7320 696e 206c 6974 746c 652d 656e 6469  s in little-endi
-00012820: 616e 2062 7974 652d 6f72 6465 722e 0a20  an byte-order.. 
-00012830: 2020 2020 2020 2074 696d 6520 3d20 7374         time = st
-00012840: 7275 6374 2e75 6e70 6163 6b28 273c 5127  ruct.unpack('<Q'
-00012850: 2c20 6864 725b 3a38 5d29 5b30 5d0a 2020  , hdr[:8])[0].  
-00012860: 2020 2020 2020 2320 5468 6520 7265 7374        # The rest
-00012870: 2069 7320 696e 2062 6967 2d65 6e64 6961   is in big-endia
-00012880: 6e20 6279 7465 2d6f 7264 6572 2e0a 2020  n byte-order..  
-00012890: 2020 2020 2020 2320 4967 6e6f 7269 6e67        # Ignoring
-000128a0: 2066 6c61 6773 2061 6e64 206c 6374 7220   flags and lctr 
-000128b0: 286c 6f73 7320 636f 756e 7465 7229 2073  (loss counter) s
-000128c0: 696e 6365 2074 6865 7920 6172 6520 4552  ince they are ER
-000128d0: 4620 7370 6563 6966 6963 0a20 2020 2020  F specific.     
-000128e0: 2020 2023 2068 6561 6465 7220 6669 656c     # header fiel
-000128f0: 6473 2077 6869 6368 2050 6163 6b65 7420  ds which Packet 
-00012900: 6f62 6a65 6374 2064 6f65 7320 6e6f 7420  object does not 
-00012910: 7375 7070 6f72 742e 0a20 2020 2020 2020  support..       
-00012920: 2074 7970 652c 205f 2c20 726c 656e 2c20   type, _, rlen, 
-00012930: 5f2c 2077 6c65 6e20 3d20 7374 7275 6374  _, wlen = struct
-00012940: 2e75 6e70 6163 6b28 273e 4242 4848 4827  .unpack('>BBHHH'
-00012950: 2c20 6864 725b 383a 5d29 0a20 2020 2020  , hdr[8:]).     
-00012960: 2020 2023 2043 6865 636b 2069 6620 7468     # Check if th
-00012970: 6520 7479 7065 2021 3d20 3078 3032 2c20  e type != 0x02, 
-00012980: 7479 7065 2045 7468 6572 6e65 740a 2020  type Ethernet.  
-00012990: 2020 2020 2020 6966 2074 7970 6520 2620        if type & 
-000129a0: 3078 3032 203d 3d20 303a 0a20 2020 2020  0x02 == 0:.     
-000129b0: 2020 2020 2020 2072 6169 7365 2053 6361         raise Sca
-000129c0: 7079 5f45 7863 6570 7469 6f6e 2822 496e  py_Exception("In
-000129d0: 7661 6c69 6420 4552 4620 5479 7065 2028  valid ERF Type (
-000129e0: 4e6f 7420 5459 5045 5f45 5448 2922 290a  Not TYPE_ETH)").
-000129f0: 0a20 2020 2020 2020 2023 2049 6620 7468  .        # If th
-00012a00: 6572 6520 6172 6520 6578 7465 6e64 6564  ere are extended
-00012a10: 2068 6561 6465 7273 2c20 6967 6e6f 7265   headers, ignore
-00012a20: 2069 7420 6265 6361 7573 6520 5061 636b   it because Pack
-00012a30: 6574 206f 626a 6563 7420 646f 6573 0a20  et object does. 
-00012a40: 2020 2020 2020 2023 206e 6f74 2073 7570         # not sup
-00012a50: 706f 7274 2069 742e 2045 7874 656e 6465  port it. Extende
-00012a60: 6420 6865 6164 6572 7320 7369 7a65 2069  d headers size i
-00012a70: 7320 3820 6279 7465 7320 6265 666f 7265  s 8 bytes before
-00012a80: 2074 6865 2070 6179 6c6f 6164 2e0a 2020   the payload..  
-00012a90: 2020 2020 2020 6966 2074 7970 6520 2620        if type & 
-00012aa0: 3078 3830 3a0a 2020 2020 2020 2020 2020  0x80:.          
-00012ab0: 2020 5f20 3d20 7365 6c66 2e66 2e72 6561    _ = self.f.rea
-00012ac0: 6428 3829 0a20 2020 2020 2020 2020 2020  d(8).           
-00012ad0: 2073 203d 2073 656c 662e 662e 7265 6164   s = self.f.read
-00012ae0: 2872 6c65 6e20 2d20 3234 290a 2020 2020  (rlen - 24).    
-00012af0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00012b00: 2020 2020 2020 7320 3d20 7365 6c66 2e66        s = self.f
-00012b10: 2e72 6561 6428 726c 656e 202d 2031 3629  .read(rlen - 16)
-00012b20: 0a0a 2020 2020 2020 2020 2320 4574 6865  ..        # Ethe
-00012b30: 726e 6574 2068 6173 2032 2062 7974 6573  rnet has 2 bytes
-00012b40: 206f 6620 7061 6464 696e 6720 636f 6e74   of padding cont
-00012b50: 6169 6e69 6e67 2060 6f66 6673 6574 6020  aining `offset` 
-00012b60: 616e 6420 6070 6164 602e 2042 6f74 680a  and `pad`. Both.
-00012b70: 2020 2020 2020 2020 2320 6f66 2074 6865          # of the
-00012b80: 2066 6965 6c64 7320 6172 6520 6469 7372   fields are disr
-00012b90: 6567 6172 6465 6420 6279 2045 6e64 6163  egarded by Endac
-00012ba0: 652e 0a20 2020 2020 2020 2070 203d 2073  e..        p = s
-00012bb0: 5b32 3a73 697a 655d 0a20 2020 2020 2020  [2:size].       
-00012bc0: 2066 726f 6d20 7363 6170 792e 6c61 7965   from scapy.laye
-00012bd0: 7273 2e6c 3220 696d 706f 7274 2045 7468  rs.l2 import Eth
-00012be0: 6572 0a20 2020 2020 2020 2074 7279 3a0a  er.        try:.
-00012bf0: 2020 2020 2020 2020 2020 2020 7020 3d20              p = 
-00012c00: 4574 6865 7228 7029 0a20 2020 2020 2020  Ether(p).       
-00012c10: 2065 7863 6570 7420 4b65 7962 6f61 7264   except Keyboard
-00012c20: 496e 7465 7272 7570 743a 0a20 2020 2020  Interrupt:.     
-00012c30: 2020 2020 2020 2072 6169 7365 0a20 2020         raise.   
-00012c40: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
-00012c50: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
-00012c60: 2020 2069 6620 636f 6e66 2e64 6562 7567     if conf.debug
-00012c70: 5f64 6973 7365 6374 6f72 3a0a 2020 2020  _dissector:.    
-00012c80: 2020 2020 2020 2020 2020 2020 6672 6f6d              from
-00012c90: 2073 6361 7079 2e73 656e 6472 6563 7620   scapy.sendrecv 
-00012ca0: 696d 706f 7274 2064 6562 7567 0a20 2020  import debug.   
-00012cb0: 2020 2020 2020 2020 2020 2020 2064 6562               deb
-00012cc0: 7567 2e63 7261 7368 6564 5f6f 6e20 3d20  ug.crashed_on = 
-00012cd0: 2845 7468 6572 2c20 7329 0a20 2020 2020  (Ether, s).     
-00012ce0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00012cf0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00012d00: 636f 6e66 2e72 6177 5f6c 6179 6572 2069  conf.raw_layer i
-00012d10: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-00012d20: 2020 2020 2020 2020 2320 636f 6e66 2e72          # conf.r
-00012d30: 6177 5f6c 6179 6572 2069 7320 7365 7420  aw_layer is set 
-00012d40: 6f6e 2069 6d70 6f72 740a 2020 2020 2020  on import.      
-00012d50: 2020 2020 2020 2020 2020 696d 706f 7274            import
-00012d60: 2073 6361 7079 2e70 6163 6b65 7420 2023   scapy.packet  #
-00012d70: 206e 6f71 613a 2046 3430 310a 2020 2020   noqa: F401.    
-00012d80: 2020 2020 2020 2020 7020 3d20 636f 6e66          p = conf
-00012d90: 2e72 6177 5f6c 6179 6572 2873 290a 0a20  .raw_layer(s).. 
-00012da0: 2020 2020 2020 2070 2e74 696d 6520 3d20         p.time = 
-00012db0: 7365 6c66 2e5f 636f 6e76 6572 745f 6572  self._convert_er
-00012dc0: 665f 7469 6d65 7374 616d 7028 7469 6d65  f_timestamp(time
-00012dd0: 290a 2020 2020 2020 2020 702e 7769 7265  ).        p.wire
-00012de0: 6c65 6e20 3d20 776c 656e 0a0a 2020 2020  len = wlen..    
-00012df0: 2020 2020 7265 7475 726e 2070 0a0a 0a40      return p...@
-00012e00: 636f 6e66 2e63 6f6d 6d61 6e64 732e 7265  conf.commands.re
-00012e10: 6769 7374 6572 0a64 6566 2077 7265 7266  gister.def wrerf
-00012e20: 2866 696c 656e 616d 652c 2020 2320 7479  (filename,  # ty
-00012e30: 7065 3a20 556e 696f 6e5b 494f 5b62 7974  pe: Union[IO[byt
-00012e40: 6573 5d2c 2073 7472 5d0a 2020 2020 2020  es], str].      
-00012e50: 2020 2020 706b 742c 2020 2320 7479 7065      pkt,  # type
-00012e60: 3a20 5f50 6163 6b65 7449 7465 7261 626c  : _PacketIterabl
-00012e70: 650a 2020 2020 2020 2020 2020 2a61 7267  e.          *arg
-00012e80: 732c 2020 2320 7479 7065 3a20 416e 790a  s,  # type: Any.
-00012e90: 2020 2020 2020 2020 2020 2a2a 6b61 7267            **karg
-00012ea0: 7320 2023 2074 7970 653a 2041 6e79 0a20  s  # type: Any. 
-00012eb0: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
-00012ec0: 2320 7479 7065 3a20 282e 2e2e 2920 2d3e  # type: (...) ->
-00012ed0: 204e 6f6e 650a 2020 2020 2222 2257 7269   None.    """Wri
-00012ee0: 7465 2061 206c 6973 7420 6f66 2070 6163  te a list of pac
-00012ef0: 6b65 7473 2074 6f20 6120 4552 4620 6669  kets to a ERF fi
-00012f00: 6c65 0a0a 2020 2020 3a70 6172 616d 2066  le..    :param f
-00012f10: 696c 656e 616d 653a 2074 6865 206e 616d  ilename: the nam
-00012f20: 6520 6f66 2074 6865 2066 696c 6520 746f  e of the file to
-00012f30: 2077 7269 7465 2070 6163 6b65 7473 2074   write packets t
-00012f40: 6f2c 206f 7220 616e 206f 7065 6e2c 0a20  o, or an open,. 
-00012f50: 2020 2020 2020 2077 7269 7461 626c 6520         writable 
-00012f60: 6669 6c65 2d6c 696b 6520 6f62 6a65 6374  file-like object
-00012f70: 2e20 5468 6520 6669 6c65 2064 6573 6372  . The file descr
-00012f80: 6970 746f 7220 7769 6c6c 2062 650a 2020  iptor will be.  
-00012f90: 2020 2020 2020 636c 6f73 6564 2061 7420        closed at 
-00012fa0: 7468 6520 656e 6420 6f66 2074 6865 2063  the end of the c
-00012fb0: 616c 6c2c 2073 6f20 646f 206e 6f74 2075  all, so do not u
-00012fc0: 7365 2061 6e20 6f62 6a65 6374 2079 6f75  se an object you
-00012fd0: 0a20 2020 2020 2020 2064 6f20 6e6f 7420  .        do not 
-00012fe0: 7761 6e74 2074 6f20 636c 6f73 6520 2865  want to close (e
-00012ff0: 2e67 2e2c 2072 756e 6e69 6e67 2077 7265  .g., running wre
-00013000: 7266 2873 7973 2e73 7464 6f75 742c 205b  rf(sys.stdout, [
-00013010: 5d29 0a20 2020 2020 2020 2069 6e20 696e  ]).        in in
-00013020: 7465 7261 6374 6976 6520 6d6f 6465 2077  teractive mode w
-00013030: 696c 6c20 6372 6173 6820 5363 6170 7929  ill crash Scapy)
-00013040: 2e0a 2020 2020 3a70 6172 616d 2067 7a3a  ..    :param gz:
-00013050: 2073 6574 2074 6f20 3120 746f 2073 6176   set to 1 to sav
-00013060: 6520 6120 677a 6970 7065 6420 6361 7074  e a gzipped capt
-00013070: 7572 650a 2020 2020 3a70 6172 616d 2061  ure.    :param a
-00013080: 7070 656e 643a 2061 7070 656e 6420 7061  ppend: append pa
-00013090: 636b 6574 7320 746f 2074 6865 2063 6170  ckets to the cap
-000130a0: 7475 7265 2066 696c 6520 696e 7374 6561  ture file instea
-000130b0: 6420 6f66 0a20 2020 2020 2020 2074 7275  d of.        tru
-000130c0: 6e63 6174 696e 6720 6974 0a20 2020 203a  ncating it.    :
-000130d0: 7061 7261 6d20 7379 6e63 3a20 646f 206e  param sync: do n
-000130e0: 6f74 2062 7566 6665 7269 7a65 2077 7269  ot bufferize wri
-000130f0: 7465 7320 746f 2074 6865 2063 6170 7475  tes to the captu
-00013100: 7265 2066 696c 650a 2020 2020 2222 220a  re file.    """.
-00013110: 2020 2020 7769 7468 2045 5246 4574 6865      with ERFEthe
-00013120: 726e 6574 5772 6974 6572 2866 696c 656e  rnetWriter(filen
-00013130: 616d 652c 202a 6172 6773 2c20 2a2a 6b61  ame, *args, **ka
-00013140: 7267 7329 2061 7320 6664 6573 633a 0a20  rgs) as fdesc:. 
-00013150: 2020 2020 2020 2066 6465 7363 2e77 7269         fdesc.wri
-00013160: 7465 2870 6b74 290a 0a0a 636c 6173 7320  te(pkt)...class 
-00013170: 4552 4645 7468 6572 6e65 7457 7269 7465  ERFEthernetWrite
-00013180: 7228 5063 6170 5772 6974 6572 293a 0a20  r(PcapWriter):. 
-00013190: 2020 2022 2222 4120 7374 7265 616d 2045     """A stream E
-000131a0: 5246 2045 7468 6572 6e65 7420 7772 6974  RF Ethernet writ
-000131b0: 6572 2077 6974 6820 6d6f 7265 2063 6f6e  er with more con
-000131c0: 7472 6f6c 2074 6861 6e20 7772 6572 6628  trol than wrerf(
-000131d0: 2922 2222 0a0a 2020 2020 6465 6620 5f5f  )"""..    def __
-000131e0: 696e 6974 5f5f 2873 656c 662c 0a20 2020  init__(self,.   
-000131f0: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-00013200: 6c65 6e61 6d65 2c20 2023 2074 7970 653a  lename,  # type:
-00013210: 2055 6e69 6f6e 5b49 4f5b 6279 7465 735d   Union[IO[bytes]
-00013220: 2c20 7374 725d 0a20 2020 2020 2020 2020  , str].         
-00013230: 2020 2020 2020 2020 677a 3d46 616c 7365          gz=False
-00013240: 2c20 2023 2074 7970 653a 2062 6f6f 6c0a  ,  # type: bool.
-00013250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013260: 2061 7070 656e 643d 4661 6c73 652c 2020   append=False,  
-00013270: 2320 7479 7065 3a20 626f 6f6c 0a20 2020  # type: bool.   
-00013280: 2020 2020 2020 2020 2020 2020 2020 7379                sy
-00013290: 6e63 3d46 616c 7365 2c20 2023 2074 7970  nc=False,  # typ
-000132a0: 653a 2062 6f6f 6c0a 2020 2020 2020 2020  e: bool.        
-000132b0: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
-000132c0: 2020 2020 2320 7479 7065 3a20 282e 2e2e      # type: (...
-000132d0: 2920 2d3e 204e 6f6e 650a 2020 2020 2020  ) -> None.      
-000132e0: 2020 2222 220a 2020 2020 2020 2020 3a70    """.        :p
-000132f0: 6172 616d 2066 696c 656e 616d 653a 2074  aram filename: t
-00013300: 6865 206e 616d 6520 6f66 2074 6865 2066  he name of the f
-00013310: 696c 6520 746f 2077 7269 7465 2070 6163  ile to write pac
-00013320: 6b65 7473 2074 6f2c 206f 7220 616e 206f  kets to, or an o
-00013330: 7065 6e2c 0a20 2020 2020 2020 2020 2020  pen,.           
-00013340: 2077 7269 7461 626c 6520 6669 6c65 2d6c   writable file-l
-00013350: 696b 6520 6f62 6a65 6374 2e0a 2020 2020  ike object..    
-00013360: 2020 2020 3a70 6172 616d 2067 7a3a 2063      :param gz: c
-00013370: 6f6d 7072 6573 7320 7468 6520 6361 7074  ompress the capt
-00013380: 7572 6520 6f6e 2074 6865 2066 6c79 0a20  ure on the fly. 
-00013390: 2020 2020 2020 203a 7061 7261 6d20 6170         :param ap
-000133a0: 7065 6e64 3a20 6170 7065 6e64 2070 6163  pend: append pac
-000133b0: 6b65 7473 2074 6f20 7468 6520 6361 7074  kets to the capt
-000133c0: 7572 6520 6669 6c65 2069 6e73 7465 6164  ure file instead
-000133d0: 206f 660a 2020 2020 2020 2020 2020 2020   of.            
-000133e0: 7472 756e 6361 7469 6e67 2069 740a 2020  truncating it.  
-000133f0: 2020 2020 2020 3a70 6172 616d 2073 796e        :param syn
-00013400: 633a 2064 6f20 6e6f 7420 6275 6666 6572  c: do not buffer
-00013410: 697a 6520 7772 6974 6573 2074 6f20 7468  ize writes to th
-00013420: 6520 6361 7074 7572 6520 6669 6c65 0a20  e capture file. 
-00013430: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00013440: 2020 2073 7570 6572 2845 5246 4574 6865     super(ERFEthe
-00013450: 726e 6574 5772 6974 6572 2c20 7365 6c66  rnetWriter, self
-00013460: 292e 5f5f 696e 6974 5f5f 2866 696c 656e  ).__init__(filen
-00013470: 616d 652c 0a20 2020 2020 2020 2020 2020  ame,.           
-00013480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000134a0: 2020 2020 2067 7a3d 677a 2c0a 2020 2020       gz=gz,.    
-000134b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000134c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000134d0: 2020 2020 2020 2020 2020 2020 6170 7065              appe
-000134e0: 6e64 3d61 7070 656e 642c 0a20 2020 2020  nd=append,.     
-000134f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013510: 2020 2020 2020 2020 2020 2073 796e 633d             sync=
-00013520: 7379 6e63 290a 0a20 2020 2064 6566 2077  sync)..    def w
-00013530: 7269 7465 2873 656c 662c 2070 6b74 293a  rite(self, pkt):
-00013540: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00013550: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
-00013560: 2028 5f50 6163 6b65 7449 7465 7261 626c   (_PacketIterabl
-00013570: 6529 202d 3e20 4e6f 6e65 0a20 2020 2020  e) -> None.     
-00013580: 2020 2022 2222 0a20 2020 2020 2020 2057     """.        W
-00013590: 7269 7465 7320 6120 5061 636b 6574 2c20  rites a Packet, 
-000135a0: 6120 536e 6452 6376 4c69 7374 206f 626a  a SndRcvList obj
-000135b0: 6563 742c 206f 7220 6279 7465 7320 746f  ect, or bytes to
-000135c0: 2061 2045 5246 2066 696c 652e 0a0a 2020   a ERF file...  
-000135d0: 2020 2020 2020 3a70 6172 616d 2070 6b74        :param pkt
-000135e0: 3a20 5061 636b 6574 2873 2920 746f 2077  : Packet(s) to w
-000135f0: 7269 7465 2028 6f6e 6520 7265 636f 7264  rite (one record
-00013600: 2066 6f72 2065 6163 6820 5061 636b 6574   for each Packet
-00013610: 290a 2020 2020 2020 2020 3a74 7970 6520  ).        :type 
-00013620: 706b 743a 2069 7465 7261 626c 655b 7363  pkt: iterable[sc
-00013630: 6170 792e 7061 636b 6574 2e50 6163 6b65  apy.packet.Packe
-00013640: 745d 2c20 7363 6170 792e 7061 636b 6574  t], scapy.packet
-00013650: 2e50 6163 6b65 740a 2020 2020 2020 2020  .Packet.        
-00013660: 2222 220a 2020 2020 2020 2020 2320 496d  """.        # Im
-00013670: 706f 7274 2068 6572 6520 746f 2061 766f  port here to avo
-00013680: 6964 2063 6972 6375 6c61 7220 6465 7065  id circular depe
-00013690: 6e64 656e 6379 0a20 2020 2020 2020 2066  ndency.        f
-000136a0: 726f 6d20 7363 6170 792e 7375 7065 7273  rom scapy.supers
-000136b0: 6f63 6b65 7420 696d 706f 7274 2049 7465  ocket import Ite
-000136c0: 7253 6f63 6b65 740a 2020 2020 2020 2020  rSocket.        
-000136d0: 666f 7220 7020 696e 2049 7465 7253 6f63  for p in IterSoc
-000136e0: 6b65 7428 706b 7429 2e69 7465 723a 0a20  ket(pkt).iter:. 
-000136f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00013700: 7772 6974 655f 7061 636b 6574 2870 290a  write_packet(p).
-00013710: 0a20 2020 2064 6566 2077 7269 7465 5f70  .    def write_p
-00013720: 6163 6b65 7428 7365 6c66 2c20 706b 7429  acket(self, pkt)
-00013730: 3a20 2023 2074 7970 653a 2069 676e 6f72  :  # type: ignor
-00013740: 650a 2020 2020 2020 2020 2320 7479 7065  e.        # type
-00013750: 3a20 2850 6163 6b65 7429 202d 3e20 4e6f  : (Packet) -> No
-00013760: 6e65 0a0a 2020 2020 2020 2020 6966 2068  ne..        if h
-00013770: 6173 6174 7472 2870 6b74 2c20 2274 696d  asattr(pkt, "tim
-00013780: 6522 293a 0a20 2020 2020 2020 2020 2020  e"):.           
-00013790: 2073 6563 203d 2069 6e74 2870 6b74 2e74   sec = int(pkt.t
-000137a0: 696d 6529 0a20 2020 2020 2020 2020 2020  ime).           
-000137b0: 2075 7365 6320 3d20 696e 7428 2869 6e74   usec = int((int
-000137c0: 2872 6f75 6e64 2828 706b 742e 7469 6d65  (round((pkt.time
-000137d0: 202d 2073 6563 2920 2a20 3130 2a2a 3929   - sec) * 10**9)
-000137e0: 2920 3c3c 2033 3229 202f 2031 302a 2a39  ) << 32) / 10**9
-000137f0: 290a 2020 2020 2020 2020 2020 2020 7420  ).            t 
-00013800: 3d20 2873 6563 203c 3c20 3332 2920 2b20  = (sec << 32) + 
-00013810: 7573 6563 0a20 2020 2020 2020 2065 6c73  usec.        els
-00013820: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
-00013830: 203d 2069 6e74 2874 696d 652e 7469 6d65   = int(time.time
-00013840: 2829 2920 3c3c 2033 320a 0a20 2020 2020  ()) << 32..     
-00013850: 2020 2023 2054 6865 7265 2061 7265 2031     # There are 1
-00013860: 3620 6279 7465 7320 6f66 2068 6561 6465  6 bytes of heade
-00013870: 7273 202b 2032 2062 7974 6573 206f 6620  rs + 2 bytes of 
-00013880: 7061 6464 696e 6720 6265 666f 7265 2074  padding before t
-00013890: 6865 2070 6163 6b65 7473 0a20 2020 2020  he packets.     
-000138a0: 2020 2023 2070 6179 6c6f 6164 2e0a 2020     # payload..  
-000138b0: 2020 2020 2020 726c 656e 203d 206c 656e        rlen = len
-000138c0: 2870 6b74 2920 2b20 3138 0a0a 2020 2020  (pkt) + 18..    
-000138d0: 2020 2020 6966 2068 6173 6174 7472 2870      if hasattr(p
-000138e0: 6b74 2c20 2277 6972 656c 656e 2229 3a0a  kt, "wirelen"):.
-000138f0: 2020 2020 2020 2020 2020 2020 7769 7265              wire
-00013900: 6c65 6e20 3d20 706b 742e 7769 7265 6c65  len = pkt.wirele
-00013910: 6e0a 2020 2020 2020 2020 6966 2077 6972  n.        if wir
-00013920: 656c 656e 2069 7320 4e6f 6e65 3a0a 2020  elen is None:.  
-00013930: 2020 2020 2020 2020 2020 7769 7265 6c65            wirele
-00013940: 6e20 3d20 726c 656e 0a0a 2020 2020 2020  n = rlen..      
-00013950: 2020 7365 6c66 2e66 2e77 7269 7465 2873    self.f.write(s
-00013960: 7472 7563 742e 7061 636b 2822 3c51 222c  truct.pack("<Q",
-00013970: 2074 2929 0a20 2020 2020 2020 2073 656c   t)).        sel
-00013980: 662e 662e 7772 6974 6528 7374 7275 6374  f.f.write(struct
-00013990: 2e70 6163 6b28 223e 4242 4848 4848 222c  .pack(">BBHHHH",
-000139a0: 2032 2c20 302c 2072 6c65 6e2c 2030 2c20   2, 0, rlen, 0, 
-000139b0: 7769 7265 6c65 6e2c 2030 2929 0a20 2020  wirelen, 0)).   
-000139c0: 2020 2020 2073 656c 662e 662e 7772 6974       self.f.writ
-000139d0: 6528 6279 7465 7328 706b 7429 290a 2020  e(bytes(pkt)).  
-000139e0: 2020 2020 2020 7365 6c66 2e66 2e66 6c75        self.f.flu
-000139f0: 7368 2829 0a0a 2020 2020 6465 6620 636c  sh()..    def cl
-00013a00: 6f73 6528 7365 6c66 293a 0a20 2020 2020  ose(self):.     
-00013a10: 2020 2023 2074 7970 653a 2028 2920 2d3e     # type: () ->
-00013a20: 204f 7074 696f 6e61 6c5b 416e 795d 0a20   Optional[Any]. 
-00013a30: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00013a40: 6c66 2e66 2e63 6c6f 7365 2829 0a0a 0a40  lf.f.close()...@
-00013a50: 636f 6e66 2e63 6f6d 6d61 6e64 732e 7265  conf.commands.re
-00013a60: 6769 7374 6572 0a64 6566 2069 6d70 6f72  gister.def impor
-00013a70: 745f 6865 7863 6170 2869 6e70 7574 5f73  t_hexcap(input_s
-00013a80: 7472 696e 673d 4e6f 6e65 293a 0a20 2020  tring=None):.   
-00013a90: 2023 2074 7970 653a 2028 4f70 7469 6f6e   # type: (Option
-00013aa0: 616c 5b73 7472 5d29 202d 3e20 6279 7465  al[str]) -> byte
-00013ab0: 730a 2020 2020 2222 2249 6d70 6f72 7473  s.    """Imports
-00013ac0: 2061 2074 6370 6475 6d70 206c 696b 6520   a tcpdump like 
-00013ad0: 6865 7861 6465 6369 6d61 6c20 7669 6577  hexadecimal view
-00013ae0: 0a0a 2020 2020 652e 673a 2065 7870 6f72  ..    e.g: expor
-00013af0: 7465 6420 7669 6120 6865 7864 756d 7028  ted via hexdump(
-00013b00: 2920 6f72 2074 6370 6475 6d70 206f 7220  ) or tcpdump or 
-00013b10: 7769 7265 7368 6172 6b27 7320 2265 7870  wireshark's "exp
-00013b20: 6f72 7420 6173 2068 6578 220a 0a20 2020  ort as hex"..   
-00013b30: 203a 7061 7261 6d20 696e 7075 745f 7374   :param input_st
-00013b40: 7269 6e67 3a20 5374 7269 6e67 2063 6f6e  ring: String con
-00013b50: 7461 696e 696e 6720 7468 6520 6865 7864  taining the hexd
-00013b60: 756d 7020 696e 7075 7420 746f 2070 6172  ump input to par
-00013b70: 7365 2e20 4966 204e 6f6e 652c 0a20 2020  se. If None,.   
-00013b80: 2020 2020 2072 6561 6420 6672 6f6d 2073       read from s
-00013b90: 7461 6e64 6172 6420 696e 7075 742e 0a20  tandard input.. 
-00013ba0: 2020 2022 2222 0a20 2020 2072 655f 6578     """.    re_ex
-00013bb0: 7472 6163 745f 6865 7863 6170 203d 2072  tract_hexcap = r
-00013bc0: 652e 636f 6d70 696c 6528 7222 5e28 2830  e.compile(r"^((0
-00013bd0: 7829 3f5b 302d 3961 2d66 412d 465d 7b32  x)?[0-9a-fA-F]{2
-00013be0: 2c7d 5b20 3a5c 745d 7b2c 337d 7c29 202a  ,}[ :\t]{,3}|) *
-00013bf0: 2828 5b30 2d39 612d 6641 2d46 5d7b 327d  (([0-9a-fA-F]{2}
-00013c00: 207b 2c32 7d29 7b2c 3136 7d29 2229 2020   {,2}){,16})")  
-00013c10: 2320 6e6f 7161 3a20 4535 3031 0a20 2020  # noqa: E501.   
-00013c20: 2070 203d 2022 220a 2020 2020 7472 793a   p = "".    try:
-00013c30: 0a20 2020 2020 2020 2069 6620 696e 7075  .        if inpu
-00013c40: 745f 7374 7269 6e67 3a0a 2020 2020 2020  t_string:.      
-00013c50: 2020 2020 2020 696e 7075 745f 6675 6e63        input_func
-00013c60: 7469 6f6e 203d 2073 6978 2e53 7472 696e  tion = six.Strin
-00013c70: 6749 4f28 696e 7075 745f 7374 7269 6e67  gIO(input_string
-00013c80: 292e 7265 6164 6c69 6e65 0a20 2020 2020  ).readline.     
-00013c90: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00013ca0: 2020 2020 2069 6e70 7574 5f66 756e 6374       input_funct
-00013cb0: 696f 6e20 3d20 696e 7075 740a 2020 2020  ion = input.    
-00013cc0: 2020 2020 7768 696c 6520 5472 7565 3a0a      while True:.
-00013cd0: 2020 2020 2020 2020 2020 2020 6c69 6e65              line
-00013ce0: 203d 2069 6e70 7574 5f66 756e 6374 696f   = input_functio
-00013cf0: 6e28 292e 7374 7269 7028 290a 2020 2020  n().strip().    
-00013d00: 2020 2020 2020 2020 6966 206e 6f74 206c          if not l
-00013d10: 696e 653a 0a20 2020 2020 2020 2020 2020  ine:.           
-00013d20: 2020 2020 2062 7265 616b 0a20 2020 2020       break.     
-00013d30: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-00013d40: 2020 2020 2020 2020 2020 2020 7020 2b3d              p +=
-00013d50: 2072 655f 6578 7472 6163 745f 6865 7863   re_extract_hexc
-00013d60: 6170 2e6d 6174 6368 286c 696e 6529 2e67  ap.match(line).g
-00013d70: 726f 7570 7328 295b 325d 2020 2320 7479  roups()[2]  # ty
-00013d80: 7065 3a20 6967 6e6f 7265 0a20 2020 2020  pe: ignore.     
-00013d90: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
-00013da0: 6365 7074 696f 6e3a 0a20 2020 2020 2020  ception:.       
-00013db0: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
-00013dc0: 2822 5061 7273 696e 6720 6572 726f 7220  ("Parsing error 
-00013dd0: 6475 7269 6e67 2068 6578 6361 7022 290a  during hexcap").
-00013de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013df0: 636f 6e74 696e 7565 0a20 2020 2065 7863  continue.    exc
-00013e00: 6570 7420 454f 4645 7272 6f72 3a0a 2020  ept EOFError:.  
-00013e10: 2020 2020 2020 7061 7373 0a0a 2020 2020        pass..    
-00013e20: 7020 3d20 702e 7265 706c 6163 6528 2220  p = p.replace(" 
-00013e30: 222c 2022 2229 0a20 2020 2072 6574 7572  ", "").    retur
-00013e40: 6e20 6865 785f 6279 7465 7328 7029 0a0a  n hex_bytes(p)..
-00013e50: 0a40 636f 6e66 2e63 6f6d 6d61 6e64 732e  .@conf.commands.
-00013e60: 7265 6769 7374 6572 0a64 6566 2077 6972  register.def wir
-00013e70: 6573 6861 726b 2870 6b74 6c69 7374 2c20  eshark(pktlist, 
-00013e80: 7761 6974 3d46 616c 7365 2c20 2a2a 6b77  wait=False, **kw
-00013e90: 6172 6773 293a 0a20 2020 2023 2074 7970  args):.    # typ
-00013ea0: 653a 2028 4c69 7374 5b50 6163 6b65 745d  e: (List[Packet]
-00013eb0: 2c20 626f 6f6c 2c20 2a2a 416e 7929 202d  , bool, **Any) -
-00013ec0: 3e20 4f70 7469 6f6e 616c 5b41 6e79 5d0a  > Optional[Any].
-00013ed0: 2020 2020 2222 220a 2020 2020 5275 6e73      """.    Runs
-00013ee0: 2057 6972 6573 6861 726b 206f 6e20 6120   Wireshark on a 
-00013ef0: 6c69 7374 206f 6620 7061 636b 6574 732e  list of packets.
-00013f00: 0a0a 2020 2020 5365 6520 3a66 756e 633a  ..    See :func:
-00013f10: 6074 6370 6475 6d70 6020 666f 7220 6d6f  `tcpdump` for mo
-00013f20: 7265 2070 6172 616d 6574 6572 2064 6573  re parameter des
-00013f30: 6372 6970 7469 6f6e 2e0a 0a20 2020 204e  cription...    N
-00013f40: 6f74 653a 2074 6869 7320 6465 6661 756c  ote: this defaul
-00013f50: 7473 2074 6f20 7761 6974 3d46 616c 7365  ts to wait=False
-00013f60: 2c20 746f 2072 756e 2057 6972 6573 6861  , to run Wiresha
-00013f70: 726b 2069 6e20 7468 6520 6261 636b 6772  rk in the backgr
-00013f80: 6f75 6e64 2e0a 2020 2020 2222 220a 2020  ound..    """.  
-00013f90: 2020 7265 7475 726e 2074 6370 6475 6d70    return tcpdump
-00013fa0: 2870 6b74 6c69 7374 2c20 7072 6f67 3d63  (pktlist, prog=c
-00013fb0: 6f6e 662e 7072 6f67 2e77 6972 6573 6861  onf.prog.wiresha
-00013fc0: 726b 2c20 7761 6974 3d77 6169 742c 202a  rk, wait=wait, *
-00013fd0: 2a6b 7761 7267 7329 0a0a 0a40 636f 6e66  *kwargs)...@conf
-00013fe0: 2e63 6f6d 6d61 6e64 732e 7265 6769 7374  .commands.regist
-00013ff0: 6572 0a64 6566 2074 6465 636f 6465 280a  er.def tdecode(.
-00014000: 2020 2020 706b 746c 6973 742c 2020 2320      pktlist,  # 
-00014010: 7479 7065 3a20 556e 696f 6e5b 494f 5b62  type: Union[IO[b
-00014020: 7974 6573 5d2c 204e 6f6e 652c 2073 7472  ytes], None, str
-00014030: 2c20 5f50 6163 6b65 7449 7465 7261 626c  , _PacketIterabl
-00014040: 655d 0a20 2020 2061 7267 733d 4e6f 6e65  e].    args=None
-00014050: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-00014060: 6e61 6c5b 4c69 7374 5b73 7472 5d5d 0a20  nal[List[str]]. 
-00014070: 2020 202a 2a6b 7761 7267 7320 2023 2074     **kwargs  # t
-00014080: 7970 653a 2041 6e79 0a29 3a0a 2020 2020  ype: Any.):.    
-00014090: 2320 7479 7065 3a20 282e 2e2e 2920 2d3e  # type: (...) ->
-000140a0: 2041 6e79 0a20 2020 2022 2222 0a20 2020   Any.    """.   
-000140b0: 2052 756e 2074 7368 6172 6b20 6f6e 2061   Run tshark on a
-000140c0: 206c 6973 7420 6f66 2070 6163 6b65 7473   list of packets
-000140d0: 2e0a 0a20 2020 203a 7061 7261 6d20 6172  ...    :param ar
-000140e0: 6773 3a20 4966 206e 6f74 2073 7065 6369  gs: If not speci
-000140f0: 6669 6564 2c20 6465 6661 756c 7473 2074  fied, defaults t
-00014100: 6f20 6060 7473 6861 726b 202d 5660 602e  o ``tshark -V``.
-00014110: 0a0a 2020 2020 5365 6520 3a66 756e 633a  ..    See :func:
-00014120: 6074 6370 6475 6d70 6020 666f 7220 6d6f  `tcpdump` for mo
-00014130: 7265 2070 6172 616d 6574 6572 732e 0a20  re parameters.. 
-00014140: 2020 2022 2222 0a20 2020 2069 6620 6172     """.    if ar
-00014150: 6773 2069 7320 4e6f 6e65 3a0a 2020 2020  gs is None:.    
-00014160: 2020 2020 6172 6773 203d 205b 222d 5622      args = ["-V"
-00014170: 5d0a 2020 2020 7265 7475 726e 2074 6370  ].    return tcp
-00014180: 6475 6d70 2870 6b74 6c69 7374 2c20 7072  dump(pktlist, pr
-00014190: 6f67 3d63 6f6e 662e 7072 6f67 2e74 7368  og=conf.prog.tsh
-000141a0: 6172 6b2c 2061 7267 733d 6172 6773 2c20  ark, args=args, 
-000141b0: 2a2a 6b77 6172 6773 290a 0a0a 6465 6620  **kwargs)...def 
-000141c0: 5f67 7565 7373 5f6c 696e 6b74 7970 655f  _guess_linktype_
-000141d0: 6e61 6d65 2876 616c 7565 293a 0a20 2020  name(value):.   
-000141e0: 2023 2074 7970 653a 2028 696e 7429 202d   # type: (int) -
-000141f0: 3e20 7374 720a 2020 2020 2222 2247 7565  > str.    """Gue
-00014200: 7373 2074 6865 2044 4c54 206e 616d 6520  ss the DLT name 
-00014210: 6672 6f6d 2069 7473 2076 616c 7565 2e22  from its value."
-00014220: 2222 0a20 2020 2066 726f 6d20 7363 6170  "".    from scap
-00014230: 792e 6c69 6273 2e77 696e 7063 6170 7920  y.libs.winpcapy 
-00014240: 696d 706f 7274 2070 6361 705f 6461 7461  import pcap_data
-00014250: 6c69 6e6b 5f76 616c 5f74 6f5f 6e61 6d65  link_val_to_name
-00014260: 0a20 2020 2072 6574 7572 6e20 6361 7374  .    return cast
-00014270: 2862 7974 6573 2c20 7063 6170 5f64 6174  (bytes, pcap_dat
-00014280: 616c 696e 6b5f 7661 6c5f 746f 5f6e 616d  alink_val_to_nam
-00014290: 6528 7661 6c75 6529 292e 6465 636f 6465  e(value)).decode
-000142a0: 2829 0a0a 0a64 6566 205f 6775 6573 735f  ()...def _guess_
-000142b0: 6c69 6e6b 7479 7065 5f76 616c 7565 286e  linktype_value(n
-000142c0: 616d 6529 3a0a 2020 2020 2320 7479 7065  ame):.    # type
-000142d0: 3a20 2873 7472 2920 2d3e 2069 6e74 0a20  : (str) -> int. 
-000142e0: 2020 2022 2222 4775 6573 7320 7468 6520     """Guess the 
-000142f0: 7661 6c75 6520 6f66 2061 2044 4c54 206e  value of a DLT n
-00014300: 616d 652e 2222 220a 2020 2020 6672 6f6d  ame.""".    from
-00014310: 2073 6361 7079 2e6c 6962 732e 7769 6e70   scapy.libs.winp
-00014320: 6361 7079 2069 6d70 6f72 7420 7063 6170  capy import pcap
-00014330: 5f64 6174 616c 696e 6b5f 6e61 6d65 5f74  _datalink_name_t
-00014340: 6f5f 7661 6c0a 2020 2020 7661 6c20 3d20  o_val.    val = 
-00014350: 6361 7374 2869 6e74 2c20 7063 6170 5f64  cast(int, pcap_d
-00014360: 6174 616c 696e 6b5f 6e61 6d65 5f74 6f5f  atalink_name_to_
-00014370: 7661 6c28 6e61 6d65 2e65 6e63 6f64 6528  val(name.encode(
-00014380: 2929 290a 2020 2020 6966 2076 616c 203d  ))).    if val =
-00014390: 3d20 2d31 3a0a 2020 2020 2020 2020 7761  = -1:.        wa
-000143a0: 726e 696e 6728 2255 6e6b 6e6f 776e 206c  rning("Unknown l
-000143b0: 696e 6b74 7970 653a 2025 732e 2055 7369  inktype: %s. Usi
-000143c0: 6e67 2045 4e31 304d 4222 2c20 6e61 6d65  ng EN10MB", name
-000143d0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-000143e0: 2044 4c54 5f45 4e31 304d 420a 2020 2020   DLT_EN10MB.    
-000143f0: 7265 7475 726e 2076 616c 0a0a 0a40 636f  return val...@co
-00014400: 6e66 2e63 6f6d 6d61 6e64 732e 7265 6769  nf.commands.regi
-00014410: 7374 6572 0a64 6566 2074 6370 6475 6d70  ster.def tcpdump
-00014420: 280a 2020 2020 706b 746c 6973 743d 4e6f  (.    pktlist=No
-00014430: 6e65 2c20 2023 2074 7970 653a 2055 6e69  ne,  # type: Uni
-00014440: 6f6e 5b49 4f5b 6279 7465 735d 2c20 4e6f  on[IO[bytes], No
-00014450: 6e65 2c20 7374 722c 205f 5061 636b 6574  ne, str, _Packet
-00014460: 4974 6572 6162 6c65 5d0a 2020 2020 6475  Iterable].    du
-00014470: 6d70 3d46 616c 7365 2c20 2023 2074 7970  mp=False,  # typ
-00014480: 653a 2062 6f6f 6c0a 2020 2020 6765 7466  e: bool.    getf
-00014490: 643d 4661 6c73 652c 2020 2320 7479 7065  d=False,  # type
-000144a0: 3a20 626f 6f6c 0a20 2020 2061 7267 733d  : bool.    args=
-000144b0: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
-000144c0: 7074 696f 6e61 6c5b 4c69 7374 5b73 7472  ptional[List[str
-000144d0: 5d5d 0a20 2020 2066 6c74 3d4e 6f6e 652c  ]].    flt=None,
-000144e0: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
-000144f0: 616c 5b73 7472 5d0a 2020 2020 7072 6f67  al[str].    prog
-00014500: 3d4e 6f6e 652c 2020 2320 7479 7065 3a20  =None,  # type: 
-00014510: 4f70 7469 6f6e 616c 5b41 6e79 5d0a 2020  Optional[Any].  
-00014520: 2020 6765 7470 726f 633d 4661 6c73 652c    getproc=False,
-00014530: 2020 2320 7479 7065 3a20 626f 6f6c 0a20    # type: bool. 
-00014540: 2020 2071 7569 6574 3d46 616c 7365 2c20     quiet=False, 
-00014550: 2023 2074 7970 653a 2062 6f6f 6c0a 2020   # type: bool.  
-00014560: 2020 7573 655f 7465 6d70 6669 6c65 3d4e    use_tempfile=N
-00014570: 6f6e 652c 2020 2320 7479 7065 3a20 4f70  one,  # type: Op
-00014580: 7469 6f6e 616c 5b41 6e79 5d0a 2020 2020  tional[Any].    
-00014590: 7265 6164 5f73 7464 696e 5f6f 7074 733d  read_stdin_opts=
-000145a0: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
-000145b0: 7074 696f 6e61 6c5b 416e 795d 0a20 2020  ptional[Any].   
-000145c0: 206c 696e 6b74 7970 653d 4e6f 6e65 2c20   linktype=None, 
-000145d0: 2023 2074 7970 653a 204f 7074 696f 6e61   # type: Optiona
-000145e0: 6c5b 416e 795d 0a20 2020 2077 6169 743d  l[Any].    wait=
-000145f0: 5472 7565 2c20 2023 2074 7970 653a 2062  True,  # type: b
-00014600: 6f6f 6c0a 2020 2020 5f73 7570 7072 6573  ool.    _suppres
-00014610: 733d 4661 6c73 6520 2023 2074 7970 653a  s=False  # type:
-00014620: 2062 6f6f 6c0a 293a 0a20 2020 2023 2074   bool.):.    # t
-00014630: 7970 653a 2028 2e2e 2e29 202d 3e20 416e  ype: (...) -> An
-00014640: 790a 2020 2020 2222 2252 756e 2074 6370  y.    """Run tcp
-00014650: 6475 6d70 206f 7220 7473 6861 726b 206f  dump or tshark o
-00014660: 6e20 6120 6c69 7374 206f 6620 7061 636b  n a list of pack
-00014670: 6574 732e 0a0a 2020 2020 5768 656e 2075  ets...    When u
-00014680: 7369 6e67 2060 6074 6370 6475 6d70 6060  sing ``tcpdump``
-00014690: 206f 6e20 4f53 5820 2860 6070 726f 6720   on OSX (``prog 
-000146a0: 3d3d 2063 6f6e 662e 7072 6f67 2e74 6370  == conf.prog.tcp
-000146b0: 6475 6d70 6060 292c 2074 6869 7320 7573  dump``), this us
-000146c0: 6573 2061 0a20 2020 2074 656d 706f 7261  es a.    tempora
-000146d0: 7279 2066 696c 6520 746f 2073 746f 7265  ry file to store
-000146e0: 2074 6865 2070 6163 6b65 7473 2e20 5468   the packets. Th
-000146f0: 6973 2077 6f72 6b73 2061 726f 756e 6420  is works around 
-00014700: 6120 6275 6720 696e 2041 7070 6c65 2773  a bug in Apple's
-00014710: 0a20 2020 2076 6572 7369 6f6e 206f 6620  .    version of 
-00014720: 6060 7463 7064 756d 7060 603a 2068 7474  ``tcpdump``: htt
-00014730: 703a 2f2f 6170 706c 652e 7374 6163 6b65  p://apple.stacke
-00014740: 7863 6861 6e67 652e 636f 6d2f 7175 6573  xchange.com/ques
-00014750: 7469 6f6e 732f 3135 3236 3832 2f0a 0a20  tions/152682/.. 
-00014760: 2020 204f 7468 6572 7769 7365 2c20 7468     Otherwise, th
-00014770: 6520 7061 636b 6574 7320 6172 6520 7061  e packets are pa
-00014780: 7373 6564 2069 6e20 7374 6469 6e2e 0a0a  ssed in stdin...
-00014790: 2020 2020 5468 6973 2066 756e 6374 696f      This functio
-000147a0: 6e20 6361 6e20 6265 2065 7870 6c69 6369  n can be explici
-000147b0: 746c 7920 656e 6162 6c65 6420 6f72 2064  tly enabled or d
-000147c0: 6973 6162 6c65 6420 7769 7468 2074 6865  isabled with the
-000147d0: 0a20 2020 2060 6075 7365 5f74 656d 7066  .    ``use_tempf
-000147e0: 696c 6560 6020 7061 7261 6d65 7465 722e  ile`` parameter.
-000147f0: 0a0a 2020 2020 5768 656e 2075 7369 6e67  ..    When using
-00014800: 2060 6077 6972 6573 6861 726b 6060 2c20   ``wireshark``, 
-00014810: 6974 2077 696c 6c20 6265 2063 616c 6c65  it will be calle
-00014820: 6420 7769 7468 2060 602d 6b69 202d 6060  d with ``-ki -``
-00014830: 2074 6f20 7374 6172 740a 2020 2020 696d   to start.    im
-00014840: 6d65 6469 6174 656c 7920 6361 7074 7572  mediately captur
-00014850: 696e 6720 7061 636b 6574 7320 6672 6f6d  ing packets from
-00014860: 2073 7464 696e 2e0a 0a20 2020 204f 7468   stdin...    Oth
-00014870: 6572 7769 7365 2c20 7468 6520 636f 6d6d  erwise, the comm
-00014880: 616e 6420 7769 6c6c 2062 6520 7275 6e20  and will be run 
-00014890: 7769 7468 2060 602d 7220 2d60 6020 2877  with ``-r -`` (w
-000148a0: 6869 6368 2069 7320 636f 7272 6563 7420  hich is correct 
-000148b0: 666f 720a 2020 2020 6060 7463 7064 756d  for.    ``tcpdum
-000148c0: 7060 6020 616e 6420 6060 7473 6861 726b  p`` and ``tshark
-000148d0: 6060 292e 0a0a 2020 2020 5468 6973 2063  ``)...    This c
-000148e0: 616e 2062 6520 6f76 6572 7269 6464 656e  an be overridden
-000148f0: 2077 6974 6820 6060 7265 6164 5f73 7464   with ``read_std
-00014900: 696e 5f6f 7074 7360 602e 2054 6869 7320  in_opts``. This 
-00014910: 6861 7320 6e6f 2065 6666 6563 7420 7768  has no effect wh
-00014920: 656e 0a20 2020 2060 6075 7365 5f74 656d  en.    ``use_tem
-00014930: 7066 696c 653d 5472 7565 6060 2c20 6f72  pfile=True``, or
-00014940: 206f 7468 6572 7769 7365 2072 6561 6469   otherwise readi
-00014950: 6e67 2070 6163 6b65 7473 2066 726f 6d20  ng packets from 
-00014960: 6120 7265 6775 6c61 7220 6669 6c65 2e0a  a regular file..
-00014970: 0a20 2020 203a 7061 7261 6d20 706b 746c  .    :param pktl
-00014980: 6973 743a 2061 2050 6163 6b65 7420 696e  ist: a Packet in
-00014990: 7374 616e 6365 2c20 6120 5061 636b 6574  stance, a Packet
-000149a0: 4c69 7374 2069 6e73 7461 6e63 6520 6f72  List instance or
-000149b0: 2061 206c 6973 7420 6f66 0a20 2020 2020   a list of.     
-000149c0: 2020 2050 6163 6b65 7420 696e 7374 616e     Packet instan
-000149d0: 6365 732e 2043 616e 2061 6c73 6f20 6265  ces. Can also be
-000149e0: 2061 2066 696c 656e 616d 6520 2861 7320   a filename (as 
-000149f0: 6120 7374 7269 6e67 292c 2061 6e20 6f70  a string), an op
-00014a00: 656e 0a20 2020 2020 2020 2066 696c 652d  en.        file-
-00014a10: 6c69 6b65 206f 626a 6563 7420 7468 6174  like object that
-00014a20: 206d 7573 7420 6265 2061 2066 696c 6520   must be a file 
-00014a30: 666f 726d 6174 2072 6561 6461 626c 6520  format readable 
-00014a40: 6279 0a20 2020 2020 2020 2074 7368 6172  by.        tshar
-00014a50: 6b20 2850 6361 702c 2050 6361 704e 672c  k (Pcap, PcapNg,
-00014a60: 2065 7463 2e29 206f 7220 4e6f 6e65 2028   etc.) or None (
-00014a70: 746f 2073 6e69 6666 290a 2020 2020 3a70  to sniff).    :p
-00014a80: 6172 616d 2066 6c74 3a20 6120 6669 6c74  aram flt: a filt
-00014a90: 6572 2074 6f20 7573 6520 7769 7468 2074  er to use with t
-00014aa0: 6370 6475 6d70 0a20 2020 203a 7061 7261  cpdump.    :para
-00014ab0: 6d20 6475 6d70 3a20 2020 2077 6865 6e20  m dump:    when 
-00014ac0: 7365 7420 746f 2054 7275 652c 2072 6574  set to True, ret
-00014ad0: 7572 6e73 2061 2073 7472 696e 6720 696e  urns a string in
-00014ae0: 7374 6561 6420 6f66 2064 6973 706c 6179  stead of display
-00014af0: 696e 6720 6974 2e0a 2020 2020 3a70 6172  ing it..    :par
-00014b00: 616d 2067 6574 6664 3a20 2020 7768 656e  am getfd:   when
-00014b10: 2073 6574 2074 6f20 5472 7565 2c20 7265   set to True, re
-00014b20: 7475 726e 7320 6120 6669 6c65 2d6c 696b  turns a file-lik
-00014b30: 6520 6f62 6a65 6374 2074 6f20 7265 6164  e object to read
-00014b40: 2064 6174 610a 2020 2020 2020 2020 6672   data.        fr
-00014b50: 6f6d 2074 6370 6475 6d70 206f 7220 7473  om tcpdump or ts
-00014b60: 6861 726b 2066 726f 6d2e 0a20 2020 203a  hark from..    :
-00014b70: 7061 7261 6d20 6765 7470 726f 633a 2077  param getproc: w
-00014b80: 6865 6e20 7365 7420 746f 2054 7275 652c  hen set to True,
-00014b90: 2074 6865 2073 7562 7072 6f63 6573 732e   the subprocess.
-00014ba0: 506f 7065 6e20 6f62 6a65 6374 2069 7320  Popen object is 
-00014bb0: 7265 7475 726e 6564 0a20 2020 203a 7061  returned.    :pa
-00014bc0: 7261 6d20 6172 6773 3a20 2020 2061 7267  ram args:    arg
-00014bd0: 756d 656e 7473 2028 6173 2061 206c 6973  uments (as a lis
-00014be0: 7429 2074 6f20 7061 7373 2074 6f20 7473  t) to pass to ts
-00014bf0: 6861 726b 2028 6578 616d 706c 6520 666f  hark (example fo
-00014c00: 7220 7473 6861 726b 3a0a 2020 2020 2020  r tshark:.      
-00014c10: 2020 6172 6773 3d5b 222d 5422 2c20 226a    args=["-T", "j
-00014c20: 736f 6e22 5d29 2e0a 2020 2020 3a70 6172  son"])..    :par
-00014c30: 616d 2070 726f 673a 2020 2020 7072 6f67  am prog:    prog
-00014c40: 7261 6d20 746f 2075 7365 2028 6465 6661  ram to use (defa
-00014c50: 756c 7473 2074 6f20 7463 7064 756d 702c  ults to tcpdump,
-00014c60: 2077 696c 6c20 776f 726b 2077 6974 6820   will work with 
-00014c70: 7473 6861 726b 290a 2020 2020 3a70 6172  tshark).    :par
-00014c80: 616d 2071 7569 6574 3a20 2020 7768 656e  am quiet:   when
-00014c90: 2073 6574 2074 6f20 5472 7565 2c20 7468   set to True, th
-00014ca0: 6520 7072 6f63 6573 7320 7374 6465 7272  e process stderr
-00014cb0: 2069 7320 6469 7363 6172 6465 640a 2020   is discarded.  
-00014cc0: 2020 3a70 6172 616d 2075 7365 5f74 656d    :param use_tem
-00014cd0: 7066 696c 653a 2057 6865 6e20 7365 7420  pfile: When set 
-00014ce0: 746f 2054 7275 652c 2061 6c77 6179 7320  to True, always 
-00014cf0: 7573 6520 6120 7465 6d70 6f72 6172 7920  use a temporary 
-00014d00: 6669 6c65 2074 6f20 7374 6f72 650a 2020  file to store.  
-00014d10: 2020 2020 2020 7061 636b 6574 732e 0a20        packets.. 
-00014d20: 2020 2020 2020 2057 6865 6e20 7365 7420         When set 
-00014d30: 746f 2046 616c 7365 2c20 7069 7065 2070  to False, pipe p
-00014d40: 6163 6b65 7473 2074 6872 6f75 6768 2073  ackets through s
-00014d50: 7464 696e 2e0a 2020 2020 2020 2020 5768  tdin..        Wh
-00014d60: 656e 2073 6574 2074 6f20 4e6f 6e65 2028  en set to None (
-00014d70: 6465 6661 756c 7429 2c20 6f6e 6c79 2075  default), only u
-00014d80: 7365 2061 2074 656d 706f 7261 7279 2066  se a temporary f
-00014d90: 696c 6520 7769 7468 0a20 2020 2020 2020  ile with.       
-00014da0: 2060 6074 6370 6475 6d70 6060 206f 6e20   ``tcpdump`` on 
-00014db0: 4f53 582e 0a20 2020 203a 7061 7261 6d20  OSX..    :param 
-00014dc0: 7265 6164 5f73 7464 696e 5f6f 7074 733a  read_stdin_opts:
-00014dd0: 2057 6865 6e20 7365 742c 2061 206c 6973   When set, a lis
-00014de0: 7420 6f66 2061 7267 756d 656e 7473 206e  t of arguments n
-00014df0: 6565 6465 6420 746f 2063 6170 7475 7265  eeded to capture
-00014e00: 0a20 2020 2020 2020 2066 726f 6d20 7374  .        from st
-00014e10: 6469 6e2e 204f 7468 6572 7769 7365 2c20  din. Otherwise, 
-00014e20: 6174 7465 6d70 7473 2074 6f20 6775 6573  attempts to gues
-00014e30: 732e 0a20 2020 203a 7061 7261 6d20 6c69  s..    :param li
-00014e40: 6e6b 7479 7065 3a20 4120 6375 7374 6f6d  nktype: A custom
-00014e50: 2044 4c54 2076 616c 7565 206f 7220 6e61   DLT value or na
-00014e60: 6d65 2c20 746f 206f 7665 7277 7269 7465  me, to overwrite
-00014e70: 2074 6865 2064 6566 6175 6c74 0a20 2020   the default.   
-00014e80: 2020 2020 2076 616c 7565 732e 0a20 2020       values..   
-00014e90: 203a 7061 7261 6d20 7761 6974 3a20 4966   :param wait: If
-00014ea0: 2054 7275 6520 2864 6566 6175 6c74 292c   True (default),
-00014eb0: 2077 6169 7473 2066 6f72 2074 6865 2070   waits for the p
-00014ec0: 726f 6365 7373 2074 6f20 7465 726d 696e  rocess to termin
-00014ed0: 6174 6520 6265 666f 7265 0a20 2020 2020  ate before.     
-00014ee0: 2020 2072 6574 7572 6e69 6e67 2074 6f20     returning to 
-00014ef0: 5363 6170 792e 2049 6620 4661 6c73 652c  Scapy. If False,
-00014f00: 2074 6865 2070 726f 6365 7373 2077 696c   the process wil
-00014f10: 6c20 6265 2064 6574 6163 6865 6420 746f  l be detached to
-00014f20: 2074 6865 0a20 2020 2020 2020 2062 6163   the.        bac
-00014f30: 6b67 726f 756e 642e 2049 6620 6475 6d70  kground. If dump
-00014f40: 2c20 6765 7470 726f 6320 6f72 2067 6574  , getproc or get
-00014f50: 6664 2069 7320 5472 7565 2c20 7468 6573  fd is True, thes
-00014f60: 6520 6861 7665 2074 6865 2073 616d 650a  e have the same.
-00014f70: 2020 2020 2020 2020 6566 6665 6374 2061          effect a
-00014f80: 7320 6060 7761 6974 3d46 616c 7365 6060  s ``wait=False``
-00014f90: 2e0a 0a20 2020 2045 7861 6d70 6c65 733a  ...    Examples:
-00014fa0: 3a0a 0a20 2020 2020 2020 203e 3e3e 2074  :..        >>> t
-00014fb0: 6370 6475 6d70 285b 4950 2829 2f54 4350  cpdump([IP()/TCP
-00014fc0: 2829 2c20 4950 2829 2f55 4450 2829 5d29  (), IP()/UDP()])
-00014fd0: 0a20 2020 2020 2020 2072 6561 6469 6e67  .        reading
-00014fe0: 2066 726f 6d20 6669 6c65 202d 2c20 6c69   from file -, li
-00014ff0: 6e6b 2d74 7970 6520 5241 5720 2852 6177  nk-type RAW (Raw
-00015000: 2049 5029 0a20 2020 2020 2020 2031 363a   IP).        16:
-00015010: 3436 3a30 302e 3437 3435 3135 2049 5020  46:00.474515 IP 
-00015020: 3132 372e 302e 302e 312e 3230 203e 2031  127.0.0.1.20 > 1
-00015030: 3237 2e30 2e30 2e31 2e38 303a 2046 6c61  27.0.0.1.80: Fla
-00015040: 6773 205b 535d 2c20 7365 7120 302c 2077  gs [S], seq 0, w
-00015050: 696e 2038 3139 322c 206c 656e 6774 6820  in 8192, length 
-00015060: 3020 2023 206e 6f71 613a 2045 3530 310a  0  # noqa: E501.
-00015070: 2020 2020 2020 2020 3136 3a34 363a 3030          16:46:00
-00015080: 2e34 3735 3031 3920 4950 2031 3237 2e30  .475019 IP 127.0
-00015090: 2e30 2e31 2e35 3320 3e20 3132 372e 302e  .0.1.53 > 127.0.
-000150a0: 302e 312e 3533 3a20 5b7c 646f 6d61 696e  0.1.53: [|domain
-000150b0: 5d0a 0a20 2020 2020 2020 203e 3e3e 2074  ]..        >>> t
-000150c0: 6370 6475 6d70 285b 4950 2829 2f54 4350  cpdump([IP()/TCP
-000150d0: 2829 2c20 4950 2829 2f55 4450 2829 5d2c  (), IP()/UDP()],
-000150e0: 2070 726f 673d 636f 6e66 2e70 726f 672e   prog=conf.prog.
-000150f0: 7473 6861 726b 290a 2020 2020 2020 2020  tshark).        
-00015100: 2020 3120 2020 302e 3030 3030 3030 2020    1   0.000000  
-00015110: 2020 3132 372e 302e 302e 3120 2d3e 2031    127.0.0.1 -> 1
-00015120: 3237 2e30 2e30 2e31 2020 2020 5443 5020  27.0.0.1    TCP 
-00015130: 3430 2032 302d 3e38 3020 5b53 594e 5d20  40 20->80 [SYN] 
-00015140: 5365 713d 3020 5769 6e3d 3831 3932 204c  Seq=0 Win=8192 L
-00015150: 656e 3d30 2020 2320 6e6f 7161 3a20 4535  en=0  # noqa: E5
-00015160: 3031 0a20 2020 2020 2020 2020 2032 2020  01.          2  
-00015170: 2030 2e30 3030 3435 3920 2020 2031 3237   0.000459    127
-00015180: 2e30 2e30 2e31 202d 3e20 3132 372e 302e  .0.0.1 -> 127.0.
-00015190: 302e 3120 2020 2055 4450 2032 3820 3533  0.1    UDP 28 53
-000151a0: 2d3e 3533 204c 656e 3d30 0a0a 2020 2020  ->53 Len=0..    
-000151b0: 546f 2067 6574 2061 204a 534f 4e20 7265  To get a JSON re
-000151c0: 7072 6573 656e 7461 7469 6f6e 206f 6620  presentation of 
-000151d0: 6120 7473 6861 726b 2d70 6172 7365 6420  a tshark-parsed 
-000151e0: 5061 636b 6574 4c69 7374 2829 2c20 6f6e  PacketList(), on
-000151f0: 6520 6361 6e3a 3a0a 0a20 2020 2020 2020  e can::..       
-00015200: 203e 3e3e 2069 6d70 6f72 7420 6a73 6f6e   >>> import json
-00015210: 2c20 7070 7269 6e74 0a20 2020 2020 2020  , pprint.       
-00015220: 203e 3e3e 206a 736f 6e5f 6461 7461 203d   >>> json_data =
-00015230: 206a 736f 6e2e 6c6f 6164 2874 6370 6475   json.load(tcpdu
-00015240: 6d70 2849 5028 7372 633d 2232 3137 2e32  mp(IP(src="217.2
-00015250: 352e 3137 382e 3522 2c0a 2020 2020 2020  5.178.5",.      
-00015260: 2020 2e2e 2e20 2020 2020 2020 2020 2020    ...           
-00015270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015280: 2020 2020 2020 2064 7374 3d22 3435 2e33         dst="45.3
-00015290: 332e 3332 2e31 3536 2229 2c0a 2020 2020  3.32.156"),.    
-000152a0: 2020 2020 2e2e 2e20 2020 2020 2020 2020      ...         
-000152b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000152c0: 2020 2020 2020 7072 6f67 3d63 6f6e 662e        prog=conf.
-000152d0: 7072 6f67 2e74 7368 6172 6b2c 0a20 2020  prog.tshark,.   
-000152e0: 2020 2020 202e 2e2e 2020 2020 2020 2020       ...        
-000152f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015300: 2020 2020 2020 2061 7267 733d 5b22 2d54         args=["-T
-00015310: 222c 2022 6a73 6f6e 225d 2c0a 2020 2020  ", "json"],.    
-00015320: 2020 2020 2e2e 2e20 2020 2020 2020 2020      ...         
-00015330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015340: 2020 2020 2020 6765 7466 643d 5472 7565        getfd=True
-00015350: 2929 0a20 2020 2020 2020 203e 3e3e 2070  )).        >>> p
-00015360: 7072 696e 742e 7070 7269 6e74 286a 736f  print.pprint(jso
-00015370: 6e5f 6461 7461 290a 2020 2020 2020 2020  n_data).        
-00015380: 5b7b 7527 5f69 6e64 6578 273a 2075 2770  [{u'_index': u'p
-00015390: 6163 6b65 7473 2d32 3031 362d 3132 2d32  ackets-2016-12-2
-000153a0: 3327 2c0a 2020 2020 2020 2020 2020 7527  3',.          u'
-000153b0: 5f73 636f 7265 273a 204e 6f6e 652c 0a20  _score': None,. 
-000153c0: 2020 2020 2020 2020 2075 275f 736f 7572           u'_sour
-000153d0: 6365 273a 207b 7527 6c61 7965 7273 273a  ce': {u'layers':
-000153e0: 207b 7527 6672 616d 6527 3a20 7b75 2766   {u'frame': {u'f
-000153f0: 7261 6d65 2e63 6170 5f6c 656e 273a 2075  rame.cap_len': u
-00015400: 2732 3027 2c0a 2020 2020 2020 2020 2020  '20',.          
-00015410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015430: 2020 2020 7527 6672 616d 652e 656e 6361      u'frame.enca
-00015440: 705f 7479 7065 273a 2075 2737 272c 0a20  p_type': u'7',. 
-00015450: 2020 2020 2020 205b 2e2e 2e5d 0a20 2020         [...].   
-00015460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015480: 2020 2020 2020 2020 2020 207d 2c0a 2020             },.  
-00015490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000154a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000154b0: 2075 2769 7027 3a20 7b75 2769 702e 6164   u'ip': {u'ip.ad
-000154c0: 6472 273a 2075 2734 352e 3333 2e33 322e  dr': u'45.33.32.
-000154d0: 3135 3627 2c0a 2020 2020 2020 2020 2020  156',.          
-000154e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000154f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015500: 2075 2769 702e 6368 6563 6b73 756d 273a   u'ip.checksum':
-00015510: 2075 2730 7830 3030 3061 3230 6427 2c0a   u'0x0000a20d',.
-00015520: 2020 2020 2020 2020 5b2e 2e2e 5d0a 2020          [...].  
-00015530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015550: 2020 2020 2020 2020 2075 2769 702e 7474           u'ip.tt
-00015560: 6c27 3a20 7527 3634 272c 0a20 2020 2020  l': u'64',.     
+000117c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117d0: 696e 7428 7365 6329 2c20 7573 6563 2c20  int(sec), usec, 
+000117e0: 6361 706c 656e 2c20 7769 7265 6c65 6e29  caplen, wirelen)
+000117f0: 290a 2020 2020 2020 2020 7365 6c66 2e66  ).        self.f
+00011800: 2e77 7269 7465 2862 7974 6573 2870 6163  .write(bytes(pac
+00011810: 6b65 7429 290a 2020 2020 2020 2020 6966  ket)).        if
+00011820: 2073 656c 662e 7379 6e63 3a0a 2020 2020   self.sync:.    
+00011830: 2020 2020 2020 2020 7365 6c66 2e66 2e66          self.f.f
+00011840: 6c75 7368 2829 0a0a 0a63 6c61 7373 2052  lush()...class R
+00011850: 6177 5063 6170 4e67 5772 6974 6572 2847  awPcapNgWriter(G
+00011860: 656e 6572 6963 5261 7750 6361 7057 7269  enericRawPcapWri
+00011870: 7465 7229 3a0a 2020 2020 2222 2241 2073  ter):.    """A s
+00011880: 7472 6561 6d20 7063 6170 6e67 2077 7269  tream pcapng wri
+00011890: 7465 7220 7769 7468 206d 6f72 6520 636f  ter with more co
+000118a0: 6e74 726f 6c20 7468 616e 2077 7270 6361  ntrol than wrpca
+000118b0: 706e 6728 2922 2222 0a0a 2020 2020 6465  png()"""..    de
+000118c0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+000118d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000118e0: 2020 6669 6c65 6e61 6d65 2c20 2023 2074    filename,  # t
+000118f0: 7970 653a 2073 7472 0a20 2020 2020 2020  ype: str.       
+00011900: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+00011910: 2020 2020 2023 2074 7970 653a 2028 2e2e       # type: (..
+00011920: 2e29 202d 3e20 4e6f 6e65 0a0a 2020 2020  .) -> None..    
+00011930: 2020 2020 7365 6c66 2e68 6561 6465 725f      self.header_
+00011940: 7072 6573 656e 7420 3d20 4661 6c73 650a  present = False.
+00011950: 2020 2020 2020 2020 7365 6c66 2e74 7372          self.tsr
+00011960: 6573 6f6c 203d 2031 3030 3030 3030 0a20  esol = 1000000. 
+00011970: 2020 2020 2020 2023 2041 2064 6963 7420         # A dict 
+00011980: 746f 206b 6565 7020 6966 5f6e 616d 6520  to keep if_name 
+00011990: 746f 2049 4442 2069 6420 6d61 7070 696e  to IDB id mappin
+000119a0: 672e 0a20 2020 2020 2020 2023 2075 6e6b  g..        # unk
+000119b0: 6e6f 776e 2069 665f 6e61 6d65 284e 6f6e  nown if_name(Non
+000119c0: 6529 2069 643d 300a 2020 2020 2020 2020  e) id=0.        
+000119d0: 7365 6c66 2e69 6e74 6572 6661 6365 7332  self.interfaces2
+000119e0: 6964 3a20 4469 6374 5b4f 7074 696f 6e61  id: Dict[Optiona
+000119f0: 6c5b 6279 7465 735d 2c20 696e 745d 203d  l[bytes], int] =
+00011a00: 207b 4e6f 6e65 3a20 307d 0a0a 2020 2020   {None: 0}..    
+00011a10: 2020 2020 2320 7463 7064 756d 7020 6f6e      # tcpdump on
+00011a20: 6c79 2073 7570 706f 7274 206c 6974 746c  ly support littl
+00011a30: 652d 656e 6469 616e 2069 6e20 5043 4150  e-endian in PCAP
+00011a40: 6e67 2066 696c 6573 0a20 2020 2020 2020  ng files.       
+00011a50: 2073 656c 662e 656e 6469 616e 203d 2022   self.endian = "
+00011a60: 3c22 0a20 2020 2020 2020 2073 656c 662e  <".        self.
+00011a70: 656e 6469 616e 5f6d 6167 6963 203d 2062  endian_magic = b
+00011a80: 225c 7834 645c 7833 635c 7832 625c 7831  "\x4d\x3c\x2b\x1
+00011a90: 6122 0a0a 2020 2020 2020 2020 7365 6c66  a"..        self
+00011aa0: 2e66 696c 656e 616d 6520 3d20 6669 6c65  .filename = file
+00011ab0: 6e61 6d65 0a20 2020 2020 2020 2073 656c  name.        sel
+00011ac0: 662e 6620 3d20 6f70 656e 2866 696c 656e  f.f = open(filen
+00011ad0: 616d 652c 2022 7762 222c 2034 3039 3629  ame, "wb", 4096)
+00011ae0: 0a0a 2020 2020 6465 6620 5f67 6574 5f74  ..    def _get_t
+00011af0: 696d 6528 7365 6c66 2c0a 2020 2020 2020  ime(self,.      
+00011b00: 2020 2020 2020 2020 2020 2020 7061 636b              pack
+00011b10: 6574 2c20 2023 2074 7970 653a 2055 6e69  et,  # type: Uni
+00011b20: 6f6e 5b62 7974 6573 2c20 5061 636b 6574  on[bytes, Packet
+00011b30: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00011b40: 2020 2020 7365 632c 2020 2320 7479 7065      sec,  # type
+00011b50: 3a20 4f70 7469 6f6e 616c 5b66 6c6f 6174  : Optional[float
+00011b60: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00011b70: 2020 2020 7573 6563 2020 2320 7479 7065      usec  # type
+00011b80: 3a20 4f70 7469 6f6e 616c 5b69 6e74 5d0a  : Optional[int].
+00011b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011ba0: 2020 293a 0a20 2020 2020 2020 2023 2074    ):.        # t
+00011bb0: 7970 653a 2028 2e2e 2e29 202d 3e20 5475  ype: (...) -> Tu
+00011bc0: 706c 655b 666c 6f61 742c 2069 6e74 5d0a  ple[float, int].
+00011bd0: 2020 2020 2020 2020 6966 2068 6173 6174          if hasat
+00011be0: 7472 2870 6163 6b65 742c 2022 7469 6d65  tr(packet, "time
+00011bf0: 2229 3a0a 2020 2020 2020 2020 2020 2020  "):.            
+00011c00: 6966 2073 6563 2069 7320 4e6f 6e65 3a0a  if sec is None:.
+00011c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c20: 7365 6320 3d20 666c 6f61 7428 7061 636b  sec = float(pack
+00011c30: 6574 2e74 696d 6529 0a0a 2020 2020 2020  et.time)..      
+00011c40: 2020 6966 2075 7365 6320 6973 204e 6f6e    if usec is Non
+00011c50: 653a 0a20 2020 2020 2020 2020 2020 2075  e:.            u
+00011c60: 7365 6320 3d20 300a 0a20 2020 2020 2020  sec = 0..       
+00011c70: 2072 6574 7572 6e20 7365 632c 2075 7365   return sec, use
+00011c80: 6320 2023 2074 7970 653a 2069 676e 6f72  c  # type: ignor
+00011c90: 650a 0a20 2020 2064 6566 205f 6164 645f  e..    def _add_
+00011ca0: 7061 6464 696e 6728 7365 6c66 2c20 7261  padding(self, ra
+00011cb0: 775f 6461 7461 293a 0a20 2020 2020 2020  w_data):.       
+00011cc0: 2023 2074 7970 653a 2028 6279 7465 7329   # type: (bytes)
+00011cd0: 202d 3e20 6279 7465 730a 2020 2020 2020   -> bytes.      
+00011ce0: 2020 7261 775f 6461 7461 202b 3d20 2828    raw_data += ((
+00011cf0: 2d6c 656e 2872 6177 5f64 6174 6129 2920  -len(raw_data)) 
+00011d00: 2520 3429 202a 2062 225c 7830 3022 0a20  % 4) * b"\x00". 
+00011d10: 2020 2020 2020 2072 6574 7572 6e20 7261         return ra
+00011d20: 775f 6461 7461 0a0a 2020 2020 6465 6620  w_data..    def 
+00011d30: 6275 696c 645f 626c 6f63 6b28 7365 6c66  build_block(self
+00011d40: 2c20 626c 6f63 6b5f 7479 7065 2c20 626c  , block_type, bl
+00011d50: 6f63 6b5f 626f 6479 2c20 6f70 7469 6f6e  ock_body, option
+00011d60: 733d 4e6f 6e65 293a 0a20 2020 2020 2020  s=None):.       
+00011d70: 2023 2074 7970 653a 2028 6279 7465 732c   # type: (bytes,
+00011d80: 2062 7974 6573 2c20 4f70 7469 6f6e 616c   bytes, Optional
+00011d90: 5b62 7974 6573 5d29 202d 3e20 6279 7465  [bytes]) -> byte
+00011da0: 730a 0a20 2020 2020 2020 2023 2050 6164  s..        # Pad
+00011db0: 2042 6c6f 636b 2042 6f64 7920 746f 2033   Block Body to 3
+00011dc0: 3220 6269 7473 0a20 2020 2020 2020 2062  2 bits.        b
+00011dd0: 6c6f 636b 5f62 6f64 7920 3d20 7365 6c66  lock_body = self
+00011de0: 2e5f 6164 645f 7061 6464 696e 6728 626c  ._add_padding(bl
+00011df0: 6f63 6b5f 626f 6479 290a 0a20 2020 2020  ock_body)..     
+00011e00: 2020 2069 6620 6f70 7469 6f6e 733a 0a20     if options:. 
+00011e10: 2020 2020 2020 2020 2020 2062 6c6f 636b             block
+00011e20: 5f62 6f64 7920 2b3d 206f 7074 696f 6e73  _body += options
+00011e30: 0a0a 2020 2020 2020 2020 2320 416e 2065  ..        # An e
+00011e40: 6d70 7479 2062 6c6f 636b 2069 7320 3132  mpty block is 12
+00011e50: 2062 7974 6573 206c 6f6e 670a 2020 2020   bytes long.    
+00011e60: 2020 2020 626c 6f63 6b5f 746f 7461 6c5f      block_total_
+00011e70: 6c65 6e67 7468 203d 2031 3220 2b20 6c65  length = 12 + le
+00011e80: 6e28 626c 6f63 6b5f 626f 6479 290a 0a20  n(block_body).. 
+00011e90: 2020 2020 2020 2023 2042 6c6f 636b 2054         # Block T
+00011ea0: 7970 650a 2020 2020 2020 2020 626c 6f63  ype.        bloc
+00011eb0: 6b20 3d20 626c 6f63 6b5f 7479 7065 0a20  k = block_type. 
+00011ec0: 2020 2020 2020 2023 2042 6c6f 636b 2054         # Block T
+00011ed0: 6f74 616c 204c 656e 6774 6824 0a20 2020  otal Length$.   
+00011ee0: 2020 2020 2062 6c6f 636b 202b 3d20 7374       block += st
+00011ef0: 7275 6374 2e70 6163 6b28 7365 6c66 2e65  ruct.pack(self.e
+00011f00: 6e64 6961 6e20 2b20 2249 222c 2062 6c6f  ndian + "I", blo
+00011f10: 636b 5f74 6f74 616c 5f6c 656e 6774 6829  ck_total_length)
+00011f20: 0a20 2020 2020 2020 2023 2042 6c6f 636b  .        # Block
+00011f30: 2042 6f64 790a 2020 2020 2020 2020 626c   Body.        bl
+00011f40: 6f63 6b20 2b3d 2062 6c6f 636b 5f62 6f64  ock += block_bod
+00011f50: 790a 2020 2020 2020 2020 2320 426c 6f63  y.        # Bloc
+00011f60: 6b20 546f 7461 6c20 4c65 6e67 7468 240a  k Total Length$.
+00011f70: 2020 2020 2020 2020 626c 6f63 6b20 2b3d          block +=
+00011f80: 2073 7472 7563 742e 7061 636b 2873 656c   struct.pack(sel
+00011f90: 662e 656e 6469 616e 202b 2022 4922 2c20  f.endian + "I", 
+00011fa0: 626c 6f63 6b5f 746f 7461 6c5f 6c65 6e67  block_total_leng
+00011fb0: 7468 290a 0a20 2020 2020 2020 2072 6574  th)..        ret
+00011fc0: 7572 6e20 626c 6f63 6b0a 0a20 2020 2064  urn block..    d
+00011fd0: 6566 205f 7772 6974 655f 6865 6164 6572  ef _write_header
+00011fe0: 2873 656c 662c 2070 6b74 293a 0a20 2020  (self, pkt):.   
+00011ff0: 2020 2020 2023 2074 7970 653a 2028 4f70       # type: (Op
+00012000: 7469 6f6e 616c 5b55 6e69 6f6e 5b50 6163  tional[Union[Pac
+00012010: 6b65 742c 2062 7974 6573 5d5d 2920 2d3e  ket, bytes]]) ->
+00012020: 204e 6f6e 650a 2020 2020 2020 2020 6966   None.        if
+00012030: 206e 6f74 2073 656c 662e 6865 6164 6572   not self.header
+00012040: 5f70 7265 7365 6e74 3a0a 2020 2020 2020  _present:.      
+00012050: 2020 2020 2020 7365 6c66 2e68 6561 6465        self.heade
+00012060: 725f 7072 6573 656e 7420 3d20 5472 7565  r_present = True
+00012070: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00012080: 662e 5f77 7269 7465 5f62 6c6f 636b 5f73  f._write_block_s
+00012090: 6862 2829 0a20 2020 2020 2020 2020 2020  hb().           
+000120a0: 2073 656c 662e 5f77 7269 7465 5f62 6c6f   self._write_blo
+000120b0: 636b 5f69 6462 286c 696e 6b74 7970 653d  ck_idb(linktype=
+000120c0: 7365 6c66 2e6c 696e 6b74 7970 6529 0a0a  self.linktype)..
+000120d0: 2020 2020 6465 6620 5f77 7269 7465 5f62      def _write_b
+000120e0: 6c6f 636b 5f73 6862 2873 656c 6629 3a0a  lock_shb(self):.
+000120f0: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
+00012100: 2829 202d 3e20 4e6f 6e65 0a0a 2020 2020  () -> None..    
+00012110: 2020 2020 2320 426c 6f63 6b20 5479 7065      # Block Type
+00012120: 0a20 2020 2020 2020 2062 6c6f 636b 5f74  .        block_t
+00012130: 7970 6520 3d20 6222 5c78 3041 5c78 3044  ype = b"\x0A\x0D
+00012140: 5c78 3044 5c78 3041 220a 2020 2020 2020  \x0D\x0A".      
+00012150: 2020 2320 4279 7465 2d4f 7264 6572 204d    # Byte-Order M
+00012160: 6167 6963 0a20 2020 2020 2020 2062 6c6f  agic.        blo
+00012170: 636b 5f73 6862 203d 2073 656c 662e 656e  ck_shb = self.en
+00012180: 6469 616e 5f6d 6167 6963 0a20 2020 2020  dian_magic.     
+00012190: 2020 2023 204d 616a 6f72 2056 6572 7369     # Major Versi
+000121a0: 6f6e 0a20 2020 2020 2020 2062 6c6f 636b  on.        block
+000121b0: 5f73 6862 202b 3d20 7374 7275 6374 2e70  _shb += struct.p
+000121c0: 6163 6b28 7365 6c66 2e65 6e64 6961 6e20  ack(self.endian 
+000121d0: 2b20 2248 222c 2031 290a 2020 2020 2020  + "H", 1).      
+000121e0: 2020 2320 4d69 6e6f 7220 5665 7273 696f    # Minor Versio
+000121f0: 6e0a 2020 2020 2020 2020 626c 6f63 6b5f  n.        block_
+00012200: 7368 6220 2b3d 2073 7472 7563 742e 7061  shb += struct.pa
+00012210: 636b 2873 656c 662e 656e 6469 616e 202b  ck(self.endian +
+00012220: 2022 4822 2c20 3029 0a20 2020 2020 2020   "H", 0).       
+00012230: 2023 2053 6563 7469 6f6e 204c 656e 6774   # Section Lengt
+00012240: 680a 2020 2020 2020 2020 626c 6f63 6b5f  h.        block_
+00012250: 7368 6220 2b3d 2073 7472 7563 742e 7061  shb += struct.pa
+00012260: 636b 2873 656c 662e 656e 6469 616e 202b  ck(self.endian +
+00012270: 2022 7122 2c20 2d31 290a 0a20 2020 2020   "q", -1)..     
+00012280: 2020 2073 656c 662e 662e 7772 6974 6528     self.f.write(
+00012290: 7365 6c66 2e62 7569 6c64 5f62 6c6f 636b  self.build_block
+000122a0: 2862 6c6f 636b 5f74 7970 652c 2062 6c6f  (block_type, blo
+000122b0: 636b 5f73 6862 2929 0a0a 2020 2020 6465  ck_shb))..    de
+000122c0: 6620 5f77 7269 7465 5f62 6c6f 636b 5f69  f _write_block_i
+000122d0: 6462 2873 656c 662c 0a20 2020 2020 2020  db(self,.       
+000122e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000122f0: 2020 6c69 6e6b 7479 7065 2c20 2023 2074    linktype,  # t
+00012300: 7970 653a 2069 6e74 0a20 2020 2020 2020  ype: int.       
+00012310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012320: 2020 6966 6e61 6d65 3d4e 6f6e 6520 2023    ifname=None  #
+00012330: 2074 7970 653a 204f 7074 696f 6e61 6c5b   type: Optional[
+00012340: 6279 7465 735d 0a20 2020 2020 2020 2020  bytes].         
+00012350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012360: 293a 0a20 2020 2020 2020 2023 2074 7970  ):.        # typ
+00012370: 653a 2028 2e2e 2e29 202d 3e20 4e6f 6e65  e: (...) -> None
+00012380: 0a0a 2020 2020 2020 2020 2320 426c 6f63  ..        # Bloc
+00012390: 6b20 5479 7065 0a20 2020 2020 2020 2062  k Type.        b
+000123a0: 6c6f 636b 5f74 7970 6520 3d20 7374 7275  lock_type = stru
+000123b0: 6374 2e70 6163 6b28 7365 6c66 2e65 6e64  ct.pack(self.end
+000123c0: 6961 6e20 2b20 2249 222c 2031 290a 2020  ian + "I", 1).  
+000123d0: 2020 2020 2020 2320 4c69 6e6b 5479 7065        # LinkType
+000123e0: 0a20 2020 2020 2020 2062 6c6f 636b 5f69  .        block_i
+000123f0: 6462 203d 2073 7472 7563 742e 7061 636b  db = struct.pack
+00012400: 2873 656c 662e 656e 6469 616e 202b 2022  (self.endian + "
+00012410: 4822 2c20 6c69 6e6b 7479 7065 290a 2020  H", linktype).  
+00012420: 2020 2020 2020 2320 5265 7365 7276 6564        # Reserved
+00012430: 0a20 2020 2020 2020 2062 6c6f 636b 5f69  .        block_i
+00012440: 6462 202b 3d20 7374 7275 6374 2e70 6163  db += struct.pac
+00012450: 6b28 7365 6c66 2e65 6e64 6961 6e20 2b20  k(self.endian + 
+00012460: 2248 222c 2030 290a 2020 2020 2020 2020  "H", 0).        
+00012470: 2320 536e 6170 4c65 6e0a 2020 2020 2020  # SnapLen.      
+00012480: 2020 626c 6f63 6b5f 6964 6220 2b3d 2073    block_idb += s
+00012490: 7472 7563 742e 7061 636b 2873 656c 662e  truct.pack(self.
+000124a0: 656e 6469 616e 202b 2022 4922 2c20 3236  endian + "I", 26
+000124b0: 3231 3434 290a 0a20 2020 2020 2020 2023  2144)..        #
+000124c0: 2069 665f 6e61 6d65 206f 7074 696f 6e0a   if_name option.
+000124d0: 2020 2020 2020 2020 6f70 7473 203d 204e          opts = N
+000124e0: 6f6e 650a 2020 2020 2020 2020 6966 2069  one.        if i
+000124f0: 666e 616d 6520 6973 206e 6f74 204e 6f6e  fname is not Non
+00012500: 653a 0a20 2020 2020 2020 2020 2020 206f  e:.            o
+00012510: 7074 7320 3d20 7374 7275 6374 2e70 6163  pts = struct.pac
+00012520: 6b28 7365 6c66 2e65 6e64 6961 6e20 2b20  k(self.endian + 
+00012530: 2248 4822 2c20 322c 206c 656e 2869 666e  "HH", 2, len(ifn
+00012540: 616d 6529 290a 2020 2020 2020 2020 2020  ame)).          
+00012550: 2020 2320 5061 6420 4f70 7469 6f6e 2056    # Pad Option V
+00012560: 616c 7565 2074 6f20 3332 2062 6974 730a  alue to 32 bits.
+00012570: 2020 2020 2020 2020 2020 2020 6f70 7473              opts
+00012580: 202b 3d20 7365 6c66 2e5f 6164 645f 7061   += self._add_pa
+00012590: 6464 696e 6728 6966 6e61 6d65 290a 2020  dding(ifname).  
+000125a0: 2020 2020 2020 2020 2020 6f70 7473 202b            opts +
+000125b0: 3d20 7374 7275 6374 2e70 6163 6b28 7365  = struct.pack(se
+000125c0: 6c66 2e65 6e64 6961 6e20 2b20 2248 4822  lf.endian + "HH"
+000125d0: 2c20 302c 2030 290a 0a20 2020 2020 2020  , 0, 0)..       
+000125e0: 2073 656c 662e 662e 7772 6974 6528 7365   self.f.write(se
+000125f0: 6c66 2e62 7569 6c64 5f62 6c6f 636b 2862  lf.build_block(b
+00012600: 6c6f 636b 5f74 7970 652c 2062 6c6f 636b  lock_type, block
+00012610: 5f69 6462 2c20 6f70 7469 6f6e 733d 6f70  _idb, options=op
+00012620: 7473 2929 0a0a 2020 2020 6465 6620 5f77  ts))..    def _w
+00012630: 7269 7465 5f62 6c6f 636b 5f73 7062 2873  rite_block_spb(s
+00012640: 656c 662c 2072 6177 5f70 6b74 293a 0a20  elf, raw_pkt):. 
+00012650: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+00012660: 6279 7465 7329 202d 3e20 4e6f 6e65 0a0a  bytes) -> None..
+00012670: 2020 2020 2020 2020 2320 426c 6f63 6b20          # Block 
+00012680: 5479 7065 0a20 2020 2020 2020 2062 6c6f  Type.        blo
+00012690: 636b 5f74 7970 6520 3d20 7374 7275 6374  ck_type = struct
+000126a0: 2e70 6163 6b28 7365 6c66 2e65 6e64 6961  .pack(self.endia
+000126b0: 6e20 2b20 2249 222c 2033 290a 2020 2020  n + "I", 3).    
+000126c0: 2020 2020 2320 4f72 6967 696e 616c 2050      # Original P
+000126d0: 6163 6b65 7420 4c65 6e67 7468 0a20 2020  acket Length.   
+000126e0: 2020 2020 2062 6c6f 636b 5f73 7062 203d       block_spb =
+000126f0: 2073 7472 7563 742e 7061 636b 2873 656c   struct.pack(sel
+00012700: 662e 656e 6469 616e 202b 2022 4922 2c20  f.endian + "I", 
+00012710: 6c65 6e28 7261 775f 706b 7429 290a 2020  len(raw_pkt)).  
+00012720: 2020 2020 2020 2320 5061 636b 6574 2044        # Packet D
+00012730: 6174 610a 2020 2020 2020 2020 626c 6f63  ata.        bloc
+00012740: 6b5f 7370 6220 2b3d 2072 6177 5f70 6b74  k_spb += raw_pkt
+00012750: 0a0a 2020 2020 2020 2020 7365 6c66 2e66  ..        self.f
+00012760: 2e77 7269 7465 2873 656c 662e 6275 696c  .write(self.buil
+00012770: 645f 626c 6f63 6b28 626c 6f63 6b5f 7479  d_block(block_ty
+00012780: 7065 2c20 626c 6f63 6b5f 7370 6229 290a  pe, block_spb)).
+00012790: 0a20 2020 2064 6566 205f 7772 6974 655f  .    def _write_
+000127a0: 626c 6f63 6b5f 6570 6228 7365 6c66 2c0a  block_epb(self,.
+000127b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000127c0: 2020 2020 2020 2020 2072 6177 5f70 6b74           raw_pkt
+000127d0: 2c20 2023 2074 7970 653a 2062 7974 6573  ,  # type: bytes
+000127e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000127f0: 2020 2020 2020 2020 2020 6966 6964 2c20            ifid, 
+00012800: 2023 2074 7970 653a 2069 6e74 0a20 2020   # type: int.   
+00012810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012820: 2020 2020 2020 7469 6d65 7374 616d 703d        timestamp=
+00012830: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
+00012840: 7074 696f 6e61 6c5b 556e 696f 6e5b 4544  ptional[Union[ED
+00012850: 6563 696d 616c 2c20 666c 6f61 745d 5d20  ecimal, float]] 
+00012860: 2023 206e 6f71 613a 2045 3530 310a 2020   # noqa: E501.  
+00012870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012880: 2020 2020 2020 2063 6170 6c65 6e3d 4e6f         caplen=No
+00012890: 6e65 2c20 2023 2074 7970 653a 204f 7074  ne,  # type: Opt
+000128a0: 696f 6e61 6c5b 696e 745d 0a20 2020 2020  ional[int].     
+000128b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000128c0: 2020 2020 6f72 676c 656e 3d4e 6f6e 652c      orglen=None,
+000128d0: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
+000128e0: 616c 5b69 6e74 5d0a 2020 2020 2020 2020  al[int].        
+000128f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012900: 2063 6f6d 6d65 6e74 3d4e 6f6e 652c 2020   comment=None,  
+00012910: 2320 7479 7065 3a20 4f70 7469 6f6e 616c  # type: Optional
+00012920: 5b62 7974 6573 5d0a 2020 2020 2020 2020  [bytes].        
+00012930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012940: 2066 6c61 6773 3d4e 6f6e 652c 2020 2320   flags=None,  # 
+00012950: 7479 7065 3a20 4f70 7469 6f6e 616c 5b69  type: Optional[i
+00012960: 6e74 5d0a 2020 2020 2020 2020 2020 2020  nt].            
+00012970: 2020 2020 2020 2020 2020 2020 2029 3a0a               ):.
+00012980: 2020 2020 2020 2020 2320 7479 7065 3a20          # type: 
+00012990: 282e 2e2e 2920 2d3e 204e 6f6e 650a 0a20  (...) -> None.. 
+000129a0: 2020 2020 2020 2069 6620 7469 6d65 7374         if timest
+000129b0: 616d 703a 0a20 2020 2020 2020 2020 2020  amp:.           
+000129c0: 2074 6d70 5f74 7320 3d20 696e 7428 7469   tmp_ts = int(ti
+000129d0: 6d65 7374 616d 7020 2a20 7365 6c66 2e74  mestamp * self.t
+000129e0: 7372 6573 6f6c 290a 2020 2020 2020 2020  sresol).        
+000129f0: 2020 2020 7473 5f68 6967 6820 3d20 746d      ts_high = tm
+00012a00: 705f 7473 203e 3e20 3332 0a20 2020 2020  p_ts >> 32.     
+00012a10: 2020 2020 2020 2074 735f 6c6f 7720 3d20         ts_low = 
+00012a20: 746d 705f 7473 2026 2030 7846 4646 4646  tmp_ts & 0xFFFFF
+00012a30: 4646 460a 2020 2020 2020 2020 656c 7365  FFF.        else
+00012a40: 3a0a 2020 2020 2020 2020 2020 2020 7473  :.            ts
+00012a50: 5f68 6967 6820 3d20 7473 5f6c 6f77 203d  _high = ts_low =
+00012a60: 2030 0a0a 2020 2020 2020 2020 6966 206e   0..        if n
+00012a70: 6f74 2063 6170 6c65 6e3a 0a20 2020 2020  ot caplen:.     
+00012a80: 2020 2020 2020 2063 6170 6c65 6e20 3d20         caplen = 
+00012a90: 6c65 6e28 7261 775f 706b 7429 0a0a 2020  len(raw_pkt)..  
+00012aa0: 2020 2020 2020 6966 206e 6f74 206f 7267        if not org
+00012ab0: 6c65 6e3a 0a20 2020 2020 2020 2020 2020  len:.           
+00012ac0: 206f 7267 6c65 6e20 3d20 6c65 6e28 7261   orglen = len(ra
+00012ad0: 775f 706b 7429 0a0a 2020 2020 2020 2020  w_pkt)..        
+00012ae0: 2320 426c 6f63 6b20 5479 7065 0a20 2020  # Block Type.   
+00012af0: 2020 2020 2062 6c6f 636b 5f74 7970 6520       block_type 
+00012b00: 3d20 7374 7275 6374 2e70 6163 6b28 7365  = struct.pack(se
+00012b10: 6c66 2e65 6e64 6961 6e20 2b20 2249 222c  lf.endian + "I",
+00012b20: 2036 290a 2020 2020 2020 2020 2320 496e   6).        # In
+00012b30: 7465 7266 6163 6520 4944 0a20 2020 2020  terface ID.     
+00012b40: 2020 2062 6c6f 636b 5f65 7062 203d 2073     block_epb = s
+00012b50: 7472 7563 742e 7061 636b 2873 656c 662e  truct.pack(self.
+00012b60: 656e 6469 616e 202b 2022 4922 2c20 6966  endian + "I", if
+00012b70: 6964 290a 2020 2020 2020 2020 2320 5469  id).        # Ti
+00012b80: 6d65 7374 616d 7020 2848 6967 6829 0a20  mestamp (High). 
+00012b90: 2020 2020 2020 2062 6c6f 636b 5f65 7062         block_epb
+00012ba0: 202b 3d20 7374 7275 6374 2e70 6163 6b28   += struct.pack(
+00012bb0: 7365 6c66 2e65 6e64 6961 6e20 2b20 2249  self.endian + "I
+00012bc0: 222c 2074 735f 6869 6768 290a 2020 2020  ", ts_high).    
+00012bd0: 2020 2020 2320 5469 6d65 7374 616d 7020      # Timestamp 
+00012be0: 284c 6f77 290a 2020 2020 2020 2020 626c  (Low).        bl
+00012bf0: 6f63 6b5f 6570 6220 2b3d 2073 7472 7563  ock_epb += struc
+00012c00: 742e 7061 636b 2873 656c 662e 656e 6469  t.pack(self.endi
+00012c10: 616e 202b 2022 4922 2c20 7473 5f6c 6f77  an + "I", ts_low
+00012c20: 290a 2020 2020 2020 2020 2320 4361 7074  ).        # Capt
+00012c30: 7572 6564 2050 6163 6b65 7420 4c65 6e67  ured Packet Leng
+00012c40: 7468 0a20 2020 2020 2020 2062 6c6f 636b  th.        block
+00012c50: 5f65 7062 202b 3d20 7374 7275 6374 2e70  _epb += struct.p
+00012c60: 6163 6b28 7365 6c66 2e65 6e64 6961 6e20  ack(self.endian 
+00012c70: 2b20 2249 222c 2063 6170 6c65 6e29 0a20  + "I", caplen). 
+00012c80: 2020 2020 2020 2023 204f 7269 6769 6e61         # Origina
+00012c90: 6c20 5061 636b 6574 204c 656e 6774 680a  l Packet Length.
+00012ca0: 2020 2020 2020 2020 626c 6f63 6b5f 6570          block_ep
+00012cb0: 6220 2b3d 2073 7472 7563 742e 7061 636b  b += struct.pack
+00012cc0: 2873 656c 662e 656e 6469 616e 202b 2022  (self.endian + "
+00012cd0: 4922 2c20 6f72 676c 656e 290a 2020 2020  I", orglen).    
+00012ce0: 2020 2020 2320 5061 636b 6574 2044 6174      # Packet Dat
+00012cf0: 610a 2020 2020 2020 2020 626c 6f63 6b5f  a.        block_
+00012d00: 6570 6220 2b3d 2072 6177 5f70 6b74 0a0a  epb += raw_pkt..
+00012d10: 2020 2020 2020 2020 2320 4f70 7469 6f6e          # Option
+00012d20: 730a 2020 2020 2020 2020 6f70 7473 203d  s.        opts =
+00012d30: 2062 2727 0a20 2020 2020 2020 2069 6620   b''.        if 
+00012d40: 636f 6d6d 656e 7420 6973 206e 6f74 204e  comment is not N
+00012d50: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00012d60: 2063 6f6d 6d65 6e74 203d 2062 7974 6573   comment = bytes
+00012d70: 5f65 6e63 6f64 6528 636f 6d6d 656e 7429  _encode(comment)
+00012d80: 0a20 2020 2020 2020 2020 2020 206f 7074  .            opt
+00012d90: 7320 2b3d 2073 7472 7563 742e 7061 636b  s += struct.pack
+00012da0: 2873 656c 662e 656e 6469 616e 202b 2022  (self.endian + "
+00012db0: 4848 222c 2031 2c20 6c65 6e28 636f 6d6d  HH", 1, len(comm
+00012dc0: 656e 7429 290a 2020 2020 2020 2020 2020  ent)).          
+00012dd0: 2020 2320 5061 6420 4f70 7469 6f6e 2056    # Pad Option V
+00012de0: 616c 7565 2074 6f20 3332 2062 6974 730a  alue to 32 bits.
+00012df0: 2020 2020 2020 2020 2020 2020 6f70 7473              opts
+00012e00: 202b 3d20 7365 6c66 2e5f 6164 645f 7061   += self._add_pa
+00012e10: 6464 696e 6728 636f 6d6d 656e 7429 0a20  dding(comment). 
+00012e20: 2020 2020 2020 2069 6620 7479 7065 2866         if type(f
+00012e30: 6c61 6773 2920 3d3d 2069 6e74 3a0a 2020  lags) == int:.  
+00012e40: 2020 2020 2020 2020 2020 6f70 7473 202b            opts +
+00012e50: 3d20 7374 7275 6374 2e70 6163 6b28 7365  = struct.pack(se
+00012e60: 6c66 2e65 6e64 6961 6e20 2b20 2248 4822  lf.endian + "HH"
+00012e70: 2c20 322c 2034 290a 2020 2020 2020 2020  , 2, 4).        
+00012e80: 2020 2020 6f70 7473 202b 3d20 7374 7275      opts += stru
+00012e90: 6374 2e70 6163 6b28 7365 6c66 2e65 6e64  ct.pack(self.end
+00012ea0: 6961 6e20 2b20 2249 222c 2066 6c61 6773  ian + "I", flags
+00012eb0: 290a 2020 2020 2020 2020 6966 206f 7074  ).        if opt
+00012ec0: 733a 0a20 2020 2020 2020 2020 2020 206f  s:.            o
+00012ed0: 7074 7320 2b3d 2073 7472 7563 742e 7061  pts += struct.pa
+00012ee0: 636b 2873 656c 662e 656e 6469 616e 202b  ck(self.endian +
+00012ef0: 2022 4848 222c 2030 2c20 3029 0a0a 2020   "HH", 0, 0)..  
+00012f00: 2020 2020 2020 7365 6c66 2e66 2e77 7269        self.f.wri
+00012f10: 7465 2873 656c 662e 6275 696c 645f 626c  te(self.build_bl
+00012f20: 6f63 6b28 626c 6f63 6b5f 7479 7065 2c20  ock(block_type, 
+00012f30: 626c 6f63 6b5f 6570 622c 0a20 2020 2020  block_epb,.     
+00012f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012f60: 206f 7074 696f 6e73 3d6f 7074 7329 290a   options=opts)).
+00012f70: 0a20 2020 2064 6566 205f 7772 6974 655f  .    def _write_
+00012f80: 7061 636b 6574 2873 656c 662c 2020 2320  packet(self,  # 
+00012f90: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+00012fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012fb0: 2020 2070 6163 6b65 742c 2020 2320 7479     packet,  # ty
+00012fc0: 7065 3a20 6279 7465 730a 2020 2020 2020  pe: bytes.      
+00012fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012fe0: 6c69 6e6b 7479 7065 2c20 2023 2074 7970  linktype,  # typ
+00012ff0: 653a 2069 6e74 0a20 2020 2020 2020 2020  e: int.         
+00013000: 2020 2020 2020 2020 2020 2020 2073 6563               sec
+00013010: 3d4e 6f6e 652c 2020 2320 7479 7065 3a20  =None,  # type: 
+00013020: 4f70 7469 6f6e 616c 5b66 6c6f 6174 5d0a  Optional[float].
+00013030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013040: 2020 2020 2020 7573 6563 3d4e 6f6e 652c        usec=None,
+00013050: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
+00013060: 616c 5b69 6e74 5d0a 2020 2020 2020 2020  al[int].        
+00013070: 2020 2020 2020 2020 2020 2020 2020 6361                ca
+00013080: 706c 656e 3d4e 6f6e 652c 2020 2320 7479  plen=None,  # ty
+00013090: 7065 3a20 4f70 7469 6f6e 616c 5b69 6e74  pe: Optional[int
+000130a0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000130b0: 2020 2020 2020 2020 7769 7265 6c65 6e3d          wirelen=
+000130c0: 4e6f 6e65 2c20 2023 2074 7970 653a 204f  None,  # type: O
+000130d0: 7074 696f 6e61 6c5b 696e 745d 0a20 2020  ptional[int].   
+000130e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000130f0: 2020 2063 6f6d 6d65 6e74 3d4e 6f6e 652c     comment=None,
+00013100: 2020 2320 7479 7065 3a20 4f70 7469 6f6e    # type: Option
+00013110: 616c 5b62 7974 6573 5d0a 2020 2020 2020  al[bytes].      
+00013120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013130: 6966 6e61 6d65 3d4e 6f6e 652c 2020 2320  ifname=None,  # 
+00013140: 7479 7065 3a20 4f70 7469 6f6e 616c 5b62  type: Optional[b
+00013150: 7974 6573 5d0a 2020 2020 2020 2020 2020  ytes].          
+00013160: 2020 2020 2020 2020 2020 2020 6469 7265              dire
+00013170: 6374 696f 6e3d 4e6f 6e65 2c20 2023 2074  ction=None,  # t
+00013180: 7970 653a 204f 7074 696f 6e61 6c5b 696e  ype: Optional[in
+00013190: 745d 0a20 2020 2020 2020 2020 2020 2020  t].             
+000131a0: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
+000131b0: 2020 2020 2320 7479 7065 3a20 282e 2e2e      # type: (...
+000131c0: 2920 2d3e 204e 6f6e 650a 2020 2020 2020  ) -> None.      
+000131d0: 2020 2222 220a 2020 2020 2020 2020 5772    """.        Wr
+000131e0: 6974 6573 2061 2073 696e 676c 6520 7061  ites a single pa
+000131f0: 636b 6574 2074 6f20 7468 6520 7063 6170  cket to the pcap
+00013200: 2066 696c 652e 0a0a 2020 2020 2020 2020   file...        
+00013210: 3a70 6172 616d 2070 6163 6b65 743a 2062  :param packet: b
+00013220: 7974 6573 2066 6f72 2061 2073 696e 676c  ytes for a singl
+00013230: 6520 7061 636b 6574 0a20 2020 2020 2020  e packet.       
+00013240: 203a 7479 7065 2070 6163 6b65 743a 2062   :type packet: b
+00013250: 7974 6573 0a20 2020 2020 2020 203a 7061  ytes.        :pa
+00013260: 7261 6d20 6c69 6e6b 7479 7065 3a20 6c69  ram linktype: li
+00013270: 6e6b 7479 7065 2076 616c 7565 2061 7373  nktype value ass
+00013280: 6f63 6961 7465 6420 7769 7468 2074 6865  ociated with the
+00013290: 2070 6163 6b65 740a 2020 2020 2020 2020   packet.        
+000132a0: 3a74 7970 6520 6c69 6e6b 7479 7065 3a20  :type linktype: 
+000132b0: 696e 740a 2020 2020 2020 2020 3a70 6172  int.        :par
+000132c0: 616d 2073 6563 3a20 7469 6d65 2074 6865  am sec: time the
+000132d0: 2070 6163 6b65 7420 7761 7320 6361 7074   packet was capt
+000132e0: 7572 6564 2c20 696e 2073 6563 6f6e 6473  ured, in seconds
+000132f0: 2073 696e 6365 2065 706f 6368 2e20 4966   since epoch. If
+00013300: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013310: 2020 2020 206e 6f74 2073 7570 706c 6965       not supplie
+00013320: 642c 2064 6566 6175 6c74 7320 746f 206e  d, defaults to n
+00013330: 6f77 2e0a 2020 2020 2020 2020 3a74 7970  ow..        :typ
+00013340: 6520 7365 633a 2066 6c6f 6174 0a20 2020  e sec: float.   
+00013350: 2020 2020 203a 7061 7261 6d20 6361 706c       :param capl
+00013360: 656e 3a20 5468 6520 6c65 6e67 7468 206f  en: The length o
+00013370: 6620 7468 6520 7061 636b 6574 2069 6e20  f the packet in 
+00013380: 7468 6520 6361 7074 7572 6520 6669 6c65  the capture file
+00013390: 2e20 4966 206e 6f74 0a20 2020 2020 2020  . If not.       
+000133a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000133b0: 7370 6563 6966 6965 642c 2075 7365 7320  specified, uses 
+000133c0: 6060 6c65 6e28 7061 636b 6574 2960 602e  ``len(packet)``.
+000133d0: 0a20 2020 2020 2020 203a 7479 7065 2063  .        :type c
+000133e0: 6170 6c65 6e3a 2069 6e74 0a20 2020 2020  aplen: int.     
+000133f0: 2020 203a 7061 7261 6d20 7769 7265 6c65     :param wirele
+00013400: 6e3a 2054 6865 206c 656e 6774 6820 6f66  n: The length of
+00013410: 2074 6865 2070 6163 6b65 7420 6f6e 2074   the packet on t
+00013420: 6865 2077 6972 652e 2049 6620 6e6f 740a  he wire. If not.
+00013430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013440: 2020 2020 2020 2020 7370 6563 6966 6965          specifie
+00013450: 642c 2075 7365 7320 6060 6361 706c 656e  d, uses ``caplen
+00013460: 6060 2e0a 2020 2020 2020 2020 3a74 7970  ``..        :typ
+00013470: 6520 7769 7265 6c65 6e3a 2069 6e74 0a20  e wirelen: int. 
+00013480: 2020 2020 2020 203a 7061 7261 6d20 636f         :param co
+00013490: 6d6d 656e 743a 2055 5446 2d38 2073 7472  mment: UTF-8 str
+000134a0: 696e 6720 636f 6e74 6169 6e69 6e67 2068  ing containing h
+000134b0: 756d 616e 2d72 6561 6461 626c 6520 636f  uman-readable co
+000134c0: 6d6d 656e 7420 7465 7874 0a20 2020 2020  mment text.     
+000134d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000134e0: 2020 2074 6861 7420 6973 2061 7373 6f63     that is assoc
+000134f0: 6961 7465 6420 746f 2074 6865 2063 7572  iated to the cur
+00013500: 7265 6e74 2062 6c6f 636b 2e20 4c69 6e65  rent block. Line
+00013510: 2073 6570 6172 6174 6f72 730a 2020 2020   separators.    
+00013520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013530: 2020 2020 5348 4f55 4c44 2062 6520 6120      SHOULD be a 
+00013540: 6361 7272 6961 6765 2d72 6574 7572 6e20  carriage-return 
+00013550: 2b20 6c69 6e65 6665 6564 2028 275c 725c  + linefeed ('\r\
+00013560: 6e27 2920 6f72 0a20 2020 2020 2020 2020  n') or.         
+00013570: 2020 2020 2020 2020 2020 2020 2020 206a                 j
+00013580: 7573 7420 6c69 6e65 6665 6564 2028 275c  ust linefeed ('\
+00013590: 6e27 293b 2065 6974 6865 7220 666f 726d  n'); either form
+000135a0: 206d 6179 2061 7070 6561 7220 616e 640a   may appear and.
+000135b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000135c0: 2020 2020 2020 2020 6265 2063 6f6e 7369          be consi
+000135d0: 6465 7265 6420 6120 6c69 6e65 2073 6570  dered a line sep
+000135e0: 6172 6174 6f72 2e20 5468 6520 7374 7269  arator. The stri
+000135f0: 6e67 2069 7320 6e6f 740a 2020 2020 2020  ng is not.      
+00013600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013610: 2020 7a65 726f 2d74 6572 6d69 6e61 7465    zero-terminate
+00013620: 642e 0a20 2020 2020 2020 203a 7479 7065  d..        :type
+00013630: 2062 7974 6573 0a20 2020 2020 2020 203a   bytes.        :
+00013640: 7061 7261 6d20 6966 6e61 6d65 3a20 5554  param ifname: UT
+00013650: 462d 3820 7374 7269 6e67 2063 6f6e 7461  F-8 string conta
+00013660: 696e 696e 6720 7468 650a 2020 2020 2020  ining the.      
+00013670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013680: 206e 616d 6520 6f66 2074 6865 2064 6576   name of the dev
+00013690: 6963 6520 7573 6564 2074 6f20 6361 7074  ice used to capt
+000136a0: 7572 6520 6461 7461 2e0a 2020 2020 2020  ure data..      
+000136b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000136c0: 2054 6865 2073 7472 696e 6720 6973 206e   The string is n
+000136d0: 6f74 207a 6572 6f2d 7465 726d 696e 6174  ot zero-terminat
+000136e0: 6564 2e0a 2020 2020 2020 2020 3a74 7970  ed..        :typ
+000136f0: 6520 6279 7465 730a 2020 2020 2020 2020  e bytes.        
+00013700: 3a70 6172 616d 2064 6972 6563 7469 6f6e  :param direction
+00013710: 3a20 2030 203d 2069 6e66 6f72 6d61 7469  :  0 = informati
+00013720: 6f6e 206e 6f74 2061 7661 696c 6162 6c65  on not available
+00013730: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013740: 2020 2020 2020 2020 2020 2020 2031 203d               1 =
+00013750: 2069 6e62 6f75 6e64 2c0a 2020 2020 2020   inbound,.      
+00013760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013770: 2020 2020 2032 203d 206f 7574 626f 756e       2 = outboun
+00013780: 640a 2020 2020 2020 2020 3a74 7970 6520  d.        :type 
+00013790: 696e 740a 2020 2020 2020 2020 3a72 6574  int.        :ret
+000137a0: 7572 6e3a 204e 6f6e 650a 2020 2020 2020  urn: None.      
+000137b0: 2020 3a72 7479 7065 3a20 4e6f 6e65 0a20    :rtype: None. 
+000137c0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+000137d0: 2020 2069 6620 6361 706c 656e 2069 7320     if caplen is 
+000137e0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+000137f0: 2020 6361 706c 656e 203d 206c 656e 2870    caplen = len(p
+00013800: 6163 6b65 7429 0a20 2020 2020 2020 2069  acket).        i
+00013810: 6620 7769 7265 6c65 6e20 6973 204e 6f6e  f wirelen is Non
+00013820: 653a 0a20 2020 2020 2020 2020 2020 2077  e:.            w
+00013830: 6972 656c 656e 203d 2063 6170 6c65 6e0a  irelen = caplen.
+00013840: 0a20 2020 2020 2020 2069 6669 6420 3d20  .        ifid = 
+00013850: 7365 6c66 2e69 6e74 6572 6661 6365 7332  self.interfaces2
+00013860: 6964 2e67 6574 2869 666e 616d 652c 204e  id.get(ifname, N
+00013870: 6f6e 6529 0a20 2020 2020 2020 2069 6620  one).        if 
+00013880: 6966 6964 2069 7320 4e6f 6e65 3a0a 2020  ifid is None:.  
+00013890: 2020 2020 2020 2020 2020 6966 6964 203d            ifid =
+000138a0: 206d 6178 2873 656c 662e 696e 7465 7266   max(self.interf
+000138b0: 6163 6573 3269 642e 7661 6c75 6573 2829  aces2id.values()
+000138c0: 2920 2b20 310a 2020 2020 2020 2020 2020  ) + 1.          
+000138d0: 2020 7365 6c66 2e69 6e74 6572 6661 6365    self.interface
+000138e0: 7332 6964 5b69 666e 616d 655d 203d 2069  s2id[ifname] = i
+000138f0: 6669 640a 2020 2020 2020 2020 2020 2020  fid.            
+00013900: 7365 6c66 2e5f 7772 6974 655f 626c 6f63  self._write_bloc
+00013910: 6b5f 6964 6228 6c69 6e6b 7479 7065 3d6c  k_idb(linktype=l
+00013920: 696e 6b74 7970 652c 2069 666e 616d 653d  inktype, ifname=
+00013930: 6966 6e61 6d65 290a 0a20 2020 2020 2020  ifname)..       
+00013940: 2023 2045 5042 2066 6c61 6773 2028 3332   # EPB flags (32
+00013950: 2062 6974 7329 2e0a 2020 2020 2020 2020   bits)..        
+00013960: 2320 6375 7272 656e 746c 7920 6f6e 6c79  # currently only
+00013970: 2064 6972 6563 7469 6f6e 2069 7320 696d   direction is im
+00013980: 706c 656d 656e 7465 6420 286c 6561 7374  plemented (least
+00013990: 2032 2073 6967 6e69 6669 6361 6e74 2062   2 significant b
+000139a0: 6974 7329 0a20 2020 2020 2020 2069 6620  its).        if 
+000139b0: 7479 7065 2864 6972 6563 7469 6f6e 2920  type(direction) 
+000139c0: 3d3d 2069 6e74 3a0a 2020 2020 2020 2020  == int:.        
+000139d0: 2020 2020 666c 6167 7320 3d20 6469 7265      flags = dire
+000139e0: 6374 696f 6e20 2620 3078 330a 2020 2020  ction & 0x3.    
+000139f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00013a00: 2020 2020 2020 666c 6167 7320 3d20 4e6f        flags = No
+00013a10: 6e65 0a0a 2020 2020 2020 2020 7365 6c66  ne..        self
+00013a20: 2e5f 7772 6974 655f 626c 6f63 6b5f 6570  ._write_block_ep
+00013a30: 6228 7061 636b 6574 2c20 7469 6d65 7374  b(packet, timest
+00013a40: 616d 703d 7365 632c 2063 6170 6c65 6e3d  amp=sec, caplen=
+00013a50: 6361 706c 656e 2c0a 2020 2020 2020 2020  caplen,.        
+00013a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013a70: 2020 2020 2020 6f72 676c 656e 3d77 6972        orglen=wir
+00013a80: 656c 656e 2c20 636f 6d6d 656e 743d 636f  elen, comment=co
+00013a90: 6d6d 656e 742c 2069 6669 643d 6966 6964  mment, ifid=ifid
+00013aa0: 2c20 666c 6167 733d 666c 6167 7329 0a20  , flags=flags). 
+00013ab0: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+00013ac0: 796e 633a 0a20 2020 2020 2020 2020 2020  ync:.           
+00013ad0: 2073 656c 662e 662e 666c 7573 6828 290a   self.f.flush().
+00013ae0: 0a0a 636c 6173 7320 5063 6170 5772 6974  ..class PcapWrit
+00013af0: 6572 2852 6177 5063 6170 5772 6974 6572  er(RawPcapWriter
+00013b00: 293a 0a20 2020 2022 2222 4120 7374 7265  ):.    """A stre
+00013b10: 616d 2050 4341 5020 7772 6974 6572 2077  am PCAP writer w
+00013b20: 6974 6820 6d6f 7265 2063 6f6e 7472 6f6c  ith more control
+00013b30: 2074 6861 6e20 7772 7063 6170 2829 2222   than wrpcap()""
+00013b40: 220a 2020 2020 7061 7373 0a0a 0a63 6c61  ".    pass...cla
+00013b50: 7373 2050 6361 704e 6757 7269 7465 7228  ss PcapNgWriter(
+00013b60: 5261 7750 6361 704e 6757 7269 7465 7229  RawPcapNgWriter)
+00013b70: 3a0a 2020 2020 2222 2241 2073 7472 6561  :.    """A strea
+00013b80: 6d20 7063 6170 6e67 2077 7269 7465 7220  m pcapng writer 
+00013b90: 7769 7468 206d 6f72 6520 636f 6e74 726f  with more contro
+00013ba0: 6c20 7468 616e 2077 7270 6361 706e 6728  l than wrpcapng(
+00013bb0: 2922 2222 0a0a 2020 2020 6465 6620 5f67  )"""..    def _g
+00013bc0: 6574 5f74 696d 6528 7365 6c66 2c0a 2020  et_time(self,.  
+00013bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013be0: 7061 636b 6574 2c20 2023 2074 7970 653a  packet,  # type:
+00013bf0: 2055 6e69 6f6e 5b62 7974 6573 2c20 5061   Union[bytes, Pa
+00013c00: 636b 6574 5d0a 2020 2020 2020 2020 2020  cket].          
+00013c10: 2020 2020 2020 2020 7365 632c 2020 2320          sec,  # 
+00013c20: 7479 7065 3a20 4f70 7469 6f6e 616c 5b66  type: Optional[f
+00013c30: 6c6f 6174 5d0a 2020 2020 2020 2020 2020  loat].          
+00013c40: 2020 2020 2020 2020 7573 6563 2020 2320          usec  # 
+00013c50: 7479 7065 3a20 4f70 7469 6f6e 616c 5b69  type: Optional[i
+00013c60: 6e74 5d0a 2020 2020 2020 2020 2020 2020  nt].            
+00013c70: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+00013c80: 2023 2074 7970 653a 2028 2e2e 2e29 202d   # type: (...) -
+00013c90: 3e20 5475 706c 655b 666c 6f61 742c 2069  > Tuple[float, i
+00013ca0: 6e74 5d0a 2020 2020 2020 2020 6966 2068  nt].        if h
+00013cb0: 6173 6174 7472 2870 6163 6b65 742c 2022  asattr(packet, "
+00013cc0: 7469 6d65 2229 3a0a 2020 2020 2020 2020  time"):.        
+00013cd0: 2020 2020 6966 2073 6563 2069 7320 4e6f      if sec is No
+00013ce0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00013cf0: 2020 2020 7365 6320 3d20 666c 6f61 7428      sec = float(
+00013d00: 7061 636b 6574 2e74 696d 6529 0a0a 2020  packet.time)..  
+00013d10: 2020 2020 2020 6966 2075 7365 6320 6973        if usec is
+00013d20: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00013d30: 2020 2075 7365 6320 3d20 300a 0a20 2020     usec = 0..   
+00013d40: 2020 2020 2072 6574 7572 6e20 7365 632c       return sec,
+00013d50: 2075 7365 6320 2023 2074 7970 653a 2069   usec  # type: i
+00013d60: 676e 6f72 650a 0a0a 4063 6f6e 662e 636f  gnore...@conf.co
+00013d70: 6d6d 616e 6473 2e72 6567 6973 7465 720a  mmands.register.
+00013d80: 6465 6620 7264 6572 6628 6669 6c65 6e61  def rderf(filena
+00013d90: 6d65 2c20 636f 756e 743d 2d31 293a 0a20  me, count=-1):. 
+00013da0: 2020 2023 2074 7970 653a 2028 556e 696f     # type: (Unio
+00013db0: 6e5b 494f 5b62 7974 6573 5d2c 2073 7472  n[IO[bytes], str
+00013dc0: 5d2c 2069 6e74 2920 2d3e 2050 6163 6b65  ], int) -> Packe
+00013dd0: 744c 6973 740a 2020 2020 2222 2252 6561  tList.    """Rea
+00013de0: 6420 6120 4552 4620 6669 6c65 2061 6e64  d a ERF file and
+00013df0: 2072 6574 7572 6e20 6120 7061 636b 6574   return a packet
+00013e00: 206c 6973 740a 0a20 2020 203a 7061 7261   list..    :para
+00013e10: 6d20 636f 756e 743a 2072 6561 6420 6f6e  m count: read on
+00013e20: 6c79 203c 636f 756e 743e 2070 6163 6b65  ly <count> packe
+00013e30: 7473 0a20 2020 2022 2222 0a20 2020 2077  ts.    """.    w
+00013e40: 6974 6820 4552 4645 7468 6572 6e65 7452  ith ERFEthernetR
+00013e50: 6561 6465 7228 6669 6c65 6e61 6d65 2920  eader(filename) 
+00013e60: 6173 2066 6465 7363 3a0a 2020 2020 2020  as fdesc:.      
+00013e70: 2020 7265 7475 726e 2066 6465 7363 2e72    return fdesc.r
+00013e80: 6561 645f 616c 6c28 636f 756e 743d 636f  ead_all(count=co
+00013e90: 756e 7429 0a0a 0a63 6c61 7373 2045 5246  unt)...class ERF
+00013ea0: 4574 6865 726e 6574 5265 6164 6572 5f6d  EthernetReader_m
+00013eb0: 6574 6163 6c61 7373 2850 6361 7052 6561  etaclass(PcapRea
+00013ec0: 6465 725f 6d65 7461 636c 6173 7329 3a0a  der_metaclass):.
+00013ed0: 2020 2020 6465 6620 5f5f 6361 6c6c 5f5f      def __call__
+00013ee0: 2863 6c73 2c20 6669 6c65 6e61 6d65 293a  (cls, filename):
+00013ef0: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+00013f00: 2028 556e 696f 6e5b 494f 5b62 7974 6573   (Union[IO[bytes
+00013f10: 5d2c 2073 7472 5d29 202d 3e20 416e 790a  ], str]) -> Any.
+00013f20: 2020 2020 2020 2020 6920 3d20 636c 732e          i = cls.
+00013f30: 5f5f 6e65 775f 5f28 636c 732c 2063 6c73  __new__(cls, cls
+00013f40: 2e5f 5f6e 616d 655f 5f2c 2063 6c73 2e5f  .__name__, cls._
+00013f50: 5f62 6173 6573 5f5f 2c20 636c 732e 5f5f  _bases__, cls.__
+00013f60: 6469 6374 5f5f 2920 2023 2074 7970 653a  dict__)  # type:
+00013f70: 2069 676e 6f72 650a 2020 2020 2020 2020   ignore.        
+00013f80: 6669 6c65 6e61 6d65 2c20 6664 6573 6320  filename, fdesc 
+00013f90: 3d20 636c 732e 6f70 656e 2866 696c 656e  = cls.open(filen
+00013fa0: 616d 6529 0a20 2020 2020 2020 2074 7279  ame).        try
+00013fb0: 3a0a 2020 2020 2020 2020 2020 2020 692e  :.            i.
+00013fc0: 5f5f 696e 6974 5f5f 2866 696c 656e 616d  __init__(filenam
+00013fd0: 652c 2066 6465 7363 290a 2020 2020 2020  e, fdesc).      
+00013fe0: 2020 2020 2020 7265 7475 726e 2069 0a20        return i. 
+00013ff0: 2020 2020 2020 2065 7863 6570 7420 2853         except (S
+00014000: 6361 7079 5f45 7863 6570 7469 6f6e 2c20  capy_Exception, 
+00014010: 454f 4645 7272 6f72 293a 0a20 2020 2020  EOFError):.     
+00014020: 2020 2020 2020 2070 6173 730a 0a20 2020         pass..   
+00014030: 2020 2020 2069 6620 2261 6c74 6572 6e61       if "alterna
+00014040: 7469 7665 2220 696e 2063 6c73 2e5f 5f64  tive" in cls.__d
+00014050: 6963 745f 5f3a 0a20 2020 2020 2020 2020  ict__:.         
+00014060: 2020 2063 6c73 203d 2063 6c73 2e5f 5f64     cls = cls.__d
+00014070: 6963 745f 5f5b 2261 6c74 6572 6e61 7469  ict__["alternati
+00014080: 7665 225d 0a20 2020 2020 2020 2020 2020  ve"].           
+00014090: 2069 203d 2063 6c73 2e5f 5f6e 6577 5f5f   i = cls.__new__
+000140a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000140b0: 2020 636c 732c 0a20 2020 2020 2020 2020    cls,.         
+000140c0: 2020 2020 2020 2063 6c73 2e5f 5f6e 616d         cls.__nam
+000140d0: 655f 5f2c 0a20 2020 2020 2020 2020 2020  e__,.           
+000140e0: 2020 2020 2063 6c73 2e5f 5f62 6173 6573       cls.__bases
+000140f0: 5f5f 2c0a 2020 2020 2020 2020 2020 2020  __,.            
+00014100: 2020 2020 636c 732e 5f5f 6469 6374 5f5f      cls.__dict__
+00014110: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
+00014120: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+00014130: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
+00014140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014150: 692e 5f5f 696e 6974 5f5f 2866 696c 656e  i.__init__(filen
+00014160: 616d 652c 2066 6465 7363 290a 2020 2020  ame, fdesc).    
+00014170: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00014180: 726e 2069 0a20 2020 2020 2020 2020 2020  rn i.           
+00014190: 2065 7863 6570 7420 2853 6361 7079 5f45   except (Scapy_E
+000141a0: 7863 6570 7469 6f6e 2c20 454f 4645 7272  xception, EOFErr
+000141b0: 6f72 293a 0a20 2020 2020 2020 2020 2020  or):.           
+000141c0: 2020 2020 2070 6173 730a 0a20 2020 2020       pass..     
+000141d0: 2020 2072 6169 7365 2053 6361 7079 5f45     raise Scapy_E
+000141e0: 7863 6570 7469 6f6e 2822 4e6f 7420 6120  xception("Not a 
+000141f0: 7375 7070 6f72 7465 6420 6361 7074 7572  supported captur
+00014200: 6520 6669 6c65 2229 0a0a 2020 2020 4073  e file")..    @s
+00014210: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+00014220: 6465 6620 6f70 656e 2866 6e61 6d65 2020  def open(fname  
+00014230: 2320 7479 7065 3a20 6967 6e6f 7265 0a20  # type: ignore. 
+00014240: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
+00014250: 2020 2020 2020 2023 2074 7970 653a 2028         # type: (
+00014260: 2e2e 2e29 202d 3e20 5475 706c 655b 7374  ...) -> Tuple[st
+00014270: 722c 205f 4279 7465 5374 7265 616d 5d0a  r, _ByteStream].
+00014280: 2020 2020 2020 2020 2222 224f 7065 6e20          """Open 
+00014290: 2869 6620 6e65 6365 7373 6172 7929 2066  (if necessary) f
+000142a0: 696c 656e 616d 6522 2222 0a20 2020 2020  ilename""".     
+000142b0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+000142c0: 2866 6e61 6d65 2c20 7374 7229 3a0a 2020  (fname, str):.  
+000142d0: 2020 2020 2020 2020 2020 6669 6c65 6e61            filena
+000142e0: 6d65 203d 2066 6e61 6d65 0a20 2020 2020  me = fname.     
+000142f0: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00014300: 2020 2020 2020 2020 2020 2020 7769 7468              with
+00014310: 2067 7a69 702e 6f70 656e 2866 696c 656e   gzip.open(filen
+00014320: 616d 652c 2022 7262 2229 2061 7320 746d  ame, "rb") as tm
+00014330: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
+00014340: 2020 2020 2020 2074 6d70 2e72 6561 6428         tmp.read(
+00014350: 3129 0a20 2020 2020 2020 2020 2020 2020  1).             
+00014360: 2020 2066 6465 7363 203d 2067 7a69 702e     fdesc = gzip.
+00014370: 6f70 656e 2866 696c 656e 616d 652c 2022  open(filename, "
+00014380: 7262 2229 2020 2320 7479 7065 3a20 5f42  rb")  # type: _B
+00014390: 7974 6553 7472 6561 6d0a 2020 2020 2020  yteStream.      
+000143a0: 2020 2020 2020 6578 6365 7074 2049 4f45        except IOE
+000143b0: 7272 6f72 3a0a 2020 2020 2020 2020 2020  rror:.          
+000143c0: 2020 2020 2020 6664 6573 6320 3d20 6f70        fdesc = op
+000143d0: 656e 2866 696c 656e 616d 652c 2022 7262  en(filename, "rb
+000143e0: 2229 0a0a 2020 2020 2020 2020 656c 7365  ")..        else
+000143f0: 3a0a 2020 2020 2020 2020 2020 2020 6664  :.            fd
+00014400: 6573 6320 3d20 666e 616d 650a 2020 2020  esc = fname.    
+00014410: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
+00014420: 203d 2067 6574 6174 7472 2866 6465 7363   = getattr(fdesc
+00014430: 2c20 226e 616d 6522 2c20 224e 6f20 6e61  , "name", "No na
+00014440: 6d65 2229 0a20 2020 2020 2020 2072 6574  me").        ret
+00014450: 7572 6e20 6669 6c65 6e61 6d65 2c20 6664  urn filename, fd
+00014460: 6573 630a 0a0a 636c 6173 7320 4552 4645  esc...class ERFE
+00014470: 7468 6572 6e65 7452 6561 6465 7228 5063  thernetReader(Pc
+00014480: 6170 5265 6164 6572 2c0a 2020 2020 2020  apReader,.      
+00014490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000144a0: 2020 6d65 7461 636c 6173 733d 4552 4645    metaclass=ERFE
+000144b0: 7468 6572 6e65 7452 6561 6465 725f 6d65  thernetReader_me
+000144c0: 7461 636c 6173 7329 3a0a 0a20 2020 2064  taclass):..    d
+000144d0: 6566 205f 5f69 6e69 745f 5f28 7365 6c66  ef __init__(self
+000144e0: 2c20 6669 6c65 6e61 6d65 2c20 6664 6573  , filename, fdes
+000144f0: 633d 4e6f 6e65 293a 2020 2320 7479 7065  c=None):  # type
+00014500: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+00014510: 2023 2074 7970 653a 2028 556e 696f 6e5b   # type: (Union[
+00014520: 494f 5b62 7974 6573 5d2c 2073 7472 5d2c  IO[bytes], str],
+00014530: 2049 4f5b 6279 7465 735d 2920 2d3e 204e   IO[bytes]) -> N
+00014540: 6f6e 650a 2020 2020 2020 2020 7365 6c66  one.        self
+00014550: 2e66 696c 656e 616d 6520 3d20 6669 6c65  .filename = file
+00014560: 6e61 6d65 2020 2320 7479 7065 3a20 6967  name  # type: ig
+00014570: 6e6f 7265 0a20 2020 2020 2020 2073 656c  nore.        sel
+00014580: 662e 6620 3d20 6664 6573 630a 2020 2020  f.f = fdesc.    
+00014590: 2020 2020 7365 6c66 2e70 6f77 6572 203d      self.power =
+000145a0: 2044 6563 696d 616c 2831 3029 202a 2a20   Decimal(10) ** 
+000145b0: 4465 6369 6d61 6c28 2d39 290a 0a20 2020  Decimal(-9)..   
+000145c0: 2023 2074 696d 6520 6973 2069 6e20 3634   # time is in 64
+000145d0: 2d62 6974 7320 456e 6461 6365 2773 2066  -bits Endace's f
+000145e0: 6f72 6d61 7420 7768 6963 6820 6361 6e20  ormat which can 
+000145f0: 6265 2073 6565 2068 6572 653a 0a20 2020  be see here:.   
+00014600: 2023 2068 7474 7073 3a2f 2f77 7777 2e65   # https://www.e
+00014610: 6e64 6163 652e 636f 6d2f 6572 662d 6578  ndace.com/erf-ex
+00014620: 7465 6e73 6962 6c65 2d72 6563 6f72 642d  tensible-record-
+00014630: 666f 726d 6174 2d74 7970 6573 2e70 6466  format-types.pdf
+00014640: 0a20 2020 2064 6566 205f 636f 6e76 6572  .    def _conver
+00014650: 745f 6572 665f 7469 6d65 7374 616d 7028  t_erf_timestamp(
+00014660: 7365 6c66 2c20 7429 3a0a 2020 2020 2020  self, t):.      
+00014670: 2020 2320 7479 7065 3a20 2869 6e74 2920    # type: (int) 
+00014680: 2d3e 2045 4465 6369 6d61 6c0a 2020 2020  -> EDecimal.    
+00014690: 2020 2020 7365 6320 3d20 7420 3e3e 2033      sec = t >> 3
+000146a0: 320a 2020 2020 2020 2020 6672 6163 5f73  2.        frac_s
+000146b0: 6563 203d 2074 2026 2030 7866 6666 6666  ec = t & 0xfffff
+000146c0: 6666 660a 2020 2020 2020 2020 6672 6163  fff.        frac
+000146d0: 5f73 6563 202a 3d20 3130 2a2a 390a 2020  _sec *= 10**9.  
+000146e0: 2020 2020 2020 6672 6163 5f73 6563 202b        frac_sec +
+000146f0: 3d20 2866 7261 635f 7365 6320 2620 3078  = (frac_sec & 0x
+00014700: 3830 3030 3030 3030 2920 3c3c 2031 0a20  80000000) << 1. 
+00014710: 2020 2020 2020 2066 7261 635f 7365 6320         frac_sec 
+00014720: 3e3e 3d20 3332 0a20 2020 2020 2020 2072  >>= 32.        r
+00014730: 6574 7572 6e20 4544 6563 696d 616c 2873  eturn EDecimal(s
+00014740: 6563 202b 2073 656c 662e 706f 7765 7220  ec + self.power 
+00014750: 2a20 6672 6163 5f73 6563 290a 0a20 2020  * frac_sec)..   
+00014760: 2023 2054 6865 2064 6574 6169 6c73 206f   # The details o
+00014770: 6620 4552 4620 5061 636b 6574 2066 6f72  f ERF Packet for
+00014780: 6d61 7420 6361 6e20 6265 2073 6565 2068  mat can be see h
+00014790: 6572 653a 0a20 2020 2023 2068 7474 7073  ere:.    # https
+000147a0: 3a2f 2f77 7777 2e65 6e64 6163 652e 636f  ://www.endace.co
+000147b0: 6d2f 6572 662d 6578 7465 6e73 6962 6c65  m/erf-extensible
+000147c0: 2d72 6563 6f72 642d 666f 726d 6174 2d74  -record-format-t
+000147d0: 7970 6573 2e70 6466 0a20 2020 2064 6566  ypes.pdf.    def
+000147e0: 2072 6561 645f 7061 636b 6574 2873 656c   read_packet(sel
+000147f0: 662c 2073 697a 653d 4d54 552c 202a 2a6b  f, size=MTU, **k
+00014800: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+00014810: 2320 7479 7065 3a20 2869 6e74 2c20 2a2a  # type: (int, **
+00014820: 416e 7929 202d 3e20 5061 636b 6574 0a0a  Any) -> Packet..
+00014830: 2020 2020 2020 2020 2320 4765 6e65 7261          # Genera
+00014840: 6c20 4552 4620 4865 6164 6572 2068 6176  l ERF Header hav
+00014850: 6520 6578 6163 746c 7920 3136 2062 7974  e exactly 16 byt
+00014860: 6573 0a20 2020 2020 2020 2068 6472 203d  es.        hdr =
+00014870: 2073 656c 662e 662e 7265 6164 2831 3629   self.f.read(16)
+00014880: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+00014890: 6864 7229 203c 2031 363a 0a20 2020 2020  hdr) < 16:.     
+000148a0: 2020 2020 2020 2072 6169 7365 2045 4f46         raise EOF
+000148b0: 4572 726f 720a 0a20 2020 2020 2020 2023  Error..        #
+000148c0: 2054 6865 2074 696d 6573 7461 6d70 2069   The timestamp i
+000148d0: 7320 696e 206c 6974 746c 652d 656e 6469  s in little-endi
+000148e0: 616e 2062 7974 652d 6f72 6465 722e 0a20  an byte-order.. 
+000148f0: 2020 2020 2020 2074 696d 6520 3d20 7374         time = st
+00014900: 7275 6374 2e75 6e70 6163 6b28 273c 5127  ruct.unpack('<Q'
+00014910: 2c20 6864 725b 3a38 5d29 5b30 5d0a 2020  , hdr[:8])[0].  
+00014920: 2020 2020 2020 2320 5468 6520 7265 7374        # The rest
+00014930: 2069 7320 696e 2062 6967 2d65 6e64 6961   is in big-endia
+00014940: 6e20 6279 7465 2d6f 7264 6572 2e0a 2020  n byte-order..  
+00014950: 2020 2020 2020 2320 4967 6e6f 7269 6e67        # Ignoring
+00014960: 2066 6c61 6773 2061 6e64 206c 6374 7220   flags and lctr 
+00014970: 286c 6f73 7320 636f 756e 7465 7229 2073  (loss counter) s
+00014980: 696e 6365 2074 6865 7920 6172 6520 4552  ince they are ER
+00014990: 4620 7370 6563 6966 6963 0a20 2020 2020  F specific.     
+000149a0: 2020 2023 2068 6561 6465 7220 6669 656c     # header fiel
+000149b0: 6473 2077 6869 6368 2050 6163 6b65 7420  ds which Packet 
+000149c0: 6f62 6a65 6374 2064 6f65 7320 6e6f 7420  object does not 
+000149d0: 7375 7070 6f72 742e 0a20 2020 2020 2020  support..       
+000149e0: 2074 7970 652c 205f 2c20 726c 656e 2c20   type, _, rlen, 
+000149f0: 5f2c 2077 6c65 6e20 3d20 7374 7275 6374  _, wlen = struct
+00014a00: 2e75 6e70 6163 6b28 273e 4242 4848 4827  .unpack('>BBHHH'
+00014a10: 2c20 6864 725b 383a 5d29 0a20 2020 2020  , hdr[8:]).     
+00014a20: 2020 2023 2043 6865 636b 2069 6620 7468     # Check if th
+00014a30: 6520 7479 7065 2021 3d20 3078 3032 2c20  e type != 0x02, 
+00014a40: 7479 7065 2045 7468 6572 6e65 740a 2020  type Ethernet.  
+00014a50: 2020 2020 2020 6966 2074 7970 6520 2620        if type & 
+00014a60: 3078 3032 203d 3d20 303a 0a20 2020 2020  0x02 == 0:.     
+00014a70: 2020 2020 2020 2072 6169 7365 2053 6361         raise Sca
+00014a80: 7079 5f45 7863 6570 7469 6f6e 2822 496e  py_Exception("In
+00014a90: 7661 6c69 6420 4552 4620 5479 7065 2028  valid ERF Type (
+00014aa0: 4e6f 7420 5459 5045 5f45 5448 2922 290a  Not TYPE_ETH)").
+00014ab0: 0a20 2020 2020 2020 2023 2049 6620 7468  .        # If th
+00014ac0: 6572 6520 6172 6520 6578 7465 6e64 6564  ere are extended
+00014ad0: 2068 6561 6465 7273 2c20 6967 6e6f 7265   headers, ignore
+00014ae0: 2069 7420 6265 6361 7573 6520 5061 636b   it because Pack
+00014af0: 6574 206f 626a 6563 7420 646f 6573 0a20  et object does. 
+00014b00: 2020 2020 2020 2023 206e 6f74 2073 7570         # not sup
+00014b10: 706f 7274 2069 742e 2045 7874 656e 6465  port it. Extende
+00014b20: 6420 6865 6164 6572 7320 7369 7a65 2069  d headers size i
+00014b30: 7320 3820 6279 7465 7320 6265 666f 7265  s 8 bytes before
+00014b40: 2074 6865 2070 6179 6c6f 6164 2e0a 2020   the payload..  
+00014b50: 2020 2020 2020 6966 2074 7970 6520 2620        if type & 
+00014b60: 3078 3830 3a0a 2020 2020 2020 2020 2020  0x80:.          
+00014b70: 2020 5f20 3d20 7365 6c66 2e66 2e72 6561    _ = self.f.rea
+00014b80: 6428 3829 0a20 2020 2020 2020 2020 2020  d(8).           
+00014b90: 2073 203d 2073 656c 662e 662e 7265 6164   s = self.f.read
+00014ba0: 2872 6c65 6e20 2d20 3234 290a 2020 2020  (rlen - 24).    
+00014bb0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00014bc0: 2020 2020 2020 7320 3d20 7365 6c66 2e66        s = self.f
+00014bd0: 2e72 6561 6428 726c 656e 202d 2031 3629  .read(rlen - 16)
+00014be0: 0a0a 2020 2020 2020 2020 2320 4574 6865  ..        # Ethe
+00014bf0: 726e 6574 2068 6173 2032 2062 7974 6573  rnet has 2 bytes
+00014c00: 206f 6620 7061 6464 696e 6720 636f 6e74   of padding cont
+00014c10: 6169 6e69 6e67 2060 6f66 6673 6574 6020  aining `offset` 
+00014c20: 616e 6420 6070 6164 602e 2042 6f74 680a  and `pad`. Both.
+00014c30: 2020 2020 2020 2020 2320 6f66 2074 6865          # of the
+00014c40: 2066 6965 6c64 7320 6172 6520 6469 7372   fields are disr
+00014c50: 6567 6172 6465 6420 6279 2045 6e64 6163  egarded by Endac
+00014c60: 652e 0a20 2020 2020 2020 2070 6220 3d20  e..        pb = 
+00014c70: 735b 323a 7369 7a65 5d0a 2020 2020 2020  s[2:size].      
+00014c80: 2020 6672 6f6d 2073 6361 7079 2e6c 6179    from scapy.lay
+00014c90: 6572 732e 6c32 2069 6d70 6f72 7420 4574  ers.l2 import Et
+00014ca0: 6865 720a 2020 2020 2020 2020 7472 793a  her.        try:
+00014cb0: 0a20 2020 2020 2020 2020 2020 2070 203d  .            p =
+00014cc0: 2045 7468 6572 2870 622c 202a 2a6b 7761   Ether(pb, **kwa
+00014cd0: 7267 7329 2020 2320 7479 7065 3a20 5061  rgs)  # type: Pa
+00014ce0: 636b 6574 0a20 2020 2020 2020 2065 7863  cket.        exc
+00014cf0: 6570 7420 4b65 7962 6f61 7264 496e 7465  ept KeyboardInte
+00014d00: 7272 7570 743a 0a20 2020 2020 2020 2020  rrupt:.         
+00014d10: 2020 2072 6169 7365 0a20 2020 2020 2020     raise.       
+00014d20: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+00014d30: 6e3a 0a20 2020 2020 2020 2020 2020 2069  n:.            i
+00014d40: 6620 636f 6e66 2e64 6562 7567 5f64 6973  f conf.debug_dis
+00014d50: 7365 6374 6f72 3a0a 2020 2020 2020 2020  sector:.        
+00014d60: 2020 2020 2020 2020 6672 6f6d 2073 6361          from sca
+00014d70: 7079 2e73 656e 6472 6563 7620 696d 706f  py.sendrecv impo
+00014d80: 7274 2064 6562 7567 0a20 2020 2020 2020  rt debug.       
+00014d90: 2020 2020 2020 2020 2064 6562 7567 2e63           debug.c
+00014da0: 7261 7368 6564 5f6f 6e20 3d20 2845 7468  rashed_on = (Eth
+00014db0: 6572 2c20 7329 0a20 2020 2020 2020 2020  er, s).         
+00014dc0: 2020 2020 2020 2072 6169 7365 0a20 2020         raise.   
+00014dd0: 2020 2020 2020 2020 2069 6620 636f 6e66           if conf
+00014de0: 2e72 6177 5f6c 6179 6572 2069 7320 4e6f  .raw_layer is No
+00014df0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00014e00: 2020 2020 2320 636f 6e66 2e72 6177 5f6c      # conf.raw_l
+00014e10: 6179 6572 2069 7320 7365 7420 6f6e 2069  ayer is set on i
+00014e20: 6d70 6f72 740a 2020 2020 2020 2020 2020  mport.          
+00014e30: 2020 2020 2020 696d 706f 7274 2073 6361        import sca
+00014e40: 7079 2e70 6163 6b65 7420 2023 206e 6f71  py.packet  # noq
+00014e50: 613a 2046 3430 310a 2020 2020 2020 2020  a: F401.        
+00014e60: 2020 2020 7020 3d20 636f 6e66 2e72 6177      p = conf.raw
+00014e70: 5f6c 6179 6572 2873 290a 0a20 2020 2020  _layer(s)..     
+00014e80: 2020 2070 2e74 696d 6520 3d20 7365 6c66     p.time = self
+00014e90: 2e5f 636f 6e76 6572 745f 6572 665f 7469  ._convert_erf_ti
+00014ea0: 6d65 7374 616d 7028 7469 6d65 290a 2020  mestamp(time).  
+00014eb0: 2020 2020 2020 702e 7769 7265 6c65 6e20        p.wirelen 
+00014ec0: 3d20 776c 656e 0a0a 2020 2020 2020 2020  = wlen..        
+00014ed0: 7265 7475 726e 2070 0a0a 0a40 636f 6e66  return p...@conf
+00014ee0: 2e63 6f6d 6d61 6e64 732e 7265 6769 7374  .commands.regist
+00014ef0: 6572 0a64 6566 2077 7265 7266 2866 696c  er.def wrerf(fil
+00014f00: 656e 616d 652c 2020 2320 7479 7065 3a20  ename,  # type: 
+00014f10: 556e 696f 6e5b 494f 5b62 7974 6573 5d2c  Union[IO[bytes],
+00014f20: 2073 7472 5d0a 2020 2020 2020 2020 2020   str].          
+00014f30: 706b 742c 2020 2320 7479 7065 3a20 5f50  pkt,  # type: _P
+00014f40: 6163 6b65 7449 7465 7261 626c 650a 2020  acketIterable.  
+00014f50: 2020 2020 2020 2020 2a61 7267 732c 2020          *args,  
+00014f60: 2320 7479 7065 3a20 416e 790a 2020 2020  # type: Any.    
+00014f70: 2020 2020 2020 2a2a 6b61 7267 7320 2023        **kargs  #
+00014f80: 2074 7970 653a 2041 6e79 0a20 2020 2020   type: Any.     
+00014f90: 2020 2020 2029 3a0a 2020 2020 2320 7479       ):.    # ty
+00014fa0: 7065 3a20 282e 2e2e 2920 2d3e 204e 6f6e  pe: (...) -> Non
+00014fb0: 650a 2020 2020 2222 2257 7269 7465 2061  e.    """Write a
+00014fc0: 206c 6973 7420 6f66 2070 6163 6b65 7473   list of packets
+00014fd0: 2074 6f20 6120 4552 4620 6669 6c65 0a0a   to a ERF file..
+00014fe0: 2020 2020 3a70 6172 616d 2066 696c 656e      :param filen
+00014ff0: 616d 653a 2074 6865 206e 616d 6520 6f66  ame: the name of
+00015000: 2074 6865 2066 696c 6520 746f 2077 7269   the file to wri
+00015010: 7465 2070 6163 6b65 7473 2074 6f2c 206f  te packets to, o
+00015020: 7220 616e 206f 7065 6e2c 0a20 2020 2020  r an open,.     
+00015030: 2020 2077 7269 7461 626c 6520 6669 6c65     writable file
+00015040: 2d6c 696b 6520 6f62 6a65 6374 2e20 5468  -like object. Th
+00015050: 6520 6669 6c65 2064 6573 6372 6970 746f  e file descripto
+00015060: 7220 7769 6c6c 2062 650a 2020 2020 2020  r will be.      
+00015070: 2020 636c 6f73 6564 2061 7420 7468 6520    closed at the 
+00015080: 656e 6420 6f66 2074 6865 2063 616c 6c2c  end of the call,
+00015090: 2073 6f20 646f 206e 6f74 2075 7365 2061   so do not use a
+000150a0: 6e20 6f62 6a65 6374 2079 6f75 0a20 2020  n object you.   
+000150b0: 2020 2020 2064 6f20 6e6f 7420 7761 6e74       do not want
+000150c0: 2074 6f20 636c 6f73 6520 2865 2e67 2e2c   to close (e.g.,
+000150d0: 2072 756e 6e69 6e67 2077 7265 7266 2873   running wrerf(s
+000150e0: 7973 2e73 7464 6f75 742c 205b 5d29 0a20  ys.stdout, []). 
+000150f0: 2020 2020 2020 2069 6e20 696e 7465 7261         in intera
+00015100: 6374 6976 6520 6d6f 6465 2077 696c 6c20  ctive mode will 
+00015110: 6372 6173 6820 5363 6170 7929 2e0a 2020  crash Scapy)..  
+00015120: 2020 3a70 6172 616d 2067 7a3a 2073 6574    :param gz: set
+00015130: 2074 6f20 3120 746f 2073 6176 6520 6120   to 1 to save a 
+00015140: 677a 6970 7065 6420 6361 7074 7572 650a  gzipped capture.
+00015150: 2020 2020 3a70 6172 616d 2061 7070 656e      :param appen
+00015160: 643a 2061 7070 656e 6420 7061 636b 6574  d: append packet
+00015170: 7320 746f 2074 6865 2063 6170 7475 7265  s to the capture
+00015180: 2066 696c 6520 696e 7374 6561 6420 6f66   file instead of
+00015190: 0a20 2020 2020 2020 2074 7275 6e63 6174  .        truncat
+000151a0: 696e 6720 6974 0a20 2020 203a 7061 7261  ing it.    :para
+000151b0: 6d20 7379 6e63 3a20 646f 206e 6f74 2062  m sync: do not b
+000151c0: 7566 6665 7269 7a65 2077 7269 7465 7320  ufferize writes 
+000151d0: 746f 2074 6865 2063 6170 7475 7265 2066  to the capture f
+000151e0: 696c 650a 2020 2020 2222 220a 2020 2020  ile.    """.    
+000151f0: 7769 7468 2045 5246 4574 6865 726e 6574  with ERFEthernet
+00015200: 5772 6974 6572 2866 696c 656e 616d 652c  Writer(filename,
+00015210: 202a 6172 6773 2c20 2a2a 6b61 7267 7329   *args, **kargs)
+00015220: 2061 7320 6664 6573 633a 0a20 2020 2020   as fdesc:.     
+00015230: 2020 2066 6465 7363 2e77 7269 7465 2870     fdesc.write(p
+00015240: 6b74 290a 0a0a 636c 6173 7320 4552 4645  kt)...class ERFE
+00015250: 7468 6572 6e65 7457 7269 7465 7228 5063  thernetWriter(Pc
+00015260: 6170 5772 6974 6572 293a 0a20 2020 2022  apWriter):.    "
+00015270: 2222 4120 7374 7265 616d 2045 5246 2045  ""A stream ERF E
+00015280: 7468 6572 6e65 7420 7772 6974 6572 2077  thernet writer w
+00015290: 6974 6820 6d6f 7265 2063 6f6e 7472 6f6c  ith more control
+000152a0: 2074 6861 6e20 7772 6572 6628 2922 2222   than wrerf()"""
+000152b0: 0a0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+000152c0: 5f5f 2873 656c 662c 0a20 2020 2020 2020  __(self,.       
+000152d0: 2020 2020 2020 2020 2020 6669 6c65 6e61            filena
+000152e0: 6d65 2c20 2023 2074 7970 653a 2055 6e69  me,  # type: Uni
+000152f0: 6f6e 5b49 4f5b 6279 7465 735d 2c20 7374  on[IO[bytes], st
+00015300: 725d 0a20 2020 2020 2020 2020 2020 2020  r].             
+00015310: 2020 2020 677a 3d46 616c 7365 2c20 2023      gz=False,  #
+00015320: 2074 7970 653a 2062 6f6f 6c0a 2020 2020   type: bool.    
+00015330: 2020 2020 2020 2020 2020 2020 2061 7070               app
+00015340: 656e 643d 4661 6c73 652c 2020 2320 7479  end=False,  # ty
+00015350: 7065 3a20 626f 6f6c 0a20 2020 2020 2020  pe: bool.       
+00015360: 2020 2020 2020 2020 2020 7379 6e63 3d46            sync=F
+00015370: 616c 7365 2c20 2023 2074 7970 653a 2062  alse,  # type: b
+00015380: 6f6f 6c0a 2020 2020 2020 2020 2020 2020  ool.            
+00015390: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
+000153a0: 2320 7479 7065 3a20 282e 2e2e 2920 2d3e  # type: (...) ->
+000153b0: 204e 6f6e 650a 2020 2020 2020 2020 2222   None.        ""
+000153c0: 220a 2020 2020 2020 2020 3a70 6172 616d  ".        :param
+000153d0: 2066 696c 656e 616d 653a 2074 6865 206e   filename: the n
+000153e0: 616d 6520 6f66 2074 6865 2066 696c 6520  ame of the file 
+000153f0: 746f 2077 7269 7465 2070 6163 6b65 7473  to write packets
+00015400: 2074 6f2c 206f 7220 616e 206f 7065 6e2c   to, or an open,
+00015410: 0a20 2020 2020 2020 2020 2020 2077 7269  .            wri
+00015420: 7461 626c 6520 6669 6c65 2d6c 696b 6520  table file-like 
+00015430: 6f62 6a65 6374 2e0a 2020 2020 2020 2020  object..        
+00015440: 3a70 6172 616d 2067 7a3a 2063 6f6d 7072  :param gz: compr
+00015450: 6573 7320 7468 6520 6361 7074 7572 6520  ess the capture 
+00015460: 6f6e 2074 6865 2066 6c79 0a20 2020 2020  on the fly.     
+00015470: 2020 203a 7061 7261 6d20 6170 7065 6e64     :param append
+00015480: 3a20 6170 7065 6e64 2070 6163 6b65 7473  : append packets
+00015490: 2074 6f20 7468 6520 6361 7074 7572 6520   to the capture 
+000154a0: 6669 6c65 2069 6e73 7465 6164 206f 660a  file instead of.
+000154b0: 2020 2020 2020 2020 2020 2020 7472 756e              trun
+000154c0: 6361 7469 6e67 2069 740a 2020 2020 2020  cating it.      
+000154d0: 2020 3a70 6172 616d 2073 796e 633a 2064    :param sync: d
+000154e0: 6f20 6e6f 7420 6275 6666 6572 697a 6520  o not bufferize 
+000154f0: 7772 6974 6573 2074 6f20 7468 6520 6361  writes to the ca
+00015500: 7074 7572 6520 6669 6c65 0a20 2020 2020  pture file.     
+00015510: 2020 2022 2222 0a20 2020 2020 2020 2073     """.        s
+00015520: 7570 6572 2845 5246 4574 6865 726e 6574  uper(ERFEthernet
+00015530: 5772 6974 6572 2c20 7365 6c66 292e 5f5f  Writer, self).__
+00015540: 696e 6974 5f5f 2866 696c 656e 616d 652c  init__(filename,
+00015550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015560: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00015570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015590: 2020 2020 2020 7527 6970 2e76 6572 7369        u'ip.versi
-000155a0: 6f6e 273a 2075 2734 277d 2c0a 2020 2020  on': u'4'},.    
-000155b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000155c0: 2020 2020 2020 2020 2020 2020 2020 2075                 u
-000155d0: 2772 6177 273a 2075 2752 6177 2070 6163  'raw': u'Raw pac
-000155e0: 6b65 7420 6461 7461 277d 7d2c 0a20 2020  ket data'}},.   
-000155f0: 2020 2020 2020 2075 275f 7479 7065 273a         u'_type':
-00015600: 2075 2770 6361 705f 6669 6c65 277d 5d0a   u'pcap_file'}].
-00015610: 2020 2020 2020 2020 3e3e 3e20 6a73 6f6e          >>> json
-00015620: 5f64 6174 615b 305d 5b27 5f73 6f75 7263  _data[0]['_sourc
-00015630: 6527 5d5b 276c 6179 6572 7327 5d5b 2769  e']['layers']['i
-00015640: 7027 5d5b 2769 702e 7474 6c27 5d0a 2020  p']['ip.ttl'].  
-00015650: 2020 2020 2020 7527 3634 270a 2020 2020        u'64'.    
-00015660: 2222 220a 2020 2020 6765 7466 6420 3d20  """.    getfd = 
-00015670: 6765 7466 6420 6f72 2067 6574 7072 6f63  getfd or getproc
-00015680: 0a20 2020 2069 6620 7072 6f67 2069 7320  .    if prog is 
-00015690: 4e6f 6e65 3a0a 2020 2020 2020 2020 6966  None:.        if
-000156a0: 206e 6f74 2063 6f6e 662e 7072 6f67 2e74   not conf.prog.t
-000156b0: 6370 6475 6d70 3a0a 2020 2020 2020 2020  cpdump:.        
-000156c0: 2020 2020 7261 6973 6520 5363 6170 795f      raise Scapy_
-000156d0: 4578 6365 7074 696f 6e28 0a20 2020 2020  Exception(.     
-000156e0: 2020 2020 2020 2020 2020 2022 7463 7064             "tcpd
-000156f0: 756d 7020 6973 206e 6f74 2061 7661 696c  ump is not avail
-00015700: 6162 6c65 220a 2020 2020 2020 2020 2020  able".          
-00015710: 2020 290a 2020 2020 2020 2020 7072 6f67    ).        prog
-00015720: 203d 205b 636f 6e66 2e70 726f 672e 7463   = [conf.prog.tc
-00015730: 7064 756d 705d 0a20 2020 2065 6c69 6620  pdump].    elif 
-00015740: 6973 696e 7374 616e 6365 2870 726f 672c  isinstance(prog,
-00015750: 2073 6978 2e73 7472 696e 675f 7479 7065   six.string_type
-00015760: 7329 3a0a 2020 2020 2020 2020 7072 6f67  s):.        prog
-00015770: 203d 205b 7072 6f67 5d0a 2020 2020 656c   = [prog].    el
-00015780: 7365 3a0a 2020 2020 2020 2020 7261 6973  se:.        rais
-00015790: 6520 5661 6c75 6545 7272 6f72 2822 7072  e ValueError("pr
-000157a0: 6f67 206d 7573 7420 6265 2061 2073 7472  og must be a str
-000157b0: 696e 6722 290a 0a20 2020 2069 6620 6c69  ing")..    if li
-000157c0: 6e6b 7479 7065 2069 7320 6e6f 7420 4e6f  nktype is not No
-000157d0: 6e65 3a0a 2020 2020 2020 2020 6966 2069  ne:.        if i
-000157e0: 7369 6e73 7461 6e63 6528 6c69 6e6b 7479  sinstance(linkty
-000157f0: 7065 2c20 696e 7429 3a0a 2020 2020 2020  pe, int):.      
-00015800: 2020 2020 2020 2320 4775 6573 7320 6e61        # Guess na
-00015810: 6d65 2066 726f 6d20 7661 6c75 650a 2020  me from value.  
-00015820: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
-00015830: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00015840: 696e 6b74 7970 655f 6e61 6d65 203d 205f  inktype_name = _
-00015850: 6775 6573 735f 6c69 6e6b 7479 7065 5f6e  guess_linktype_n
-00015860: 616d 6528 6c69 6e6b 7479 7065 290a 2020  ame(linktype).  
-00015870: 2020 2020 2020 2020 2020 6578 6365 7074            except
-00015880: 2053 746f 7049 7465 7261 7469 6f6e 3a0a   StopIteration:.
-00015890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000158a0: 6c69 6e6b 7479 7065 203d 202d 310a 2020  linktype = -1.  
-000158b0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000158c0: 2020 2020 2020 2020 2320 4775 6573 7320          # Guess 
-000158d0: 7661 6c75 6520 6672 6f6d 206e 616d 650a  value from name.
-000158e0: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-000158f0: 696e 6b74 7970 652e 7374 6172 7473 7769  inktype.startswi
-00015900: 7468 2822 444c 545f 2229 3a0a 2020 2020  th("DLT_"):.    
-00015910: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
-00015920: 7479 7065 203d 206c 696e 6b74 7970 655b  type = linktype[
-00015930: 343a 5d0a 2020 2020 2020 2020 2020 2020  4:].            
-00015940: 6c69 6e6b 7479 7065 5f6e 616d 6520 3d20  linktype_name = 
-00015950: 6c69 6e6b 7479 7065 0a20 2020 2020 2020  linktype.       
-00015960: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00015970: 2020 2020 2020 2020 2020 6c69 6e6b 7479            linkty
-00015980: 7065 203d 205f 6775 6573 735f 6c69 6e6b  pe = _guess_link
-00015990: 7479 7065 5f76 616c 7565 286c 696e 6b74  type_value(linkt
-000159a0: 7970 6529 0a20 2020 2020 2020 2020 2020  ype).           
-000159b0: 2065 7863 6570 7420 4b65 7945 7272 6f72   except KeyError
-000159c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000159d0: 2020 6c69 6e6b 7479 7065 203d 202d 310a    linktype = -1.
-000159e0: 2020 2020 2020 2020 6966 206c 696e 6b74          if linkt
-000159f0: 7970 6520 3d3d 202d 313a 0a20 2020 2020  ype == -1:.     
-00015a00: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00015a10: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
-00015a20: 2020 2020 2020 2020 2022 556e 6b6e 6f77           "Unknow
-00015a30: 6e20 6c69 6e6b 7479 7065 2e20 5472 7920  n linktype. Try 
-00015a40: 7061 7373 696e 6720 6974 7320 6461 7461  passing its data
-00015a50: 6c69 6e6b 206e 616d 6520 696e 7374 6561  link name instea
-00015a60: 6422 0a20 2020 2020 2020 2020 2020 2029  d".            )
-00015a70: 0a20 2020 2020 2020 2070 726f 6720 2b3d  .        prog +=
-00015a80: 205b 222d 7922 2c20 6c69 6e6b 7479 7065   ["-y", linktype
-00015a90: 5f6e 616d 655d 0a0a 2020 2020 2320 4275  _name]..    # Bu
-00015aa0: 696c 6420 506f 7065 6e20 6172 6775 6d65  ild Popen argume
-00015ab0: 6e74 730a 2020 2020 6966 2061 7267 7320  nts.    if args 
-00015ac0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-00015ad0: 2061 7267 7320 3d20 5b5d 0a20 2020 2065   args = [].    e
-00015ae0: 6c73 653a 0a20 2020 2020 2020 2023 204d  lse:.        # M
-00015af0: 616b 6520 6120 636f 7079 206f 6620 6172  ake a copy of ar
-00015b00: 6773 0a20 2020 2020 2020 2061 7267 7320  gs.        args 
-00015b10: 3d20 6c69 7374 2861 7267 7329 0a0a 2020  = list(args)..  
-00015b20: 2020 6966 2066 6c74 2069 7320 6e6f 7420    if flt is not 
-00015b30: 4e6f 6e65 3a0a 2020 2020 2020 2020 2320  None:.        # 
-00015b40: 4368 6563 6b20 7468 6520 7661 6c69 6469  Check the validi
-00015b50: 7479 206f 6620 7468 6520 6669 6c74 6572  ty of the filter
-00015b60: 0a20 2020 2020 2020 2069 6620 6c69 6e6b  .        if link
-00015b70: 7479 7065 2069 7320 4e6f 6e65 2061 6e64  type is None and
-00015b80: 2069 7369 6e73 7461 6e63 6528 706b 746c   isinstance(pktl
-00015b90: 6973 742c 2073 7472 293a 0a20 2020 2020  ist, str):.     
-00015ba0: 2020 2020 2020 2023 206c 696e 6b74 7970         # linktyp
-00015bb0: 6520 6973 2075 6e6b 6e6f 776e 2062 7574  e is unknown but
-00015bc0: 2072 6571 7569 7265 642e 2052 6561 6420   required. Read 
-00015bd0: 6974 2066 726f 6d20 6669 6c65 0a20 2020  it from file.   
-00015be0: 2020 2020 2020 2020 2077 6974 6820 5063           with Pc
-00015bf0: 6170 5265 6164 6572 2870 6b74 6c69 7374  apReader(pktlist
-00015c00: 2920 6173 2072 643a 0a20 2020 2020 2020  ) as rd:.       
-00015c10: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
-00015c20: 7374 616e 6365 2872 642c 2050 6361 704e  stance(rd, PcapN
-00015c30: 6752 6561 6465 7229 3a0a 2020 2020 2020  gReader):.      
-00015c40: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00015c50: 4765 7420 7468 6520 6c69 6e6b 7479 7065  Get the linktype
-00015c60: 2066 726f 6d20 7468 6520 6669 7273 7420   from the first 
-00015c70: 7061 636b 6574 0a20 2020 2020 2020 2020  packet.         
-00015c80: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
-00015c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015ca0: 2020 2020 2020 2020 5f2c 206d 6574 6164          _, metad
-00015cb0: 6174 6120 3d20 7264 2e5f 7265 6164 5f70  ata = rd._read_p
-00015cc0: 6163 6b65 7428 290a 2020 2020 2020 2020  acket().        
-00015cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015ce0: 6c69 6e6b 7479 7065 203d 206d 6574 6164  linktype = metad
-00015cf0: 6174 612e 6c69 6e6b 7479 7065 0a20 2020  ata.linktype.   
-00015d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d10: 2020 2020 2069 6620 4f50 454e 4253 4420       if OPENBSD 
-00015d20: 616e 6420 6c69 6e6b 7479 7065 203d 3d20  and linktype == 
-00015d30: 3232 383a 0a20 2020 2020 2020 2020 2020  228:.           
-00015d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d50: 206c 696e 6b74 7970 6520 3d20 444c 545f   linktype = DLT_
-00015d60: 5241 570a 2020 2020 2020 2020 2020 2020  RAW.            
-00015d70: 2020 2020 2020 2020 6578 6365 7074 2045          except E
-00015d80: 4f46 4572 726f 723a 0a20 2020 2020 2020  OFError:.       
-00015d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015da0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00015db0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-00015dc0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00015dd0: 4361 6e6e 6f74 2067 6574 206c 696e 6b74  Cannot get linkt
-00015de0: 7970 6520 6672 6f6d 2061 2050 6361 704e  ype from a PcapN
-00015df0: 6720 7061 636b 6574 2e22 0a20 2020 2020  g packet.".     
-00015e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015e10: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-00015e20: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00015e30: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00015e40: 696e 6b74 7970 6520 3d20 7264 2e6c 696e  inktype = rd.lin
-00015e50: 6b74 7970 650a 2020 2020 2020 2020 6672  ktype.        fr
-00015e60: 6f6d 2073 6361 7079 2e61 7263 682e 636f  om scapy.arch.co
-00015e70: 6d6d 6f6e 2069 6d70 6f72 7420 636f 6d70  mmon import comp
-00015e80: 696c 655f 6669 6c74 6572 0a20 2020 2020  ile_filter.     
-00015e90: 2020 2063 6f6d 7069 6c65 5f66 696c 7465     compile_filte
-00015ea0: 7228 666c 742c 206c 696e 6b74 7970 653d  r(flt, linktype=
-00015eb0: 6c69 6e6b 7479 7065 290a 2020 2020 2020  linktype).      
-00015ec0: 2020 6172 6773 2e61 7070 656e 6428 666c    args.append(fl
-00015ed0: 7429 0a0a 2020 2020 7374 646f 7574 203d  t)..    stdout =
-00015ee0: 2073 7562 7072 6f63 6573 732e 5049 5045   subprocess.PIPE
-00015ef0: 2069 6620 6475 6d70 206f 7220 6765 7466   if dump or getf
-00015f00: 6420 656c 7365 204e 6f6e 650a 2020 2020  d else None.    
-00015f10: 7374 6465 7272 203d 206f 7065 6e28 6f73  stderr = open(os
-00015f20: 2e64 6576 6e75 6c6c 2920 6966 2071 7569  .devnull) if qui
-00015f30: 6574 2065 6c73 6520 4e6f 6e65 0a20 2020  et else None.   
-00015f40: 2070 726f 6320 3d20 4e6f 6e65 0a0a 2020   proc = None..  
-00015f50: 2020 6966 2075 7365 5f74 656d 7066 696c    if use_tempfil
-00015f60: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
-00015f70: 2020 2023 2041 7070 6c65 2773 2074 6370     # Apple's tcp
-00015f80: 6475 6d70 2063 616e 6e6f 7420 7265 6164  dump cannot read
-00015f90: 2066 726f 6d20 7374 6469 6e2c 2073 6565   from stdin, see
-00015fa0: 3a0a 2020 2020 2020 2020 2320 6874 7470  :.        # http
-00015fb0: 3a2f 2f61 7070 6c65 2e73 7461 636b 6578  ://apple.stackex
-00015fc0: 6368 616e 6765 2e63 6f6d 2f71 7565 7374  change.com/quest
-00015fd0: 696f 6e73 2f31 3532 3638 322f 0a20 2020  ions/152682/.   
-00015fe0: 2020 2020 2075 7365 5f74 656d 7066 696c       use_tempfil
-00015ff0: 6520 3d20 4441 5257 494e 2061 6e64 2070  e = DARWIN and p
-00016000: 726f 675b 305d 203d 3d20 636f 6e66 2e70  rog[0] == conf.p
-00016010: 726f 672e 7463 7064 756d 700a 0a20 2020  rog.tcpdump..   
-00016020: 2069 6620 7265 6164 5f73 7464 696e 5f6f   if read_stdin_o
-00016030: 7074 7320 6973 204e 6f6e 653a 0a20 2020  pts is None:.   
-00016040: 2020 2020 2069 6620 7072 6f67 5b30 5d20       if prog[0] 
-00016050: 3d3d 2063 6f6e 662e 7072 6f67 2e77 6972  == conf.prog.wir
-00016060: 6573 6861 726b 3a0a 2020 2020 2020 2020  eshark:.        
-00016070: 2020 2020 2320 5374 6172 7420 6361 7074      # Start capt
-00016080: 7572 696e 6720 696d 6d65 6469 6174 656c  uring immediatel
-00016090: 7920 282d 6b29 2066 726f 6d20 7374 6469  y (-k) from stdi
-000160a0: 6e20 282d 6920 2d29 0a20 2020 2020 2020  n (-i -).       
-000160b0: 2020 2020 2072 6561 645f 7374 6469 6e5f       read_stdin_
-000160c0: 6f70 7473 203d 205b 222d 6b69 222c 2022  opts = ["-ki", "
-000160d0: 2d22 5d0a 2020 2020 2020 2020 656c 6966  -"].        elif
-000160e0: 2070 726f 675b 305d 203d 3d20 636f 6e66   prog[0] == conf
-000160f0: 2e70 726f 672e 7463 7064 756d 7020 616e  .prog.tcpdump an
-00016100: 6420 6e6f 7420 4f50 454e 4253 443a 0a20  d not OPENBSD:. 
-00016110: 2020 2020 2020 2020 2020 2023 2043 6170             # Cap
-00016120: 7475 7265 2069 6e20 7061 636b 6574 2d62  ture in packet-b
-00016130: 7566 6665 7265 6420 6d6f 6465 2028 2d55  uffered mode (-U
-00016140: 2920 6672 6f6d 2073 7464 696e 2028 2d72  ) from stdin (-r
-00016150: 202d 290a 2020 2020 2020 2020 2020 2020   -).            
-00016160: 7265 6164 5f73 7464 696e 5f6f 7074 7320  read_stdin_opts 
-00016170: 3d20 5b22 2d55 222c 2022 2d72 222c 2022  = ["-U", "-r", "
-00016180: 2d22 5d0a 2020 2020 2020 2020 656c 7365  -"].        else
-00016190: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-000161a0: 6164 5f73 7464 696e 5f6f 7074 7320 3d20  ad_stdin_opts = 
-000161b0: 5b22 2d72 222c 2022 2d22 5d0a 2020 2020  ["-r", "-"].    
-000161c0: 656c 7365 3a0a 2020 2020 2020 2020 2320  else:.        # 
-000161d0: 4d61 6b65 2061 2063 6f70 7920 6f66 2072  Make a copy of r
-000161e0: 6561 645f 7374 6469 6e5f 6f70 7473 0a20  ead_stdin_opts. 
-000161f0: 2020 2020 2020 2072 6561 645f 7374 6469         read_stdi
-00016200: 6e5f 6f70 7473 203d 206c 6973 7428 7265  n_opts = list(re
-00016210: 6164 5f73 7464 696e 5f6f 7074 7329 0a0a  ad_stdin_opts)..
-00016220: 2020 2020 6966 2070 6b74 6c69 7374 2069      if pktlist i
-00016230: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-00016240: 2320 736e 6966 660a 2020 2020 2020 2020  # sniff.        
-00016250: 7769 7468 2043 6f6e 7465 7874 4d61 6e61  with ContextMana
-00016260: 6765 7253 7562 7072 6f63 6573 7328 7072  gerSubprocess(pr
-00016270: 6f67 5b30 5d2c 2073 7570 7072 6573 733d  og[0], suppress=
-00016280: 5f73 7570 7072 6573 7329 3a0a 2020 2020  _suppress):.    
-00016290: 2020 2020 2020 2020 7072 6f63 203d 2073          proc = s
-000162a0: 7562 7072 6f63 6573 732e 506f 7065 6e28  ubprocess.Popen(
-000162b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000162c0: 2070 726f 6720 2b20 6172 6773 2c0a 2020   prog + args,.  
-000162d0: 2020 2020 2020 2020 2020 2020 2020 7374                st
-000162e0: 646f 7574 3d73 7464 6f75 742c 0a20 2020  dout=stdout,.   
-000162f0: 2020 2020 2020 2020 2020 2020 2073 7464               std
-00016300: 6572 723d 7374 6465 7272 2c0a 2020 2020  err=stderr,.    
-00016310: 2020 2020 2020 2020 290a 2020 2020 656c          ).    el
-00016320: 6966 2069 7369 6e73 7461 6e63 6528 706b  if isinstance(pk
-00016330: 746c 6973 742c 2073 6978 2e73 7472 696e  tlist, six.strin
-00016340: 675f 7479 7065 7329 3a0a 2020 2020 2020  g_types):.      
-00016350: 2020 2320 6669 6c65 0a20 2020 2020 2020    # file.       
-00016360: 2077 6974 6820 436f 6e74 6578 744d 616e   with ContextMan
-00016370: 6167 6572 5375 6270 726f 6365 7373 2870  agerSubprocess(p
-00016380: 726f 675b 305d 2c20 7375 7070 7265 7373  rog[0], suppress
-00016390: 3d5f 7375 7070 7265 7373 293a 0a20 2020  =_suppress):.   
-000163a0: 2020 2020 2020 2020 2070 726f 6320 3d20           proc = 
-000163b0: 7375 6270 726f 6365 7373 2e50 6f70 656e  subprocess.Popen
-000163c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000163d0: 2020 7072 6f67 202b 205b 222d 7222 2c20    prog + ["-r", 
-000163e0: 706b 746c 6973 745d 202b 2061 7267 732c  pktlist] + args,
-000163f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016400: 2073 7464 6f75 743d 7374 646f 7574 2c0a   stdout=stdout,.
-00016410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016420: 7374 6465 7272 3d73 7464 6572 722c 0a20  stderr=stderr,. 
-00016430: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00016440: 2065 6c69 6620 7573 655f 7465 6d70 6669   elif use_tempfi
-00016450: 6c65 3a0a 2020 2020 2020 2020 706b 746c  le:.        pktl
-00016460: 6973 7420 3d20 6361 7374 2855 6e69 6f6e  ist = cast(Union
-00016470: 5b49 4f5b 6279 7465 735d 2c20 225f 5061  [IO[bytes], "_Pa
-00016480: 636b 6574 4974 6572 6162 6c65 225d 2c20  cketIterable"], 
-00016490: 706b 746c 6973 7429 0a20 2020 2020 2020  pktlist).       
-000164a0: 2074 6d70 6669 6c65 203d 2067 6574 5f74   tmpfile = get_t
-000164b0: 656d 705f 6669 6c65 2820 2023 2074 7970  emp_file(  # typ
-000164c0: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
-000164d0: 2020 2020 2020 6175 746f 6578 743d 222e        autoext=".
-000164e0: 7063 6170 222c 0a20 2020 2020 2020 2020  pcap",.         
-000164f0: 2020 2066 643d 5472 7565 0a20 2020 2020     fd=True.     
-00016500: 2020 2029 2020 2320 7479 7065 3a20 494f     )  # type: IO
-00016510: 5b62 7974 6573 5d0a 2020 2020 2020 2020  [bytes].        
-00016520: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-00016530: 2074 6d70 6669 6c65 2e77 7269 7465 6c69   tmpfile.writeli
-00016540: 6e65 7328 0a20 2020 2020 2020 2020 2020  nes(.           
-00016550: 2020 2020 2069 7465 7228 6c61 6d62 6461       iter(lambda
-00016560: 3a20 706b 746c 6973 742e 7265 6164 2831  : pktlist.read(1
-00016570: 3034 3835 3736 292c 2062 2222 2920 2023  048576), b"")  #
-00016580: 2074 7970 653a 2069 676e 6f72 650a 2020   type: ignore.  
-00016590: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000165a0: 2020 2020 6578 6365 7074 2041 7474 7269      except Attri
-000165b0: 6275 7465 4572 726f 723a 0a20 2020 2020  buteError:.     
-000165c0: 2020 2020 2020 2070 6b74 6c69 7374 203d         pktlist =
-000165d0: 2063 6173 7428 225f 5061 636b 6574 4974   cast("_PacketIt
-000165e0: 6572 6162 6c65 222c 2070 6b74 6c69 7374  erable", pktlist
-000165f0: 290a 2020 2020 2020 2020 2020 2020 7772  ).            wr
-00016600: 7063 6170 2874 6d70 6669 6c65 2c20 706b  pcap(tmpfile, pk
-00016610: 746c 6973 742c 206c 696e 6b74 7970 653d  tlist, linktype=
-00016620: 6c69 6e6b 7479 7065 290a 2020 2020 2020  linktype).      
-00016630: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00016640: 2020 2020 746d 7066 696c 652e 636c 6f73      tmpfile.clos
-00016650: 6528 290a 2020 2020 2020 2020 7769 7468  e().        with
-00016660: 2043 6f6e 7465 7874 4d61 6e61 6765 7253   ContextManagerS
-00016670: 7562 7072 6f63 6573 7328 7072 6f67 5b30  ubprocess(prog[0
-00016680: 5d2c 2073 7570 7072 6573 733d 5f73 7570  ], suppress=_sup
-00016690: 7072 6573 7329 3a0a 2020 2020 2020 2020  press):.        
-000166a0: 2020 2020 7072 6f63 203d 2073 7562 7072      proc = subpr
-000166b0: 6f63 6573 732e 506f 7065 6e28 0a20 2020  ocess.Popen(.   
-000166c0: 2020 2020 2020 2020 2020 2020 2070 726f               pro
-000166d0: 6720 2b20 5b22 2d72 222c 2074 6d70 6669  g + ["-r", tmpfi
-000166e0: 6c65 2e6e 616d 655d 202b 2061 7267 732c  le.name] + args,
-000166f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016700: 2073 7464 6f75 743d 7374 646f 7574 2c0a   stdout=stdout,.
-00016710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016720: 7374 6465 7272 3d73 7464 6572 722c 0a20  stderr=stderr,. 
-00016730: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00016740: 2065 6c73 653a 0a20 2020 2020 2020 2074   else:.        t
-00016750: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-00016760: 706b 746c 6973 742e 6669 6c65 6e6f 2829  pktlist.fileno()
-00016770: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00016780: 0a20 2020 2020 2020 2020 2020 2023 2070  .            # p
-00016790: 6173 7320 7468 6520 7061 636b 6574 2073  ass the packet s
-000167a0: 7472 6561 6d0a 2020 2020 2020 2020 2020  tream.          
-000167b0: 2020 7769 7468 2043 6f6e 7465 7874 4d61    with ContextMa
-000167c0: 6e61 6765 7253 7562 7072 6f63 6573 7328  nagerSubprocess(
-000167d0: 7072 6f67 5b30 5d2c 2073 7570 7072 6573  prog[0], suppres
-000167e0: 733d 5f73 7570 7072 6573 7329 3a0a 2020  s=_suppress):.  
-000167f0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00016800: 6f63 203d 2073 7562 7072 6f63 6573 732e  oc = subprocess.
-00016810: 506f 7065 6e28 0a20 2020 2020 2020 2020  Popen(.         
-00016820: 2020 2020 2020 2020 2020 2070 726f 6720             prog 
-00016830: 2b20 7265 6164 5f73 7464 696e 5f6f 7074  + read_stdin_opt
-00016840: 7320 2b20 6172 6773 2c0a 2020 2020 2020  s + args,.      
-00016850: 2020 2020 2020 2020 2020 2020 2020 7374                st
-00016860: 6469 6e3d 706b 746c 6973 742c 2020 2320  din=pktlist,  # 
-00016870: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
-00016880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016890: 2073 7464 6f75 743d 7374 646f 7574 2c0a   stdout=stdout,.
-000168a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000168b0: 2020 2020 7374 6465 7272 3d73 7464 6572      stderr=stder
-000168c0: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
-000168d0: 2020 2029 0a20 2020 2020 2020 2065 7863     ).        exc
-000168e0: 6570 7420 2841 7474 7269 6275 7465 4572  ept (AttributeEr
-000168f0: 726f 722c 2056 616c 7565 4572 726f 7229  ror, ValueError)
-00016900: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-00016910: 7772 6974 6520 7468 6520 7061 636b 6574  write the packet
-00016920: 2073 7472 6561 6d20 746f 2073 7464 696e   stream to stdin
-00016930: 0a20 2020 2020 2020 2020 2020 2077 6974  .            wit
-00016940: 6820 436f 6e74 6578 744d 616e 6167 6572  h ContextManager
-00016950: 5375 6270 726f 6365 7373 2870 726f 675b  Subprocess(prog[
-00016960: 305d 2c20 7375 7070 7265 7373 3d5f 7375  0], suppress=_su
-00016970: 7070 7265 7373 293a 0a20 2020 2020 2020  ppress):.       
-00016980: 2020 2020 2020 2020 2070 726f 6320 3d20           proc = 
-00016990: 7375 6270 726f 6365 7373 2e50 6f70 656e  subprocess.Popen
-000169a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000169b0: 2020 2020 2020 7072 6f67 202b 2072 6561        prog + rea
-000169c0: 645f 7374 6469 6e5f 6f70 7473 202b 2061  d_stdin_opts + a
-000169d0: 7267 732c 0a20 2020 2020 2020 2020 2020  rgs,.           
-000169e0: 2020 2020 2020 2020 2073 7464 696e 3d73           stdin=s
-000169f0: 7562 7072 6f63 6573 732e 5049 5045 2c0a  ubprocess.PIPE,.
-00016a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a10: 2020 2020 7374 646f 7574 3d73 7464 6f75      stdout=stdou
-00016a20: 742c 0a20 2020 2020 2020 2020 2020 2020  t,.             
-00016a30: 2020 2020 2020 2073 7464 6572 723d 7374         stderr=st
-00016a40: 6465 7272 2c0a 2020 2020 2020 2020 2020  derr,.          
-00016a50: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00016a60: 2020 2020 6966 2070 726f 6320 6973 204e      if proc is N
-00016a70: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00016a80: 2020 2020 2023 2041 6e20 6572 726f 7220       # An error 
-00016a90: 6861 7320 6f63 6375 7272 6564 0a20 2020  has occurred.   
-00016aa0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00016ab0: 7572 6e0a 2020 2020 2020 2020 2020 2020  urn.            
-00016ac0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-00016ad0: 2020 2020 2070 726f 632e 7374 6469 6e2e       proc.stdin.
-00016ae0: 7772 6974 656c 696e 6573 2820 2023 2074  writelines(  # t
-00016af0: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
-00016b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b10: 6974 6572 286c 616d 6264 613a 2070 6b74  iter(lambda: pkt
-00016b20: 6c69 7374 2e72 6561 6428 3130 3438 3537  list.read(104857
-00016b30: 3629 2c20 6222 2229 2020 2320 7479 7065  6), b"")  # type
-00016b40: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
-00016b50: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00016b60: 2020 2020 2020 2065 7863 6570 7420 4174         except At
-00016b70: 7472 6962 7574 6545 7272 6f72 3a0a 2020  tributeError:.  
-00016b80: 2020 2020 2020 2020 2020 2020 2020 7772                wr
-00016b90: 7063 6170 2870 726f 632e 7374 6469 6e2c  pcap(proc.stdin,
-00016ba0: 2070 6b74 6c69 7374 2c20 6c69 6e6b 7479   pktlist, linkty
-00016bb0: 7065 3d6c 696e 6b74 7970 6529 2020 2320  pe=linktype)  # 
-00016bc0: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
-00016bd0: 2020 2020 2020 2020 2065 7863 6570 7420           except 
-00016be0: 556e 626f 756e 644c 6f63 616c 4572 726f  UnboundLocalErro
-00016bf0: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
-00016c00: 2020 2023 2054 6865 2065 7272 6f72 2077     # The error w
-00016c10: 6173 2068 616e 646c 6564 2062 7920 436f  as handled by Co
-00016c20: 6e74 6578 744d 616e 6167 6572 5375 6270  ntextManagerSubp
-00016c30: 726f 6365 7373 0a20 2020 2020 2020 2020  rocess.         
-00016c40: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
-00016c50: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00016c60: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00016c70: 6f63 2e73 7464 696e 2e63 6c6f 7365 2829  oc.stdin.close()
-00016c80: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00016c90: 0a20 2020 2069 6620 7072 6f63 2069 7320  .    if proc is 
-00016ca0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2320  None:.        # 
-00016cb0: 416e 2065 7272 6f72 2068 6173 206f 6363  An error has occ
-00016cc0: 7572 7265 640a 2020 2020 2020 2020 7265  urred.        re
-00016cd0: 7475 726e 0a20 2020 2069 6620 6475 6d70  turn.    if dump
-00016ce0: 3a0a 2020 2020 2020 2020 6461 7461 203d  :.        data =
-00016cf0: 2062 2222 2e6a 6f69 6e28 0a20 2020 2020   b"".join(.     
-00016d00: 2020 2020 2020 2069 7465 7228 6c61 6d62         iter(lamb
-00016d10: 6461 3a20 7072 6f63 2e73 7464 6f75 742e  da: proc.stdout.
-00016d20: 7265 6164 2831 3034 3835 3736 292c 2062  read(1048576), b
-00016d30: 2222 2920 2023 2074 7970 653a 2069 676e  "")  # type: ign
-00016d40: 6f72 650a 2020 2020 2020 2020 290a 2020  ore.        ).  
-00016d50: 2020 2020 2020 7072 6f63 2e74 6572 6d69        proc.termi
-00016d60: 6e61 7465 2829 0a20 2020 2020 2020 2072  nate().        r
-00016d70: 6574 7572 6e20 6461 7461 0a20 2020 2069  eturn data.    i
-00016d80: 6620 6765 7470 726f 633a 0a20 2020 2020  f getproc:.     
-00016d90: 2020 2072 6574 7572 6e20 7072 6f63 0a20     return proc. 
-00016da0: 2020 2069 6620 6765 7466 643a 0a20 2020     if getfd:.   
-00016db0: 2020 2020 2072 6574 7572 6e20 7072 6f63       return proc
-00016dc0: 2e73 7464 6f75 740a 2020 2020 6966 2077  .stdout.    if w
-00016dd0: 6169 743a 0a20 2020 2020 2020 2070 726f  ait:.        pro
-00016de0: 632e 7761 6974 2829 0a0a 0a40 636f 6e66  c.wait()...@conf
-00016df0: 2e63 6f6d 6d61 6e64 732e 7265 6769 7374  .commands.regist
-00016e00: 6572 0a64 6566 2068 6578 6564 6974 2870  er.def hexedit(p
-00016e10: 6b74 6c69 7374 293a 0a20 2020 2023 2074  ktlist):.    # t
-00016e20: 7970 653a 2028 5f50 6163 6b65 7449 7465  ype: (_PacketIte
-00016e30: 7261 626c 6529 202d 3e20 5061 636b 6574  rable) -> Packet
-00016e40: 4c69 7374 0a20 2020 2022 2222 5275 6e20  List.    """Run 
-00016e50: 6865 7865 6469 7420 6f6e 2061 206c 6973  hexedit on a lis
-00016e60: 7420 6f66 2070 6163 6b65 7473 2c20 7468  t of packets, th
-00016e70: 656e 2072 6574 7572 6e20 7468 6520 6564  en return the ed
-00016e80: 6974 6564 2070 6163 6b65 7473 2e22 2222  ited packets."""
-00016e90: 0a20 2020 2066 203d 2067 6574 5f74 656d  .    f = get_tem
-00016ea0: 705f 6669 6c65 2829 0a20 2020 2077 7270  p_file().    wrp
-00016eb0: 6361 7028 662c 2070 6b74 6c69 7374 290a  cap(f, pktlist).
-00016ec0: 2020 2020 7769 7468 2043 6f6e 7465 7874      with Context
-00016ed0: 4d61 6e61 6765 7253 7562 7072 6f63 6573  ManagerSubproces
-00016ee0: 7328 636f 6e66 2e70 726f 672e 6865 7865  s(conf.prog.hexe
-00016ef0: 6469 7429 3a0a 2020 2020 2020 2020 7375  dit):.        su
-00016f00: 6270 726f 6365 7373 2e63 616c 6c28 5b63  bprocess.call([c
-00016f10: 6f6e 662e 7072 6f67 2e68 6578 6564 6974  onf.prog.hexedit
-00016f20: 2c20 665d 290a 2020 2020 7270 6b74 6c69  , f]).    rpktli
-00016f30: 7374 203d 2072 6470 6361 7028 6629 0a20  st = rdpcap(f). 
-00016f40: 2020 206f 732e 756e 6c69 6e6b 2866 290a     os.unlink(f).
-00016f50: 2020 2020 7265 7475 726e 2072 706b 746c      return rpktl
-00016f60: 6973 740a 0a0a 6465 6620 6765 745f 7465  ist...def get_te
-00016f70: 726d 696e 616c 5f77 6964 7468 2829 3a0a  rminal_width():.
-00016f80: 2020 2020 2320 7479 7065 3a20 2829 202d      # type: () -
-00016f90: 3e20 4f70 7469 6f6e 616c 5b69 6e74 5d0a  > Optional[int].
-00016fa0: 2020 2020 2222 2247 6574 2074 6572 6d69      """Get termi
-00016fb0: 6e61 6c20 7769 6474 6820 286e 756d 6265  nal width (numbe
-00016fc0: 7220 6f66 2063 6861 7261 6374 6572 7329  r of characters)
-00016fd0: 2069 6620 696e 2061 2077 696e 646f 772e   if in a window.
-00016fe0: 0a0a 2020 2020 4e6f 7469 6365 3a20 7468  ..    Notice: th
-00016ff0: 6973 2077 696c 6c20 7472 7920 7365 7665  is will try seve
-00017000: 7261 6c20 6d65 7468 6f64 7320 696e 206f  ral methods in o
-00017010: 7264 6572 2074 6f0a 2020 2020 7375 7070  rder to.    supp
-00017020: 6f72 7420 6173 206d 616e 7920 7465 726d  ort as many term
-00017030: 696e 616c 7320 616e 6420 4f53 2061 7320  inals and OS as 
-00017040: 706f 7373 6962 6c65 2e0a 2020 2020 2222  possible..    ""
-00017050: 220a 2020 2020 2320 4c65 7427 7320 6669  ".    # Let's fi
-00017060: 7273 7420 7472 7920 7573 696e 6720 7468  rst try using th
-00017070: 6520 6f66 6669 6369 616c 2041 5049 0a20  e official API. 
-00017080: 2020 2023 2028 5079 7468 6f6e 2033 2e33     # (Python 3.3
-00017090: 2b29 0a20 2020 2073 697a 6578 203d 204e  +).    sizex = N
-000170a0: 6f6e 6520 2023 2074 7970 653a 204f 7074  one  # type: Opt
-000170b0: 696f 6e61 6c5b 696e 745d 0a20 2020 2069  ional[int].    i
-000170c0: 6620 6e6f 7420 7369 782e 5059 323a 0a20  f not six.PY2:. 
-000170d0: 2020 2020 2020 2069 6d70 6f72 7420 7368         import sh
-000170e0: 7574 696c 0a20 2020 2020 2020 2073 697a  util.        siz
-000170f0: 6578 203d 2073 6875 7469 6c2e 6765 745f  ex = shutil.get_
-00017100: 7465 726d 696e 616c 5f73 697a 6528 6661  terminal_size(fa
-00017110: 6c6c 6261 636b 3d28 302c 2030 2929 5b30  llback=(0, 0))[0
-00017120: 5d0a 2020 2020 2020 2020 6966 2073 697a  ].        if siz
-00017130: 6578 2021 3d20 303a 0a20 2020 2020 2020  ex != 0:.       
-00017140: 2020 2020 2072 6574 7572 6e20 7369 7a65       return size
-00017150: 780a 2020 2020 2320 4261 636b 7570 7320  x.    # Backups 
-00017160: 2f20 5079 7468 6f6e 2032 2e37 0a20 2020  / Python 2.7.   
-00017170: 2069 6620 5749 4e44 4f57 533a 0a20 2020   if WINDOWS:.   
-00017180: 2020 2020 2066 726f 6d20 6374 7970 6573       from ctypes
-00017190: 2069 6d70 6f72 7420 7769 6e64 6c6c 2c20   import windll, 
-000171a0: 6372 6561 7465 5f73 7472 696e 675f 6275  create_string_bu
-000171b0: 6666 6572 0a20 2020 2020 2020 2023 2068  ffer.        # h
-000171c0: 7474 703a 2f2f 636f 6465 2e61 6374 6976  ttp://code.activ
-000171d0: 6573 7461 7465 2e63 6f6d 2f72 6563 6970  estate.com/recip
-000171e0: 6573 2f34 3430 3639 342d 6465 7465 726d  es/440694-determ
-000171f0: 696e 652d 7369 7a65 2d6f 662d 636f 6e73  ine-size-of-cons
-00017200: 6f6c 652d 7769 6e64 6f77 2d6f 6e2d 7769  ole-window-on-wi
-00017210: 6e64 6f77 732f 0a20 2020 2020 2020 2068  ndows/.        h
-00017220: 203d 2077 696e 646c 6c2e 6b65 726e 656c   = windll.kernel
-00017230: 3332 2e47 6574 5374 6448 616e 646c 6528  32.GetStdHandle(
-00017240: 2d31 3229 0a20 2020 2020 2020 2063 7362  -12).        csb
-00017250: 6920 3d20 6372 6561 7465 5f73 7472 696e  i = create_strin
-00017260: 675f 6275 6666 6572 2832 3229 0a20 2020  g_buffer(22).   
-00017270: 2020 2020 2072 6573 203d 2077 696e 646c       res = windl
-00017280: 6c2e 6b65 726e 656c 3332 2e47 6574 436f  l.kernel32.GetCo
-00017290: 6e73 6f6c 6553 6372 6565 6e42 7566 6665  nsoleScreenBuffe
-000172a0: 7249 6e66 6f28 682c 2063 7362 6929 0a20  rInfo(h, csbi). 
-000172b0: 2020 2020 2020 2069 6620 7265 733a 0a20         if res:. 
-000172c0: 2020 2020 2020 2020 2020 2028 6275 6678             (bufx
-000172d0: 2c20 6275 6679 2c20 6375 7278 2c20 6375  , bufy, curx, cu
-000172e0: 7279 2c20 7761 7474 722c 0a20 2020 2020  ry, wattr,.     
-000172f0: 2020 2020 2020 2020 6c65 6674 2c20 746f          left, to
-00017300: 702c 2072 6967 6874 2c20 626f 7474 6f6d  p, right, bottom
-00017310: 2c20 6d61 7878 2c20 6d61 7879 2920 3d20  , maxx, maxy) = 
-00017320: 7374 7275 6374 2e75 6e70 6163 6b28 2268  struct.unpack("h
-00017330: 6868 6848 6868 6868 6868 222c 2063 7362  hhhHhhhhhh", csb
-00017340: 692e 7261 7729 2020 2320 6e6f 7161 3a20  i.raw)  # noqa: 
-00017350: 4535 3031 0a20 2020 2020 2020 2020 2020  E501.           
-00017360: 2073 697a 6578 203d 2072 6967 6874 202d   sizex = right -
-00017370: 206c 6566 7420 2b20 310a 2020 2020 2020   left + 1.      
-00017380: 2020 2020 2020 2320 7369 7a65 7920 3d20        # sizey = 
-00017390: 626f 7474 6f6d 202d 2074 6f70 202b 2031  bottom - top + 1
-000173a0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000173b0: 7572 6e20 7369 7a65 780a 2020 2020 2020  urn sizex.      
-000173c0: 2020 7265 7475 726e 2073 697a 6578 0a20    return sizex. 
-000173d0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000173e0: 2023 2057 6520 6861 7665 2076 6172 696f   # We have vario
-000173f0: 7573 206d 6574 686f 6473 0a20 2020 2020  us methods.     
-00017400: 2020 2023 2043 4f4c 554d 4e53 2069 7320     # COLUMNS is 
-00017410: 7365 7420 6f6e 2073 6f6d 6520 7465 726d  set on some term
-00017420: 696e 616c 730a 2020 2020 2020 2020 7472  inals.        tr
-00017430: 793a 0a20 2020 2020 2020 2020 2020 2073  y:.            s
-00017440: 697a 6578 203d 2069 6e74 286f 732e 656e  izex = int(os.en
-00017450: 7669 726f 6e5b 2743 4f4c 554d 4e53 275d  viron['COLUMNS']
-00017460: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
-00017470: 2045 7863 6570 7469 6f6e 3a0a 2020 2020   Exception:.    
-00017480: 2020 2020 2020 2020 7061 7373 0a20 2020          pass.   
-00017490: 2020 2020 2069 6620 7369 7a65 783a 0a20       if sizex:. 
-000174a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000174b0: 6e20 7369 7a65 780a 2020 2020 2020 2020  n sizex.        
-000174c0: 2320 5765 2063 616e 2071 7565 7279 2054  # We can query T
-000174d0: 494f 4347 5749 4e53 5a0a 2020 2020 2020  IOCGWINSZ.      
-000174e0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-000174f0: 2020 2069 6d70 6f72 7420 6663 6e74 6c0a     import fcntl.
-00017500: 2020 2020 2020 2020 2020 2020 696d 706f              impo
-00017510: 7274 2074 6572 6d69 6f73 0a20 2020 2020  rt termios.     
-00017520: 2020 2020 2020 2073 203d 2073 7472 7563         s = struc
-00017530: 742e 7061 636b 2827 4848 4848 272c 2030  t.pack('HHHH', 0
-00017540: 2c20 302c 2030 2c20 3029 0a20 2020 2020  , 0, 0, 0).     
-00017550: 2020 2020 2020 2078 203d 2066 636e 746c         x = fcntl
-00017560: 2e69 6f63 746c 2831 2c20 7465 726d 696f  .ioctl(1, termio
-00017570: 732e 5449 4f43 4757 494e 535a 2c20 7329  s.TIOCGWINSZ, s)
-00017580: 0a20 2020 2020 2020 2020 2020 2073 697a  .            siz
-00017590: 6578 203d 2073 7472 7563 742e 756e 7061  ex = struct.unpa
-000175a0: 636b 2827 4848 4848 272c 2078 295b 315d  ck('HHHH', x)[1]
-000175b0: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-000175c0: 494f 4572 726f 723a 0a20 2020 2020 2020  IOError:.       
-000175d0: 2020 2020 2070 6173 730a 2020 2020 2020       pass.      
-000175e0: 2020 7265 7475 726e 2073 697a 6578 0a0a    return sizex..
-000175f0: 0a64 6566 2070 7265 7474 795f 6c69 7374  .def pretty_list
-00017600: 2872 746c 7374 2c20 2023 2074 7970 653a  (rtlst,  # type:
-00017610: 204c 6973 745b 5475 706c 655b 556e 696f   List[Tuple[Unio
-00017620: 6e5b 7374 722c 204c 6973 745b 7374 725d  n[str, List[str]
-00017630: 5d2c 202e 2e2e 5d5d 0a20 2020 2020 2020  ], ...]].       
-00017640: 2020 2020 2020 2020 2068 6561 6465 722c           header,
-00017650: 2020 2320 7479 7065 3a20 4c69 7374 5b54    # type: List[T
-00017660: 7570 6c65 5b73 7472 2c20 2e2e 2e5d 5d0a  uple[str, ...]].
-00017670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017680: 736f 7274 4279 3d30 2c20 2023 2074 7970  sortBy=0,  # typ
-00017690: 653a 2069 6e74 0a20 2020 2020 2020 2020  e: int.         
-000176a0: 2020 2020 2020 2062 6f72 6465 7273 3d46         borders=F
-000176b0: 616c 7365 2c20 2023 2074 7970 653a 2062  alse,  # type: b
-000176c0: 6f6f 6c0a 2020 2020 2020 2020 2020 2020  ool.            
-000176d0: 2020 2020 293a 0a20 2020 2023 2074 7970      ):.    # typ
-000176e0: 653a 2028 2e2e 2e29 202d 3e20 7374 720a  e: (...) -> str.
-000176f0: 2020 2020 2222 220a 2020 2020 5072 6574      """.    Pret
-00017700: 7479 206c 6973 7420 746f 2066 6974 2074  ty list to fit t
-00017710: 6865 2074 6572 6d69 6e61 6c2c 2061 6e64  he terminal, and
-00017720: 2061 6464 2068 6561 6465 722e 0a0a 2020   add header...  
-00017730: 2020 3a70 6172 616d 2072 746c 7374 3a20    :param rtlst: 
-00017740: 6120 6c69 7374 206f 6620 7475 706c 6573  a list of tuples
-00017750: 2e20 6561 6368 2074 7570 6c65 2063 6f6e  . each tuple con
-00017760: 7461 696e 7320 6120 7661 6c75 6520 7768  tains a value wh
-00017770: 6963 6820 6361 6e0a 2020 2020 2020 2020  ich can.        
-00017780: 6265 2065 6974 6865 7220 6120 7374 7269  be either a stri
-00017790: 6e67 206f 7220 6120 6c69 7374 206f 6620  ng or a list of 
-000177a0: 7374 7269 6e67 2e0a 2020 2020 3a70 6172  string..    :par
-000177b0: 616d 2073 6f72 7442 793a 2074 6865 2063  am sortBy: the c
-000177c0: 6f6c 756d 6e20 6964 2028 7374 6172 7469  olumn id (starti
-000177d0: 6e67 2077 6974 6820 3029 2077 6869 6368  ng with 0) which
-000177e0: 2077 696c 6c20 6265 2075 7365 6420 666f   will be used fo
-000177f0: 720a 2020 2020 2020 2020 6f72 6465 7269  r.        orderi
-00017800: 6e67 0a20 2020 203a 7061 7261 6d20 626f  ng.    :param bo
-00017810: 7264 6572 733a 2077 6865 7468 6572 2074  rders: whether t
-00017820: 6f20 7075 7420 626f 7264 6572 7320 6f6e  o put borders on
-00017830: 2074 6865 2074 6162 6c65 206f 7220 6e6f   the table or no
-00017840: 740a 2020 2020 2222 220a 2020 2020 6966  t.    """.    if
-00017850: 2062 6f72 6465 7273 3a0a 2020 2020 2020   borders:.      
-00017860: 2020 5f73 7061 6365 203d 2022 7c22 0a20    _space = "|". 
-00017870: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00017880: 205f 7370 6163 6520 3d20 2220 2022 0a20   _space = "  ". 
-00017890: 2020 2063 6f6c 7320 3d20 6c65 6e28 6865     cols = len(he
-000178a0: 6164 6572 5b30 5d29 0a20 2020 2023 2057  ader[0]).    # W
-000178b0: 696e 646f 7773 2068 6173 2061 2066 6174  indows has a fat
-000178c0: 2074 6572 6d69 6e61 6c20 626f 7264 6572   terminal border
-000178d0: 0a20 2020 205f 7370 6163 656c 656e 203d  .    _spacelen =
-000178e0: 206c 656e 285f 7370 6163 6529 202a 2028   len(_space) * (
-000178f0: 636f 6c73 202d 2031 2920 2b20 696e 7428  cols - 1) + int(
-00017900: 5749 4e44 4f57 5329 0a20 2020 205f 6372  WINDOWS).    _cr
-00017910: 6f70 6564 203d 2046 616c 7365 0a20 2020  oped = False.   
-00017920: 2023 2053 6f72 7420 636f 7272 6563 746c   # Sort correctl
-00017930: 790a 2020 2020 7274 6c73 742e 736f 7274  y.    rtlst.sort
-00017940: 286b 6579 3d6c 616d 6264 6120 783a 2078  (key=lambda x: x
-00017950: 5b73 6f72 7442 795d 290a 2020 2020 2320  [sortBy]).    # 
-00017960: 5265 736f 6c76 6520 6d75 6c74 692d 7661  Resolve multi-va
-00017970: 6c75 6573 0a20 2020 2066 6f72 2069 2c20  lues.    for i, 
-00017980: 6c69 6e65 2069 6e20 656e 756d 6572 6174  line in enumerat
-00017990: 6528 7274 6c73 7429 3a0a 2020 2020 2020  e(rtlst):.      
-000179a0: 2020 6964 7320 3d20 5b5d 2020 2320 7479    ids = []  # ty
-000179b0: 7065 3a20 4c69 7374 5b69 6e74 5d0a 2020  pe: List[int].  
-000179c0: 2020 2020 2020 7661 6c75 6573 203d 205b        values = [
-000179d0: 5d20 2023 2074 7970 653a 204c 6973 745b  ]  # type: List[
-000179e0: 556e 696f 6e5b 7374 722c 204c 6973 745b  Union[str, List[
-000179f0: 7374 725d 5d5d 0a20 2020 2020 2020 2066  str]]].        f
-00017a00: 6f72 206a 2c20 7661 6c20 696e 2065 6e75  or j, val in enu
-00017a10: 6d65 7261 7465 286c 696e 6529 3a0a 2020  merate(line):.  
-00017a20: 2020 2020 2020 2020 2020 6966 2069 7369            if isi
-00017a30: 6e73 7461 6e63 6528 7661 6c2c 206c 6973  nstance(val, lis
-00017a40: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-00017a50: 2020 2020 6964 732e 6170 7065 6e64 286a      ids.append(j
-00017a60: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00017a70: 2020 7661 6c75 6573 2e61 7070 656e 6428    values.append(
-00017a80: 7661 6c20 6f72 2022 2022 290a 2020 2020  val or " ").    
-00017a90: 2020 2020 6966 2076 616c 7565 733a 0a20      if values:. 
-00017aa0: 2020 2020 2020 2020 2020 2064 656c 2072             del r
-00017ab0: 746c 7374 5b69 5d0a 2020 2020 2020 2020  tlst[i].        
-00017ac0: 2020 2020 6b20 3d20 300a 2020 2020 2020      k = 0.      
-00017ad0: 2020 2020 2020 666f 7220 6578 5f76 616c        for ex_val
-00017ae0: 7320 696e 207a 6970 5f6c 6f6e 6765 7374  s in zip_longest
-00017af0: 282a 7661 6c75 6573 2c20 6669 6c6c 7661  (*values, fillva
-00017b00: 6c75 653d 2220 2229 3a0a 2020 2020 2020  lue=" "):.      
-00017b10: 2020 2020 2020 2020 2020 6966 206b 3a0a            if k:.
-00017b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017b30: 2020 2020 6578 7472 615f 6c69 6e65 203d      extra_line =
-00017b40: 205b 2220 225d 202a 2063 6f6c 730a 2020   [" "] * cols.  
-00017b50: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00017b60: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00017b70: 2020 2020 2020 2020 6578 7472 615f 6c69          extra_li
-00017b80: 6e65 203d 206c 6973 7428 6c69 6e65 2920  ne = list(line) 
-00017b90: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
-00017ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017bb0: 666f 7220 6a2c 2068 2069 6e20 656e 756d  for j, h in enum
-00017bc0: 6572 6174 6528 6964 7329 3a0a 2020 2020  erate(ids):.    
-00017bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017be0: 6578 7472 615f 6c69 6e65 5b68 5d20 3d20  extra_line[h] = 
-00017bf0: 6578 5f76 616c 735b 6a5d 0a20 2020 2020  ex_vals[j].     
-00017c00: 2020 2020 2020 2020 2020 2072 746c 7374             rtlst
-00017c10: 2e69 6e73 6572 7428 6920 2b20 6b2c 2074  .insert(i + k, t
-00017c20: 7570 6c65 2865 7874 7261 5f6c 696e 6529  uple(extra_line)
-00017c30: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00017c40: 2020 6b20 2b3d 2031 0a20 2020 2072 7473    k += 1.    rts
-00017c50: 6c73 7420 3d20 6361 7374 284c 6973 745b  lst = cast(List[
-00017c60: 5475 706c 655b 7374 722c 202e 2e2e 5d5d  Tuple[str, ...]]
-00017c70: 2c20 7274 6c73 7429 0a20 2020 2023 2041  , rtlst).    # A
-00017c80: 7070 656e 6420 7461 670a 2020 2020 7274  ppend tag.    rt
-00017c90: 736c 7374 203d 2068 6561 6465 7220 2b20  slst = header + 
-00017ca0: 7274 736c 7374 0a20 2020 2023 2044 6574  rtslst.    # Det
-00017cb0: 6563 7420 636f 6c75 6d6e 2773 2077 6964  ect column's wid
-00017cc0: 7468 0a20 2020 2063 6f6c 7769 6474 6820  th.    colwidth 
-00017cd0: 3d20 5b6d 6178 286c 656e 2879 2920 666f  = [max(len(y) fo
-00017ce0: 7220 7920 696e 2078 2920 666f 7220 7820  r y in x) for x 
-00017cf0: 696e 207a 6970 282a 7274 736c 7374 295d  in zip(*rtslst)]
-00017d00: 0a20 2020 2023 204d 616b 6520 7465 7874  .    # Make text
-00017d10: 2066 6974 2069 6e20 626f 7820 2869 6620   fit in box (if 
-00017d20: 7265 7175 6972 6564 290a 2020 2020 7769  required).    wi
-00017d30: 6474 6820 3d20 6765 745f 7465 726d 696e  dth = get_termin
-00017d40: 616c 5f77 6964 7468 2829 0a20 2020 2069  al_width().    i
-00017d50: 6620 636f 6e66 2e61 7574 6f5f 6372 6f70  f conf.auto_crop
-00017d60: 5f74 6162 6c65 7320 616e 6420 7769 6474  _tables and widt
-00017d70: 683a 0a20 2020 2020 2020 2077 6964 7468  h:.        width
-00017d80: 203d 2077 6964 7468 202d 205f 7370 6163   = width - _spac
-00017d90: 656c 656e 0a20 2020 2020 2020 2077 6869  elen.        whi
-00017da0: 6c65 2073 756d 2863 6f6c 7769 6474 6829  le sum(colwidth)
-00017db0: 203e 2077 6964 7468 3a0a 2020 2020 2020   > width:.      
-00017dc0: 2020 2020 2020 5f63 726f 7065 6420 3d20        _croped = 
-00017dd0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00017de0: 2023 204e 6565 6473 2074 6f20 6265 2063   # Needs to be c
-00017df0: 726f 7070 6564 0a20 2020 2020 2020 2020  ropped.         
-00017e00: 2020 2023 2047 6574 2074 6865 206c 6f6e     # Get the lon
-00017e10: 6765 7374 2072 6f77 0a20 2020 2020 2020  gest row.       
-00017e20: 2020 2020 2069 203d 2063 6f6c 7769 6474       i = colwidt
-00017e30: 682e 696e 6465 7828 6d61 7828 636f 6c77  h.index(max(colw
-00017e40: 6964 7468 2929 0a20 2020 2020 2020 2020  idth)).         
-00017e50: 2020 2023 2047 6574 2061 6c6c 2065 6c65     # Get all ele
-00017e60: 6d65 6e74 7320 6f66 2074 6869 7320 726f  ments of this ro
-00017e70: 770a 2020 2020 2020 2020 2020 2020 726f  w.            ro
-00017e80: 7720 3d20 5b6c 656e 2878 5b69 5d29 2066  w = [len(x[i]) f
-00017e90: 6f72 2078 2069 6e20 7274 736c 7374 5d0a  or x in rtslst].
-00017ea0: 2020 2020 2020 2020 2020 2020 2320 4765              # Ge
-00017eb0: 7420 6269 6767 6573 7420 656c 656d 656e  t biggest elemen
-00017ec0: 7420 6f66 2074 6869 7320 726f 773a 2062  t of this row: b
-00017ed0: 6967 6765 7374 206f 6620 7468 6520 6172  iggest of the ar
-00017ee0: 7261 790a 2020 2020 2020 2020 2020 2020  ray.            
-00017ef0: 6a20 3d20 726f 772e 696e 6465 7828 6d61  j = row.index(ma
-00017f00: 7828 726f 7729 290a 2020 2020 2020 2020  x(row)).        
-00017f10: 2020 2020 2320 5265 2d62 7569 6c64 2063      # Re-build c
-00017f20: 6f6c 756d 6e20 7475 706c 6520 7769 7468  olumn tuple with
-00017f30: 2074 6865 2065 6469 7465 6420 656c 656d   the edited elem
-00017f40: 656e 740a 2020 2020 2020 2020 2020 2020  ent.            
-00017f50: 7420 3d20 6c69 7374 2872 7473 6c73 745b  t = list(rtslst[
-00017f60: 6a5d 290a 2020 2020 2020 2020 2020 2020  j]).            
-00017f70: 745b 695d 203d 2074 5b69 5d5b 3a2d 325d  t[i] = t[i][:-2]
-00017f80: 202b 2022 5f22 0a20 2020 2020 2020 2020   + "_".         
-00017f90: 2020 2072 7473 6c73 745b 6a5d 203d 2074     rtslst[j] = t
-00017fa0: 7570 6c65 2874 290a 2020 2020 2020 2020  uple(t).        
-00017fb0: 2020 2020 2320 5570 6461 7465 206d 6178      # Update max
-00017fc0: 2073 697a 650a 2020 2020 2020 2020 2020   size.          
-00017fd0: 2020 726f 775b 6a5d 203d 206c 656e 2874    row[j] = len(t
-00017fe0: 5b69 5d29 0a20 2020 2020 2020 2020 2020  [i]).           
-00017ff0: 2063 6f6c 7769 6474 685b 695d 203d 206d   colwidth[i] = m
-00018000: 6178 2872 6f77 290a 2020 2020 6966 205f  ax(row).    if _
-00018010: 6372 6f70 6564 3a0a 2020 2020 2020 2020  croped:.        
-00018020: 6c6f 675f 7275 6e74 696d 652e 696e 666f  log_runtime.info
-00018030: 2822 5461 626c 6520 6372 6f70 7065 6420  ("Table cropped 
-00018040: 746f 2066 6974 2074 6865 2074 6572 6d69  to fit the termi
-00018050: 6e61 6c20 2863 6f6e 662e 6175 746f 5f63  nal (conf.auto_c
-00018060: 726f 705f 7461 626c 6573 3d3d 5472 7565  rop_tables==True
-00018070: 2922 2920 2023 206e 6f71 613a 2045 3530  )")  # noqa: E50
-00018080: 310a 2020 2020 2320 4765 6e65 7261 7465  1.    # Generate
-00018090: 2070 6164 6469 6e67 2073 6368 656d 650a   padding scheme.
-000180a0: 2020 2020 666d 7420 3d20 5f73 7061 6365      fmt = _space
-000180b0: 2e6a 6f69 6e28 5b22 2525 2d25 6473 2220  .join(["%%-%ds" 
-000180c0: 2520 7820 666f 7220 7820 696e 2063 6f6c  % x for x in col
-000180d0: 7769 6474 685d 290a 2020 2020 2320 4170  width]).    # Ap
-000180e0: 7065 6e64 2073 6570 6172 6174 696f 6e20  pend separation 
-000180f0: 6c69 6e65 2069 6620 6e65 6564 6564 0a20  line if needed. 
-00018100: 2020 2069 6620 626f 7264 6572 733a 0a20     if borders:. 
-00018110: 2020 2020 2020 2072 7473 6c73 742e 696e         rtslst.in
-00018120: 7365 7274 2831 2c20 7475 706c 6528 222d  sert(1, tuple("-
-00018130: 2220 2a20 7820 666f 7220 7820 696e 2063  " * x for x in c
-00018140: 6f6c 7769 6474 6829 290a 2020 2020 2320  olwidth)).    # 
-00018150: 436f 6d70 696c 650a 2020 2020 7265 7475  Compile.    retu
-00018160: 726e 2022 5c6e 222e 6a6f 696e 2866 6d74  rn "\n".join(fmt
-00018170: 2025 2078 2066 6f72 2078 2069 6e20 7274   % x for x in rt
-00018180: 736c 7374 290a 0a0a 6465 6620 5f5f 6d61  slst)...def __ma
-00018190: 6b65 5f74 6162 6c65 280a 2020 2020 7966  ke_table(.    yf
-000181a0: 6d74 6675 6e63 2c20 2023 2074 7970 653a  mtfunc,  # type:
-000181b0: 2043 616c 6c61 626c 655b 5b69 6e74 5d2c   Callable[[int],
-000181c0: 2073 7472 5d0a 2020 2020 666d 7466 756e   str].    fmtfun
-000181d0: 632c 2020 2320 7479 7065 3a20 4361 6c6c  c,  # type: Call
-000181e0: 6162 6c65 5b5b 696e 745d 2c20 7374 725d  able[[int], str]
-000181f0: 0a20 2020 2065 6e64 6c69 6e65 2c20 2023  .    endline,  #
-00018200: 2074 7970 653a 2073 7472 0a20 2020 2064   type: str.    d
-00018210: 6174 612c 2020 2320 7479 7065 3a20 4c69  ata,  # type: Li
-00018220: 7374 5b54 7570 6c65 5b50 6163 6b65 742c  st[Tuple[Packet,
-00018230: 2050 6163 6b65 745d 5d0a 2020 2020 6678   Packet]].    fx
-00018240: 797a 2c20 2023 2074 7970 653a 2043 616c  yz,  # type: Cal
-00018250: 6c61 626c 655b 5b50 6163 6b65 742c 2050  lable[[Packet, P
-00018260: 6163 6b65 745d 2c20 5475 706c 655b 416e  acket], Tuple[An
-00018270: 792c 2041 6e79 2c20 416e 795d 5d0a 2020  y, Any, Any]].  
-00018280: 2020 736f 7274 783d 4e6f 6e65 2c20 2023    sortx=None,  #
-00018290: 2074 7970 653a 204f 7074 696f 6e61 6c5b   type: Optional[
-000182a0: 4361 6c6c 6162 6c65 5b5b 7374 725d 2c20  Callable[[str], 
-000182b0: 5475 706c 655b 416e 792c 202e 2e2e 5d5d  Tuple[Any, ...]]
-000182c0: 5d0a 2020 2020 736f 7274 793d 4e6f 6e65  ].    sorty=None
-000182d0: 2c20 2023 2074 7970 653a 204f 7074 696f  ,  # type: Optio
-000182e0: 6e61 6c5b 4361 6c6c 6162 6c65 5b5b 7374  nal[Callable[[st
-000182f0: 725d 2c20 5475 706c 655b 416e 792c 202e  r], Tuple[Any, .
-00018300: 2e2e 5d5d 5d0a 2020 2020 7365 706c 696e  ..]]].    seplin
-00018310: 6566 756e 633d 4e6f 6e65 2c20 2023 2074  efunc=None,  # t
-00018320: 7970 653a 204f 7074 696f 6e61 6c5b 4361  ype: Optional[Ca
-00018330: 6c6c 6162 6c65 5b5b 696e 742c 204c 6973  llable[[int, Lis
-00018340: 745b 696e 745d 5d2c 2073 7472 5d5d 0a20  t[int]], str]]. 
-00018350: 2020 2064 756d 703d 4661 6c73 6520 2023     dump=False  #
-00018360: 2074 7970 653a 2062 6f6f 6c0a 293a 0a20   type: bool.):. 
-00018370: 2020 2023 2074 7970 653a 2028 2e2e 2e29     # type: (...)
-00018380: 202d 3e20 4f70 7469 6f6e 616c 5b73 7472   -> Optional[str
-00018390: 5d0a 2020 2020 2222 2243 6f72 6520 6675  ].    """Core fu
-000183a0: 6e63 7469 6f6e 206f 6620 7468 6520 6d61  nction of the ma
-000183b0: 6b65 5f74 6162 6c65 2073 7569 7465 2c20  ke_table suite, 
-000183c0: 7768 6963 6820 6765 6e65 7261 7465 7320  which generates 
-000183d0: 7468 6520 7461 626c 6522 2222 0a20 2020  the table""".   
-000183e0: 2076 7820 3d20 7b7d 2020 2320 7479 7065   vx = {}  # type
-000183f0: 3a20 4469 6374 5b73 7472 2c20 696e 745d  : Dict[str, int]
-00018400: 0a20 2020 2076 7920 3d20 7b7d 2020 2320  .    vy = {}  # 
-00018410: 7479 7065 3a20 4469 6374 5b73 7472 2c20  type: Dict[str, 
-00018420: 4f70 7469 6f6e 616c 5b69 6e74 5d5d 0a20  Optional[int]]. 
-00018430: 2020 2076 7a20 3d20 7b7d 2020 2320 7479     vz = {}  # ty
-00018440: 7065 3a20 4469 6374 5b54 7570 6c65 5b73  pe: Dict[Tuple[s
-00018450: 7472 2c20 7374 725d 2c20 7374 725d 0a20  tr, str], str]. 
-00018460: 2020 2076 7866 203d 207b 7d20 2023 2074     vxf = {}  # t
-00018470: 7970 653a 2044 6963 745b 7374 722c 2073  ype: Dict[str, s
-00018480: 7472 5d0a 0a20 2020 2023 2050 7974 686f  tr]..    # Pytho
-00018490: 6e20 3220 6261 636b 7761 7264 2063 6f6d  n 2 backward com
-000184a0: 7061 7469 6269 6c69 7479 0a20 2020 2066  patibility.    f
-000184b0: 7879 7a20 3d20 6c61 6d62 6461 5f74 7570  xyz = lambda_tup
-000184c0: 6c65 5f63 6f6e 7665 7274 6572 2866 7879  le_converter(fxy
-000184d0: 7a29 0a0a 2020 2020 746d 705f 6c65 6e20  z)..    tmp_len 
-000184e0: 3d20 300a 2020 2020 666f 7220 6520 696e  = 0.    for e in
-000184f0: 2064 6174 613a 0a20 2020 2020 2020 2078   data:.        x
-00018500: 782c 2079 792c 207a 7a20 3d20 5b73 7472  x, yy, zz = [str
-00018510: 2873 2920 666f 7220 7320 696e 2066 7879  (s) for s in fxy
-00018520: 7a28 2a65 295d 0a20 2020 2020 2020 2074  z(*e)].        t
-00018530: 6d70 5f6c 656e 203d 206d 6178 286c 656e  mp_len = max(len
-00018540: 2879 7929 2c20 746d 705f 6c65 6e29 0a20  (yy), tmp_len). 
-00018550: 2020 2020 2020 2076 785b 7878 5d20 3d20         vx[xx] = 
-00018560: 6d61 7828 7678 2e67 6574 2878 782c 2030  max(vx.get(xx, 0
-00018570: 292c 206c 656e 2878 7829 2c20 6c65 6e28  ), len(xx), len(
-00018580: 7a7a 2929 0a20 2020 2020 2020 2076 795b  zz)).        vy[
-00018590: 7979 5d20 3d20 4e6f 6e65 0a20 2020 2020  yy] = None.     
-000185a0: 2020 2076 7a5b 2878 782c 2079 7929 5d20     vz[(xx, yy)] 
-000185b0: 3d20 7a7a 0a0a 2020 2020 7678 6b20 3d20  = zz..    vxk = 
-000185c0: 6c69 7374 2876 7829 0a20 2020 2076 796b  list(vx).    vyk
-000185d0: 203d 206c 6973 7428 7679 290a 2020 2020   = list(vy).    
-000185e0: 6966 2073 6f72 7478 3a0a 2020 2020 2020  if sortx:.      
-000185f0: 2020 7678 6b2e 736f 7274 286b 6579 3d73    vxk.sort(key=s
-00018600: 6f72 7478 290a 2020 2020 656c 7365 3a0a  ortx).    else:.
-00018610: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-00018620: 2020 2020 2020 2020 2076 786b 2e73 6f72           vxk.sor
-00018630: 7428 6b65 793d 696e 7429 0a20 2020 2020  t(key=int).     
-00018640: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
-00018650: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
-00018660: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
-00018670: 2020 2020 2020 7678 6b2e 736f 7274 286b        vxk.sort(k
-00018680: 6579 3d61 746f 6c29 0a20 2020 2020 2020  ey=atol).       
-00018690: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
-000186a0: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
-000186b0: 2020 2020 2020 2076 786b 2e73 6f72 7428         vxk.sort(
-000186c0: 290a 2020 2020 6966 2073 6f72 7479 3a0a  ).    if sorty:.
-000186d0: 2020 2020 2020 2020 7679 6b2e 736f 7274          vyk.sort
-000186e0: 286b 6579 3d73 6f72 7479 290a 2020 2020  (key=sorty).    
-000186f0: 656c 7365 3a0a 2020 2020 2020 2020 7472  else:.        tr
-00018700: 793a 0a20 2020 2020 2020 2020 2020 2076  y:.            v
-00018710: 796b 2e73 6f72 7428 6b65 793d 696e 7429  yk.sort(key=int)
-00018720: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-00018730: 4578 6365 7074 696f 6e3a 0a20 2020 2020  Exception:.     
-00018740: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-00018750: 2020 2020 2020 2020 2020 2020 7679 6b2e              vyk.
-00018760: 736f 7274 286b 6579 3d61 746f 6c29 0a20  sort(key=atol). 
-00018770: 2020 2020 2020 2020 2020 2065 7863 6570             excep
-00018780: 7420 4578 6365 7074 696f 6e3a 0a20 2020  t Exception:.   
-00018790: 2020 2020 2020 2020 2020 2020 2076 796b               vyk
-000187a0: 2e73 6f72 7428 290a 0a20 2020 2073 203d  .sort()..    s =
-000187b0: 2022 220a 2020 2020 6966 2073 6570 6c69   "".    if sepli
-000187c0: 6e65 6675 6e63 3a0a 2020 2020 2020 2020  nefunc:.        
-000187d0: 7365 706c 696e 6520 3d20 7365 706c 696e  sepline = seplin
-000187e0: 6566 756e 6328 746d 705f 6c65 6e2c 205b  efunc(tmp_len, [
-000187f0: 7678 5b78 5d20 666f 7220 7820 696e 2076  vx[x] for x in v
-00018800: 786b 5d29 0a20 2020 2020 2020 2073 202b  xk]).        s +
-00018810: 3d20 7365 706c 696e 6520 2b20 225c 6e22  = sepline + "\n"
-00018820: 0a0a 2020 2020 666d 7420 3d20 7966 6d74  ..    fmt = yfmt
-00018830: 6675 6e63 2874 6d70 5f6c 656e 290a 2020  func(tmp_len).  
-00018840: 2020 7320 2b3d 2066 6d74 2025 2022 220a    s += fmt % "".
-00018850: 2020 2020 7320 2b3d 2027 2027 0a20 2020      s += ' '.   
-00018860: 2066 6f72 2078 2069 6e20 7678 6b3a 0a20   for x in vxk:. 
-00018870: 2020 2020 2020 2076 7866 5b78 5d20 3d20         vxf[x] = 
-00018880: 666d 7466 756e 6328 7678 5b78 5d29 0a20  fmtfunc(vx[x]). 
-00018890: 2020 2020 2020 2073 202b 3d20 7678 665b         s += vxf[
-000188a0: 785d 2025 2078 0a20 2020 2020 2020 2073  x] % x.        s
-000188b0: 202b 3d20 2720 270a 2020 2020 7320 2b3d   += ' '.    s +=
-000188c0: 2065 6e64 6c69 6e65 202b 2022 5c6e 220a   endline + "\n".
-000188d0: 2020 2020 6966 2073 6570 6c69 6e65 6675      if seplinefu
-000188e0: 6e63 3a0a 2020 2020 2020 2020 7320 2b3d  nc:.        s +=
-000188f0: 2073 6570 6c69 6e65 202b 2022 5c6e 220a   sepline + "\n".
-00018900: 2020 2020 666f 7220 7920 696e 2076 796b      for y in vyk
-00018910: 3a0a 2020 2020 2020 2020 7320 2b3d 2066  :.        s += f
-00018920: 6d74 2025 2079 0a20 2020 2020 2020 2073  mt % y.        s
-00018930: 202b 3d20 2720 270a 2020 2020 2020 2020   += ' '.        
-00018940: 666f 7220 7820 696e 2076 786b 3a0a 2020  for x in vxk:.  
-00018950: 2020 2020 2020 2020 2020 7320 2b3d 2076            s += v
-00018960: 7866 5b78 5d20 2520 767a 2e67 6574 2828  xf[x] % vz.get((
-00018970: 782c 2079 292c 2022 2d22 290a 2020 2020  x, y), "-").    
-00018980: 2020 2020 2020 2020 7320 2b3d 2027 2027          s += ' '
-00018990: 0a20 2020 2020 2020 2073 202b 3d20 656e  .        s += en
-000189a0: 646c 696e 6520 2b20 225c 6e22 0a20 2020  dline + "\n".   
-000189b0: 2069 6620 7365 706c 696e 6566 756e 633a   if seplinefunc:
-000189c0: 0a20 2020 2020 2020 2073 202b 3d20 7365  .        s += se
-000189d0: 706c 696e 6520 2b20 225c 6e22 0a0a 2020  pline + "\n"..  
-000189e0: 2020 6966 2064 756d 703a 0a20 2020 2020    if dump:.     
-000189f0: 2020 2072 6574 7572 6e20 730a 2020 2020     return s.    
-00018a00: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
-00018a10: 696e 7428 732c 2065 6e64 3d22 2229 0a20  int(s, end=""). 
-00018a20: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
-00018a30: 6e65 0a0a 0a64 6566 206d 616b 655f 7461  ne...def make_ta
-00018a40: 626c 6528 2a61 7267 732c 202a 2a6b 6172  ble(*args, **kar
-00018a50: 6773 293a 0a20 2020 2023 2074 7970 653a  gs):.    # type:
-00018a60: 2028 2a41 6e79 2c20 2a2a 416e 7929 202d   (*Any, **Any) -
-00018a70: 3e20 4f70 7469 6f6e 616c 5b41 6e79 5d0a  > Optional[Any].
-00018a80: 2020 2020 7265 7475 726e 205f 5f6d 616b      return __mak
-00018a90: 655f 7461 626c 6528 0a20 2020 2020 2020  e_table(.       
-00018aa0: 206c 616d 6264 6120 6c3a 2022 2525 2d25   lambda l: "%%-%
-00018ab0: 6973 2220 2520 6c2c 0a20 2020 2020 2020  is" % l,.       
-00018ac0: 206c 616d 6264 6120 6c3a 2022 2525 2d25   lambda l: "%%-%
-00018ad0: 6973 2220 2520 6c2c 0a20 2020 2020 2020  is" % l,.       
-00018ae0: 2022 222c 0a20 2020 2020 2020 202a 6172   "",.        *ar
-00018af0: 6773 2c0a 2020 2020 2020 2020 2a2a 6b61  gs,.        **ka
-00018b00: 7267 730a 2020 2020 290a 0a0a 6465 6620  rgs.    )...def 
-00018b10: 6d61 6b65 5f6c 696e 6564 5f74 6162 6c65  make_lined_table
-00018b20: 282a 6172 6773 2c20 2a2a 6b61 7267 7329  (*args, **kargs)
-00018b30: 3a0a 2020 2020 2320 7479 7065 3a20 282a  :.    # type: (*
-00018b40: 416e 792c 202a 2a41 6e79 2920 2d3e 204f  Any, **Any) -> O
-00018b50: 7074 696f 6e61 6c5b 7374 725d 0a20 2020  ptional[str].   
-00018b60: 2072 6574 7572 6e20 5f5f 6d61 6b65 5f74   return __make_t
-00018b70: 6162 6c65 2820 2023 2074 7970 653a 2069  able(  # type: i
-00018b80: 676e 6f72 650a 2020 2020 2020 2020 6c61  gnore.        la
-00018b90: 6d62 6461 206c 3a20 2225 252d 2569 7320  mbda l: "%%-%is 
-00018ba0: 7c22 2025 206c 2c0a 2020 2020 2020 2020  |" % l,.        
-00018bb0: 6c61 6d62 6461 206c 3a20 2225 252d 2569  lambda l: "%%-%i
-00018bc0: 7320 7c22 2025 206c 2c0a 2020 2020 2020  s |" % l,.      
-00018bd0: 2020 2222 2c0a 2020 2020 2020 2020 2a61    "",.        *a
-00018be0: 7267 732c 0a20 2020 2020 2020 2073 6570  rgs,.        sep
-00018bf0: 6c69 6e65 6675 6e63 3d6c 616d 6264 6120  linefunc=lambda 
-00018c00: 612c 2078 3a20 222b 222e 6a6f 696e 280a  a, x: "+".join(.
-00018c10: 2020 2020 2020 2020 2020 2020 272d 2720              '-' 
-00018c20: 2a20 2879 202b 2032 2920 666f 7220 7920  * (y + 2) for y 
-00018c30: 696e 205b 6120 2d20 315d 202b 2078 202b  in [a - 1] + x +
-00018c40: 205b 2d32 5d0a 2020 2020 2020 2020 292c   [-2].        ),
-00018c50: 0a20 2020 2020 2020 202a 2a6b 6172 6773  .        **kargs
-00018c60: 0a20 2020 2029 0a0a 0a64 6566 206d 616b  .    )...def mak
-00018c70: 655f 7465 785f 7461 626c 6528 2a61 7267  e_tex_table(*arg
-00018c80: 732c 202a 2a6b 6172 6773 293a 0a20 2020  s, **kargs):.   
-00018c90: 2023 2074 7970 653a 2028 2a41 6e79 2c20   # type: (*Any, 
-00018ca0: 2a2a 416e 7929 202d 3e20 4f70 7469 6f6e  **Any) -> Option
-00018cb0: 616c 5b73 7472 5d0a 2020 2020 7265 7475  al[str].    retu
-00018cc0: 726e 205f 5f6d 616b 655f 7461 626c 6528  rn __make_table(
-00018cd0: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00018ce0: 0a20 2020 2020 2020 206c 616d 6264 6120  .        lambda 
-00018cf0: 6c3a 2022 2573 222c 0a20 2020 2020 2020  l: "%s",.       
-00018d00: 206c 616d 6264 6120 6c3a 2022 2620 2573   lambda l: "& %s
-00018d10: 222c 0a20 2020 2020 2020 2022 5c5c 5c5c  ",.        "\\\\
-00018d20: 222c 0a20 2020 2020 2020 202a 6172 6773  ",.        *args
-00018d30: 2c0a 2020 2020 2020 2020 7365 706c 696e  ,.        seplin
-00018d40: 6566 756e 633d 6c61 6d62 6461 2061 2c20  efunc=lambda a, 
-00018d50: 783a 2022 5c5c 686c 696e 6522 2c0a 2020  x: "\\hline",.  
-00018d60: 2020 2020 2020 2a2a 6b61 7267 730a 2020        **kargs.  
-00018d70: 2020 290a 0a23 2323 2323 2323 2323 2323    )..###########
-00018d80: 2323 2323 2323 2323 230a 2320 2020 5748  #########.#   WH
-00018d90: 4f49 5320 434c 4945 4e54 2020 2023 0a23  OIS CLIENT   #.#
-00018da0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00018db0: 2323 230a 0a0a 6465 6620 7768 6f69 7328  ###...def whois(
-00018dc0: 6970 5f61 6464 7265 7373 293a 0a20 2020  ip_address):.   
-00018dd0: 2023 2074 7970 653a 2028 7374 7229 202d   # type: (str) -
-00018de0: 3e20 6279 7465 730a 2020 2020 2222 2257  > bytes.    """W
-00018df0: 686f 6973 2063 6c69 656e 7420 666f 7220  hois client for 
-00018e00: 5079 7468 6f6e 2222 220a 2020 2020 7768  Python""".    wh
-00018e10: 6f69 735f 6970 203d 2073 7472 2869 705f  ois_ip = str(ip_
-00018e20: 6164 6472 6573 7329 0a20 2020 2074 7279  address).    try
-00018e30: 3a0a 2020 2020 2020 2020 7175 6572 7920  :.        query 
-00018e40: 3d20 736f 636b 6574 2e67 6574 686f 7374  = socket.gethost
-00018e50: 6279 6e61 6d65 2877 686f 6973 5f69 7029  byname(whois_ip)
-00018e60: 0a20 2020 2065 7863 6570 7420 4578 6365  .    except Exce
-00018e70: 7074 696f 6e3a 0a20 2020 2020 2020 2071  ption:.        q
-00018e80: 7565 7279 203d 2077 686f 6973 5f69 700a  uery = whois_ip.
-00018e90: 2020 2020 7320 3d20 736f 636b 6574 2e73      s = socket.s
-00018ea0: 6f63 6b65 7428 736f 636b 6574 2e41 465f  ocket(socket.AF_
-00018eb0: 494e 4554 2c20 736f 636b 6574 2e53 4f43  INET, socket.SOC
-00018ec0: 4b5f 5354 5245 414d 290a 2020 2020 732e  K_STREAM).    s.
-00018ed0: 636f 6e6e 6563 7428 2822 7768 6f69 732e  connect(("whois.
-00018ee0: 7269 7065 2e6e 6574 222c 2034 3329 290a  ripe.net", 43)).
-00018ef0: 2020 2020 732e 7365 6e64 2871 7565 7279      s.send(query
-00018f00: 2e65 6e63 6f64 6528 2275 7466 3822 2920  .encode("utf8") 
-00018f10: 2b20 6222 5c72 5c6e 2229 0a20 2020 2061  + b"\r\n").    a
-00018f20: 6e73 7765 7220 3d20 6222 220a 2020 2020  nswer = b"".    
-00018f30: 7768 696c 6520 5472 7565 3a0a 2020 2020  while True:.    
-00018f40: 2020 2020 6420 3d20 732e 7265 6376 2834      d = s.recv(4
-00018f50: 3039 3629 0a20 2020 2020 2020 2061 6e73  096).        ans
-00018f60: 7765 7220 2b3d 2064 0a20 2020 2020 2020  wer += d.       
-00018f70: 2069 6620 6e6f 7420 643a 0a20 2020 2020   if not d:.     
-00018f80: 2020 2020 2020 2062 7265 616b 0a20 2020         break.   
-00018f90: 2073 2e63 6c6f 7365 2829 0a20 2020 2069   s.close().    i
-00018fa0: 676e 6f72 655f 7461 6720 3d20 6222 7265  gnore_tag = b"re
-00018fb0: 6d61 726b 733a 220a 2020 2020 2320 6967  marks:".    # ig
-00018fc0: 6e6f 7265 2061 6c6c 206c 696e 6573 2073  nore all lines s
-00018fd0: 7461 7274 696e 6720 7769 7468 2074 6865  tarting with the
-00018fe0: 2069 676e 6f72 655f 7461 670a 2020 2020   ignore_tag.    
-00018ff0: 6c69 6e65 7320 3d20 5b6c 696e 6520 666f  lines = [line fo
-00019000: 7220 6c69 6e65 2069 6e20 616e 7377 6572  r line in answer
-00019010: 2e73 706c 6974 2862 225c 6e22 2920 6966  .split(b"\n") if
-00019020: 206e 6f74 206c 696e 6520 6f72 2028 6c69   not line or (li
-00019030: 6e65 2061 6e64 206e 6f74 206c 696e 652e  ne and not line.
-00019040: 7374 6172 7473 7769 7468 2869 676e 6f72  startswith(ignor
-00019050: 655f 7461 6729 295d 2020 2320 6e6f 7161  e_tag))]  # noqa
-00019060: 3a20 4535 3031 0a20 2020 2023 2072 656d  : E501.    # rem
-00019070: 6f76 6520 656d 7074 7920 6c69 6e65 7320  ove empty lines 
-00019080: 6174 2074 6865 2062 6f74 746f 6d0a 2020  at the bottom.  
-00019090: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-000190a0: 2831 2c20 6c65 6e28 6c69 6e65 7329 293a  (1, len(lines)):
-000190b0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-000190c0: 6c69 6e65 735b 2d69 5d2e 7374 7269 7028  lines[-i].strip(
-000190d0: 293a 0a20 2020 2020 2020 2020 2020 2064  ):.            d
-000190e0: 656c 206c 696e 6573 5b2d 695d 0a20 2020  el lines[-i].   
-000190f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00019100: 2020 2020 2020 2062 7265 616b 0a20 2020         break.   
-00019110: 2072 6574 7572 6e20 6222 5c6e 222e 6a6f   return b"\n".jo
-00019120: 696e 286c 696e 6573 5b33 3a5d 290a 0a23  in(lines[3:])..#
-00019130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019140: 2323 2323 2323 0a23 2020 2050 4552 494f  ######.#   PERIO
-00019150: 4449 4320 5345 4e44 4552 2020 2023 0a23  DIC SENDER   #.#
-00019160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019170: 2323 2323 2323 0a0a 0a63 6c61 7373 2050  ######...class P
-00019180: 6572 696f 6469 6353 656e 6465 7254 6872  eriodicSenderThr
-00019190: 6561 6428 7468 7265 6164 696e 672e 5468  ead(threading.Th
-000191a0: 7265 6164 293a 0a20 2020 2064 6566 205f  read):.    def _
-000191b0: 5f69 6e69 745f 5f28 7365 6c66 2c20 736f  _init__(self, so
-000191c0: 636b 2c20 706b 742c 2069 6e74 6572 7661  ck, pkt, interva
-000191d0: 6c3d 302e 3529 3a0a 2020 2020 2020 2020  l=0.5):.        
-000191e0: 2320 7479 7065 3a20 2841 6e79 2c20 5f50  # type: (Any, _P
-000191f0: 6163 6b65 7449 7465 7261 626c 652c 2066  acketIterable, f
-00019200: 6c6f 6174 2920 2d3e 204e 6f6e 650a 2020  loat) -> None.  
-00019210: 2020 2020 2020 2222 2220 5468 7265 6164        """ Thread
-00019220: 2074 6f20 7365 6e64 2070 6163 6b65 7473   to send packets
-00019230: 2070 6572 696f 6469 6361 6c6c 790a 0a20   periodically.. 
-00019240: 2020 2020 2020 2041 7267 733a 0a20 2020         Args:.   
-00019250: 2020 2020 2020 2020 2073 6f63 6b3a 2073           sock: s
-00019260: 6f63 6b65 7420 7768 6572 6520 7061 636b  ocket where pack
-00019270: 6574 2069 7320 7365 6e74 2070 6572 696f  et is sent perio
-00019280: 6469 6361 6c6c 790a 2020 2020 2020 2020  dically.        
-00019290: 2020 2020 706b 743a 2070 6163 6b65 7420      pkt: packet 
-000192a0: 6f72 206c 6973 7420 6f66 2070 6163 6b65  or list of packe
-000192b0: 7473 2074 6f20 7365 6e64 0a20 2020 2020  ts to send.     
-000192c0: 2020 2020 2020 2069 6e74 6572 7661 6c3a         interval:
-000192d0: 2069 6e74 6572 7661 6c20 6265 7477 6565   interval betwee
-000192e0: 6e20 7477 6f20 7061 636b 6574 730a 2020  n two packets.  
-000192f0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00019300: 2020 6966 206e 6f74 2069 7369 6e73 7461    if not isinsta
-00019310: 6e63 6528 706b 742c 206c 6973 7429 3a0a  nce(pkt, list):.
-00019320: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00019330: 2e5f 706b 7473 203d 205b 6361 7374 2822  ._pkts = [cast("
-00019340: 5061 636b 6574 222c 2070 6b74 295d 2020  Packet", pkt)]  
-00019350: 2320 7479 7065 3a20 5f50 6163 6b65 7449  # type: _PacketI
-00019360: 7465 7261 626c 650a 2020 2020 2020 2020  terable.        
-00019370: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00019380: 2020 7365 6c66 2e5f 706b 7473 203d 2070    self._pkts = p
-00019390: 6b74 0a20 2020 2020 2020 2073 656c 662e  kt.        self.
-000193a0: 5f73 6f63 6b65 7420 3d20 736f 636b 0a20  _socket = sock. 
-000193b0: 2020 2020 2020 2073 656c 662e 5f73 746f         self._sto
-000193c0: 7070 6564 203d 2074 6872 6561 6469 6e67  pped = threading
-000193d0: 2e45 7665 6e74 2829 0a20 2020 2020 2020  .Event().       
-000193e0: 2073 656c 662e 5f69 6e74 6572 7661 6c20   self._interval 
-000193f0: 3d20 696e 7465 7276 616c 0a20 2020 2020  = interval.     
-00019400: 2020 2074 6872 6561 6469 6e67 2e54 6872     threading.Thr
-00019410: 6561 642e 5f5f 696e 6974 5f5f 2873 656c  ead.__init__(sel
-00019420: 6629 0a0a 2020 2020 6465 6620 7275 6e28  f)..    def run(
-00019430: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
-00019440: 2074 7970 653a 2028 2920 2d3e 204e 6f6e   type: () -> Non
-00019450: 650a 2020 2020 2020 2020 7768 696c 6520  e.        while 
-00019460: 6e6f 7420 7365 6c66 2e5f 7374 6f70 7065  not self._stoppe
-00019470: 642e 6973 5f73 6574 2829 2061 6e64 206e  d.is_set() and n
-00019480: 6f74 2073 656c 662e 5f73 6f63 6b65 742e  ot self._socket.
-00019490: 636c 6f73 6564 3a0a 2020 2020 2020 2020  closed:.        
-000194a0: 2020 2020 666f 7220 7020 696e 2073 656c      for p in sel
-000194b0: 662e 5f70 6b74 733a 0a20 2020 2020 2020  f._pkts:.       
-000194c0: 2020 2020 2020 2020 2073 656c 662e 5f73           self._s
-000194d0: 6f63 6b65 742e 7365 6e64 2870 290a 2020  ocket.send(p).  
-000194e0: 2020 2020 2020 2020 2020 2020 2020 7469                ti
-000194f0: 6d65 2e73 6c65 6570 2873 656c 662e 5f69  me.sleep(self._i
-00019500: 6e74 6572 7661 6c29 0a20 2020 2020 2020  nterval).       
-00019510: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00019520: 2e5f 7374 6f70 7065 642e 6973 5f73 6574  ._stopped.is_set
-00019530: 2829 206f 7220 7365 6c66 2e5f 736f 636b  () or self._sock
-00019540: 6574 2e63 6c6f 7365 643a 0a20 2020 2020  et.closed:.     
-00019550: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-00019560: 7265 616b 0a0a 2020 2020 6465 6620 7374  reak..    def st
-00019570: 6f70 2873 656c 6629 3a0a 2020 2020 2020  op(self):.      
-00019580: 2020 2320 7479 7065 3a20 2829 202d 3e20    # type: () -> 
-00019590: 4e6f 6e65 0a20 2020 2020 2020 2073 656c  None.        sel
-000195a0: 662e 5f73 746f 7070 6564 2e73 6574 2829  f._stopped.set()
-000195b0: 0a20 2020 2020 2020 2073 656c 662e 6a6f  .        self.jo
-000195c0: 696e 2873 656c 662e 5f69 6e74 6572 7661  in(self._interva
-000195d0: 6c20 2a20 3229 0a0a 0a63 6c61 7373 2053  l * 2)...class S
-000195e0: 696e 676c 6543 6f6e 7665 7273 6174 696f  ingleConversatio
-000195f0: 6e53 6f63 6b65 7428 6f62 6a65 6374 293a  nSocket(object):
-00019600: 0a20 2020 2064 6566 205f 5f69 6e69 745f  .    def __init_
-00019610: 5f28 7365 6c66 2c20 6f29 3a0a 2020 2020  _(self, o):.    
-00019620: 2020 2020 2320 7479 7065 3a20 2841 6e79      # type: (Any
-00019630: 2920 2d3e 204e 6f6e 650a 2020 2020 2020  ) -> None.      
-00019640: 2020 7365 6c66 2e5f 696e 6e65 7220 3d20    self._inner = 
-00019650: 6f0a 2020 2020 2020 2020 7365 6c66 2e5f  o.        self._
-00019660: 7478 5f6d 7574 6578 203d 2074 6872 6561  tx_mutex = threa
-00019670: 6469 6e67 2e52 4c6f 636b 2829 0a0a 2020  ding.RLock()..  
-00019680: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00019690: 6465 6620 5f5f 6469 6374 5f5f 2873 656c  def __dict__(sel
-000196a0: 6629 3a20 2023 2074 7970 653a 2069 676e  f):  # type: ign
-000196b0: 6f72 650a 2020 2020 2020 2020 7265 7475  ore.        retu
-000196c0: 726e 2073 656c 662e 5f69 6e6e 6572 2e5f  rn self._inner._
-000196d0: 5f64 6963 745f 5f0a 0a20 2020 2064 6566  _dict__..    def
-000196e0: 205f 5f67 6574 6174 7472 5f5f 2873 656c   __getattr__(sel
-000196f0: 662c 206e 616d 6529 3a0a 2020 2020 2020  f, name):.      
-00019700: 2020 2320 7479 7065 3a20 2873 7472 2920    # type: (str) 
-00019710: 2d3e 2041 6e79 0a20 2020 2020 2020 2072  -> Any.        r
-00019720: 6574 7572 6e20 6765 7461 7474 7228 7365  eturn getattr(se
-00019730: 6c66 2e5f 696e 6e65 722c 206e 616d 6529  lf._inner, name)
-00019740: 0a0a 2020 2020 6465 6620 7372 3128 7365  ..    def sr1(se
-00019750: 6c66 2c20 2a61 7267 732c 202a 2a6b 6172  lf, *args, **kar
-00019760: 6773 293a 0a20 2020 2020 2020 2023 2074  gs):.        # t
-00019770: 7970 653a 2028 2a41 6e79 2c20 2a2a 416e  ype: (*Any, **An
-00019780: 7929 202d 3e20 416e 790a 2020 2020 2020  y) -> Any.      
-00019790: 2020 7769 7468 2073 656c 662e 5f74 785f    with self._tx_
-000197a0: 6d75 7465 783a 0a20 2020 2020 2020 2020  mutex:.         
-000197b0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-000197c0: 696e 6e65 722e 7372 3128 2a61 7267 732c  inner.sr1(*args,
-000197d0: 202a 2a6b 6172 6773 290a 0a20 2020 2064   **kargs)..    d
-000197e0: 6566 2073 7228 7365 6c66 2c20 2a61 7267  ef sr(self, *arg
-000197f0: 732c 202a 2a6b 6172 6773 293a 0a20 2020  s, **kargs):.   
-00019800: 2020 2020 2023 2074 7970 653a 2028 2a41       # type: (*A
-00019810: 6e79 2c20 2a2a 416e 7929 202d 3e20 416e  ny, **Any) -> An
-00019820: 790a 2020 2020 2020 2020 7769 7468 2073  y.        with s
-00019830: 656c 662e 5f74 785f 6d75 7465 783a 0a20  elf._tx_mutex:. 
-00019840: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00019850: 6e20 7365 6c66 2e5f 696e 6e65 722e 7372  n self._inner.sr
-00019860: 282a 6172 6773 2c20 2a2a 6b61 7267 7329  (*args, **kargs)
-00019870: 0a0a 2020 2020 6465 6620 7365 6e64 2873  ..    def send(s
-00019880: 656c 662c 2078 293a 0a20 2020 2020 2020  elf, x):.       
-00019890: 2023 2074 7970 653a 2028 5061 636b 6574   # type: (Packet
-000198a0: 2920 2d3e 2041 6e79 0a20 2020 2020 2020  ) -> Any.       
-000198b0: 2077 6974 6820 7365 6c66 2e5f 7478 5f6d   with self._tx_m
-000198c0: 7574 6578 3a0a 2020 2020 2020 2020 2020  utex:.          
-000198d0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-000198e0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-000198f0: 6c66 2e5f 696e 6e65 722e 7365 6e64 2878  lf._inner.send(x
-00019900: 290a 2020 2020 2020 2020 2020 2020 6578  ).            ex
-00019910: 6365 7074 2028 436f 6e6e 6563 7469 6f6e  cept (Connection
-00019920: 4572 726f 722c 204f 5345 7272 6f72 2920  Error, OSError) 
-00019930: 6173 2065 3a0a 2020 2020 2020 2020 2020  as e:.          
-00019940: 2020 2020 2020 7365 6c66 2e5f 696e 6e65        self._inne
-00019950: 722e 636c 6f73 6528 290a 2020 2020 2020  r.close().      
-00019960: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00019970: 650a                                     e.
+00015580: 2067 7a3d 677a 2c0a 2020 2020 2020 2020   gz=gz,.        
+00015590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000155a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000155b0: 2020 2020 2020 2020 6170 7065 6e64 3d61          append=a
+000155c0: 7070 656e 642c 0a20 2020 2020 2020 2020  ppend,.         
+000155d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000155e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000155f0: 2020 2020 2020 2073 796e 633d 7379 6e63         sync=sync
+00015600: 290a 0a20 2020 2064 6566 2077 7269 7465  )..    def write
+00015610: 2873 656c 662c 2070 6b74 293a 2020 2320  (self, pkt):  # 
+00015620: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+00015630: 2020 2020 2023 2074 7970 653a 2028 5f50       # type: (_P
+00015640: 6163 6b65 7449 7465 7261 626c 6529 202d  acketIterable) -
+00015650: 3e20 4e6f 6e65 0a20 2020 2020 2020 2022  > None.        "
+00015660: 2222 0a20 2020 2020 2020 2057 7269 7465  "".        Write
+00015670: 7320 6120 5061 636b 6574 2c20 6120 536e  s a Packet, a Sn
+00015680: 6452 6376 4c69 7374 206f 626a 6563 742c  dRcvList object,
+00015690: 206f 7220 6279 7465 7320 746f 2061 2045   or bytes to a E
+000156a0: 5246 2066 696c 652e 0a0a 2020 2020 2020  RF file...      
+000156b0: 2020 3a70 6172 616d 2070 6b74 3a20 5061    :param pkt: Pa
+000156c0: 636b 6574 2873 2920 746f 2077 7269 7465  cket(s) to write
+000156d0: 2028 6f6e 6520 7265 636f 7264 2066 6f72   (one record for
+000156e0: 2065 6163 6820 5061 636b 6574 290a 2020   each Packet).  
+000156f0: 2020 2020 2020 3a74 7970 6520 706b 743a        :type pkt:
+00015700: 2069 7465 7261 626c 655b 7363 6170 792e   iterable[scapy.
+00015710: 7061 636b 6574 2e50 6163 6b65 745d 2c20  packet.Packet], 
+00015720: 7363 6170 792e 7061 636b 6574 2e50 6163  scapy.packet.Pac
+00015730: 6b65 740a 2020 2020 2020 2020 2222 220a  ket.        """.
+00015740: 2020 2020 2020 2020 2320 496d 706f 7274          # Import
+00015750: 2068 6572 6520 746f 2061 766f 6964 2063   here to avoid c
+00015760: 6972 6375 6c61 7220 6465 7065 6e64 656e  ircular dependen
+00015770: 6379 0a20 2020 2020 2020 2066 726f 6d20  cy.        from 
+00015780: 7363 6170 792e 7375 7065 7273 6f63 6b65  scapy.supersocke
+00015790: 7420 696d 706f 7274 2049 7465 7253 6f63  t import IterSoc
+000157a0: 6b65 740a 2020 2020 2020 2020 666f 7220  ket.        for 
+000157b0: 7020 696e 2049 7465 7253 6f63 6b65 7428  p in IterSocket(
+000157c0: 706b 7429 2e69 7465 723a 0a20 2020 2020  pkt).iter:.     
+000157d0: 2020 2020 2020 2073 656c 662e 7772 6974         self.writ
+000157e0: 655f 7061 636b 6574 2870 290a 0a20 2020  e_packet(p)..   
+000157f0: 2064 6566 2077 7269 7465 5f70 6163 6b65   def write_packe
+00015800: 7428 7365 6c66 2c20 706b 7429 3a20 2023  t(self, pkt):  #
+00015810: 2074 7970 653a 2069 676e 6f72 650a 2020   type: ignore.  
+00015820: 2020 2020 2020 2320 7479 7065 3a20 2850        # type: (P
+00015830: 6163 6b65 7429 202d 3e20 4e6f 6e65 0a0a  acket) -> None..
+00015840: 2020 2020 2020 2020 6966 2068 6173 6174          if hasat
+00015850: 7472 2870 6b74 2c20 2274 696d 6522 293a  tr(pkt, "time"):
+00015860: 0a20 2020 2020 2020 2020 2020 2073 6563  .            sec
+00015870: 203d 2069 6e74 2870 6b74 2e74 696d 6529   = int(pkt.time)
+00015880: 0a20 2020 2020 2020 2020 2020 2075 7365  .            use
+00015890: 6320 3d20 696e 7428 2869 6e74 2872 6f75  c = int((int(rou
+000158a0: 6e64 2828 706b 742e 7469 6d65 202d 2073  nd((pkt.time - s
+000158b0: 6563 2920 2a20 3130 2a2a 3929 2920 3c3c  ec) * 10**9)) <<
+000158c0: 2033 3229 202f 2031 302a 2a39 290a 2020   32) / 10**9).  
+000158d0: 2020 2020 2020 2020 2020 7420 3d20 2873            t = (s
+000158e0: 6563 203c 3c20 3332 2920 2b20 7573 6563  ec << 32) + usec
+000158f0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00015900: 2020 2020 2020 2020 2020 2074 203d 2069             t = i
+00015910: 6e74 2874 696d 652e 7469 6d65 2829 2920  nt(time.time()) 
+00015920: 3c3c 2033 320a 0a20 2020 2020 2020 2023  << 32..        #
+00015930: 2054 6865 7265 2061 7265 2031 3620 6279   There are 16 by
+00015940: 7465 7320 6f66 2068 6561 6465 7273 202b  tes of headers +
+00015950: 2032 2062 7974 6573 206f 6620 7061 6464   2 bytes of padd
+00015960: 696e 6720 6265 666f 7265 2074 6865 2070  ing before the p
+00015970: 6163 6b65 7473 0a20 2020 2020 2020 2023  ackets.        #
+00015980: 2070 6179 6c6f 6164 2e0a 2020 2020 2020   payload..      
+00015990: 2020 726c 656e 203d 206c 656e 2870 6b74    rlen = len(pkt
+000159a0: 2920 2b20 3138 0a0a 2020 2020 2020 2020  ) + 18..        
+000159b0: 6966 2068 6173 6174 7472 2870 6b74 2c20  if hasattr(pkt, 
+000159c0: 2277 6972 656c 656e 2229 3a0a 2020 2020  "wirelen"):.    
+000159d0: 2020 2020 2020 2020 7769 7265 6c65 6e20          wirelen 
+000159e0: 3d20 706b 742e 7769 7265 6c65 6e0a 2020  = pkt.wirelen.  
+000159f0: 2020 2020 2020 6966 2077 6972 656c 656e        if wirelen
+00015a00: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00015a10: 2020 2020 2020 7769 7265 6c65 6e20 3d20        wirelen = 
+00015a20: 726c 656e 0a0a 2020 2020 2020 2020 7365  rlen..        se
+00015a30: 6c66 2e66 2e77 7269 7465 2873 7472 7563  lf.f.write(struc
+00015a40: 742e 7061 636b 2822 3c51 222c 2074 2929  t.pack("<Q", t))
+00015a50: 0a20 2020 2020 2020 2073 656c 662e 662e  .        self.f.
+00015a60: 7772 6974 6528 7374 7275 6374 2e70 6163  write(struct.pac
+00015a70: 6b28 223e 4242 4848 4848 222c 2032 2c20  k(">BBHHHH", 2, 
+00015a80: 302c 2072 6c65 6e2c 2030 2c20 7769 7265  0, rlen, 0, wire
+00015a90: 6c65 6e2c 2030 2929 0a20 2020 2020 2020  len, 0)).       
+00015aa0: 2073 656c 662e 662e 7772 6974 6528 6279   self.f.write(by
+00015ab0: 7465 7328 706b 7429 290a 2020 2020 2020  tes(pkt)).      
+00015ac0: 2020 7365 6c66 2e66 2e66 6c75 7368 2829    self.f.flush()
+00015ad0: 0a0a 2020 2020 6465 6620 636c 6f73 6528  ..    def close(
+00015ae0: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
+00015af0: 2074 7970 653a 2028 2920 2d3e 204f 7074   type: () -> Opt
+00015b00: 696f 6e61 6c5b 416e 795d 0a20 2020 2020  ional[Any].     
+00015b10: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
+00015b20: 2e63 6c6f 7365 2829 0a0a 0a40 636f 6e66  .close()...@conf
+00015b30: 2e63 6f6d 6d61 6e64 732e 7265 6769 7374  .commands.regist
+00015b40: 6572 0a64 6566 2069 6d70 6f72 745f 6865  er.def import_he
+00015b50: 7863 6170 2869 6e70 7574 5f73 7472 696e  xcap(input_strin
+00015b60: 673d 4e6f 6e65 293a 0a20 2020 2023 2074  g=None):.    # t
+00015b70: 7970 653a 2028 4f70 7469 6f6e 616c 5b73  ype: (Optional[s
+00015b80: 7472 5d29 202d 3e20 6279 7465 730a 2020  tr]) -> bytes.  
+00015b90: 2020 2222 2249 6d70 6f72 7473 2061 2074    """Imports a t
+00015ba0: 6370 6475 6d70 206c 696b 6520 6865 7861  cpdump like hexa
+00015bb0: 6465 6369 6d61 6c20 7669 6577 0a0a 2020  decimal view..  
+00015bc0: 2020 652e 673a 2065 7870 6f72 7465 6420    e.g: exported 
+00015bd0: 7669 6120 6865 7864 756d 7028 2920 6f72  via hexdump() or
+00015be0: 2074 6370 6475 6d70 206f 7220 7769 7265   tcpdump or wire
+00015bf0: 7368 6172 6b27 7320 2265 7870 6f72 7420  shark's "export 
+00015c00: 6173 2068 6578 220a 0a20 2020 203a 7061  as hex"..    :pa
+00015c10: 7261 6d20 696e 7075 745f 7374 7269 6e67  ram input_string
+00015c20: 3a20 5374 7269 6e67 2063 6f6e 7461 696e  : String contain
+00015c30: 696e 6720 7468 6520 6865 7864 756d 7020  ing the hexdump 
+00015c40: 696e 7075 7420 746f 2070 6172 7365 2e20  input to parse. 
+00015c50: 4966 204e 6f6e 652c 0a20 2020 2020 2020  If None,.       
+00015c60: 2072 6561 6420 6672 6f6d 2073 7461 6e64   read from stand
+00015c70: 6172 6420 696e 7075 742e 0a20 2020 2022  ard input..    "
+00015c80: 2222 0a20 2020 2072 655f 6578 7472 6163  "".    re_extrac
+00015c90: 745f 6865 7863 6170 203d 2072 652e 636f  t_hexcap = re.co
+00015ca0: 6d70 696c 6528 7222 5e28 2830 7829 3f5b  mpile(r"^((0x)?[
+00015cb0: 302d 3961 2d66 412d 465d 7b32 2c7d 5b20  0-9a-fA-F]{2,}[ 
+00015cc0: 3a5c 745d 7b2c 337d 7c29 202a 2828 5b30  :\t]{,3}|) *(([0
+00015cd0: 2d39 612d 6641 2d46 5d7b 327d 207b 2c32  -9a-fA-F]{2} {,2
+00015ce0: 7d29 7b2c 3136 7d29 2229 2020 2320 6e6f  }){,16})")  # no
+00015cf0: 7161 3a20 4535 3031 0a20 2020 2070 203d  qa: E501.    p =
+00015d00: 2022 220a 2020 2020 7472 793a 0a20 2020   "".    try:.   
+00015d10: 2020 2020 2069 6620 696e 7075 745f 7374       if input_st
+00015d20: 7269 6e67 3a0a 2020 2020 2020 2020 2020  ring:.          
+00015d30: 2020 696e 7075 745f 6675 6e63 7469 6f6e    input_function
+00015d40: 203d 2053 7472 696e 6749 4f28 696e 7075   = StringIO(inpu
+00015d50: 745f 7374 7269 6e67 292e 7265 6164 6c69  t_string).readli
+00015d60: 6e65 0a20 2020 2020 2020 2065 6c73 653a  ne.        else:
+00015d70: 0a20 2020 2020 2020 2020 2020 2069 6e70  .            inp
+00015d80: 7574 5f66 756e 6374 696f 6e20 3d20 696e  ut_function = in
+00015d90: 7075 740a 2020 2020 2020 2020 7768 696c  put.        whil
+00015da0: 6520 5472 7565 3a0a 2020 2020 2020 2020  e True:.        
+00015db0: 2020 2020 6c69 6e65 203d 2069 6e70 7574      line = input
+00015dc0: 5f66 756e 6374 696f 6e28 292e 7374 7269  _function().stri
+00015dd0: 7028 290a 2020 2020 2020 2020 2020 2020  p().            
+00015de0: 6966 206e 6f74 206c 696e 653a 0a20 2020  if not line:.   
+00015df0: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+00015e00: 616b 0a20 2020 2020 2020 2020 2020 2074  ak.            t
+00015e10: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+00015e20: 2020 2020 7020 2b3d 2072 655f 6578 7472      p += re_extr
+00015e30: 6163 745f 6865 7863 6170 2e6d 6174 6368  act_hexcap.match
+00015e40: 286c 696e 6529 2e67 726f 7570 7328 295b  (line).groups()[
+00015e50: 325d 2020 2320 7479 7065 3a20 6967 6e6f  2]  # type: igno
+00015e60: 7265 0a20 2020 2020 2020 2020 2020 2065  re.            e
+00015e70: 7863 6570 7420 4578 6365 7074 696f 6e3a  xcept Exception:
+00015e80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015e90: 2077 6172 6e69 6e67 2822 5061 7273 696e   warning("Parsin
+00015ea0: 6720 6572 726f 7220 6475 7269 6e67 2068  g error during h
+00015eb0: 6578 6361 7022 290a 2020 2020 2020 2020  excap").        
+00015ec0: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+00015ed0: 0a20 2020 2065 7863 6570 7420 454f 4645  .    except EOFE
+00015ee0: 7272 6f72 3a0a 2020 2020 2020 2020 7061  rror:.        pa
+00015ef0: 7373 0a0a 2020 2020 7020 3d20 702e 7265  ss..    p = p.re
+00015f00: 706c 6163 6528 2220 222c 2022 2229 0a20  place(" ", ""). 
+00015f10: 2020 2072 6574 7572 6e20 6865 785f 6279     return hex_by
+00015f20: 7465 7328 7029 0a0a 0a40 636f 6e66 2e63  tes(p)...@conf.c
+00015f30: 6f6d 6d61 6e64 732e 7265 6769 7374 6572  ommands.register
+00015f40: 0a64 6566 2077 6972 6573 6861 726b 2870  .def wireshark(p
+00015f50: 6b74 6c69 7374 2c20 7761 6974 3d46 616c  ktlist, wait=Fal
+00015f60: 7365 2c20 2a2a 6b77 6172 6773 293a 0a20  se, **kwargs):. 
+00015f70: 2020 2023 2074 7970 653a 2028 4c69 7374     # type: (List
+00015f80: 5b50 6163 6b65 745d 2c20 626f 6f6c 2c20  [Packet], bool, 
+00015f90: 2a2a 416e 7929 202d 3e20 4f70 7469 6f6e  **Any) -> Option
+00015fa0: 616c 5b41 6e79 5d0a 2020 2020 2222 220a  al[Any].    """.
+00015fb0: 2020 2020 5275 6e73 2057 6972 6573 6861      Runs Wiresha
+00015fc0: 726b 206f 6e20 6120 6c69 7374 206f 6620  rk on a list of 
+00015fd0: 7061 636b 6574 732e 0a0a 2020 2020 5365  packets...    Se
+00015fe0: 6520 3a66 756e 633a 6074 6370 6475 6d70  e :func:`tcpdump
+00015ff0: 6020 666f 7220 6d6f 7265 2070 6172 616d  ` for more param
+00016000: 6574 6572 2064 6573 6372 6970 7469 6f6e  eter description
+00016010: 2e0a 0a20 2020 204e 6f74 653a 2074 6869  ...    Note: thi
+00016020: 7320 6465 6661 756c 7473 2074 6f20 7761  s defaults to wa
+00016030: 6974 3d46 616c 7365 2c20 746f 2072 756e  it=False, to run
+00016040: 2057 6972 6573 6861 726b 2069 6e20 7468   Wireshark in th
+00016050: 6520 6261 636b 6772 6f75 6e64 2e0a 2020  e background..  
+00016060: 2020 2222 220a 2020 2020 7265 7475 726e    """.    return
+00016070: 2074 6370 6475 6d70 2870 6b74 6c69 7374   tcpdump(pktlist
+00016080: 2c20 7072 6f67 3d63 6f6e 662e 7072 6f67  , prog=conf.prog
+00016090: 2e77 6972 6573 6861 726b 2c20 7761 6974  .wireshark, wait
+000160a0: 3d77 6169 742c 202a 2a6b 7761 7267 7329  =wait, **kwargs)
+000160b0: 0a0a 0a40 636f 6e66 2e63 6f6d 6d61 6e64  ...@conf.command
+000160c0: 732e 7265 6769 7374 6572 0a64 6566 2074  s.register.def t
+000160d0: 6465 636f 6465 280a 2020 2020 706b 746c  decode(.    pktl
+000160e0: 6973 742c 2020 2320 7479 7065 3a20 556e  ist,  # type: Un
+000160f0: 696f 6e5b 494f 5b62 7974 6573 5d2c 204e  ion[IO[bytes], N
+00016100: 6f6e 652c 2073 7472 2c20 5f50 6163 6b65  one, str, _Packe
+00016110: 7449 7465 7261 626c 655d 0a20 2020 2061  tIterable].    a
+00016120: 7267 733d 4e6f 6e65 2c20 2023 2074 7970  rgs=None,  # typ
+00016130: 653a 204f 7074 696f 6e61 6c5b 4c69 7374  e: Optional[List
+00016140: 5b73 7472 5d5d 0a20 2020 202a 2a6b 7761  [str]].    **kwa
+00016150: 7267 7320 2023 2074 7970 653a 2041 6e79  rgs  # type: Any
+00016160: 0a29 3a0a 2020 2020 2320 7479 7065 3a20  .):.    # type: 
+00016170: 282e 2e2e 2920 2d3e 2041 6e79 0a20 2020  (...) -> Any.   
+00016180: 2022 2222 0a20 2020 2052 756e 2074 7368   """.    Run tsh
+00016190: 6172 6b20 6f6e 2061 206c 6973 7420 6f66  ark on a list of
+000161a0: 2070 6163 6b65 7473 2e0a 0a20 2020 203a   packets...    :
+000161b0: 7061 7261 6d20 6172 6773 3a20 4966 206e  param args: If n
+000161c0: 6f74 2073 7065 6369 6669 6564 2c20 6465  ot specified, de
+000161d0: 6661 756c 7473 2074 6f20 6060 7473 6861  faults to ``tsha
+000161e0: 726b 202d 5660 602e 0a0a 2020 2020 5365  rk -V``...    Se
+000161f0: 6520 3a66 756e 633a 6074 6370 6475 6d70  e :func:`tcpdump
+00016200: 6020 666f 7220 6d6f 7265 2070 6172 616d  ` for more param
+00016210: 6574 6572 732e 0a20 2020 2022 2222 0a20  eters..    """. 
+00016220: 2020 2069 6620 6172 6773 2069 7320 4e6f     if args is No
+00016230: 6e65 3a0a 2020 2020 2020 2020 6172 6773  ne:.        args
+00016240: 203d 205b 222d 5622 5d0a 2020 2020 7265   = ["-V"].    re
+00016250: 7475 726e 2074 6370 6475 6d70 2870 6b74  turn tcpdump(pkt
+00016260: 6c69 7374 2c20 7072 6f67 3d63 6f6e 662e  list, prog=conf.
+00016270: 7072 6f67 2e74 7368 6172 6b2c 2061 7267  prog.tshark, arg
+00016280: 733d 6172 6773 2c20 2a2a 6b77 6172 6773  s=args, **kwargs
+00016290: 290a 0a0a 6465 6620 5f67 7565 7373 5f6c  )...def _guess_l
+000162a0: 696e 6b74 7970 655f 6e61 6d65 2876 616c  inktype_name(val
+000162b0: 7565 293a 0a20 2020 2023 2074 7970 653a  ue):.    # type:
+000162c0: 2028 696e 7429 202d 3e20 7374 720a 2020   (int) -> str.  
+000162d0: 2020 2222 2247 7565 7373 2074 6865 2044    """Guess the D
+000162e0: 4c54 206e 616d 6520 6672 6f6d 2069 7473  LT name from its
+000162f0: 2076 616c 7565 2e22 2222 0a20 2020 2066   value.""".    f
+00016300: 726f 6d20 7363 6170 792e 6c69 6273 2e77  rom scapy.libs.w
+00016310: 696e 7063 6170 7920 696d 706f 7274 2070  inpcapy import p
+00016320: 6361 705f 6461 7461 6c69 6e6b 5f76 616c  cap_datalink_val
+00016330: 5f74 6f5f 6e61 6d65 0a20 2020 2072 6574  _to_name.    ret
+00016340: 7572 6e20 6361 7374 2862 7974 6573 2c20  urn cast(bytes, 
+00016350: 7063 6170 5f64 6174 616c 696e 6b5f 7661  pcap_datalink_va
+00016360: 6c5f 746f 5f6e 616d 6528 7661 6c75 6529  l_to_name(value)
+00016370: 292e 6465 636f 6465 2829 0a0a 0a64 6566  ).decode()...def
+00016380: 205f 6775 6573 735f 6c69 6e6b 7479 7065   _guess_linktype
+00016390: 5f76 616c 7565 286e 616d 6529 3a0a 2020  _value(name):.  
+000163a0: 2020 2320 7479 7065 3a20 2873 7472 2920    # type: (str) 
+000163b0: 2d3e 2069 6e74 0a20 2020 2022 2222 4775  -> int.    """Gu
+000163c0: 6573 7320 7468 6520 7661 6c75 6520 6f66  ess the value of
+000163d0: 2061 2044 4c54 206e 616d 652e 2222 220a   a DLT name.""".
+000163e0: 2020 2020 6672 6f6d 2073 6361 7079 2e6c      from scapy.l
+000163f0: 6962 732e 7769 6e70 6361 7079 2069 6d70  ibs.winpcapy imp
+00016400: 6f72 7420 7063 6170 5f64 6174 616c 696e  ort pcap_datalin
+00016410: 6b5f 6e61 6d65 5f74 6f5f 7661 6c0a 2020  k_name_to_val.  
+00016420: 2020 7661 6c20 3d20 6361 7374 2869 6e74    val = cast(int
+00016430: 2c20 7063 6170 5f64 6174 616c 696e 6b5f  , pcap_datalink_
+00016440: 6e61 6d65 5f74 6f5f 7661 6c28 6e61 6d65  name_to_val(name
+00016450: 2e65 6e63 6f64 6528 2929 290a 2020 2020  .encode())).    
+00016460: 6966 2076 616c 203d 3d20 2d31 3a0a 2020  if val == -1:.  
+00016470: 2020 2020 2020 7761 726e 696e 6728 2255        warning("U
+00016480: 6e6b 6e6f 776e 206c 696e 6b74 7970 653a  nknown linktype:
+00016490: 2025 732e 2055 7369 6e67 2045 4e31 304d   %s. Using EN10M
+000164a0: 4222 2c20 6e61 6d65 290a 2020 2020 2020  B", name).      
+000164b0: 2020 7265 7475 726e 2044 4c54 5f45 4e31    return DLT_EN1
+000164c0: 304d 420a 2020 2020 7265 7475 726e 2076  0MB.    return v
+000164d0: 616c 0a0a 0a40 636f 6e66 2e63 6f6d 6d61  al...@conf.comma
+000164e0: 6e64 732e 7265 6769 7374 6572 0a64 6566  nds.register.def
+000164f0: 2074 6370 6475 6d70 280a 2020 2020 706b   tcpdump(.    pk
+00016500: 746c 6973 743d 4e6f 6e65 2c20 2023 2074  tlist=None,  # t
+00016510: 7970 653a 2055 6e69 6f6e 5b49 4f5b 6279  ype: Union[IO[by
+00016520: 7465 735d 2c20 4e6f 6e65 2c20 7374 722c  tes], None, str,
+00016530: 205f 5061 636b 6574 4974 6572 6162 6c65   _PacketIterable
+00016540: 5d0a 2020 2020 6475 6d70 3d46 616c 7365  ].    dump=False
+00016550: 2c20 2023 2074 7970 653a 2062 6f6f 6c0a  ,  # type: bool.
+00016560: 2020 2020 6765 7466 643d 4661 6c73 652c      getfd=False,
+00016570: 2020 2320 7479 7065 3a20 626f 6f6c 0a20    # type: bool. 
+00016580: 2020 2061 7267 733d 4e6f 6e65 2c20 2023     args=None,  #
+00016590: 2074 7970 653a 204f 7074 696f 6e61 6c5b   type: Optional[
+000165a0: 4c69 7374 5b73 7472 5d5d 0a20 2020 2066  List[str]].    f
+000165b0: 6c74 3d4e 6f6e 652c 2020 2320 7479 7065  lt=None,  # type
+000165c0: 3a20 4f70 7469 6f6e 616c 5b73 7472 5d0a  : Optional[str].
+000165d0: 2020 2020 7072 6f67 3d4e 6f6e 652c 2020      prog=None,  
+000165e0: 2320 7479 7065 3a20 4f70 7469 6f6e 616c  # type: Optional
+000165f0: 5b41 6e79 5d0a 2020 2020 6765 7470 726f  [Any].    getpro
+00016600: 633d 4661 6c73 652c 2020 2320 7479 7065  c=False,  # type
+00016610: 3a20 626f 6f6c 0a20 2020 2071 7569 6574  : bool.    quiet
+00016620: 3d46 616c 7365 2c20 2023 2074 7970 653a  =False,  # type:
+00016630: 2062 6f6f 6c0a 2020 2020 7573 655f 7465   bool.    use_te
+00016640: 6d70 6669 6c65 3d4e 6f6e 652c 2020 2320  mpfile=None,  # 
+00016650: 7479 7065 3a20 4f70 7469 6f6e 616c 5b41  type: Optional[A
+00016660: 6e79 5d0a 2020 2020 7265 6164 5f73 7464  ny].    read_std
+00016670: 696e 5f6f 7074 733d 4e6f 6e65 2c20 2023  in_opts=None,  #
+00016680: 2074 7970 653a 204f 7074 696f 6e61 6c5b   type: Optional[
+00016690: 416e 795d 0a20 2020 206c 696e 6b74 7970  Any].    linktyp
+000166a0: 653d 4e6f 6e65 2c20 2023 2074 7970 653a  e=None,  # type:
+000166b0: 204f 7074 696f 6e61 6c5b 416e 795d 0a20   Optional[Any]. 
+000166c0: 2020 2077 6169 743d 5472 7565 2c20 2023     wait=True,  #
+000166d0: 2074 7970 653a 2062 6f6f 6c0a 2020 2020   type: bool.    
+000166e0: 5f73 7570 7072 6573 733d 4661 6c73 6520  _suppress=False 
+000166f0: 2023 2074 7970 653a 2062 6f6f 6c0a 293a   # type: bool.):
+00016700: 0a20 2020 2023 2074 7970 653a 2028 2e2e  .    # type: (..
+00016710: 2e29 202d 3e20 416e 790a 2020 2020 2222  .) -> Any.    ""
+00016720: 2252 756e 2074 6370 6475 6d70 206f 7220  "Run tcpdump or 
+00016730: 7473 6861 726b 206f 6e20 6120 6c69 7374  tshark on a list
+00016740: 206f 6620 7061 636b 6574 732e 0a0a 2020   of packets...  
+00016750: 2020 5768 656e 2075 7369 6e67 2060 6074    When using ``t
+00016760: 6370 6475 6d70 6060 206f 6e20 4f53 5820  cpdump`` on OSX 
+00016770: 2860 6070 726f 6720 3d3d 2063 6f6e 662e  (``prog == conf.
+00016780: 7072 6f67 2e74 6370 6475 6d70 6060 292c  prog.tcpdump``),
+00016790: 2074 6869 7320 7573 6573 2061 0a20 2020   this uses a.   
+000167a0: 2074 656d 706f 7261 7279 2066 696c 6520   temporary file 
+000167b0: 746f 2073 746f 7265 2074 6865 2070 6163  to store the pac
+000167c0: 6b65 7473 2e20 5468 6973 2077 6f72 6b73  kets. This works
+000167d0: 2061 726f 756e 6420 6120 6275 6720 696e   around a bug in
+000167e0: 2041 7070 6c65 2773 0a20 2020 2076 6572   Apple's.    ver
+000167f0: 7369 6f6e 206f 6620 6060 7463 7064 756d  sion of ``tcpdum
+00016800: 7060 603a 2068 7474 703a 2f2f 6170 706c  p``: http://appl
+00016810: 652e 7374 6163 6b65 7863 6861 6e67 652e  e.stackexchange.
+00016820: 636f 6d2f 7175 6573 7469 6f6e 732f 3135  com/questions/15
+00016830: 3236 3832 2f0a 0a20 2020 204f 7468 6572  2682/..    Other
+00016840: 7769 7365 2c20 7468 6520 7061 636b 6574  wise, the packet
+00016850: 7320 6172 6520 7061 7373 6564 2069 6e20  s are passed in 
+00016860: 7374 6469 6e2e 0a0a 2020 2020 5468 6973  stdin...    This
+00016870: 2066 756e 6374 696f 6e20 6361 6e20 6265   function can be
+00016880: 2065 7870 6c69 6369 746c 7920 656e 6162   explicitly enab
+00016890: 6c65 6420 6f72 2064 6973 6162 6c65 6420  led or disabled 
+000168a0: 7769 7468 2074 6865 0a20 2020 2060 6075  with the.    ``u
+000168b0: 7365 5f74 656d 7066 696c 6560 6020 7061  se_tempfile`` pa
+000168c0: 7261 6d65 7465 722e 0a0a 2020 2020 5768  rameter...    Wh
+000168d0: 656e 2075 7369 6e67 2060 6077 6972 6573  en using ``wires
+000168e0: 6861 726b 6060 2c20 6974 2077 696c 6c20  hark``, it will 
+000168f0: 6265 2063 616c 6c65 6420 7769 7468 2060  be called with `
+00016900: 602d 6b69 202d 6060 2074 6f20 7374 6172  `-ki -`` to star
+00016910: 740a 2020 2020 696d 6d65 6469 6174 656c  t.    immediatel
+00016920: 7920 6361 7074 7572 696e 6720 7061 636b  y capturing pack
+00016930: 6574 7320 6672 6f6d 2073 7464 696e 2e0a  ets from stdin..
+00016940: 0a20 2020 204f 7468 6572 7769 7365 2c20  .    Otherwise, 
+00016950: 7468 6520 636f 6d6d 616e 6420 7769 6c6c  the command will
+00016960: 2062 6520 7275 6e20 7769 7468 2060 602d   be run with ``-
+00016970: 7220 2d60 6020 2877 6869 6368 2069 7320  r -`` (which is 
+00016980: 636f 7272 6563 7420 666f 720a 2020 2020  correct for.    
+00016990: 6060 7463 7064 756d 7060 6020 616e 6420  ``tcpdump`` and 
+000169a0: 6060 7473 6861 726b 6060 292e 0a0a 2020  ``tshark``)...  
+000169b0: 2020 5468 6973 2063 616e 2062 6520 6f76    This can be ov
+000169c0: 6572 7269 6464 656e 2077 6974 6820 6060  erridden with ``
+000169d0: 7265 6164 5f73 7464 696e 5f6f 7074 7360  read_stdin_opts`
+000169e0: 602e 2054 6869 7320 6861 7320 6e6f 2065  `. This has no e
+000169f0: 6666 6563 7420 7768 656e 0a20 2020 2060  ffect when.    `
+00016a00: 6075 7365 5f74 656d 7066 696c 653d 5472  `use_tempfile=Tr
+00016a10: 7565 6060 2c20 6f72 206f 7468 6572 7769  ue``, or otherwi
+00016a20: 7365 2072 6561 6469 6e67 2070 6163 6b65  se reading packe
+00016a30: 7473 2066 726f 6d20 6120 7265 6775 6c61  ts from a regula
+00016a40: 7220 6669 6c65 2e0a 0a20 2020 203a 7061  r file...    :pa
+00016a50: 7261 6d20 706b 746c 6973 743a 2061 2050  ram pktlist: a P
+00016a60: 6163 6b65 7420 696e 7374 616e 6365 2c20  acket instance, 
+00016a70: 6120 5061 636b 6574 4c69 7374 2069 6e73  a PacketList ins
+00016a80: 7461 6e63 6520 6f72 2061 206c 6973 7420  tance or a list 
+00016a90: 6f66 0a20 2020 2020 2020 2050 6163 6b65  of.        Packe
+00016aa0: 7420 696e 7374 616e 6365 732e 2043 616e  t instances. Can
+00016ab0: 2061 6c73 6f20 6265 2061 2066 696c 656e   also be a filen
+00016ac0: 616d 6520 2861 7320 6120 7374 7269 6e67  ame (as a string
+00016ad0: 292c 2061 6e20 6f70 656e 0a20 2020 2020  ), an open.     
+00016ae0: 2020 2066 696c 652d 6c69 6b65 206f 626a     file-like obj
+00016af0: 6563 7420 7468 6174 206d 7573 7420 6265  ect that must be
+00016b00: 2061 2066 696c 6520 666f 726d 6174 2072   a file format r
+00016b10: 6561 6461 626c 6520 6279 0a20 2020 2020  eadable by.     
+00016b20: 2020 2074 7368 6172 6b20 2850 6361 702c     tshark (Pcap,
+00016b30: 2050 6361 704e 672c 2065 7463 2e29 206f   PcapNg, etc.) o
+00016b40: 7220 4e6f 6e65 2028 746f 2073 6e69 6666  r None (to sniff
+00016b50: 290a 2020 2020 3a70 6172 616d 2066 6c74  ).    :param flt
+00016b60: 3a20 6120 6669 6c74 6572 2074 6f20 7573  : a filter to us
+00016b70: 6520 7769 7468 2074 6370 6475 6d70 0a20  e with tcpdump. 
+00016b80: 2020 203a 7061 7261 6d20 6475 6d70 3a20     :param dump: 
+00016b90: 2020 2077 6865 6e20 7365 7420 746f 2054     when set to T
+00016ba0: 7275 652c 2072 6574 7572 6e73 2061 2073  rue, returns a s
+00016bb0: 7472 696e 6720 696e 7374 6561 6420 6f66  tring instead of
+00016bc0: 2064 6973 706c 6179 696e 6720 6974 2e0a   displaying it..
+00016bd0: 2020 2020 3a70 6172 616d 2067 6574 6664      :param getfd
+00016be0: 3a20 2020 7768 656e 2073 6574 2074 6f20  :   when set to 
+00016bf0: 5472 7565 2c20 7265 7475 726e 7320 6120  True, returns a 
+00016c00: 6669 6c65 2d6c 696b 6520 6f62 6a65 6374  file-like object
+00016c10: 2074 6f20 7265 6164 2064 6174 610a 2020   to read data.  
+00016c20: 2020 2020 2020 6672 6f6d 2074 6370 6475        from tcpdu
+00016c30: 6d70 206f 7220 7473 6861 726b 2066 726f  mp or tshark fro
+00016c40: 6d2e 0a20 2020 203a 7061 7261 6d20 6765  m..    :param ge
+00016c50: 7470 726f 633a 2077 6865 6e20 7365 7420  tproc: when set 
+00016c60: 746f 2054 7275 652c 2074 6865 2073 7562  to True, the sub
+00016c70: 7072 6f63 6573 732e 506f 7065 6e20 6f62  process.Popen ob
+00016c80: 6a65 6374 2069 7320 7265 7475 726e 6564  ject is returned
+00016c90: 0a20 2020 203a 7061 7261 6d20 6172 6773  .    :param args
+00016ca0: 3a20 2020 2061 7267 756d 656e 7473 2028  :    arguments (
+00016cb0: 6173 2061 206c 6973 7429 2074 6f20 7061  as a list) to pa
+00016cc0: 7373 2074 6f20 7473 6861 726b 2028 6578  ss to tshark (ex
+00016cd0: 616d 706c 6520 666f 7220 7473 6861 726b  ample for tshark
+00016ce0: 3a0a 2020 2020 2020 2020 6172 6773 3d5b  :.        args=[
+00016cf0: 222d 5422 2c20 226a 736f 6e22 5d29 2e0a  "-T", "json"])..
+00016d00: 2020 2020 3a70 6172 616d 2070 726f 673a      :param prog:
+00016d10: 2020 2020 7072 6f67 7261 6d20 746f 2075      program to u
+00016d20: 7365 2028 6465 6661 756c 7473 2074 6f20  se (defaults to 
+00016d30: 7463 7064 756d 702c 2077 696c 6c20 776f  tcpdump, will wo
+00016d40: 726b 2077 6974 6820 7473 6861 726b 290a  rk with tshark).
+00016d50: 2020 2020 3a70 6172 616d 2071 7569 6574      :param quiet
+00016d60: 3a20 2020 7768 656e 2073 6574 2074 6f20  :   when set to 
+00016d70: 5472 7565 2c20 7468 6520 7072 6f63 6573  True, the proces
+00016d80: 7320 7374 6465 7272 2069 7320 6469 7363  s stderr is disc
+00016d90: 6172 6465 640a 2020 2020 3a70 6172 616d  arded.    :param
+00016da0: 2075 7365 5f74 656d 7066 696c 653a 2057   use_tempfile: W
+00016db0: 6865 6e20 7365 7420 746f 2054 7275 652c  hen set to True,
+00016dc0: 2061 6c77 6179 7320 7573 6520 6120 7465   always use a te
+00016dd0: 6d70 6f72 6172 7920 6669 6c65 2074 6f20  mporary file to 
+00016de0: 7374 6f72 650a 2020 2020 2020 2020 7061  store.        pa
+00016df0: 636b 6574 732e 0a20 2020 2020 2020 2057  ckets..        W
+00016e00: 6865 6e20 7365 7420 746f 2046 616c 7365  hen set to False
+00016e10: 2c20 7069 7065 2070 6163 6b65 7473 2074  , pipe packets t
+00016e20: 6872 6f75 6768 2073 7464 696e 2e0a 2020  hrough stdin..  
+00016e30: 2020 2020 2020 5768 656e 2073 6574 2074        When set t
+00016e40: 6f20 4e6f 6e65 2028 6465 6661 756c 7429  o None (default)
+00016e50: 2c20 6f6e 6c79 2075 7365 2061 2074 656d  , only use a tem
+00016e60: 706f 7261 7279 2066 696c 6520 7769 7468  porary file with
+00016e70: 0a20 2020 2020 2020 2060 6074 6370 6475  .        ``tcpdu
+00016e80: 6d70 6060 206f 6e20 4f53 582e 0a20 2020  mp`` on OSX..   
+00016e90: 203a 7061 7261 6d20 7265 6164 5f73 7464   :param read_std
+00016ea0: 696e 5f6f 7074 733a 2057 6865 6e20 7365  in_opts: When se
+00016eb0: 742c 2061 206c 6973 7420 6f66 2061 7267  t, a list of arg
+00016ec0: 756d 656e 7473 206e 6565 6465 6420 746f  uments needed to
+00016ed0: 2063 6170 7475 7265 0a20 2020 2020 2020   capture.       
+00016ee0: 2066 726f 6d20 7374 6469 6e2e 204f 7468   from stdin. Oth
+00016ef0: 6572 7769 7365 2c20 6174 7465 6d70 7473  erwise, attempts
+00016f00: 2074 6f20 6775 6573 732e 0a20 2020 203a   to guess..    :
+00016f10: 7061 7261 6d20 6c69 6e6b 7479 7065 3a20  param linktype: 
+00016f20: 4120 6375 7374 6f6d 2044 4c54 2076 616c  A custom DLT val
+00016f30: 7565 206f 7220 6e61 6d65 2c20 746f 206f  ue or name, to o
+00016f40: 7665 7277 7269 7465 2074 6865 2064 6566  verwrite the def
+00016f50: 6175 6c74 0a20 2020 2020 2020 2076 616c  ault.        val
+00016f60: 7565 732e 0a20 2020 203a 7061 7261 6d20  ues..    :param 
+00016f70: 7761 6974 3a20 4966 2054 7275 6520 2864  wait: If True (d
+00016f80: 6566 6175 6c74 292c 2077 6169 7473 2066  efault), waits f
+00016f90: 6f72 2074 6865 2070 726f 6365 7373 2074  or the process t
+00016fa0: 6f20 7465 726d 696e 6174 6520 6265 666f  o terminate befo
+00016fb0: 7265 0a20 2020 2020 2020 2072 6574 7572  re.        retur
+00016fc0: 6e69 6e67 2074 6f20 5363 6170 792e 2049  ning to Scapy. I
+00016fd0: 6620 4661 6c73 652c 2074 6865 2070 726f  f False, the pro
+00016fe0: 6365 7373 2077 696c 6c20 6265 2064 6574  cess will be det
+00016ff0: 6163 6865 6420 746f 2074 6865 0a20 2020  ached to the.   
+00017000: 2020 2020 2062 6163 6b67 726f 756e 642e       background.
+00017010: 2049 6620 6475 6d70 2c20 6765 7470 726f   If dump, getpro
+00017020: 6320 6f72 2067 6574 6664 2069 7320 5472  c or getfd is Tr
+00017030: 7565 2c20 7468 6573 6520 6861 7665 2074  ue, these have t
+00017040: 6865 2073 616d 650a 2020 2020 2020 2020  he same.        
+00017050: 6566 6665 6374 2061 7320 6060 7761 6974  effect as ``wait
+00017060: 3d46 616c 7365 6060 2e0a 0a20 2020 2045  =False``...    E
+00017070: 7861 6d70 6c65 733a 3a0a 0a20 2020 2020  xamples::..     
+00017080: 2020 203e 3e3e 2074 6370 6475 6d70 285b     >>> tcpdump([
+00017090: 4950 2829 2f54 4350 2829 2c20 4950 2829  IP()/TCP(), IP()
+000170a0: 2f55 4450 2829 5d29 0a20 2020 2020 2020  /UDP()]).       
+000170b0: 2072 6561 6469 6e67 2066 726f 6d20 6669   reading from fi
+000170c0: 6c65 202d 2c20 6c69 6e6b 2d74 7970 6520  le -, link-type 
+000170d0: 5241 5720 2852 6177 2049 5029 0a20 2020  RAW (Raw IP).   
+000170e0: 2020 2020 2031 363a 3436 3a30 302e 3437       16:46:00.47
+000170f0: 3435 3135 2049 5020 3132 372e 302e 302e  4515 IP 127.0.0.
+00017100: 312e 3230 203e 2031 3237 2e30 2e30 2e31  1.20 > 127.0.0.1
+00017110: 2e38 303a 2046 6c61 6773 205b 535d 2c20  .80: Flags [S], 
+00017120: 7365 7120 302c 2077 696e 2038 3139 322c  seq 0, win 8192,
+00017130: 206c 656e 6774 6820 3020 2023 206e 6f71   length 0  # noq
+00017140: 613a 2045 3530 310a 2020 2020 2020 2020  a: E501.        
+00017150: 3136 3a34 363a 3030 2e34 3735 3031 3920  16:46:00.475019 
+00017160: 4950 2031 3237 2e30 2e30 2e31 2e35 3320  IP 127.0.0.1.53 
+00017170: 3e20 3132 372e 302e 302e 312e 3533 3a20  > 127.0.0.1.53: 
+00017180: 5b7c 646f 6d61 696e 5d0a 0a20 2020 2020  [|domain]..     
+00017190: 2020 203e 3e3e 2074 6370 6475 6d70 285b     >>> tcpdump([
+000171a0: 4950 2829 2f54 4350 2829 2c20 4950 2829  IP()/TCP(), IP()
+000171b0: 2f55 4450 2829 5d2c 2070 726f 673d 636f  /UDP()], prog=co
+000171c0: 6e66 2e70 726f 672e 7473 6861 726b 290a  nf.prog.tshark).
+000171d0: 2020 2020 2020 2020 2020 3120 2020 302e            1   0.
+000171e0: 3030 3030 3030 2020 2020 3132 372e 302e  000000    127.0.
+000171f0: 302e 3120 2d3e 2031 3237 2e30 2e30 2e31  0.1 -> 127.0.0.1
+00017200: 2020 2020 5443 5020 3430 2032 302d 3e38      TCP 40 20->8
+00017210: 3020 5b53 594e 5d20 5365 713d 3020 5769  0 [SYN] Seq=0 Wi
+00017220: 6e3d 3831 3932 204c 656e 3d30 2020 2320  n=8192 Len=0  # 
+00017230: 6e6f 7161 3a20 4535 3031 0a20 2020 2020  noqa: E501.     
+00017240: 2020 2020 2032 2020 2030 2e30 3030 3435       2   0.00045
+00017250: 3920 2020 2031 3237 2e30 2e30 2e31 202d  9    127.0.0.1 -
+00017260: 3e20 3132 372e 302e 302e 3120 2020 2055  > 127.0.0.1    U
+00017270: 4450 2032 3820 3533 2d3e 3533 204c 656e  DP 28 53->53 Len
+00017280: 3d30 0a0a 2020 2020 546f 2067 6574 2061  =0..    To get a
+00017290: 204a 534f 4e20 7265 7072 6573 656e 7461   JSON representa
+000172a0: 7469 6f6e 206f 6620 6120 7473 6861 726b  tion of a tshark
+000172b0: 2d70 6172 7365 6420 5061 636b 6574 4c69  -parsed PacketLi
+000172c0: 7374 2829 2c20 6f6e 6520 6361 6e3a 3a0a  st(), one can::.
+000172d0: 0a20 2020 2020 2020 203e 3e3e 2069 6d70  .        >>> imp
+000172e0: 6f72 7420 6a73 6f6e 2c20 7070 7269 6e74  ort json, pprint
+000172f0: 0a20 2020 2020 2020 203e 3e3e 206a 736f  .        >>> jso
+00017300: 6e5f 6461 7461 203d 206a 736f 6e2e 6c6f  n_data = json.lo
+00017310: 6164 2874 6370 6475 6d70 2849 5028 7372  ad(tcpdump(IP(sr
+00017320: 633d 2232 3137 2e32 352e 3137 382e 3522  c="217.25.178.5"
+00017330: 2c0a 2020 2020 2020 2020 2e2e 2e20 2020  ,.        ...   
+00017340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017350: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00017360: 7374 3d22 3435 2e33 332e 3332 2e31 3536  st="45.33.32.156
+00017370: 2229 2c0a 2020 2020 2020 2020 2e2e 2e20  "),.        ... 
+00017380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017390: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000173a0: 6f67 3d63 6f6e 662e 7072 6f67 2e74 7368  og=conf.prog.tsh
+000173b0: 6172 6b2c 0a20 2020 2020 2020 202e 2e2e  ark,.        ...
+000173c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000173d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000173e0: 7267 733d 5b22 2d54 222c 2022 6a73 6f6e  rgs=["-T", "json
+000173f0: 225d 2c0a 2020 2020 2020 2020 2e2e 2e20  "],.        ... 
+00017400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017410: 2020 2020 2020 2020 2020 2020 2020 6765                ge
+00017420: 7466 643d 5472 7565 2929 0a20 2020 2020  tfd=True)).     
+00017430: 2020 203e 3e3e 2070 7072 696e 742e 7070     >>> pprint.pp
+00017440: 7269 6e74 286a 736f 6e5f 6461 7461 290a  rint(json_data).
+00017450: 2020 2020 2020 2020 5b7b 7527 5f69 6e64          [{u'_ind
+00017460: 6578 273a 2075 2770 6163 6b65 7473 2d32  ex': u'packets-2
+00017470: 3031 362d 3132 2d32 3327 2c0a 2020 2020  016-12-23',.    
+00017480: 2020 2020 2020 7527 5f73 636f 7265 273a        u'_score':
+00017490: 204e 6f6e 652c 0a20 2020 2020 2020 2020   None,.         
+000174a0: 2075 275f 736f 7572 6365 273a 207b 7527   u'_source': {u'
+000174b0: 6c61 7965 7273 273a 207b 7527 6672 616d  layers': {u'fram
+000174c0: 6527 3a20 7b75 2766 7261 6d65 2e63 6170  e': {u'frame.cap
+000174d0: 5f6c 656e 273a 2075 2732 3027 2c0a 2020  _len': u'20',.  
+000174e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000174f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017500: 2020 2020 2020 2020 2020 2020 7527 6672              u'fr
+00017510: 616d 652e 656e 6361 705f 7479 7065 273a  ame.encap_type':
+00017520: 2075 2737 272c 0a20 2020 2020 2020 205b   u'7',.        [
+00017530: 2e2e 2e5d 0a20 2020 2020 2020 2020 2020  ...].           
+00017540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017560: 2020 207d 2c0a 2020 2020 2020 2020 2020     },.          
+00017570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017580: 2020 2020 2020 2020 2075 2769 7027 3a20           u'ip': 
+00017590: 7b75 2769 702e 6164 6472 273a 2075 2734  {u'ip.addr': u'4
+000175a0: 352e 3333 2e33 322e 3135 3627 2c0a 2020  5.33.32.156',.  
+000175b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000175c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000175d0: 2020 2020 2020 2020 2075 2769 702e 6368           u'ip.ch
+000175e0: 6563 6b73 756d 273a 2075 2730 7830 3030  ecksum': u'0x000
+000175f0: 3061 3230 6427 2c0a 2020 2020 2020 2020  0a20d',.        
+00017600: 5b2e 2e2e 5d0a 2020 2020 2020 2020 2020  [...].          
+00017610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017630: 2075 2769 702e 7474 6c27 3a20 7527 3634   u'ip.ttl': u'64
+00017640: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
+00017650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017660: 2020 2020 2020 2020 2020 2020 2020 7527                u'
+00017670: 6970 2e76 6572 7369 6f6e 273a 2075 2734  ip.version': u'4
+00017680: 277d 2c0a 2020 2020 2020 2020 2020 2020  '},.            
+00017690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000176a0: 2020 2020 2020 2075 2772 6177 273a 2075         u'raw': u
+000176b0: 2752 6177 2070 6163 6b65 7420 6461 7461  'Raw packet data
+000176c0: 277d 7d2c 0a20 2020 2020 2020 2020 2075  '}},.          u
+000176d0: 275f 7479 7065 273a 2075 2770 6361 705f  '_type': u'pcap_
+000176e0: 6669 6c65 277d 5d0a 2020 2020 2020 2020  file'}].        
+000176f0: 3e3e 3e20 6a73 6f6e 5f64 6174 615b 305d  >>> json_data[0]
+00017700: 5b27 5f73 6f75 7263 6527 5d5b 276c 6179  ['_source']['lay
+00017710: 6572 7327 5d5b 2769 7027 5d5b 2769 702e  ers']['ip']['ip.
+00017720: 7474 6c27 5d0a 2020 2020 2020 2020 7527  ttl'].        u'
+00017730: 3634 270a 2020 2020 2222 220a 2020 2020  64'.    """.    
+00017740: 6765 7466 6420 3d20 6765 7466 6420 6f72  getfd = getfd or
+00017750: 2067 6574 7072 6f63 0a20 2020 2069 6620   getproc.    if 
+00017760: 7072 6f67 2069 7320 4e6f 6e65 3a0a 2020  prog is None:.  
+00017770: 2020 2020 2020 6966 206e 6f74 2063 6f6e        if not con
+00017780: 662e 7072 6f67 2e74 6370 6475 6d70 3a0a  f.prog.tcpdump:.
+00017790: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+000177a0: 6520 5363 6170 795f 4578 6365 7074 696f  e Scapy_Exceptio
+000177b0: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+000177c0: 2020 2022 7463 7064 756d 7020 6973 206e     "tcpdump is n
+000177d0: 6f74 2061 7661 696c 6162 6c65 220a 2020  ot available".  
+000177e0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+000177f0: 2020 2020 7072 6f67 203d 205b 636f 6e66      prog = [conf
+00017800: 2e70 726f 672e 7463 7064 756d 705d 0a20  .prog.tcpdump]. 
+00017810: 2020 2065 6c69 6620 6973 696e 7374 616e     elif isinstan
+00017820: 6365 2870 726f 672c 2073 7472 293a 0a20  ce(prog, str):. 
+00017830: 2020 2020 2020 2070 726f 6720 3d20 5b70         prog = [p
+00017840: 726f 675d 0a20 2020 2065 6c73 653a 0a20  rog].    else:. 
+00017850: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00017860: 7565 4572 726f 7228 2270 726f 6720 6d75  ueError("prog mu
+00017870: 7374 2062 6520 6120 7374 7269 6e67 2229  st be a string")
+00017880: 0a0a 2020 2020 6966 206c 696e 6b74 7970  ..    if linktyp
+00017890: 6520 6973 206e 6f74 204e 6f6e 653a 0a20  e is not None:. 
+000178a0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+000178b0: 616e 6365 286c 696e 6b74 7970 652c 2069  ance(linktype, i
+000178c0: 6e74 293a 0a20 2020 2020 2020 2020 2020  nt):.           
+000178d0: 2023 2047 7565 7373 206e 616d 6520 6672   # Guess name fr
+000178e0: 6f6d 2076 616c 7565 0a20 2020 2020 2020  om value.       
+000178f0: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
+00017900: 2020 2020 2020 2020 2020 6c69 6e6b 7479            linkty
+00017910: 7065 5f6e 616d 6520 3d20 5f67 7565 7373  pe_name = _guess
+00017920: 5f6c 696e 6b74 7970 655f 6e61 6d65 286c  _linktype_name(l
+00017930: 696e 6b74 7970 6529 0a20 2020 2020 2020  inktype).       
+00017940: 2020 2020 2065 7863 6570 7420 5374 6f70       except Stop
+00017950: 4974 6572 6174 696f 6e3a 0a20 2020 2020  Iteration:.     
+00017960: 2020 2020 2020 2020 2020 206c 696e 6b74             linkt
+00017970: 7970 6520 3d20 2d31 0a20 2020 2020 2020  ype = -1.       
+00017980: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00017990: 2020 2023 2047 7565 7373 2076 616c 7565     # Guess value
+000179a0: 2066 726f 6d20 6e61 6d65 0a20 2020 2020   from name.     
+000179b0: 2020 2020 2020 2069 6620 6c69 6e6b 7479         if linkty
+000179c0: 7065 2e73 7461 7274 7377 6974 6828 2244  pe.startswith("D
+000179d0: 4c54 5f22 293a 0a20 2020 2020 2020 2020  LT_"):.         
+000179e0: 2020 2020 2020 206c 696e 6b74 7970 6520         linktype 
+000179f0: 3d20 6c69 6e6b 7479 7065 5b34 3a5d 0a20  = linktype[4:]. 
+00017a00: 2020 2020 2020 2020 2020 206c 696e 6b74             linkt
+00017a10: 7970 655f 6e61 6d65 203d 206c 696e 6b74  ype_name = linkt
+00017a20: 7970 650a 2020 2020 2020 2020 2020 2020  ype.            
+00017a30: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+00017a40: 2020 2020 206c 696e 6b74 7970 6520 3d20       linktype = 
+00017a50: 5f67 7565 7373 5f6c 696e 6b74 7970 655f  _guess_linktype_
+00017a60: 7661 6c75 6528 6c69 6e6b 7479 7065 290a  value(linktype).
+00017a70: 2020 2020 2020 2020 2020 2020 6578 6365              exce
+00017a80: 7074 204b 6579 4572 726f 723a 0a20 2020  pt KeyError:.   
+00017a90: 2020 2020 2020 2020 2020 2020 206c 696e               lin
+00017aa0: 6b74 7970 6520 3d20 2d31 0a20 2020 2020  ktype = -1.     
+00017ab0: 2020 2069 6620 6c69 6e6b 7479 7065 203d     if linktype =
+00017ac0: 3d20 2d31 3a0a 2020 2020 2020 2020 2020  = -1:.          
+00017ad0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00017ae0: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
+00017af0: 2020 2020 2255 6e6b 6e6f 776e 206c 696e      "Unknown lin
+00017b00: 6b74 7970 652e 2054 7279 2070 6173 7369  ktype. Try passi
+00017b10: 6e67 2069 7473 2064 6174 616c 696e 6b20  ng its datalink 
+00017b20: 6e61 6d65 2069 6e73 7465 6164 220a 2020  name instead".  
+00017b30: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00017b40: 2020 2020 7072 6f67 202b 3d20 5b22 2d79      prog += ["-y
+00017b50: 222c 206c 696e 6b74 7970 655f 6e61 6d65  ", linktype_name
+00017b60: 5d0a 0a20 2020 2023 2042 7569 6c64 2050  ]..    # Build P
+00017b70: 6f70 656e 2061 7267 756d 656e 7473 0a20  open arguments. 
+00017b80: 2020 2069 6620 6172 6773 2069 7320 4e6f     if args is No
+00017b90: 6e65 3a0a 2020 2020 2020 2020 6172 6773  ne:.        args
+00017ba0: 203d 205b 5d0a 2020 2020 656c 7365 3a0a   = [].    else:.
+00017bb0: 2020 2020 2020 2020 2320 4d61 6b65 2061          # Make a
+00017bc0: 2063 6f70 7920 6f66 2061 7267 730a 2020   copy of args.  
+00017bd0: 2020 2020 2020 6172 6773 203d 206c 6973        args = lis
+00017be0: 7428 6172 6773 290a 0a20 2020 2069 6620  t(args)..    if 
+00017bf0: 666c 7420 6973 206e 6f74 204e 6f6e 653a  flt is not None:
+00017c00: 0a20 2020 2020 2020 2023 2043 6865 636b  .        # Check
+00017c10: 2074 6865 2076 616c 6964 6974 7920 6f66   the validity of
+00017c20: 2074 6865 2066 696c 7465 720a 2020 2020   the filter.    
+00017c30: 2020 2020 6966 206c 696e 6b74 7970 6520      if linktype 
+00017c40: 6973 204e 6f6e 6520 616e 6420 6973 696e  is None and isin
+00017c50: 7374 616e 6365 2870 6b74 6c69 7374 2c20  stance(pktlist, 
+00017c60: 7374 7229 3a0a 2020 2020 2020 2020 2020  str):.          
+00017c70: 2020 2320 6c69 6e6b 7479 7065 2069 7320    # linktype is 
+00017c80: 756e 6b6e 6f77 6e20 6275 7420 7265 7175  unknown but requ
+00017c90: 6972 6564 2e20 5265 6164 2069 7420 6672  ired. Read it fr
+00017ca0: 6f6d 2066 696c 650a 2020 2020 2020 2020  om file.        
+00017cb0: 2020 2020 7769 7468 2050 6361 7052 6561      with PcapRea
+00017cc0: 6465 7228 706b 746c 6973 7429 2061 7320  der(pktlist) as 
+00017cd0: 7264 3a0a 2020 2020 2020 2020 2020 2020  rd:.            
+00017ce0: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00017cf0: 6528 7264 2c20 5063 6170 4e67 5265 6164  e(rd, PcapNgRead
+00017d00: 6572 293a 0a20 2020 2020 2020 2020 2020  er):.           
+00017d10: 2020 2020 2020 2020 2023 2047 6574 2074           # Get t
+00017d20: 6865 206c 696e 6b74 7970 6520 6672 6f6d  he linktype from
+00017d30: 2074 6865 2066 6972 7374 2070 6163 6b65   the first packe
+00017d40: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+00017d50: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00017d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017d70: 2020 205f 2c20 6d65 7461 6461 7461 203d     _, metadata =
+00017d80: 2072 642e 5f72 6561 645f 7061 636b 6574   rd._read_packet
+00017d90: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00017da0: 2020 2020 2020 2020 2020 206c 696e 6b74             linkt
+00017db0: 7970 6520 3d20 6d65 7461 6461 7461 2e6c  ype = metadata.l
+00017dc0: 696e 6b74 7970 650a 2020 2020 2020 2020  inktype.        
+00017dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017de0: 6966 204f 5045 4e42 5344 2061 6e64 206c  if OPENBSD and l
+00017df0: 696e 6b74 7970 6520 3d3d 2032 3238 3a0a  inktype == 228:.
+00017e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017e10: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+00017e20: 7479 7065 203d 2044 4c54 5f52 4157 0a20  type = DLT_RAW. 
+00017e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017e40: 2020 2065 7863 6570 7420 454f 4645 7272     except EOFErr
+00017e50: 6f72 3a0a 2020 2020 2020 2020 2020 2020  or:.            
+00017e60: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00017e70: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+00017e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017e90: 2020 2020 2020 2020 2020 2243 616e 6e6f            "Canno
+00017ea0: 7420 6765 7420 6c69 6e6b 7479 7065 2066  t get linktype f
+00017eb0: 726f 6d20 6120 5063 6170 4e67 2070 6163  rom a PcapNg pac
+00017ec0: 6b65 742e 220a 2020 2020 2020 2020 2020  ket.".          
+00017ed0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00017ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017ef0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00017f00: 2020 2020 2020 2020 2020 6c69 6e6b 7479            linkty
+00017f10: 7065 203d 2072 642e 6c69 6e6b 7479 7065  pe = rd.linktype
+00017f20: 0a20 2020 2020 2020 2066 726f 6d20 7363  .        from sc
+00017f30: 6170 792e 6172 6368 2e63 6f6d 6d6f 6e20  apy.arch.common 
+00017f40: 696d 706f 7274 2063 6f6d 7069 6c65 5f66  import compile_f
+00017f50: 696c 7465 720a 2020 2020 2020 2020 636f  ilter.        co
+00017f60: 6d70 696c 655f 6669 6c74 6572 2866 6c74  mpile_filter(flt
+00017f70: 2c20 6c69 6e6b 7479 7065 3d6c 696e 6b74  , linktype=linkt
+00017f80: 7970 6529 0a20 2020 2020 2020 2061 7267  ype).        arg
+00017f90: 732e 6170 7065 6e64 2866 6c74 290a 0a20  s.append(flt).. 
+00017fa0: 2020 2073 7464 6f75 7420 3d20 7375 6270     stdout = subp
+00017fb0: 726f 6365 7373 2e50 4950 4520 6966 2064  rocess.PIPE if d
+00017fc0: 756d 7020 6f72 2067 6574 6664 2065 6c73  ump or getfd els
+00017fd0: 6520 4e6f 6e65 0a20 2020 2073 7464 6572  e None.    stder
+00017fe0: 7220 3d20 6f70 656e 286f 732e 6465 766e  r = open(os.devn
+00017ff0: 756c 6c29 2069 6620 7175 6965 7420 656c  ull) if quiet el
+00018000: 7365 204e 6f6e 650a 2020 2020 7072 6f63  se None.    proc
+00018010: 203d 204e 6f6e 650a 0a20 2020 2069 6620   = None..    if 
+00018020: 7573 655f 7465 6d70 6669 6c65 2069 7320  use_tempfile is 
+00018030: 4e6f 6e65 3a0a 2020 2020 2020 2020 2320  None:.        # 
+00018040: 4170 706c 6527 7320 7463 7064 756d 7020  Apple's tcpdump 
+00018050: 6361 6e6e 6f74 2072 6561 6420 6672 6f6d  cannot read from
+00018060: 2073 7464 696e 2c20 7365 653a 0a20 2020   stdin, see:.   
+00018070: 2020 2020 2023 2068 7474 703a 2f2f 6170       # http://ap
+00018080: 706c 652e 7374 6163 6b65 7863 6861 6e67  ple.stackexchang
+00018090: 652e 636f 6d2f 7175 6573 7469 6f6e 732f  e.com/questions/
+000180a0: 3135 3236 3832 2f0a 2020 2020 2020 2020  152682/.        
+000180b0: 7573 655f 7465 6d70 6669 6c65 203d 2044  use_tempfile = D
+000180c0: 4152 5749 4e20 616e 6420 7072 6f67 5b30  ARWIN and prog[0
+000180d0: 5d20 3d3d 2063 6f6e 662e 7072 6f67 2e74  ] == conf.prog.t
+000180e0: 6370 6475 6d70 0a0a 2020 2020 6966 2072  cpdump..    if r
+000180f0: 6561 645f 7374 6469 6e5f 6f70 7473 2069  ead_stdin_opts i
+00018100: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00018110: 6966 2070 726f 675b 305d 203d 3d20 636f  if prog[0] == co
+00018120: 6e66 2e70 726f 672e 7769 7265 7368 6172  nf.prog.wireshar
+00018130: 6b3a 0a20 2020 2020 2020 2020 2020 2023  k:.            #
+00018140: 2053 7461 7274 2063 6170 7475 7269 6e67   Start capturing
+00018150: 2069 6d6d 6564 6961 7465 6c79 2028 2d6b   immediately (-k
+00018160: 2920 6672 6f6d 2073 7464 696e 2028 2d69  ) from stdin (-i
+00018170: 202d 290a 2020 2020 2020 2020 2020 2020   -).            
+00018180: 7265 6164 5f73 7464 696e 5f6f 7074 7320  read_stdin_opts 
+00018190: 3d20 5b22 2d6b 6922 2c20 222d 225d 0a20  = ["-ki", "-"]. 
+000181a0: 2020 2020 2020 2065 6c69 6620 7072 6f67         elif prog
+000181b0: 5b30 5d20 3d3d 2063 6f6e 662e 7072 6f67  [0] == conf.prog
+000181c0: 2e74 6370 6475 6d70 2061 6e64 206e 6f74  .tcpdump and not
+000181d0: 204f 5045 4e42 5344 3a0a 2020 2020 2020   OPENBSD:.      
+000181e0: 2020 2020 2020 2320 4361 7074 7572 6520        # Capture 
+000181f0: 696e 2070 6163 6b65 742d 6275 6666 6572  in packet-buffer
+00018200: 6564 206d 6f64 6520 282d 5529 2066 726f  ed mode (-U) fro
+00018210: 6d20 7374 6469 6e20 282d 7220 2d29 0a20  m stdin (-r -). 
+00018220: 2020 2020 2020 2020 2020 2072 6561 645f             read_
+00018230: 7374 6469 6e5f 6f70 7473 203d 205b 222d  stdin_opts = ["-
+00018240: 5522 2c20 222d 7222 2c20 222d 225d 0a20  U", "-r", "-"]. 
+00018250: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00018260: 2020 2020 2020 2020 2072 6561 645f 7374           read_st
+00018270: 6469 6e5f 6f70 7473 203d 205b 222d 7222  din_opts = ["-r"
+00018280: 2c20 222d 225d 0a20 2020 2065 6c73 653a  , "-"].    else:
+00018290: 0a20 2020 2020 2020 2023 204d 616b 6520  .        # Make 
+000182a0: 6120 636f 7079 206f 6620 7265 6164 5f73  a copy of read_s
+000182b0: 7464 696e 5f6f 7074 730a 2020 2020 2020  tdin_opts.      
+000182c0: 2020 7265 6164 5f73 7464 696e 5f6f 7074    read_stdin_opt
+000182d0: 7320 3d20 6c69 7374 2872 6561 645f 7374  s = list(read_st
+000182e0: 6469 6e5f 6f70 7473 290a 0a20 2020 2069  din_opts)..    i
+000182f0: 6620 706b 746c 6973 7420 6973 204e 6f6e  f pktlist is Non
+00018300: 653a 0a20 2020 2020 2020 2023 2073 6e69  e:.        # sni
+00018310: 6666 0a20 2020 2020 2020 2077 6974 6820  ff.        with 
+00018320: 436f 6e74 6578 744d 616e 6167 6572 5375  ContextManagerSu
+00018330: 6270 726f 6365 7373 2870 726f 675b 305d  bprocess(prog[0]
+00018340: 2c20 7375 7070 7265 7373 3d5f 7375 7070  , suppress=_supp
+00018350: 7265 7373 293a 0a20 2020 2020 2020 2020  ress):.         
+00018360: 2020 2070 726f 6320 3d20 7375 6270 726f     proc = subpro
+00018370: 6365 7373 2e50 6f70 656e 280a 2020 2020  cess.Popen(.    
+00018380: 2020 2020 2020 2020 2020 2020 7072 6f67              prog
+00018390: 202b 2061 7267 732c 0a20 2020 2020 2020   + args,.       
+000183a0: 2020 2020 2020 2020 2073 7464 6f75 743d           stdout=
+000183b0: 7374 646f 7574 2c0a 2020 2020 2020 2020  stdout,.        
+000183c0: 2020 2020 2020 2020 7374 6465 7272 3d73          stderr=s
+000183d0: 7464 6572 722c 0a20 2020 2020 2020 2020  tderr,.         
+000183e0: 2020 2029 0a20 2020 2065 6c69 6620 6973     ).    elif is
+000183f0: 696e 7374 616e 6365 2870 6b74 6c69 7374  instance(pktlist
+00018400: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+00018410: 2320 6669 6c65 0a20 2020 2020 2020 2077  # file.        w
+00018420: 6974 6820 436f 6e74 6578 744d 616e 6167  ith ContextManag
+00018430: 6572 5375 6270 726f 6365 7373 2870 726f  erSubprocess(pro
+00018440: 675b 305d 2c20 7375 7070 7265 7373 3d5f  g[0], suppress=_
+00018450: 7375 7070 7265 7373 293a 0a20 2020 2020  suppress):.     
+00018460: 2020 2020 2020 2070 726f 6320 3d20 7375         proc = su
+00018470: 6270 726f 6365 7373 2e50 6f70 656e 280a  bprocess.Popen(.
+00018480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018490: 7072 6f67 202b 205b 222d 7222 2c20 706b  prog + ["-r", pk
+000184a0: 746c 6973 745d 202b 2061 7267 732c 0a20  tlist] + args,. 
+000184b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000184c0: 7464 6f75 743d 7374 646f 7574 2c0a 2020  tdout=stdout,.  
+000184d0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+000184e0: 6465 7272 3d73 7464 6572 722c 0a20 2020  derr=stderr,.   
+000184f0: 2020 2020 2020 2020 2029 0a20 2020 2065           ).    e
+00018500: 6c69 6620 7573 655f 7465 6d70 6669 6c65  lif use_tempfile
+00018510: 3a0a 2020 2020 2020 2020 746d 7066 696c  :.        tmpfil
+00018520: 6520 3d20 6765 745f 7465 6d70 5f66 696c  e = get_temp_fil
+00018530: 6528 2020 2320 7479 7065 3a20 6967 6e6f  e(  # type: igno
+00018540: 7265 0a20 2020 2020 2020 2020 2020 2061  re.            a
+00018550: 7574 6f65 7874 3d22 2e70 6361 7022 2c0a  utoext=".pcap",.
+00018560: 2020 2020 2020 2020 2020 2020 6664 3d54              fd=T
+00018570: 7275 650a 2020 2020 2020 2020 2920 2023  rue.        )  #
+00018580: 2074 7970 653a 2049 4f5b 6279 7465 735d   type: IO[bytes]
+00018590: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
+000185a0: 2020 2020 2020 2020 2020 746d 7066 696c            tmpfil
+000185b0: 652e 7772 6974 656c 696e 6573 280a 2020  e.writelines(.  
+000185c0: 2020 2020 2020 2020 2020 2020 2020 6974                it
+000185d0: 6572 286c 616d 6264 613a 2070 6b74 6c69  er(lambda: pktli
+000185e0: 7374 2e72 6561 6428 3130 3438 3537 3629  st.read(1048576)
+000185f0: 2c20 6222 2229 2020 2320 7479 7065 3a20  , b"")  # type: 
+00018600: 6967 6e6f 7265 0a20 2020 2020 2020 2020  ignore.         
+00018610: 2020 2029 0a20 2020 2020 2020 2065 7863     ).        exc
+00018620: 6570 7420 4174 7472 6962 7574 6545 7272  ept AttributeErr
+00018630: 6f72 3a0a 2020 2020 2020 2020 2020 2020  or:.            
+00018640: 706b 746c 6973 7420 3d20 6361 7374 2822  pktlist = cast("
+00018650: 5f50 6163 6b65 7449 7465 7261 626c 6522  _PacketIterable"
+00018660: 2c20 706b 746c 6973 7429 0a20 2020 2020  , pktlist).     
+00018670: 2020 2020 2020 2077 7270 6361 7028 746d         wrpcap(tm
+00018680: 7066 696c 652c 2070 6b74 6c69 7374 2c20  pfile, pktlist, 
+00018690: 6c69 6e6b 7479 7065 3d6c 696e 6b74 7970  linktype=linktyp
+000186a0: 6529 0a20 2020 2020 2020 2065 6c73 653a  e).        else:
+000186b0: 0a20 2020 2020 2020 2020 2020 2074 6d70  .            tmp
+000186c0: 6669 6c65 2e63 6c6f 7365 2829 0a20 2020  file.close().   
+000186d0: 2020 2020 2077 6974 6820 436f 6e74 6578       with Contex
+000186e0: 744d 616e 6167 6572 5375 6270 726f 6365  tManagerSubproce
+000186f0: 7373 2870 726f 675b 305d 2c20 7375 7070  ss(prog[0], supp
+00018700: 7265 7373 3d5f 7375 7070 7265 7373 293a  ress=_suppress):
+00018710: 0a20 2020 2020 2020 2020 2020 2070 726f  .            pro
+00018720: 6320 3d20 7375 6270 726f 6365 7373 2e50  c = subprocess.P
+00018730: 6f70 656e 280a 2020 2020 2020 2020 2020  open(.          
+00018740: 2020 2020 2020 7072 6f67 202b 205b 222d        prog + ["-
+00018750: 7222 2c20 746d 7066 696c 652e 6e61 6d65  r", tmpfile.name
+00018760: 5d20 2b20 6172 6773 2c0a 2020 2020 2020  ] + args,.      
+00018770: 2020 2020 2020 2020 2020 7374 646f 7574            stdout
+00018780: 3d73 7464 6f75 742c 0a20 2020 2020 2020  =stdout,.       
+00018790: 2020 2020 2020 2020 2073 7464 6572 723d           stderr=
+000187a0: 7374 6465 7272 2c0a 2020 2020 2020 2020  stderr,.        
+000187b0: 2020 2020 290a 2020 2020 656c 7365 3a0a      ).    else:.
+000187c0: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+000187d0: 2020 2020 2020 2020 2070 6b74 6c69 7374           pktlist
+000187e0: 2e66 696c 656e 6f28 2920 2023 2074 7970  .fileno()  # typ
+000187f0: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
+00018800: 2020 2020 2020 2320 7061 7373 2074 6865        # pass the
+00018810: 2070 6163 6b65 7420 7374 7265 616d 0a20   packet stream. 
+00018820: 2020 2020 2020 2020 2020 2077 6974 6820             with 
+00018830: 436f 6e74 6578 744d 616e 6167 6572 5375  ContextManagerSu
+00018840: 6270 726f 6365 7373 2870 726f 675b 305d  bprocess(prog[0]
+00018850: 2c20 7375 7070 7265 7373 3d5f 7375 7070  , suppress=_supp
+00018860: 7265 7373 293a 0a20 2020 2020 2020 2020  ress):.         
+00018870: 2020 2020 2020 2070 726f 6320 3d20 7375         proc = su
+00018880: 6270 726f 6365 7373 2e50 6f70 656e 280a  bprocess.Popen(.
+00018890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000188a0: 2020 2020 7072 6f67 202b 2072 6561 645f      prog + read_
+000188b0: 7374 6469 6e5f 6f70 7473 202b 2061 7267  stdin_opts + arg
+000188c0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+000188d0: 2020 2020 2020 2073 7464 696e 3d70 6b74         stdin=pkt
+000188e0: 6c69 7374 2c20 2023 2074 7970 653a 2069  list,  # type: i
+000188f0: 676e 6f72 650a 2020 2020 2020 2020 2020  gnore.          
+00018900: 2020 2020 2020 2020 2020 7374 646f 7574            stdout
+00018910: 3d73 7464 6f75 742c 0a20 2020 2020 2020  =stdout,.       
+00018920: 2020 2020 2020 2020 2020 2020 2073 7464               std
+00018930: 6572 723d 7374 6465 7272 2c0a 2020 2020  err=stderr,.    
+00018940: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00018950: 2020 2020 2020 6578 6365 7074 2028 4174        except (At
+00018960: 7472 6962 7574 6545 7272 6f72 2c20 5661  tributeError, Va
+00018970: 6c75 6545 7272 6f72 293a 0a20 2020 2020  lueError):.     
+00018980: 2020 2020 2020 2023 2077 7269 7465 2074         # write t
+00018990: 6865 2070 6163 6b65 7420 7374 7265 616d  he packet stream
+000189a0: 2074 6f20 7374 6469 6e0a 2020 2020 2020   to stdin.      
+000189b0: 2020 2020 2020 7769 7468 2043 6f6e 7465        with Conte
+000189c0: 7874 4d61 6e61 6765 7253 7562 7072 6f63  xtManagerSubproc
+000189d0: 6573 7328 7072 6f67 5b30 5d2c 2073 7570  ess(prog[0], sup
+000189e0: 7072 6573 733d 5f73 7570 7072 6573 7329  press=_suppress)
+000189f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00018a00: 2020 7072 6f63 203d 2073 7562 7072 6f63    proc = subproc
+00018a10: 6573 732e 506f 7065 6e28 0a20 2020 2020  ess.Popen(.     
+00018a20: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00018a30: 726f 6720 2b20 7265 6164 5f73 7464 696e  rog + read_stdin
+00018a40: 5f6f 7074 7320 2b20 6172 6773 2c0a 2020  _opts + args,.  
+00018a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018a60: 2020 7374 6469 6e3d 7375 6270 726f 6365    stdin=subproce
+00018a70: 7373 2e50 4950 452c 0a20 2020 2020 2020  ss.PIPE,.       
+00018a80: 2020 2020 2020 2020 2020 2020 2073 7464               std
+00018a90: 6f75 743d 7374 646f 7574 2c0a 2020 2020  out=stdout,.    
+00018aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018ab0: 7374 6465 7272 3d73 7464 6572 722c 0a20  stderr=stderr,. 
+00018ac0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00018ad0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00018ae0: 7072 6f63 2069 7320 4e6f 6e65 3a0a 2020  proc is None:.  
+00018af0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00018b00: 416e 2065 7272 6f72 2068 6173 206f 6363  An error has occ
+00018b10: 7572 7265 640a 2020 2020 2020 2020 2020  urred.          
+00018b20: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
+00018b30: 2020 2020 2020 2020 2074 7279 3a0a 2020           try:.  
+00018b40: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00018b50: 6f63 2e73 7464 696e 2e77 7269 7465 6c69  oc.stdin.writeli
+00018b60: 6e65 7328 2020 2320 7479 7065 3a20 6967  nes(  # type: ig
+00018b70: 6e6f 7265 0a20 2020 2020 2020 2020 2020  nore.           
+00018b80: 2020 2020 2020 2020 2069 7465 7228 6c61           iter(la
+00018b90: 6d62 6461 3a20 706b 746c 6973 742e 7265  mbda: pktlist.re
+00018ba0: 6164 2831 3034 3835 3736 292c 2062 2222  ad(1048576), b""
+00018bb0: 2920 2023 2074 7970 653a 2069 676e 6f72  )  # type: ignor
+00018bc0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00018bd0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00018be0: 6578 6365 7074 2041 7474 7269 6275 7465  except Attribute
+00018bf0: 4572 726f 723a 0a20 2020 2020 2020 2020  Error:.         
+00018c00: 2020 2020 2020 2077 7270 6361 7028 7072         wrpcap(pr
+00018c10: 6f63 2e73 7464 696e 2c20 706b 746c 6973  oc.stdin, pktlis
+00018c20: 742c 206c 696e 6b74 7970 653d 6c69 6e6b  t, linktype=link
+00018c30: 7479 7065 2920 2023 2074 7970 653a 2069  type)  # type: i
+00018c40: 676e 6f72 650a 2020 2020 2020 2020 2020  gnore.          
+00018c50: 2020 6578 6365 7074 2055 6e62 6f75 6e64    except Unbound
+00018c60: 4c6f 6361 6c45 7272 6f72 3a0a 2020 2020  LocalError:.    
+00018c70: 2020 2020 2020 2020 2020 2020 2320 5468              # Th
+00018c80: 6520 6572 726f 7220 7761 7320 6861 6e64  e error was hand
+00018c90: 6c65 6420 6279 2043 6f6e 7465 7874 4d61  led by ContextMa
+00018ca0: 6e61 6765 7253 7562 7072 6f63 6573 730a  nagerSubprocess.
+00018cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018cc0: 7061 7373 0a20 2020 2020 2020 2020 2020  pass.           
+00018cd0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00018ce0: 2020 2020 2020 2070 726f 632e 7374 6469         proc.stdi
+00018cf0: 6e2e 636c 6f73 6528 2920 2023 2074 7970  n.close()  # typ
+00018d00: 653a 2069 676e 6f72 650a 2020 2020 6966  e: ignore.    if
+00018d10: 2070 726f 6320 6973 204e 6f6e 653a 0a20   proc is None:. 
+00018d20: 2020 2020 2020 2023 2041 6e20 6572 726f         # An erro
+00018d30: 7220 6861 7320 6f63 6375 7272 6564 0a20  r has occurred. 
+00018d40: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
+00018d50: 2020 6966 2064 756d 703a 0a20 2020 2020    if dump:.     
+00018d60: 2020 2064 6174 6120 3d20 6222 222e 6a6f     data = b"".jo
+00018d70: 696e 280a 2020 2020 2020 2020 2020 2020  in(.            
+00018d80: 6974 6572 286c 616d 6264 613a 2070 726f  iter(lambda: pro
+00018d90: 632e 7374 646f 7574 2e72 6561 6428 3130  c.stdout.read(10
+00018da0: 3438 3537 3629 2c20 6222 2229 2020 2320  48576), b"")  # 
+00018db0: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+00018dc0: 2020 2020 2029 0a20 2020 2020 2020 2070       ).        p
+00018dd0: 726f 632e 7465 726d 696e 6174 6528 290a  roc.terminate().
+00018de0: 2020 2020 2020 2020 7265 7475 726e 2064          return d
+00018df0: 6174 610a 2020 2020 6966 2067 6574 7072  ata.    if getpr
+00018e00: 6f63 3a0a 2020 2020 2020 2020 7265 7475  oc:.        retu
+00018e10: 726e 2070 726f 630a 2020 2020 6966 2067  rn proc.    if g
+00018e20: 6574 6664 3a0a 2020 2020 2020 2020 7265  etfd:.        re
+00018e30: 7475 726e 2070 726f 632e 7374 646f 7574  turn proc.stdout
+00018e40: 0a20 2020 2069 6620 7761 6974 3a0a 2020  .    if wait:.  
+00018e50: 2020 2020 2020 7072 6f63 2e77 6169 7428        proc.wait(
+00018e60: 290a 0a0a 4063 6f6e 662e 636f 6d6d 616e  )...@conf.comman
+00018e70: 6473 2e72 6567 6973 7465 720a 6465 6620  ds.register.def 
+00018e80: 6865 7865 6469 7428 706b 746c 6973 7429  hexedit(pktlist)
+00018e90: 3a0a 2020 2020 2320 7479 7065 3a20 285f  :.    # type: (_
+00018ea0: 5061 636b 6574 4974 6572 6162 6c65 2920  PacketIterable) 
+00018eb0: 2d3e 2050 6163 6b65 744c 6973 740a 2020  -> PacketList.  
+00018ec0: 2020 2222 2252 756e 2068 6578 6564 6974    """Run hexedit
+00018ed0: 206f 6e20 6120 6c69 7374 206f 6620 7061   on a list of pa
+00018ee0: 636b 6574 732c 2074 6865 6e20 7265 7475  ckets, then retu
+00018ef0: 726e 2074 6865 2065 6469 7465 6420 7061  rn the edited pa
+00018f00: 636b 6574 732e 2222 220a 2020 2020 6620  ckets.""".    f 
+00018f10: 3d20 6765 745f 7465 6d70 5f66 696c 6528  = get_temp_file(
+00018f20: 290a 2020 2020 7772 7063 6170 2866 2c20  ).    wrpcap(f, 
+00018f30: 706b 746c 6973 7429 0a20 2020 2077 6974  pktlist).    wit
+00018f40: 6820 436f 6e74 6578 744d 616e 6167 6572  h ContextManager
+00018f50: 5375 6270 726f 6365 7373 2863 6f6e 662e  Subprocess(conf.
+00018f60: 7072 6f67 2e68 6578 6564 6974 293a 0a20  prog.hexedit):. 
+00018f70: 2020 2020 2020 2073 7562 7072 6f63 6573         subproces
+00018f80: 732e 6361 6c6c 285b 636f 6e66 2e70 726f  s.call([conf.pro
+00018f90: 672e 6865 7865 6469 742c 2066 5d29 0a20  g.hexedit, f]). 
+00018fa0: 2020 2072 706b 746c 6973 7420 3d20 7264     rpktlist = rd
+00018fb0: 7063 6170 2866 290a 2020 2020 6f73 2e75  pcap(f).    os.u
+00018fc0: 6e6c 696e 6b28 6629 0a20 2020 2072 6574  nlink(f).    ret
+00018fd0: 7572 6e20 7270 6b74 6c69 7374 0a0a 0a64  urn rpktlist...d
+00018fe0: 6566 2067 6574 5f74 6572 6d69 6e61 6c5f  ef get_terminal_
+00018ff0: 7769 6474 6828 293a 0a20 2020 2023 2074  width():.    # t
+00019000: 7970 653a 2028 2920 2d3e 204f 7074 696f  ype: () -> Optio
+00019010: 6e61 6c5b 696e 745d 0a20 2020 2022 2222  nal[int].    """
+00019020: 4765 7420 7465 726d 696e 616c 2077 6964  Get terminal wid
+00019030: 7468 2028 6e75 6d62 6572 206f 6620 6368  th (number of ch
+00019040: 6172 6163 7465 7273 2920 6966 2069 6e20  aracters) if in 
+00019050: 6120 7769 6e64 6f77 2e0a 0a20 2020 204e  a window...    N
+00019060: 6f74 6963 653a 2074 6869 7320 7769 6c6c  otice: this will
+00019070: 2074 7279 2073 6576 6572 616c 206d 6574   try several met
+00019080: 686f 6473 2069 6e20 6f72 6465 7220 746f  hods in order to
+00019090: 0a20 2020 2073 7570 706f 7274 2061 7320  .    support as 
+000190a0: 6d61 6e79 2074 6572 6d69 6e61 6c73 2061  many terminals a
+000190b0: 6e64 204f 5320 6173 2070 6f73 7369 626c  nd OS as possibl
+000190c0: 652e 0a20 2020 2022 2222 0a20 2020 2073  e..    """.    s
+000190d0: 697a 6578 203d 2073 6875 7469 6c2e 6765  izex = shutil.ge
+000190e0: 745f 7465 726d 696e 616c 5f73 697a 6528  t_terminal_size(
+000190f0: 6661 6c6c 6261 636b 3d28 302c 2030 2929  fallback=(0, 0))
+00019100: 5b30 5d0a 2020 2020 6966 2073 697a 6578  [0].    if sizex
+00019110: 2021 3d20 303a 0a20 2020 2020 2020 2072   != 0:.        r
+00019120: 6574 7572 6e20 7369 7a65 780a 2020 2020  eturn sizex.    
+00019130: 2320 4261 636b 7570 730a 2020 2020 6966  # Backups.    if
+00019140: 2057 494e 444f 5753 3a0a 2020 2020 2020   WINDOWS:.      
+00019150: 2020 6672 6f6d 2063 7479 7065 7320 696d    from ctypes im
+00019160: 706f 7274 2077 696e 646c 6c2c 2063 7265  port windll, cre
+00019170: 6174 655f 7374 7269 6e67 5f62 7566 6665  ate_string_buffe
+00019180: 720a 2020 2020 2020 2020 2320 6874 7470  r.        # http
+00019190: 3a2f 2f63 6f64 652e 6163 7469 7665 7374  ://code.activest
+000191a0: 6174 652e 636f 6d2f 7265 6369 7065 732f  ate.com/recipes/
+000191b0: 3434 3036 3934 2d64 6574 6572 6d69 6e65  440694-determine
+000191c0: 2d73 697a 652d 6f66 2d63 6f6e 736f 6c65  -size-of-console
+000191d0: 2d77 696e 646f 772d 6f6e 2d77 696e 646f  -window-on-windo
+000191e0: 7773 2f0a 2020 2020 2020 2020 6820 3d20  ws/.        h = 
+000191f0: 7769 6e64 6c6c 2e6b 6572 6e65 6c33 322e  windll.kernel32.
+00019200: 4765 7453 7464 4861 6e64 6c65 282d 3132  GetStdHandle(-12
+00019210: 290a 2020 2020 2020 2020 6373 6269 203d  ).        csbi =
+00019220: 2063 7265 6174 655f 7374 7269 6e67 5f62   create_string_b
+00019230: 7566 6665 7228 3232 290a 2020 2020 2020  uffer(22).      
+00019240: 2020 7265 7320 3d20 7769 6e64 6c6c 2e6b    res = windll.k
+00019250: 6572 6e65 6c33 322e 4765 7443 6f6e 736f  ernel32.GetConso
+00019260: 6c65 5363 7265 656e 4275 6666 6572 496e  leScreenBufferIn
+00019270: 666f 2868 2c20 6373 6269 290a 2020 2020  fo(h, csbi).    
+00019280: 2020 2020 6966 2072 6573 3a0a 2020 2020      if res:.    
+00019290: 2020 2020 2020 2020 2862 7566 782c 2062          (bufx, b
+000192a0: 7566 792c 2063 7572 782c 2063 7572 792c  ufy, curx, cury,
+000192b0: 2077 6174 7472 2c0a 2020 2020 2020 2020   wattr,.        
+000192c0: 2020 2020 206c 6566 742c 2074 6f70 2c20       left, top, 
+000192d0: 7269 6768 742c 2062 6f74 746f 6d2c 206d  right, bottom, m
+000192e0: 6178 782c 206d 6178 7929 203d 2073 7472  axx, maxy) = str
+000192f0: 7563 742e 756e 7061 636b 2822 6868 6868  uct.unpack("hhhh
+00019300: 4868 6868 6868 6822 2c20 6373 6269 2e72  Hhhhhhh", csbi.r
+00019310: 6177 2920 2023 206e 6f71 613a 2045 3530  aw)  # noqa: E50
+00019320: 310a 2020 2020 2020 2020 2020 2020 7369  1.            si
+00019330: 7a65 7820 3d20 7269 6768 7420 2d20 6c65  zex = right - le
+00019340: 6674 202b 2031 0a20 2020 2020 2020 2020  ft + 1.         
+00019350: 2020 2023 2073 697a 6579 203d 2062 6f74     # sizey = bot
+00019360: 746f 6d20 2d20 746f 7020 2b20 310a 2020  tom - top + 1.  
+00019370: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00019380: 2073 697a 6578 0a20 2020 2020 2020 2072   sizex.        r
+00019390: 6574 7572 6e20 7369 7a65 780a 2020 2020  eturn sizex.    
+000193a0: 2320 5765 2068 6176 6520 7661 7269 6f75  # We have variou
+000193b0: 7320 6d65 7468 6f64 730a 2020 2020 2320  s methods.    # 
+000193c0: 434f 4c55 4d4e 5320 6973 2073 6574 206f  COLUMNS is set o
+000193d0: 6e20 736f 6d65 2074 6572 6d69 6e61 6c73  n some terminals
+000193e0: 0a20 2020 2074 7279 3a0a 2020 2020 2020  .    try:.      
+000193f0: 2020 7369 7a65 7820 3d20 696e 7428 6f73    sizex = int(os
+00019400: 2e65 6e76 6972 6f6e 5b27 434f 4c55 4d4e  .environ['COLUMN
+00019410: 5327 5d29 0a20 2020 2065 7863 6570 7420  S']).    except 
+00019420: 4578 6365 7074 696f 6e3a 0a20 2020 2020  Exception:.     
+00019430: 2020 2070 6173 730a 2020 2020 6966 2073     pass.    if s
+00019440: 697a 6578 3a0a 2020 2020 2020 2020 7265  izex:.        re
+00019450: 7475 726e 2073 697a 6578 0a20 2020 2023  turn sizex.    #
+00019460: 2057 6520 6361 6e20 7175 6572 7920 5449   We can query TI
+00019470: 4f43 4757 494e 535a 0a20 2020 2074 7279  OCGWINSZ.    try
+00019480: 3a0a 2020 2020 2020 2020 696d 706f 7274  :.        import
+00019490: 2066 636e 746c 0a20 2020 2020 2020 2069   fcntl.        i
+000194a0: 6d70 6f72 7420 7465 726d 696f 730a 2020  mport termios.  
+000194b0: 2020 2020 2020 7320 3d20 7374 7275 6374        s = struct
+000194c0: 2e70 6163 6b28 2748 4848 4827 2c20 302c  .pack('HHHH', 0,
+000194d0: 2030 2c20 302c 2030 290a 2020 2020 2020   0, 0, 0).      
+000194e0: 2020 7820 3d20 6663 6e74 6c2e 696f 6374    x = fcntl.ioct
+000194f0: 6c28 312c 2074 6572 6d69 6f73 2e54 494f  l(1, termios.TIO
+00019500: 4347 5749 4e53 5a2c 2073 290a 2020 2020  CGWINSZ, s).    
+00019510: 2020 2020 7369 7a65 7820 3d20 7374 7275      sizex = stru
+00019520: 6374 2e75 6e70 6163 6b28 2748 4848 4827  ct.unpack('HHHH'
+00019530: 2c20 7829 5b31 5d0a 2020 2020 6578 6365  , x)[1].    exce
+00019540: 7074 2028 494f 4572 726f 722c 204d 6f64  pt (IOError, Mod
+00019550: 756c 654e 6f74 466f 756e 6445 7272 6f72  uleNotFoundError
+00019560: 293a 0a20 2020 2020 2020 2023 2049 6620  ):.        # If 
+00019570: 6576 6572 7974 6869 6e67 2066 6169 6c65  everything faile
+00019580: 642c 2072 6574 7572 6e20 6465 6661 756c  d, return defaul
+00019590: 7420 7465 726d 696e 616c 2073 697a 650a  t terminal size.
+000195a0: 2020 2020 2020 2020 7369 7a65 7820 3d20          sizex = 
+000195b0: 3739 0a20 2020 2072 6574 7572 6e20 7369  79.    return si
+000195c0: 7a65 780a 0a0a 6465 6620 7072 6574 7479  zex...def pretty
+000195d0: 5f6c 6973 7428 7274 6c73 742c 2020 2320  _list(rtlst,  # 
+000195e0: 7479 7065 3a20 4c69 7374 5b54 7570 6c65  type: List[Tuple
+000195f0: 5b55 6e69 6f6e 5b73 7472 2c20 4c69 7374  [Union[str, List
+00019600: 5b73 7472 5d5d 2c20 2e2e 2e5d 5d0a 2020  [str]], ...]].  
+00019610: 2020 2020 2020 2020 2020 2020 2020 6865                he
+00019620: 6164 6572 2c20 2023 2074 7970 653a 204c  ader,  # type: L
+00019630: 6973 745b 5475 706c 655b 7374 722c 202e  ist[Tuple[str, .
+00019640: 2e2e 5d5d 0a20 2020 2020 2020 2020 2020  ..]].           
+00019650: 2020 2020 2073 6f72 7442 793d 302c 2020       sortBy=0,  
+00019660: 2320 7479 7065 3a20 4f70 7469 6f6e 616c  # type: Optional
+00019670: 5b69 6e74 5d0a 2020 2020 2020 2020 2020  [int].          
+00019680: 2020 2020 2020 626f 7264 6572 733d 4661        borders=Fa
+00019690: 6c73 652c 2020 2320 7479 7065 3a20 626f  lse,  # type: bo
+000196a0: 6f6c 0a20 2020 2020 2020 2020 2020 2020  ol.             
+000196b0: 2020 2029 3a0a 2020 2020 2320 7479 7065     ):.    # type
+000196c0: 3a20 282e 2e2e 2920 2d3e 2073 7472 0a20  : (...) -> str. 
+000196d0: 2020 2022 2222 0a20 2020 2050 7265 7474     """.    Prett
+000196e0: 7920 6c69 7374 2074 6f20 6669 7420 7468  y list to fit th
+000196f0: 6520 7465 726d 696e 616c 2c20 616e 6420  e terminal, and 
+00019700: 6164 6420 6865 6164 6572 2e0a 0a20 2020  add header...   
+00019710: 203a 7061 7261 6d20 7274 6c73 743a 2061   :param rtlst: a
+00019720: 206c 6973 7420 6f66 2074 7570 6c65 732e   list of tuples.
+00019730: 2065 6163 6820 7475 706c 6520 636f 6e74   each tuple cont
+00019740: 6169 6e73 2061 2076 616c 7565 2077 6869  ains a value whi
+00019750: 6368 2063 616e 0a20 2020 2020 2020 2062  ch can.        b
+00019760: 6520 6569 7468 6572 2061 2073 7472 696e  e either a strin
+00019770: 6720 6f72 2061 206c 6973 7420 6f66 2073  g or a list of s
+00019780: 7472 696e 672e 0a20 2020 203a 7061 7261  tring..    :para
+00019790: 6d20 736f 7274 4279 3a20 7468 6520 636f  m sortBy: the co
+000197a0: 6c75 6d6e 2069 6420 2873 7461 7274 696e  lumn id (startin
+000197b0: 6720 7769 7468 2030 2920 7768 6963 6820  g with 0) which 
+000197c0: 7769 6c6c 2062 6520 7573 6564 2066 6f72  will be used for
+000197d0: 0a20 2020 2020 2020 206f 7264 6572 696e  .        orderin
+000197e0: 670a 2020 2020 3a70 6172 616d 2062 6f72  g.    :param bor
+000197f0: 6465 7273 3a20 7768 6574 6865 7220 746f  ders: whether to
+00019800: 2070 7574 2062 6f72 6465 7273 206f 6e20   put borders on 
+00019810: 7468 6520 7461 626c 6520 6f72 206e 6f74  the table or not
+00019820: 0a20 2020 2022 2222 0a20 2020 2069 6620  .    """.    if 
+00019830: 626f 7264 6572 733a 0a20 2020 2020 2020  borders:.       
+00019840: 205f 7370 6163 6520 3d20 227c 220a 2020   _space = "|".  
+00019850: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00019860: 5f73 7061 6365 203d 2022 2020 220a 2020  _space = "  ".  
+00019870: 2020 636f 6c73 203d 206c 656e 2868 6561    cols = len(hea
+00019880: 6465 725b 305d 290a 2020 2020 2320 5769  der[0]).    # Wi
+00019890: 6e64 6f77 7320 6861 7320 6120 6661 7420  ndows has a fat 
+000198a0: 7465 726d 696e 616c 2062 6f72 6465 720a  terminal border.
+000198b0: 2020 2020 5f73 7061 6365 6c65 6e20 3d20      _spacelen = 
+000198c0: 6c65 6e28 5f73 7061 6365 2920 2a20 2863  len(_space) * (c
+000198d0: 6f6c 7320 2d20 3129 202b 2069 6e74 2857  ols - 1) + int(W
+000198e0: 494e 444f 5753 290a 2020 2020 5f63 726f  INDOWS).    _cro
+000198f0: 7065 6420 3d20 4661 6c73 650a 2020 2020  ped = False.    
+00019900: 6966 2073 6f72 7442 7920 6973 206e 6f74  if sortBy is not
+00019910: 204e 6f6e 653a 0a20 2020 2020 2020 2023   None:.        #
+00019920: 2053 6f72 7420 636f 7272 6563 746c 790a   Sort correctly.
+00019930: 2020 2020 2020 2020 7274 6c73 742e 736f          rtlst.so
+00019940: 7274 286b 6579 3d6c 616d 6264 6120 783a  rt(key=lambda x:
+00019950: 2078 5b73 6f72 7442 795d 290a 2020 2020   x[sortBy]).    
+00019960: 2320 5265 736f 6c76 6520 6d75 6c74 692d  # Resolve multi-
+00019970: 7661 6c75 6573 0a20 2020 2066 6f72 2069  values.    for i
+00019980: 2c20 6c69 6e65 2069 6e20 656e 756d 6572  , line in enumer
+00019990: 6174 6528 7274 6c73 7429 3a0a 2020 2020  ate(rtlst):.    
+000199a0: 2020 2020 6964 7320 3d20 5b5d 2020 2320      ids = []  # 
+000199b0: 7479 7065 3a20 4c69 7374 5b69 6e74 5d0a  type: List[int].
+000199c0: 2020 2020 2020 2020 7661 6c75 6573 203d          values =
+000199d0: 205b 5d20 2023 2074 7970 653a 204c 6973   []  # type: Lis
+000199e0: 745b 556e 696f 6e5b 7374 722c 204c 6973  t[Union[str, Lis
+000199f0: 745b 7374 725d 5d5d 0a20 2020 2020 2020  t[str]]].       
+00019a00: 2066 6f72 206a 2c20 7661 6c20 696e 2065   for j, val in e
+00019a10: 6e75 6d65 7261 7465 286c 696e 6529 3a0a  numerate(line):.
+00019a20: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00019a30: 7369 6e73 7461 6e63 6528 7661 6c2c 206c  sinstance(val, l
+00019a40: 6973 7429 3a0a 2020 2020 2020 2020 2020  ist):.          
+00019a50: 2020 2020 2020 6964 732e 6170 7065 6e64        ids.append
+00019a60: 286a 290a 2020 2020 2020 2020 2020 2020  (j).            
+00019a70: 2020 2020 7661 6c75 6573 2e61 7070 656e      values.appen
+00019a80: 6428 7661 6c20 6f72 2022 2022 290a 2020  d(val or " ").  
+00019a90: 2020 2020 2020 6966 2076 616c 7565 733a        if values:
+00019aa0: 0a20 2020 2020 2020 2020 2020 2064 656c  .            del
+00019ab0: 2072 746c 7374 5b69 5d0a 2020 2020 2020   rtlst[i].      
+00019ac0: 2020 2020 2020 6b20 3d20 300a 2020 2020        k = 0.    
+00019ad0: 2020 2020 2020 2020 666f 7220 6578 5f76          for ex_v
+00019ae0: 616c 7320 696e 207a 6970 5f6c 6f6e 6765  als in zip_longe
+00019af0: 7374 282a 7661 6c75 6573 2c20 6669 6c6c  st(*values, fill
+00019b00: 7661 6c75 653d 2220 2229 3a0a 2020 2020  value=" "):.    
+00019b10: 2020 2020 2020 2020 2020 2020 6966 206b              if k
+00019b20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00019b30: 2020 2020 2020 6578 7472 615f 6c69 6e65        extra_line
+00019b40: 203d 205b 2220 225d 202a 2063 6f6c 730a   = [" "] * cols.
+00019b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019b60: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00019b70: 2020 2020 2020 2020 2020 6578 7472 615f            extra_
+00019b80: 6c69 6e65 203d 206c 6973 7428 6c69 6e65  line = list(line
+00019b90: 2920 2023 2074 7970 653a 2069 676e 6f72  )  # type: ignor
+00019ba0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00019bb0: 2020 666f 7220 6a2c 2068 2069 6e20 656e    for j, h in en
+00019bc0: 756d 6572 6174 6528 6964 7329 3a0a 2020  umerate(ids):.  
+00019bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019be0: 2020 6578 7472 615f 6c69 6e65 5b68 5d20    extra_line[h] 
+00019bf0: 3d20 6578 5f76 616c 735b 6a5d 0a20 2020  = ex_vals[j].   
+00019c00: 2020 2020 2020 2020 2020 2020 2072 746c               rtl
+00019c10: 7374 2e69 6e73 6572 7428 6920 2b20 6b2c  st.insert(i + k,
+00019c20: 2074 7570 6c65 2865 7874 7261 5f6c 696e   tuple(extra_lin
+00019c30: 6529 290a 2020 2020 2020 2020 2020 2020  e)).            
+00019c40: 2020 2020 6b20 2b3d 2031 0a20 2020 2072      k += 1.    r
+00019c50: 7473 6c73 7420 3d20 6361 7374 284c 6973  tslst = cast(Lis
+00019c60: 745b 5475 706c 655b 7374 722c 202e 2e2e  t[Tuple[str, ...
+00019c70: 5d5d 2c20 7274 6c73 7429 0a20 2020 2023  ]], rtlst).    #
+00019c80: 2041 7070 656e 6420 7461 670a 2020 2020   Append tag.    
+00019c90: 7274 736c 7374 203d 2068 6561 6465 7220  rtslst = header 
+00019ca0: 2b20 7274 736c 7374 0a20 2020 2023 2044  + rtslst.    # D
+00019cb0: 6574 6563 7420 636f 6c75 6d6e 2773 2077  etect column's w
+00019cc0: 6964 7468 0a20 2020 2063 6f6c 7769 6474  idth.    colwidt
+00019cd0: 6820 3d20 5b6d 6178 286c 656e 2879 2920  h = [max(len(y) 
+00019ce0: 666f 7220 7920 696e 2078 2920 666f 7220  for y in x) for 
+00019cf0: 7820 696e 207a 6970 282a 7274 736c 7374  x in zip(*rtslst
+00019d00: 295d 0a20 2020 2023 204d 616b 6520 7465  )].    # Make te
+00019d10: 7874 2066 6974 2069 6e20 626f 7820 2869  xt fit in box (i
+00019d20: 6620 7265 7175 6972 6564 290a 2020 2020  f required).    
+00019d30: 7769 6474 6820 3d20 6765 745f 7465 726d  width = get_term
+00019d40: 696e 616c 5f77 6964 7468 2829 0a20 2020  inal_width().   
+00019d50: 2069 6620 636f 6e66 2e61 7574 6f5f 6372   if conf.auto_cr
+00019d60: 6f70 5f74 6162 6c65 7320 616e 6420 7769  op_tables and wi
+00019d70: 6474 683a 0a20 2020 2020 2020 2077 6964  dth:.        wid
+00019d80: 7468 203d 2077 6964 7468 202d 205f 7370  th = width - _sp
+00019d90: 6163 656c 656e 0a20 2020 2020 2020 2077  acelen.        w
+00019da0: 6869 6c65 2073 756d 2863 6f6c 7769 6474  hile sum(colwidt
+00019db0: 6829 203e 2077 6964 7468 3a0a 2020 2020  h) > width:.    
+00019dc0: 2020 2020 2020 2020 5f63 726f 7065 6420          _croped 
+00019dd0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+00019de0: 2020 2023 204e 6565 6473 2074 6f20 6265     # Needs to be
+00019df0: 2063 726f 7070 6564 0a20 2020 2020 2020   cropped.       
+00019e00: 2020 2020 2023 2047 6574 2074 6865 206c       # Get the l
+00019e10: 6f6e 6765 7374 2072 6f77 0a20 2020 2020  ongest row.     
+00019e20: 2020 2020 2020 2069 203d 2063 6f6c 7769         i = colwi
+00019e30: 6474 682e 696e 6465 7828 6d61 7828 636f  dth.index(max(co
+00019e40: 6c77 6964 7468 2929 0a20 2020 2020 2020  lwidth)).       
+00019e50: 2020 2020 2023 2047 6574 2061 6c6c 2065       # Get all e
+00019e60: 6c65 6d65 6e74 7320 6f66 2074 6869 7320  lements of this 
+00019e70: 726f 770a 2020 2020 2020 2020 2020 2020  row.            
+00019e80: 726f 7720 3d20 5b6c 656e 2878 5b69 5d29  row = [len(x[i])
+00019e90: 2066 6f72 2078 2069 6e20 7274 736c 7374   for x in rtslst
+00019ea0: 5d0a 2020 2020 2020 2020 2020 2020 2320  ].            # 
+00019eb0: 4765 7420 6269 6767 6573 7420 656c 656d  Get biggest elem
+00019ec0: 656e 7420 6f66 2074 6869 7320 726f 773a  ent of this row:
+00019ed0: 2062 6967 6765 7374 206f 6620 7468 6520   biggest of the 
+00019ee0: 6172 7261 790a 2020 2020 2020 2020 2020  array.          
+00019ef0: 2020 6a20 3d20 726f 772e 696e 6465 7828    j = row.index(
+00019f00: 6d61 7828 726f 7729 290a 2020 2020 2020  max(row)).      
+00019f10: 2020 2020 2020 2320 5265 2d62 7569 6c64        # Re-build
+00019f20: 2063 6f6c 756d 6e20 7475 706c 6520 7769   column tuple wi
+00019f30: 7468 2074 6865 2065 6469 7465 6420 656c  th the edited el
+00019f40: 656d 656e 740a 2020 2020 2020 2020 2020  ement.          
+00019f50: 2020 7420 3d20 6c69 7374 2872 7473 6c73    t = list(rtsls
+00019f60: 745b 6a5d 290a 2020 2020 2020 2020 2020  t[j]).          
+00019f70: 2020 745b 695d 203d 2074 5b69 5d5b 3a2d    t[i] = t[i][:-
+00019f80: 325d 202b 2022 5f22 0a20 2020 2020 2020  2] + "_".       
+00019f90: 2020 2020 2072 7473 6c73 745b 6a5d 203d       rtslst[j] =
+00019fa0: 2074 7570 6c65 2874 290a 2020 2020 2020   tuple(t).      
+00019fb0: 2020 2020 2020 2320 5570 6461 7465 206d        # Update m
+00019fc0: 6178 2073 697a 650a 2020 2020 2020 2020  ax size.        
+00019fd0: 2020 2020 726f 775b 6a5d 203d 206c 656e      row[j] = len
+00019fe0: 2874 5b69 5d29 0a20 2020 2020 2020 2020  (t[i]).         
+00019ff0: 2020 2063 6f6c 7769 6474 685b 695d 203d     colwidth[i] =
+0001a000: 206d 6178 2872 6f77 290a 2020 2020 6966   max(row).    if
+0001a010: 205f 6372 6f70 6564 3a0a 2020 2020 2020   _croped:.      
+0001a020: 2020 6c6f 675f 7275 6e74 696d 652e 696e    log_runtime.in
+0001a030: 666f 2822 5461 626c 6520 6372 6f70 7065  fo("Table croppe
+0001a040: 6420 746f 2066 6974 2074 6865 2074 6572  d to fit the ter
+0001a050: 6d69 6e61 6c20 2863 6f6e 662e 6175 746f  minal (conf.auto
+0001a060: 5f63 726f 705f 7461 626c 6573 3d3d 5472  _crop_tables==Tr
+0001a070: 7565 2922 2920 2023 206e 6f71 613a 2045  ue)")  # noqa: E
+0001a080: 3530 310a 2020 2020 2320 4765 6e65 7261  501.    # Genera
+0001a090: 7465 2070 6164 6469 6e67 2073 6368 656d  te padding schem
+0001a0a0: 650a 2020 2020 666d 7420 3d20 5f73 7061  e.    fmt = _spa
+0001a0b0: 6365 2e6a 6f69 6e28 5b22 2525 2d25 6473  ce.join(["%%-%ds
+0001a0c0: 2220 2520 7820 666f 7220 7820 696e 2063  " % x for x in c
+0001a0d0: 6f6c 7769 6474 685d 290a 2020 2020 2320  olwidth]).    # 
+0001a0e0: 4170 7065 6e64 2073 6570 6172 6174 696f  Append separatio
+0001a0f0: 6e20 6c69 6e65 2069 6620 6e65 6564 6564  n line if needed
+0001a100: 0a20 2020 2069 6620 626f 7264 6572 733a  .    if borders:
+0001a110: 0a20 2020 2020 2020 2072 7473 6c73 742e  .        rtslst.
+0001a120: 696e 7365 7274 2831 2c20 7475 706c 6528  insert(1, tuple(
+0001a130: 222d 2220 2a20 7820 666f 7220 7820 696e  "-" * x for x in
+0001a140: 2063 6f6c 7769 6474 6829 290a 2020 2020   colwidth)).    
+0001a150: 2320 436f 6d70 696c 650a 2020 2020 7265  # Compile.    re
+0001a160: 7475 726e 2022 5c6e 222e 6a6f 696e 2866  turn "\n".join(f
+0001a170: 6d74 2025 2078 2066 6f72 2078 2069 6e20  mt % x for x in 
+0001a180: 7274 736c 7374 290a 0a0a 6465 6620 6875  rtslst)...def hu
+0001a190: 6d61 6e5f 7369 7a65 2878 2c20 666d 743d  man_size(x, fmt=
+0001a1a0: 222e 3166 2229 3a0a 2020 2020 2320 7479  ".1f"):.    # ty
+0001a1b0: 7065 3a20 2869 6e74 2c20 7374 7229 202d  pe: (int, str) -
+0001a1c0: 3e20 7374 720a 2020 2020 2222 220a 2020  > str.    """.  
+0001a1d0: 2020 436f 6e76 6572 7420 6120 7369 7a65    Convert a size
+0001a1e0: 2069 6e20 6f63 7465 7473 2074 6f20 6120   in octets to a 
+0001a1f0: 6875 6d61 6e20 7374 7269 6e67 2072 6570  human string rep
+0001a200: 7265 7365 6e74 6174 696f 6e0a 2020 2020  resentation.    
+0001a210: 2222 220a 2020 2020 756e 6974 7320 3d20  """.    units = 
+0001a220: 5b27 4b27 2c20 274d 272c 2027 4727 2c20  ['K', 'M', 'G', 
+0001a230: 2754 272c 2027 5027 2c20 2745 275d 0a20  'T', 'P', 'E']. 
+0001a240: 2020 2069 6620 6e6f 7420 783a 0a20 2020     if not x:.   
+0001a250: 2020 2020 2072 6574 7572 6e20 2230 4222       return "0B"
+0001a260: 0a20 2020 2069 203d 2069 6e74 286d 6174  .    i = int(mat
+0001a270: 682e 6c6f 6728 782c 2032 2a2a 3130 2929  h.log(x, 2**10))
+0001a280: 0a20 2020 2069 6620 6920 616e 6420 6920  .    if i and i 
+0001a290: 3c20 6c65 6e28 756e 6974 7329 3a0a 2020  < len(units):.  
+0001a2a0: 2020 2020 2020 7265 7475 726e 2066 6f72        return for
+0001a2b0: 6d61 7428 7820 2f20 322a 2a28 3130 202a  mat(x / 2**(10 *
+0001a2c0: 2069 292c 2066 6d74 2920 2b20 756e 6974   i), fmt) + unit
+0001a2d0: 735b 6920 2d20 315d 0a20 2020 2072 6574  s[i - 1].    ret
+0001a2e0: 7572 6e20 7374 7228 7829 202b 2022 4222  urn str(x) + "B"
+0001a2f0: 0a0a 0a64 6566 205f 5f6d 616b 655f 7461  ...def __make_ta
+0001a300: 626c 6528 0a20 2020 2079 666d 7466 756e  ble(.    yfmtfun
+0001a310: 632c 2020 2320 7479 7065 3a20 4361 6c6c  c,  # type: Call
+0001a320: 6162 6c65 5b5b 696e 745d 2c20 7374 725d  able[[int], str]
+0001a330: 0a20 2020 2066 6d74 6675 6e63 2c20 2023  .    fmtfunc,  #
+0001a340: 2074 7970 653a 2043 616c 6c61 626c 655b   type: Callable[
+0001a350: 5b69 6e74 5d2c 2073 7472 5d0a 2020 2020  [int], str].    
+0001a360: 656e 646c 696e 652c 2020 2320 7479 7065  endline,  # type
+0001a370: 3a20 7374 720a 2020 2020 6461 7461 2c20  : str.    data, 
+0001a380: 2023 2074 7970 653a 204c 6973 745b 5475   # type: List[Tu
+0001a390: 706c 655b 5061 636b 6574 2c20 5061 636b  ple[Packet, Pack
+0001a3a0: 6574 5d5d 0a20 2020 2066 7879 7a2c 2020  et]].    fxyz,  
+0001a3b0: 2320 7479 7065 3a20 4361 6c6c 6162 6c65  # type: Callable
+0001a3c0: 5b5b 5061 636b 6574 2c20 5061 636b 6574  [[Packet, Packet
+0001a3d0: 5d2c 2054 7570 6c65 5b41 6e79 2c20 416e  ], Tuple[Any, An
+0001a3e0: 792c 2041 6e79 5d5d 0a20 2020 2073 6f72  y, Any]].    sor
+0001a3f0: 7478 3d4e 6f6e 652c 2020 2320 7479 7065  tx=None,  # type
+0001a400: 3a20 4f70 7469 6f6e 616c 5b43 616c 6c61  : Optional[Calla
+0001a410: 626c 655b 5b73 7472 5d2c 2054 7570 6c65  ble[[str], Tuple
+0001a420: 5b41 6e79 2c20 2e2e 2e5d 5d5d 0a20 2020  [Any, ...]]].   
+0001a430: 2073 6f72 7479 3d4e 6f6e 652c 2020 2320   sorty=None,  # 
+0001a440: 7479 7065 3a20 4f70 7469 6f6e 616c 5b43  type: Optional[C
+0001a450: 616c 6c61 626c 655b 5b73 7472 5d2c 2054  allable[[str], T
+0001a460: 7570 6c65 5b41 6e79 2c20 2e2e 2e5d 5d5d  uple[Any, ...]]]
+0001a470: 0a20 2020 2073 6570 6c69 6e65 6675 6e63  .    seplinefunc
+0001a480: 3d4e 6f6e 652c 2020 2320 7479 7065 3a20  =None,  # type: 
+0001a490: 4f70 7469 6f6e 616c 5b43 616c 6c61 626c  Optional[Callabl
+0001a4a0: 655b 5b69 6e74 2c20 4c69 7374 5b69 6e74  e[[int, List[int
+0001a4b0: 5d5d 2c20 7374 725d 5d0a 2020 2020 6475  ]], str]].    du
+0001a4c0: 6d70 3d46 616c 7365 2020 2320 7479 7065  mp=False  # type
+0001a4d0: 3a20 626f 6f6c 0a29 3a0a 2020 2020 2320  : bool.):.    # 
+0001a4e0: 7479 7065 3a20 282e 2e2e 2920 2d3e 204f  type: (...) -> O
+0001a4f0: 7074 696f 6e61 6c5b 7374 725d 0a20 2020  ptional[str].   
+0001a500: 2022 2222 436f 7265 2066 756e 6374 696f   """Core functio
+0001a510: 6e20 6f66 2074 6865 206d 616b 655f 7461  n of the make_ta
+0001a520: 626c 6520 7375 6974 652c 2077 6869 6368  ble suite, which
+0001a530: 2067 656e 6572 6174 6573 2074 6865 2074   generates the t
+0001a540: 6162 6c65 2222 220a 2020 2020 7678 203d  able""".    vx =
+0001a550: 207b 7d20 2023 2074 7970 653a 2044 6963   {}  # type: Dic
+0001a560: 745b 7374 722c 2069 6e74 5d0a 2020 2020  t[str, int].    
+0001a570: 7679 203d 207b 7d20 2023 2074 7970 653a  vy = {}  # type:
+0001a580: 2044 6963 745b 7374 722c 204f 7074 696f   Dict[str, Optio
+0001a590: 6e61 6c5b 696e 745d 5d0a 2020 2020 767a  nal[int]].    vz
+0001a5a0: 203d 207b 7d20 2023 2074 7970 653a 2044   = {}  # type: D
+0001a5b0: 6963 745b 5475 706c 655b 7374 722c 2073  ict[Tuple[str, s
+0001a5c0: 7472 5d2c 2073 7472 5d0a 2020 2020 7678  tr], str].    vx
+0001a5d0: 6620 3d20 7b7d 2020 2320 7479 7065 3a20  f = {}  # type: 
+0001a5e0: 4469 6374 5b73 7472 2c20 7374 725d 0a0a  Dict[str, str]..
+0001a5f0: 2020 2020 746d 705f 6c65 6e20 3d20 300a      tmp_len = 0.
+0001a600: 2020 2020 666f 7220 6520 696e 2064 6174      for e in dat
+0001a610: 613a 0a20 2020 2020 2020 2078 782c 2079  a:.        xx, y
+0001a620: 792c 207a 7a20 3d20 5b73 7472 2873 2920  y, zz = [str(s) 
+0001a630: 666f 7220 7320 696e 2066 7879 7a28 2a65  for s in fxyz(*e
+0001a640: 295d 0a20 2020 2020 2020 2074 6d70 5f6c  )].        tmp_l
+0001a650: 656e 203d 206d 6178 286c 656e 2879 7929  en = max(len(yy)
+0001a660: 2c20 746d 705f 6c65 6e29 0a20 2020 2020  , tmp_len).     
+0001a670: 2020 2076 785b 7878 5d20 3d20 6d61 7828     vx[xx] = max(
+0001a680: 7678 2e67 6574 2878 782c 2030 292c 206c  vx.get(xx, 0), l
+0001a690: 656e 2878 7829 2c20 6c65 6e28 7a7a 2929  en(xx), len(zz))
+0001a6a0: 0a20 2020 2020 2020 2076 795b 7979 5d20  .        vy[yy] 
+0001a6b0: 3d20 4e6f 6e65 0a20 2020 2020 2020 2076  = None.        v
+0001a6c0: 7a5b 2878 782c 2079 7929 5d20 3d20 7a7a  z[(xx, yy)] = zz
+0001a6d0: 0a0a 2020 2020 7678 6b20 3d20 6c69 7374  ..    vxk = list
+0001a6e0: 2876 7829 0a20 2020 2076 796b 203d 206c  (vx).    vyk = l
+0001a6f0: 6973 7428 7679 290a 2020 2020 6966 2073  ist(vy).    if s
+0001a700: 6f72 7478 3a0a 2020 2020 2020 2020 7678  ortx:.        vx
+0001a710: 6b2e 736f 7274 286b 6579 3d73 6f72 7478  k.sort(key=sortx
+0001a720: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+0001a730: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+0001a740: 2020 2020 2076 786b 2e73 6f72 7428 6b65       vxk.sort(ke
+0001a750: 793d 696e 7429 0a20 2020 2020 2020 2065  y=int).        e
+0001a760: 7863 6570 7420 4578 6365 7074 696f 6e3a  xcept Exception:
+0001a770: 0a20 2020 2020 2020 2020 2020 2074 7279  .            try
+0001a780: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001a790: 2020 7678 6b2e 736f 7274 286b 6579 3d61    vxk.sort(key=a
+0001a7a0: 746f 6c29 0a20 2020 2020 2020 2020 2020  tol).           
+0001a7b0: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+0001a7c0: 6e3a 0a20 2020 2020 2020 2020 2020 2020  n:.             
+0001a7d0: 2020 2076 786b 2e73 6f72 7428 290a 2020     vxk.sort().  
+0001a7e0: 2020 6966 2073 6f72 7479 3a0a 2020 2020    if sorty:.    
+0001a7f0: 2020 2020 7679 6b2e 736f 7274 286b 6579      vyk.sort(key
+0001a800: 3d73 6f72 7479 290a 2020 2020 656c 7365  =sorty).    else
+0001a810: 3a0a 2020 2020 2020 2020 7472 793a 0a20  :.        try:. 
+0001a820: 2020 2020 2020 2020 2020 2076 796b 2e73             vyk.s
+0001a830: 6f72 7428 6b65 793d 696e 7429 0a20 2020  ort(key=int).   
+0001a840: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+0001a850: 7074 696f 6e3a 0a20 2020 2020 2020 2020  ption:.         
+0001a860: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+0001a870: 2020 2020 2020 2020 7679 6b2e 736f 7274          vyk.sort
+0001a880: 286b 6579 3d61 746f 6c29 0a20 2020 2020  (key=atol).     
+0001a890: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
+0001a8a0: 6365 7074 696f 6e3a 0a20 2020 2020 2020  ception:.       
+0001a8b0: 2020 2020 2020 2020 2076 796b 2e73 6f72           vyk.sor
+0001a8c0: 7428 290a 0a20 2020 2073 203d 2022 220a  t()..    s = "".
+0001a8d0: 2020 2020 6966 2073 6570 6c69 6e65 6675      if seplinefu
+0001a8e0: 6e63 3a0a 2020 2020 2020 2020 7365 706c  nc:.        sepl
+0001a8f0: 696e 6520 3d20 7365 706c 696e 6566 756e  ine = seplinefun
+0001a900: 6328 746d 705f 6c65 6e2c 205b 7678 5b78  c(tmp_len, [vx[x
+0001a910: 5d20 666f 7220 7820 696e 2076 786b 5d29  ] for x in vxk])
+0001a920: 0a20 2020 2020 2020 2073 202b 3d20 7365  .        s += se
+0001a930: 706c 696e 6520 2b20 225c 6e22 0a0a 2020  pline + "\n"..  
+0001a940: 2020 666d 7420 3d20 7966 6d74 6675 6e63    fmt = yfmtfunc
+0001a950: 2874 6d70 5f6c 656e 290a 2020 2020 7320  (tmp_len).    s 
+0001a960: 2b3d 2066 6d74 2025 2022 220a 2020 2020  += fmt % "".    
+0001a970: 7320 2b3d 2027 2027 0a20 2020 2066 6f72  s += ' '.    for
+0001a980: 2078 2069 6e20 7678 6b3a 0a20 2020 2020   x in vxk:.     
+0001a990: 2020 2076 7866 5b78 5d20 3d20 666d 7466     vxf[x] = fmtf
+0001a9a0: 756e 6328 7678 5b78 5d29 0a20 2020 2020  unc(vx[x]).     
+0001a9b0: 2020 2073 202b 3d20 7678 665b 785d 2025     s += vxf[x] %
+0001a9c0: 2078 0a20 2020 2020 2020 2073 202b 3d20   x.        s += 
+0001a9d0: 2720 270a 2020 2020 7320 2b3d 2065 6e64  ' '.    s += end
+0001a9e0: 6c69 6e65 202b 2022 5c6e 220a 2020 2020  line + "\n".    
+0001a9f0: 6966 2073 6570 6c69 6e65 6675 6e63 3a0a  if seplinefunc:.
+0001aa00: 2020 2020 2020 2020 7320 2b3d 2073 6570          s += sep
+0001aa10: 6c69 6e65 202b 2022 5c6e 220a 2020 2020  line + "\n".    
+0001aa20: 666f 7220 7920 696e 2076 796b 3a0a 2020  for y in vyk:.  
+0001aa30: 2020 2020 2020 7320 2b3d 2066 6d74 2025        s += fmt %
+0001aa40: 2079 0a20 2020 2020 2020 2073 202b 3d20   y.        s += 
+0001aa50: 2720 270a 2020 2020 2020 2020 666f 7220  ' '.        for 
+0001aa60: 7820 696e 2076 786b 3a0a 2020 2020 2020  x in vxk:.      
+0001aa70: 2020 2020 2020 7320 2b3d 2076 7866 5b78        s += vxf[x
+0001aa80: 5d20 2520 767a 2e67 6574 2828 782c 2079  ] % vz.get((x, y
+0001aa90: 292c 2022 2d22 290a 2020 2020 2020 2020  ), "-").        
+0001aaa0: 2020 2020 7320 2b3d 2027 2027 0a20 2020      s += ' '.   
+0001aab0: 2020 2020 2073 202b 3d20 656e 646c 696e       s += endlin
+0001aac0: 6520 2b20 225c 6e22 0a20 2020 2069 6620  e + "\n".    if 
+0001aad0: 7365 706c 696e 6566 756e 633a 0a20 2020  seplinefunc:.   
+0001aae0: 2020 2020 2073 202b 3d20 7365 706c 696e       s += seplin
+0001aaf0: 6520 2b20 225c 6e22 0a0a 2020 2020 6966  e + "\n"..    if
+0001ab00: 2064 756d 703a 0a20 2020 2020 2020 2072   dump:.        r
+0001ab10: 6574 7572 6e20 730a 2020 2020 656c 7365  eturn s.    else
+0001ab20: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
+0001ab30: 732c 2065 6e64 3d22 2229 0a20 2020 2020  s, end="").     
+0001ab40: 2020 2072 6574 7572 6e20 4e6f 6e65 0a0a     return None..
+0001ab50: 0a64 6566 206d 616b 655f 7461 626c 6528  .def make_table(
+0001ab60: 2a61 7267 732c 202a 2a6b 6172 6773 293a  *args, **kargs):
+0001ab70: 0a20 2020 2023 2074 7970 653a 2028 2a41  .    # type: (*A
+0001ab80: 6e79 2c20 2a2a 416e 7929 202d 3e20 4f70  ny, **Any) -> Op
+0001ab90: 7469 6f6e 616c 5b41 6e79 5d0a 2020 2020  tional[Any].    
+0001aba0: 7265 7475 726e 205f 5f6d 616b 655f 7461  return __make_ta
+0001abb0: 626c 6528 0a20 2020 2020 2020 206c 616d  ble(.        lam
+0001abc0: 6264 6120 6c3a 2022 2525 2d25 6973 2220  bda l: "%%-%is" 
+0001abd0: 2520 6c2c 0a20 2020 2020 2020 206c 616d  % l,.        lam
+0001abe0: 6264 6120 6c3a 2022 2525 2d25 6973 2220  bda l: "%%-%is" 
+0001abf0: 2520 6c2c 0a20 2020 2020 2020 2022 222c  % l,.        "",
+0001ac00: 0a20 2020 2020 2020 202a 6172 6773 2c0a  .        *args,.
+0001ac10: 2020 2020 2020 2020 2a2a 6b61 7267 730a          **kargs.
+0001ac20: 2020 2020 290a 0a0a 6465 6620 6d61 6b65      )...def make
+0001ac30: 5f6c 696e 6564 5f74 6162 6c65 282a 6172  _lined_table(*ar
+0001ac40: 6773 2c20 2a2a 6b61 7267 7329 3a0a 2020  gs, **kargs):.  
+0001ac50: 2020 2320 7479 7065 3a20 282a 416e 792c    # type: (*Any,
+0001ac60: 202a 2a41 6e79 2920 2d3e 204f 7074 696f   **Any) -> Optio
+0001ac70: 6e61 6c5b 7374 725d 0a20 2020 2072 6574  nal[str].    ret
+0001ac80: 7572 6e20 5f5f 6d61 6b65 5f74 6162 6c65  urn __make_table
+0001ac90: 2820 2023 2074 7970 653a 2069 676e 6f72  (  # type: ignor
+0001aca0: 650a 2020 2020 2020 2020 6c61 6d62 6461  e.        lambda
+0001acb0: 206c 3a20 2225 252d 2569 7320 7c22 2025   l: "%%-%is |" %
+0001acc0: 206c 2c0a 2020 2020 2020 2020 6c61 6d62   l,.        lamb
+0001acd0: 6461 206c 3a20 2225 252d 2569 7320 7c22  da l: "%%-%is |"
+0001ace0: 2025 206c 2c0a 2020 2020 2020 2020 2222   % l,.        ""
+0001acf0: 2c0a 2020 2020 2020 2020 2a61 7267 732c  ,.        *args,
+0001ad00: 0a20 2020 2020 2020 2073 6570 6c69 6e65  .        sepline
+0001ad10: 6675 6e63 3d6c 616d 6264 6120 612c 2078  func=lambda a, x
+0001ad20: 3a20 222b 222e 6a6f 696e 280a 2020 2020  : "+".join(.    
+0001ad30: 2020 2020 2020 2020 272d 2720 2a20 2879          '-' * (y
+0001ad40: 202b 2032 2920 666f 7220 7920 696e 205b   + 2) for y in [
+0001ad50: 6120 2d20 315d 202b 2078 202b 205b 2d32  a - 1] + x + [-2
+0001ad60: 5d0a 2020 2020 2020 2020 292c 0a20 2020  ].        ),.   
+0001ad70: 2020 2020 202a 2a6b 6172 6773 0a20 2020       **kargs.   
+0001ad80: 2029 0a0a 0a64 6566 206d 616b 655f 7465   )...def make_te
+0001ad90: 785f 7461 626c 6528 2a61 7267 732c 202a  x_table(*args, *
+0001ada0: 2a6b 6172 6773 293a 0a20 2020 2023 2074  *kargs):.    # t
+0001adb0: 7970 653a 2028 2a41 6e79 2c20 2a2a 416e  ype: (*Any, **An
+0001adc0: 7929 202d 3e20 4f70 7469 6f6e 616c 5b73  y) -> Optional[s
+0001add0: 7472 5d0a 2020 2020 7265 7475 726e 205f  tr].    return _
+0001ade0: 5f6d 616b 655f 7461 626c 6528 2020 2320  _make_table(  # 
+0001adf0: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+0001ae00: 2020 2020 206c 616d 6264 6120 6c3a 2022       lambda l: "
+0001ae10: 2573 222c 0a20 2020 2020 2020 206c 616d  %s",.        lam
+0001ae20: 6264 6120 6c3a 2022 2620 2573 222c 0a20  bda l: "& %s",. 
+0001ae30: 2020 2020 2020 2022 5c5c 5c5c 222c 0a20         "\\\\",. 
+0001ae40: 2020 2020 2020 202a 6172 6773 2c0a 2020         *args,.  
+0001ae50: 2020 2020 2020 7365 706c 696e 6566 756e        seplinefun
+0001ae60: 633d 6c61 6d62 6461 2061 2c20 783a 2022  c=lambda a, x: "
+0001ae70: 5c5c 686c 696e 6522 2c0a 2020 2020 2020  \\hline",.      
+0001ae80: 2020 2a2a 6b61 7267 730a 2020 2020 290a    **kargs.    ).
+0001ae90: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+0001aea0: 2323 2323 230a 2320 2020 5748 4f49 5320  #####.#   WHOIS 
+0001aeb0: 434c 4945 4e54 2020 2023 0a23 2323 2323  CLIENT   #.#####
+0001aec0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+0001aed0: 0a0a 6465 6620 7768 6f69 7328 6970 5f61  ..def whois(ip_a
+0001aee0: 6464 7265 7373 293a 0a20 2020 2023 2074  ddress):.    # t
+0001aef0: 7970 653a 2028 7374 7229 202d 3e20 6279  ype: (str) -> by
+0001af00: 7465 730a 2020 2020 2222 2257 686f 6973  tes.    """Whois
+0001af10: 2063 6c69 656e 7420 666f 7220 5079 7468   client for Pyth
+0001af20: 6f6e 2222 220a 2020 2020 7768 6f69 735f  on""".    whois_
+0001af30: 6970 203d 2073 7472 2869 705f 6164 6472  ip = str(ip_addr
+0001af40: 6573 7329 0a20 2020 2074 7279 3a0a 2020  ess).    try:.  
+0001af50: 2020 2020 2020 7175 6572 7920 3d20 736f        query = so
+0001af60: 636b 6574 2e67 6574 686f 7374 6279 6e61  cket.gethostbyna
+0001af70: 6d65 2877 686f 6973 5f69 7029 0a20 2020  me(whois_ip).   
+0001af80: 2065 7863 6570 7420 4578 6365 7074 696f   except Exceptio
+0001af90: 6e3a 0a20 2020 2020 2020 2071 7565 7279  n:.        query
+0001afa0: 203d 2077 686f 6973 5f69 700a 2020 2020   = whois_ip.    
+0001afb0: 7320 3d20 736f 636b 6574 2e73 6f63 6b65  s = socket.socke
+0001afc0: 7428 736f 636b 6574 2e41 465f 494e 4554  t(socket.AF_INET
+0001afd0: 2c20 736f 636b 6574 2e53 4f43 4b5f 5354  , socket.SOCK_ST
+0001afe0: 5245 414d 290a 2020 2020 732e 636f 6e6e  REAM).    s.conn
+0001aff0: 6563 7428 2822 7768 6f69 732e 7269 7065  ect(("whois.ripe
+0001b000: 2e6e 6574 222c 2034 3329 290a 2020 2020  .net", 43)).    
+0001b010: 732e 7365 6e64 2871 7565 7279 2e65 6e63  s.send(query.enc
+0001b020: 6f64 6528 2275 7466 3822 2920 2b20 6222  ode("utf8") + b"
+0001b030: 5c72 5c6e 2229 0a20 2020 2061 6e73 7765  \r\n").    answe
+0001b040: 7220 3d20 6222 220a 2020 2020 7768 696c  r = b"".    whil
+0001b050: 6520 5472 7565 3a0a 2020 2020 2020 2020  e True:.        
+0001b060: 6420 3d20 732e 7265 6376 2834 3039 3629  d = s.recv(4096)
+0001b070: 0a20 2020 2020 2020 2061 6e73 7765 7220  .        answer 
+0001b080: 2b3d 2064 0a20 2020 2020 2020 2069 6620  += d.        if 
+0001b090: 6e6f 7420 643a 0a20 2020 2020 2020 2020  not d:.         
+0001b0a0: 2020 2062 7265 616b 0a20 2020 2073 2e63     break.    s.c
+0001b0b0: 6c6f 7365 2829 0a20 2020 2069 676e 6f72  lose().    ignor
+0001b0c0: 655f 7461 6720 3d20 6222 7265 6d61 726b  e_tag = b"remark
+0001b0d0: 733a 220a 2020 2020 2320 6967 6e6f 7265  s:".    # ignore
+0001b0e0: 2061 6c6c 206c 696e 6573 2073 7461 7274   all lines start
+0001b0f0: 696e 6720 7769 7468 2074 6865 2069 676e  ing with the ign
+0001b100: 6f72 655f 7461 670a 2020 2020 6c69 6e65  ore_tag.    line
+0001b110: 7320 3d20 5b6c 696e 6520 666f 7220 6c69  s = [line for li
+0001b120: 6e65 2069 6e20 616e 7377 6572 2e73 706c  ne in answer.spl
+0001b130: 6974 2862 225c 6e22 2920 6966 206e 6f74  it(b"\n") if not
+0001b140: 206c 696e 6520 6f72 2028 6c69 6e65 2061   line or (line a
+0001b150: 6e64 206e 6f74 206c 696e 652e 7374 6172  nd not line.star
+0001b160: 7473 7769 7468 2869 676e 6f72 655f 7461  tswith(ignore_ta
+0001b170: 6729 295d 2020 2320 6e6f 7161 3a20 4535  g))]  # noqa: E5
+0001b180: 3031 0a20 2020 2023 2072 656d 6f76 6520  01.    # remove 
+0001b190: 656d 7074 7920 6c69 6e65 7320 6174 2074  empty lines at t
+0001b1a0: 6865 2062 6f74 746f 6d0a 2020 2020 666f  he bottom.    fo
+0001b1b0: 7220 6920 696e 2072 616e 6765 2831 2c20  r i in range(1, 
+0001b1c0: 6c65 6e28 6c69 6e65 7329 293a 0a20 2020  len(lines)):.   
+0001b1d0: 2020 2020 2069 6620 6e6f 7420 6c69 6e65       if not line
+0001b1e0: 735b 2d69 5d2e 7374 7269 7028 293a 0a20  s[-i].strip():. 
+0001b1f0: 2020 2020 2020 2020 2020 2064 656c 206c             del l
+0001b200: 696e 6573 5b2d 695d 0a20 2020 2020 2020  ines[-i].       
+0001b210: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001b220: 2020 2062 7265 616b 0a20 2020 2072 6574     break.    ret
+0001b230: 7572 6e20 6222 5c6e 222e 6a6f 696e 286c  urn b"\n".join(l
+0001b240: 696e 6573 5b33 3a5d 290a 0a23 2323 2323  ines[3:])..#####
+0001b250: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+0001b260: 2320 2020 2020 434c 4920 7574 696c 7320  #     CLI utils 
+0001b270: 2020 2023 0a23 2323 2323 2323 2323 2323     #.###########
+0001b280: 2323 2323 2323 2323 230a 0a0a 636c 6173  #########...clas
+0001b290: 7320 434c 4955 7469 6c3a 0a20 2020 2022  s CLIUtil:.    "
+0001b2a0: 2222 0a20 2020 2050 726f 7669 6465 7320  "".    Provides 
+0001b2b0: 6120 5574 696c 2063 6c61 7373 2074 6f20  a Util class to 
+0001b2c0: 6561 7369 6c79 2063 7265 6174 6520 7369  easily create si
+0001b2d0: 6d70 6c65 2043 4c49 2074 6f6f 6c73 2069  mple CLI tools i
+0001b2e0: 6e20 5363 6170 792c 0a20 2020 2074 6861  n Scapy,.    tha
+0001b2f0: 7420 6361 6e20 7374 696c 6c20 6265 2075  t can still be u
+0001b300: 7365 6420 6173 2061 6e20 4150 492e 0a0a  sed as an API...
+0001b310: 2020 2020 446f 633a 0a20 2020 2020 2020      Doc:.       
+0001b320: 202d 206f 7665 7272 6964 6520 7468 6520   - override the 
+0001b330: 7073 3128 2920 6675 6e63 7469 6f6e 0a20  ps1() function. 
+0001b340: 2020 2020 2020 202d 2072 6567 6973 7465         - registe
+0001b350: 7220 636f 6d6d 616e 6473 2077 6974 6820  r commands with 
+0001b360: 7468 6520 4043 4c49 5574 696c 2e61 6464  the @CLIUtil.add
+0001b370: 636f 6d6d 656e 7420 6465 636f 7261 746f  comment decorato
+0001b380: 720a 2020 2020 2020 2020 2d20 6361 6c6c  r.        - call
+0001b390: 2074 6865 206c 6f6f 7028 2920 6675 6e63   the loop() func
+0001b3a0: 7469 6f6e 2077 6865 6e20 7265 6164 790a  tion when ready.
+0001b3b0: 2020 2020 2222 220a 0a20 2020 2064 6566      """..    def
+0001b3c0: 205f 6465 7063 6865 636b 2873 656c 6629   _depcheck(self)
+0001b3d0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+0001b3e0: 2020 2222 220a 2020 2020 2020 2020 4368    """.        Ch
+0001b3f0: 6563 6b20 7468 6174 2061 6c6c 2064 6570  eck that all dep
+0001b400: 656e 6465 6e63 6965 7320 6172 6520 696e  endencies are in
+0001b410: 7374 616c 6c65 640a 2020 2020 2020 2020  stalled.        
+0001b420: 2222 220a 2020 2020 2020 2020 7472 793a  """.        try:
+0001b430: 0a20 2020 2020 2020 2020 2020 2069 6d70  .            imp
+0001b440: 6f72 7420 7072 6f6d 7074 5f74 6f6f 6c6b  ort prompt_toolk
+0001b450: 6974 2020 2320 6e6f 7161 3a20 4634 3031  it  # noqa: F401
+0001b460: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+0001b470: 496d 706f 7274 4572 726f 723a 0a20 2020  ImportError:.   
+0001b480: 2020 2020 2020 2020 2023 206f 6b61 7920           # okay 
+0001b490: 7765 206c 6965 2062 7574 2070 726f 6d70  we lie but promp
+0001b4a0: 745f 746f 6f6c 6b69 7420 6973 2061 2064  t_toolkit is a d
+0001b4b0: 6570 656e 6465 6e63 792e 2e2e 0a20 2020  ependency....   
+0001b4c0: 2020 2020 2020 2020 2072 6169 7365 2049           raise I
+0001b4d0: 6d70 6f72 7445 7272 6f72 2822 596f 7520  mportError("You 
+0001b4e0: 6e65 6564 2074 6f20 6861 7665 2049 5079  need to have IPy
+0001b4f0: 7468 6f6e 2069 6e73 7461 6c6c 6564 2074  thon installed t
+0001b500: 6f20 7573 6520 7468 6520 434c 4922 290a  o use the CLI").
+0001b510: 0a20 2020 2023 204f 6b61 7920 6c65 7427  .    # Okay let'
+0001b520: 7320 646f 206e 6963 6520 636f 6465 0a20  s do nice code. 
+0001b530: 2020 2063 6f6d 6d61 6e64 733a 2044 6963     commands: Dic
+0001b540: 745b 7374 722c 2043 616c 6c61 626c 655b  t[str, Callable[
+0001b550: 2e2e 2e2c 2041 6e79 5d5d 203d 207b 7d0a  ..., Any]] = {}.
+0001b560: 2020 2020 2320 7072 696e 7420 6f75 7470      # print outp
+0001b570: 7574 206f 6620 636f 6d6d 616e 640a 2020  ut of command.  
+0001b580: 2020 636f 6d6d 616e 6473 5f6f 7574 7075    commands_outpu
+0001b590: 743a 2044 6963 745b 7374 722c 2043 616c  t: Dict[str, Cal
+0001b5a0: 6c61 626c 655b 2e2e 2e2c 2073 7472 5d5d  lable[..., str]]
+0001b5b0: 203d 207b 7d0a 2020 2020 2320 7072 6f76   = {}.    # prov
+0001b5c0: 6964 6573 2063 6f6d 706c 6574 696f 6e20  ides completion 
+0001b5d0: 746f 2063 6f6d 6d61 6e64 0a20 2020 2063  to command.    c
+0001b5e0: 6f6d 6d61 6e64 735f 636f 6d70 6c65 7465  ommands_complete
+0001b5f0: 3a20 4469 6374 5b73 7472 2c20 4361 6c6c  : Dict[str, Call
+0001b600: 6162 6c65 5b2e 2e2e 2c20 4c69 7374 5b73  able[..., List[s
+0001b610: 7472 5d5d 5d20 3d20 7b7d 0a0a 2020 2020  tr]]] = {}..    
+0001b620: 4073 7461 7469 636d 6574 686f 640a 2020  @staticmethod.  
+0001b630: 2020 6465 6620 5f69 6e73 7065 6374 6b77    def _inspectkw
+0001b640: 6172 6773 2866 756e 633a 2044 6563 6f72  args(func: Decor
+0001b650: 6174 6f72 4361 6c6c 6162 6c65 2920 2d3e  atorCallable) ->
+0001b660: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
+0001b670: 2222 0a20 2020 2020 2020 2049 6e74 6572  "".        Inter
+0001b680: 6e61 6c20 6675 6e63 7469 6f6e 2074 6f20  nal function to 
+0001b690: 7061 7273 6520 6172 6775 6d65 6e74 7320  parse arguments 
+0001b6a0: 6672 6f6d 2074 6865 206b 7761 7267 7320  from the kwargs 
+0001b6b0: 6f66 2074 6865 2066 756e 6374 696f 6e73  of the functions
+0001b6c0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001b6d0: 2020 2020 2066 756e 632e 5f66 6c61 676e       func._flagn
+0001b6e0: 616d 6573 203d 205b 2020 2320 7479 7065  ames = [  # type
+0001b6f0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+0001b700: 2020 2020 2078 2e6e 616d 6520 666f 7220       x.name for 
+0001b710: 7820 696e 0a20 2020 2020 2020 2020 2020  x in.           
+0001b720: 2069 6e73 7065 6374 2e73 6967 6e61 7475   inspect.signatu
+0001b730: 7265 2866 756e 6329 2e70 6172 616d 6574  re(func).paramet
+0001b740: 6572 732e 7661 6c75 6573 2829 0a20 2020  ers.values().   
+0001b750: 2020 2020 2020 2020 2069 6620 782e 6b69           if x.ki
+0001b760: 6e64 203d 3d20 696e 7370 6563 742e 5061  nd == inspect.Pa
+0001b770: 7261 6d65 7465 722e 4b45 5957 4f52 445f  rameter.KEYWORD_
+0001b780: 4f4e 4c59 0a20 2020 2020 2020 205d 0a20  ONLY.        ]. 
+0001b790: 2020 2020 2020 2066 756e 632e 5f66 6c61         func._fla
+0001b7a0: 6773 203d 205b 2020 2320 7479 7065 3a20  gs = [  # type: 
+0001b7b0: 6967 6e6f 7265 0a20 2020 2020 2020 2020  ignore.         
+0001b7c0: 2020 2028 222d 2573 2220 2520 7829 2069     ("-%s" % x) i
+0001b7d0: 6620 6c65 6e28 7829 203d 3d20 3120 656c  f len(x) == 1 el
+0001b7e0: 7365 2028 222d 2d25 7322 2025 2078 290a  se ("--%s" % x).
+0001b7f0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0001b800: 7820 696e 2066 756e 632e 5f66 6c61 676e  x in func._flagn
+0001b810: 616d 6573 2020 2320 7479 7065 3a20 6967  ames  # type: ig
+0001b820: 6e6f 7265 0a20 2020 2020 2020 205d 0a0a  nore.        ]..
+0001b830: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
+0001b840: 640a 2020 2020 6465 6620 5f70 6172 7365  d.    def _parse
+0001b850: 6b77 6172 6773 280a 2020 2020 2020 2020  kwargs(.        
+0001b860: 6675 6e63 3a20 4465 636f 7261 746f 7243  func: DecoratorC
+0001b870: 616c 6c61 626c 652c 0a20 2020 2020 2020  allable,.       
+0001b880: 2061 7267 733a 204c 6973 745b 7374 725d   args: List[str]
+0001b890: 0a20 2020 2029 202d 3e20 5475 706c 655b  .    ) -> Tuple[
+0001b8a0: 4c69 7374 5b73 7472 5d2c 2044 6963 745b  List[str], Dict[
+0001b8b0: 7374 722c 204c 6974 6572 616c 5b54 7275  str, Literal[Tru
+0001b8c0: 655d 5d5d 3a0a 2020 2020 2020 2020 2222  e]]]:.        ""
+0001b8d0: 220a 2020 2020 2020 2020 496e 7465 726e  ".        Intern
+0001b8e0: 616c 2066 756e 6374 696f 6e20 746f 2070  al function to p
+0001b8f0: 6172 7365 2043 4c49 2061 7267 756d 656e  arse CLI argumen
+0001b900: 7473 206f 6620 6120 6675 6e63 7469 6f6e  ts of a function
+0001b910: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+0001b920: 2020 2020 2020 6b77 6172 6773 3a20 4469        kwargs: Di
+0001b930: 6374 5b73 7472 2c20 4c69 7465 7261 6c5b  ct[str, Literal[
+0001b940: 5472 7565 5d5d 203d 207b 7d0a 2020 2020  True]] = {}.    
+0001b950: 2020 2020 6966 2066 756e 632e 5f66 6c61      if func._fla
+0001b960: 6773 3a20 2023 2074 7970 653a 2069 676e  gs:  # type: ign
+0001b970: 6f72 650a 2020 2020 2020 2020 2020 2020  ore.            
+0001b980: 6920 3d20 300a 2020 2020 2020 2020 2020  i = 0.          
+0001b990: 2020 666f 7220 6172 6720 696e 2061 7267    for arg in arg
+0001b9a0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+0001b9b0: 2020 2069 6620 6172 6720 696e 2066 756e     if arg in fun
+0001b9c0: 632e 5f66 6c61 6773 3a20 2023 2074 7970  c._flags:  # typ
+0001b9d0: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
+0001b9e0: 2020 2020 2020 2020 2020 2020 2020 6920                i 
+0001b9f0: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+0001ba00: 2020 2020 2020 2020 206b 7761 7267 735b           kwargs[
+0001ba10: 6675 6e63 2e5f 666c 6167 6e61 6d65 735b  func._flagnames[
+0001ba20: 6675 6e63 2e5f 666c 6167 732e 696e 6465  func._flags.inde
+0001ba30: 7828 6172 6729 5d5d 203d 2054 7275 6520  x(arg)]] = True 
+0001ba40: 2023 2074 7970 653a 2069 676e 6f72 6520   # type: ignore 
+0001ba50: 2023 206e 6f71 613a 2045 3530 310a 2020   # noqa: E501.  
+0001ba60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ba70: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+0001ba80: 2020 2020 2020 2020 2020 2062 7265 616b             break
+0001ba90: 0a20 2020 2020 2020 2020 2020 2061 7267  .            arg
+0001baa0: 7320 3d20 6172 6773 5b69 3a5d 0a20 2020  s = args[i:].   
+0001bab0: 2020 2020 2072 6574 7572 6e20 6172 6773       return args
+0001bac0: 2c20 6b77 6172 6773 0a0a 2020 2020 4063  , kwargs..    @c
+0001bad0: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
+0001bae0: 6566 205f 7061 7273 6561 6c6c 6172 6773  ef _parseallargs
+0001baf0: 280a 2020 2020 2020 2020 636c 732c 0a20  (.        cls,. 
+0001bb00: 2020 2020 2020 2066 756e 633a 2044 6563         func: Dec
+0001bb10: 6f72 6174 6f72 4361 6c6c 6162 6c65 2c0a  oratorCallable,.
+0001bb20: 2020 2020 2020 2020 636d 643a 2073 7472          cmd: str
+0001bb30: 2c20 6172 6773 3a20 4c69 7374 5b73 7472  , args: List[str
+0001bb40: 5d0a 2020 2020 2920 2d3e 2054 7570 6c65  ].    ) -> Tuple
+0001bb50: 5b4c 6973 745b 7374 725d 2c20 4469 6374  [List[str], Dict
+0001bb60: 5b73 7472 2c20 4c69 7465 7261 6c5b 5472  [str, Literal[Tr
+0001bb70: 7565 5d5d 2c20 4469 6374 5b73 7472 2c20  ue]], Dict[str, 
+0001bb80: 4c69 7465 7261 6c5b 5472 7565 5d5d 5d3a  Literal[True]]]:
+0001bb90: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001bba0: 2020 2020 2049 6e74 6572 6e61 6c20 6675       Internal fu
+0001bbb0: 6e63 7469 6f6e 2074 6f20 7061 7273 6520  nction to parse 
+0001bbc0: 434c 4920 6172 6775 6d65 6e74 7320 6f66  CLI arguments of
+0001bbd0: 2062 6f74 6820 7468 6520 6675 6e63 7469   both the functi
+0001bbe0: 6f6e 0a20 2020 2020 2020 2061 6e64 2069  on.        and i
+0001bbf0: 7473 206f 7574 7075 7420 6675 6e63 7469  ts output functi
+0001bc00: 6f6e 2e0a 2020 2020 2020 2020 2222 220a  on..        """.
+0001bc10: 2020 2020 2020 2020 6172 6773 2c20 6b77          args, kw
+0001bc20: 6172 6773 203d 2063 6c73 2e5f 7061 7273  args = cls._pars
+0001bc30: 656b 7761 7267 7328 6675 6e63 2c20 6172  ekwargs(func, ar
+0001bc40: 6773 290a 2020 2020 2020 2020 6f75 746b  gs).        outk
+0001bc50: 7761 7267 733a 2044 6963 745b 7374 722c  wargs: Dict[str,
+0001bc60: 204c 6974 6572 616c 5b54 7275 655d 5d20   Literal[True]] 
+0001bc70: 3d20 7b7d 0a20 2020 2020 2020 2069 6620  = {}.        if 
+0001bc80: 636d 6420 696e 2063 6c73 2e63 6f6d 6d61  cmd in cls.comma
+0001bc90: 6e64 735f 6f75 7470 7574 3a0a 2020 2020  nds_output:.    
+0001bca0: 2020 2020 2020 2020 6172 6773 2c20 6f75          args, ou
+0001bcb0: 746b 7761 7267 7320 3d20 636c 732e 5f70  tkwargs = cls._p
+0001bcc0: 6172 7365 6b77 6172 6773 2863 6c73 2e63  arsekwargs(cls.c
+0001bcd0: 6f6d 6d61 6e64 735f 6f75 7470 7574 5b63  ommands_output[c
+0001bce0: 6d64 5d2c 2061 7267 7329 0a20 2020 2020  md], args).     
+0001bcf0: 2020 2072 6574 7572 6e20 6172 6773 2c20     return args, 
+0001bd00: 6b77 6172 6773 2c20 6f75 746b 7761 7267  kwargs, outkwarg
+0001bd10: 730a 0a20 2020 2040 636c 6173 736d 6574  s..    @classmet
+0001bd20: 686f 640a 2020 2020 6465 6620 6164 6463  hod.    def addc
+0001bd30: 6f6d 6d61 6e64 280a 2020 2020 2020 2020  ommand(.        
+0001bd40: 636c 732c 0a20 2020 2020 2020 2073 7061  cls,.        spa
+0001bd50: 6365 733a 2062 6f6f 6c20 3d20 4661 6c73  ces: bool = Fals
+0001bd60: 652c 0a20 2020 2020 2020 2067 6c6f 6273  e,.        globs
+0001bd70: 7570 706f 7274 3a20 626f 6f6c 203d 2046  upport: bool = F
+0001bd80: 616c 7365 2c0a 2020 2020 2920 2d3e 2043  alse,.    ) -> C
+0001bd90: 616c 6c61 626c 655b 5b44 6563 6f72 6174  allable[[Decorat
+0001bda0: 6f72 4361 6c6c 6162 6c65 5d2c 2044 6563  orCallable], Dec
+0001bdb0: 6f72 6174 6f72 4361 6c6c 6162 6c65 5d3a  oratorCallable]:
+0001bdc0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001bdd0: 2020 2020 2044 6563 6f72 6174 6f72 2074       Decorator t
+0001bde0: 6f20 7265 6769 7374 6572 2061 2063 6f6d  o register a com
+0001bdf0: 6d61 6e64 0a20 2020 2020 2020 2022 2222  mand.        """
+0001be00: 0a20 2020 2020 2020 2064 6566 2066 756e  .        def fun
+0001be10: 6328 636d 643a 2044 6563 6f72 6174 6f72  c(cmd: Decorator
+0001be20: 4361 6c6c 6162 6c65 2920 2d3e 2044 6563  Callable) -> Dec
+0001be30: 6f72 6174 6f72 4361 6c6c 6162 6c65 3a0a  oratorCallable:.
+0001be40: 2020 2020 2020 2020 2020 2020 636c 732e              cls.
+0001be50: 636f 6d6d 616e 6473 5b63 6d64 2e5f 5f6e  commands[cmd.__n
+0001be60: 616d 655f 5f5d 203d 2063 6d64 0a20 2020  ame__] = cmd.   
+0001be70: 2020 2020 2020 2020 2063 6d64 2e5f 7370           cmd._sp
+0001be80: 6163 6573 203d 2073 7061 6365 7320 2023  aces = spaces  #
+0001be90: 2074 7970 653a 2069 676e 6f72 650a 2020   type: ignore.  
+0001bea0: 2020 2020 2020 2020 2020 636d 642e 5f67            cmd._g
+0001beb0: 6c6f 6273 7570 706f 7274 203d 2067 6c6f  lobsupport = glo
+0001bec0: 6273 7570 706f 7274 2020 2320 7479 7065  bsupport  # type
+0001bed0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
+0001bee0: 2020 2020 2063 6c73 2e5f 696e 7370 6563       cls._inspec
+0001bef0: 746b 7761 7267 7328 636d 6429 0a20 2020  tkwargs(cmd).   
+0001bf00: 2020 2020 2020 2020 2069 6620 636d 642e           if cmd.
+0001bf10: 5f67 6c6f 6273 7570 706f 7274 2061 6e64  _globsupport and
+0001bf20: 206e 6f74 2063 6d64 2e5f 7370 6163 6573   not cmd._spaces
+0001bf30: 3a20 2023 2074 7970 653a 2069 676e 6f72  :  # type: ignor
+0001bf40: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0001bf50: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+0001bf60: 6f72 2822 4361 6e6e 6f74 2075 7365 2067  or("Cannot use g
+0001bf70: 6c6f 6273 7570 706f 7274 2077 6974 686f  lobsupport witho
+0001bf80: 7574 2073 7061 6365 732e 2229 0a20 2020  ut spaces.").   
+0001bf90: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001bfa0: 636d 640a 2020 2020 2020 2020 7265 7475  cmd.        retu
+0001bfb0: 726e 2066 756e 630a 0a20 2020 2040 636c  rn func..    @cl
+0001bfc0: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+0001bfd0: 6620 6164 646f 7574 7075 7428 636c 732c  f addoutput(cls,
+0001bfe0: 2063 6d64 3a20 4465 636f 7261 746f 7243   cmd: DecoratorC
+0001bff0: 616c 6c61 626c 6529 202d 3e20 4361 6c6c  allable) -> Call
+0001c000: 6162 6c65 5b5b 4465 636f 7261 746f 7243  able[[DecoratorC
+0001c010: 616c 6c61 626c 655d 2c20 4465 636f 7261  allable], Decora
+0001c020: 746f 7243 616c 6c61 626c 655d 3a20 2023  torCallable]:  #
+0001c030: 206e 6f71 613a 2045 3530 310a 2020 2020   noqa: E501.    
+0001c040: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0001c050: 4465 636f 7261 746f 7220 746f 2072 6567  Decorator to reg
+0001c060: 6973 7465 7220 6120 636f 6d6d 616e 6420  ister a command 
+0001c070: 6f75 7470 7574 2070 726f 6365 7373 6f72  output processor
+0001c080: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001c090: 2020 2020 2064 6566 2066 756e 6328 7072       def func(pr
+0001c0a0: 6f63 6573 736f 723a 2044 6563 6f72 6174  ocessor: Decorat
+0001c0b0: 6f72 4361 6c6c 6162 6c65 2920 2d3e 2044  orCallable) -> D
+0001c0c0: 6563 6f72 6174 6f72 4361 6c6c 6162 6c65  ecoratorCallable
+0001c0d0: 3a0a 2020 2020 2020 2020 2020 2020 636c  :.            cl
+0001c0e0: 732e 636f 6d6d 616e 6473 5f6f 7574 7075  s.commands_outpu
+0001c0f0: 745b 636d 642e 5f5f 6e61 6d65 5f5f 5d20  t[cmd.__name__] 
+0001c100: 3d20 7072 6f63 6573 736f 720a 2020 2020  = processor.    
+0001c110: 2020 2020 2020 2020 636c 732e 5f69 6e73          cls._ins
+0001c120: 7065 6374 6b77 6172 6773 2870 726f 6365  pectkwargs(proce
+0001c130: 7373 6f72 290a 2020 2020 2020 2020 2020  ssor).          
+0001c140: 2020 7265 7475 726e 2070 726f 6365 7373    return process
+0001c150: 6f72 0a20 2020 2020 2020 2072 6574 7572  or.        retur
+0001c160: 6e20 6675 6e63 0a0a 2020 2020 4063 6c61  n func..    @cla
+0001c170: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
+0001c180: 2061 6464 636f 6d70 6c65 7465 2863 6c73   addcomplete(cls
+0001c190: 2c20 636d 643a 2044 6563 6f72 6174 6f72  , cmd: Decorator
+0001c1a0: 4361 6c6c 6162 6c65 2920 2d3e 2043 616c  Callable) -> Cal
+0001c1b0: 6c61 626c 655b 5b44 6563 6f72 6174 6f72  lable[[Decorator
+0001c1c0: 4361 6c6c 6162 6c65 5d2c 2044 6563 6f72  Callable], Decor
+0001c1d0: 6174 6f72 4361 6c6c 6162 6c65 5d3a 2020  atorCallable]:  
+0001c1e0: 2320 6e6f 7161 3a20 4535 3031 0a20 2020  # noqa: E501.   
+0001c1f0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0001c200: 2044 6563 6f72 6174 6f72 2074 6f20 7265   Decorator to re
+0001c210: 6769 7374 6572 2061 2063 6f6d 6d61 6e64  gister a command
+0001c220: 2063 6f6d 706c 6574 6f72 0a20 2020 2020   completor.     
+0001c230: 2020 2022 2222 0a20 2020 2020 2020 2064     """.        d
+0001c240: 6566 2066 756e 6328 7072 6f63 6573 736f  ef func(processo
+0001c250: 723a 2044 6563 6f72 6174 6f72 4361 6c6c  r: DecoratorCall
+0001c260: 6162 6c65 2920 2d3e 2044 6563 6f72 6174  able) -> Decorat
+0001c270: 6f72 4361 6c6c 6162 6c65 3a0a 2020 2020  orCallable:.    
+0001c280: 2020 2020 2020 2020 636c 732e 636f 6d6d          cls.comm
+0001c290: 616e 6473 5f63 6f6d 706c 6574 655b 636d  ands_complete[cm
+0001c2a0: 642e 5f5f 6e61 6d65 5f5f 5d20 3d20 7072  d.__name__] = pr
+0001c2b0: 6f63 6573 736f 720a 2020 2020 2020 2020  ocessor.        
+0001c2c0: 2020 2020 7265 7475 726e 2070 726f 6365      return proce
+0001c2d0: 7373 6f72 0a20 2020 2020 2020 2072 6574  ssor.        ret
+0001c2e0: 7572 6e20 6675 6e63 0a0a 2020 2020 6465  urn func..    de
+0001c2f0: 6620 7073 3128 7365 6c66 2920 2d3e 2073  f ps1(self) -> s
+0001c300: 7472 3a0a 2020 2020 2020 2020 2222 220a  tr:.        """.
+0001c310: 2020 2020 2020 2020 5265 7475 726e 2074          Return t
+0001c320: 6865 2050 5331 206f 6620 7468 6520 7368  he PS1 of the sh
+0001c330: 656c 6c0a 2020 2020 2020 2020 2222 220a  ell.        """.
+0001c340: 2020 2020 2020 2020 7265 7475 726e 2022          return "
+0001c350: 3e20 220a 0a20 2020 2064 6566 2063 6c6f  > "..    def clo
+0001c360: 7365 2873 656c 6629 202d 3e20 4e6f 6e65  se(self) -> None
+0001c370: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+0001c380: 2020 2020 2020 4675 6e63 7469 6f6e 2063        Function c
+0001c390: 616c 6c65 6420 6f6e 2065 7869 7469 6e67  alled on exiting
+0001c3a0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001c3b0: 2020 2020 2070 7269 6e74 2822 4578 6974       print("Exit
+0001c3c0: 6564 2229 0a0a 2020 2020 6465 6620 6865  ed")..    def he
+0001c3d0: 6c70 2873 656c 662c 2063 6d64 3a20 4f70  lp(self, cmd: Op
+0001c3e0: 7469 6f6e 616c 5b73 7472 5d20 3d20 4e6f  tional[str] = No
+0001c3f0: 6e65 2920 2d3e 204e 6f6e 653a 0a20 2020  ne) -> None:.   
+0001c400: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0001c410: 2052 6574 7572 6e20 7468 6520 6865 6c70   Return the help
+0001c420: 2072 656c 6174 6564 2074 6f20 7468 6973   related to this
+0001c430: 2043 4c49 2075 7469 6c0a 2020 2020 2020   CLI util.      
+0001c440: 2020 2222 220a 2020 2020 2020 2020 6465    """.        de
+0001c450: 6620 5f61 7267 7328 6675 6e63 3a20 416e  f _args(func: An
+0001c460: 7929 202d 3e20 7374 723a 0a20 2020 2020  y) -> str:.     
+0001c470: 2020 2020 2020 2066 6c61 6773 203d 2066         flags = f
+0001c480: 756e 632e 5f66 6c61 6773 2e63 6f70 7928  unc._flags.copy(
+0001c490: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+0001c4a0: 2066 756e 632e 5f5f 6e61 6d65 5f5f 2069   func.__name__ i
+0001c4b0: 6e20 7365 6c66 2e63 6f6d 6d61 6e64 735f  n self.commands_
+0001c4c0: 6f75 7470 7574 3a0a 2020 2020 2020 2020  output:.        
+0001c4d0: 2020 2020 2020 2020 666c 6167 7320 2b3d          flags +=
+0001c4e0: 2073 656c 662e 636f 6d6d 616e 6473 5f6f   self.commands_o
+0001c4f0: 7574 7075 745b 6675 6e63 2e5f 5f6e 616d  utput[func.__nam
+0001c500: 655f 5f5d 2e5f 666c 6167 7320 2023 2074  e__]._flags  # t
+0001c510: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
+0001c520: 2020 2020 2020 2020 7265 7475 726e 2022          return "
+0001c530: 2025 7325 7322 2025 2028 0a20 2020 2020   %s%s" % (.     
+0001c540: 2020 2020 2020 2020 2020 2028 0a20 2020             (.   
+0001c550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c560: 2022 2573 2022 2025 2022 2022 2e6a 6f69   "%s " % " ".joi
+0001c570: 6e28 225b 2573 5d22 2025 2078 2066 6f72  n("[%s]" % x for
+0001c580: 2078 2069 6e20 666c 6167 7329 0a20 2020   x in flags).   
+0001c590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c5a0: 2069 6620 666c 6167 7320 656c 7365 2022   if flags else "
+0001c5b0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0001c5c0: 2020 292c 0a20 2020 2020 2020 2020 2020    ),.           
+0001c5d0: 2020 2020 2022 2022 2e6a 6f69 6e28 0a20       " ".join(. 
+0001c5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c5f0: 2020 2022 3c25 7325 733e 2220 2520 280a     "<%s%s>" % (.
+0001c600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c610: 2020 2020 2020 2020 782e 6e61 6d65 2c0a          x.name,.
+0001c620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c630: 2020 2020 2020 2020 223f 2220 6966 0a20          "?" if. 
+0001c640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c650: 2020 2020 2020 2028 782e 6465 6661 756c         (x.defaul
+0001c660: 7420 6973 204e 6f6e 6520 6f72 2078 2e64  t is None or x.d
+0001c670: 6566 6175 6c74 2021 3d20 696e 7370 6563  efault != inspec
+0001c680: 742e 5061 7261 6d65 7465 722e 656d 7074  t.Parameter.empt
+0001c690: 7929 0a20 2020 2020 2020 2020 2020 2020  y).             
+0001c6a0: 2020 2020 2020 2020 2020 2065 6c73 6520             else 
+0001c6b0: 2222 0a20 2020 2020 2020 2020 2020 2020  "".             
+0001c6c0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001c6d0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0001c6e0: 2078 2069 6e20 6c69 7374 2869 6e73 7065   x in list(inspe
+0001c6f0: 6374 2e73 6967 6e61 7475 7265 2866 756e  ct.signature(fun
+0001c700: 6329 2e70 6172 616d 6574 6572 732e 7661  c).parameters.va
+0001c710: 6c75 6573 2829 295b 313a 5d0a 2020 2020  lues())[1:].    
+0001c720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c730: 6966 2078 2e6e 616d 6520 6e6f 7420 696e  if x.name not in
+0001c740: 2066 756e 632e 5f66 6c61 676e 616d 6573   func._flagnames
+0001c750: 2061 6e64 2078 2e6e 616d 655b 305d 2021   and x.name[0] !
+0001c760: 3d20 225f 220a 2020 2020 2020 2020 2020  = "_".          
+0001c770: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001c780: 2020 2020 290a 0a20 2020 2020 2020 2069      )..        i
+0001c790: 6620 636d 643a 0a20 2020 2020 2020 2020  f cmd:.         
+0001c7a0: 2020 2069 6620 636d 6420 6e6f 7420 696e     if cmd not in
+0001c7b0: 2073 656c 662e 636f 6d6d 616e 6473 3a0a   self.commands:.
+0001c7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c7d0: 7072 696e 7428 2255 6e6b 6e6f 776e 2063  print("Unknown c
+0001c7e0: 6f6d 6d61 6e64 2027 2573 2722 2025 2063  ommand '%s'" % c
+0001c7f0: 6d64 290a 2020 2020 2020 2020 2020 2020  md).            
+0001c800: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
+0001c810: 2020 2020 2020 2023 2068 656c 7020 666f         # help fo
+0001c820: 7220 6f6e 6520 636f 6d6d 616e 640a 2020  r one command.  
+0001c830: 2020 2020 2020 2020 2020 6675 6e63 203d            func =
+0001c840: 2073 656c 662e 636f 6d6d 616e 6473 5b63   self.commands[c
+0001c850: 6d64 5d0a 2020 2020 2020 2020 2020 2020  md].            
+0001c860: 7072 696e 7428 2225 7325 733a 2025 7322  print("%s%s: %s"
+0001c870: 2025 2028 0a20 2020 2020 2020 2020 2020   % (.           
+0001c880: 2020 2020 2063 6d64 2c0a 2020 2020 2020       cmd,.      
+0001c890: 2020 2020 2020 2020 2020 5f61 7267 7328            _args(
+0001c8a0: 6675 6e63 292c 0a20 2020 2020 2020 2020  func),.         
+0001c8b0: 2020 2020 2020 2066 756e 632e 5f5f 646f         func.__do
+0001c8c0: 635f 5f20 616e 6420 6675 6e63 2e5f 5f64  c__ and func.__d
+0001c8d0: 6f63 5f5f 2e73 7472 6970 2829 0a20 2020  oc__.strip().   
+0001c8e0: 2020 2020 2020 2020 2029 290a 2020 2020           )).    
+0001c8f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001c900: 2020 2020 2020 6865 6164 6572 203d 2022        header = "
+0001c910: e294 8220 2573 202d 2048 656c 7020 e294  ... %s - Help ..
+0001c920: 8222 2025 2073 656c 662e 5f5f 636c 6173  ." % self.__clas
+0001c930: 735f 5f2e 5f5f 6e61 6d65 5f5f 0a20 2020  s__.__name__.   
+0001c940: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+0001c950: e294 8c22 202b 2022 e294 8022 202a 2028  ..." + "..." * (
+0001c960: 6c65 6e28 6865 6164 6572 2920 2d20 3229  len(header) - 2)
+0001c970: 202b 2022 e294 9022 290a 2020 2020 2020   + "...").      
+0001c980: 2020 2020 2020 7072 696e 7428 6865 6164        print(head
+0001c990: 6572 290a 2020 2020 2020 2020 2020 2020  er).            
+0001c9a0: 7072 696e 7428 22e2 9494 2220 2b20 22e2  print("..." + ".
+0001c9b0: 9480 2220 2a20 286c 656e 2868 6561 6465  .." * (len(heade
+0001c9c0: 7229 202d 2032 2920 2b20 22e2 9498 2229  r) - 2) + "...")
+0001c9d0: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+0001c9e0: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+0001c9f0: 2020 2020 7072 6574 7479 5f6c 6973 7428      pretty_list(
+0001ca00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ca10: 2020 2020 205b 0a20 2020 2020 2020 2020       [.         
+0001ca20: 2020 2020 2020 2020 2020 2020 2020 2028                 (
+0001ca30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ca40: 2020 2020 2020 2020 2020 2020 2063 6d64               cmd
+0001ca50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001ca60: 2020 2020 2020 2020 2020 2020 2020 5f61                _a
+0001ca70: 7267 7328 6675 6e63 292c 0a20 2020 2020  rgs(func),.     
+0001ca80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ca90: 2020 2020 2020 2066 756e 632e 5f5f 646f         func.__do
+0001caa0: 635f 5f20 616e 6420 6675 6e63 2e5f 5f64  c__ and func.__d
+0001cab0: 6f63 5f5f 2e73 7472 6970 2829 2e73 706c  oc__.strip().spl
+0001cac0: 6974 2822 5c6e 2229 5b30 5d20 6f72 2022  it("\n")[0] or "
+0001cad0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0001cae0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0001caf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cb00: 2020 2020 666f 7220 636d 642c 2066 756e      for cmd, fun
+0001cb10: 6320 696e 2073 656c 662e 636f 6d6d 616e  c in self.comman
+0001cb20: 6473 2e69 7465 6d73 2829 0a20 2020 2020  ds.items().     
+0001cb30: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
+0001cb40: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001cb50: 2020 2020 2020 5b28 2243 6f6d 6d61 6e64        [("Command
+0001cb60: 222c 2022 4172 6775 6d65 6e74 7322 2c20  ", "Arguments", 
+0001cb70: 2244 6573 6372 6970 7469 6f6e 2229 5d0a  "Description")].
+0001cb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cb90: 290a 2020 2020 2020 2020 2020 2020 290a  ).            ).
+0001cba0: 0a20 2020 2064 6566 205f 636f 6d70 6c65  .    def _comple
+0001cbb0: 7465 7228 7365 6c66 2920 2d3e 2027 7072  ter(self) -> 'pr
+0001cbc0: 6f6d 7074 5f74 6f6f 6c6b 6974 2e63 6f6d  ompt_toolkit.com
+0001cbd0: 706c 6574 696f 6e2e 436f 6d70 6c65 7465  pletion.Complete
+0001cbe0: 7227 3a0a 2020 2020 2020 2020 2222 220a  r':.        """.
+0001cbf0: 2020 2020 2020 2020 5265 7475 726e 7320          Returns 
+0001cc00: 6120 7072 6f6d 7074 5f74 6f6f 6c6b 6974  a prompt_toolkit
+0001cc10: 2063 7573 746f 6d20 636f 6d70 6c65 7465   custom complete
+0001cc20: 720a 2020 2020 2020 2020 2222 220a 2020  r.        """.  
+0001cc30: 2020 2020 2020 6672 6f6d 2070 726f 6d70        from promp
+0001cc40: 745f 746f 6f6c 6b69 742e 636f 6d70 6c65  t_toolkit.comple
+0001cc50: 7469 6f6e 2069 6d70 6f72 7420 436f 6d70  tion import Comp
+0001cc60: 6c65 7465 722c 2043 6f6d 706c 6574 696f  leter, Completio
+0001cc70: 6e0a 0a20 2020 2020 2020 2063 6c61 7373  n..        class
+0001cc80: 2043 4c49 436f 6d70 6c65 7465 7228 436f   CLICompleter(Co
+0001cc90: 6d70 6c65 7465 7229 3a0a 2020 2020 2020  mpleter):.      
+0001cca0: 2020 2020 2020 6465 6620 6765 745f 636f        def get_co
+0001ccb0: 6d70 6c65 7469 6f6e 7328 636d 706c 2c20  mpletions(cmpl, 
+0001ccc0: 646f 6375 6d65 6e74 2c20 636f 6d70 6c65  document, comple
+0001ccd0: 7465 5f65 7665 6e74 293a 2020 2320 7479  te_event):  # ty
+0001cce0: 7065 3a20 6967 6e6f 7265 0a20 2020 2020  pe: ignore.     
+0001ccf0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+0001cd00: 7420 636f 6d70 6c65 7465 5f65 7665 6e74  t complete_event
+0001cd10: 2e63 6f6d 706c 6574 696f 6e5f 7265 7175  .completion_requ
+0001cd20: 6573 7465 643a 0a20 2020 2020 2020 2020  ested:.         
+0001cd30: 2020 2020 2020 2020 2020 2023 204f 6e6c             # Onl
+0001cd40: 7920 6163 7469 7661 7465 2077 6865 6e20  y activate when 
+0001cd50: 7468 6520 7573 6572 2064 6f65 7320 3c54  the user does <T
+0001cd60: 4142 3e0a 2020 2020 2020 2020 2020 2020  AB>.            
+0001cd70: 2020 2020 2020 2020 7265 7475 726e 0a20          return. 
+0001cd80: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0001cd90: 6172 7473 203d 2064 6f63 756d 656e 742e  arts = document.
+0001cda0: 7465 7874 2e73 706c 6974 2822 2022 290a  text.split(" ").
+0001cdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cdc0: 636d 6420 3d20 7061 7274 735b 305d 2e6c  cmd = parts[0].l
+0001cdd0: 6f77 6572 2829 0a20 2020 2020 2020 2020  ower().         
+0001cde0: 2020 2020 2020 2069 6620 636d 6420 6e6f         if cmd no
+0001cdf0: 7420 696e 2073 656c 662e 636f 6d6d 616e  t in self.comman
+0001ce00: 6473 3a0a 2020 2020 2020 2020 2020 2020  ds:.            
+0001ce10: 2020 2020 2020 2020 2320 5765 2061 7265          # We are
+0001ce20: 2074 7279 696e 6720 746f 2063 6f6d 706c   trying to compl
+0001ce30: 6574 6520 7468 6520 636f 6d6d 616e 640a  ete the command.
+0001ce40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ce50: 2020 2020 666f 7220 706f 7373 6962 6c65      for possible
+0001ce60: 5f63 6d64 2069 6e20 2878 2066 6f72 2078  _cmd in (x for x
+0001ce70: 2069 6e20 7365 6c66 2e63 6f6d 6d61 6e64   in self.command
+0001ce80: 7320 6966 2078 2e73 7461 7274 7377 6974  s if x.startswit
+0001ce90: 6828 636d 6429 293a 0a20 2020 2020 2020  h(cmd)):.       
+0001cea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ceb0: 2079 6965 6c64 2043 6f6d 706c 6574 696f   yield Completio
+0001cec0: 6e28 706f 7373 6962 6c65 5f63 6d64 2c20  n(possible_cmd, 
+0001ced0: 7374 6172 745f 706f 7369 7469 6f6e 3d2d  start_position=-
+0001cee0: 6c65 6e28 636d 6429 290a 2020 2020 2020  len(cmd)).      
+0001cef0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0001cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cf10: 2020 2020 2320 5765 2061 7265 2074 7279      # We are try
+0001cf20: 696e 6720 746f 2063 6f6d 706c 6574 6520  ing to complete 
+0001cf30: 7468 6520 636f 6d6d 616e 6420 636f 6e74  the command cont
+0001cf40: 656e 740a 2020 2020 2020 2020 2020 2020  ent.            
+0001cf50: 2020 2020 2020 2020 6966 206c 656e 2870          if len(p
+0001cf60: 6172 7473 2920 3d3d 2031 3a0a 2020 2020  arts) == 1:.    
+0001cf70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cf80: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
+0001cf90: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0001cfa0: 7267 732c 205f 2c20 5f20 3d20 7365 6c66  rgs, _, _ = self
+0001cfb0: 2e5f 7061 7273 6561 6c6c 6172 6773 2873  ._parseallargs(s
+0001cfc0: 656c 662e 636f 6d6d 616e 6473 5b63 6d64  elf.commands[cmd
+0001cfd0: 5d2c 2063 6d64 2c20 7061 7274 735b 313a  ], cmd, parts[1:
+0001cfe0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0001cff0: 2020 2020 2020 2061 7267 203d 2022 2022         arg = " "
+0001d000: 2e6a 6f69 6e28 6172 6773 290a 2020 2020  .join(args).    
+0001d010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d020: 6966 2063 6d64 2069 6e20 7365 6c66 2e63  if cmd in self.c
+0001d030: 6f6d 6d61 6e64 735f 636f 6d70 6c65 7465  ommands_complete
+0001d040: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001d050: 2020 2020 2020 2020 2020 666f 7220 706f            for po
+0001d060: 7373 6962 6c65 5f61 7267 2069 6e20 7365  ssible_arg in se
+0001d070: 6c66 2e63 6f6d 6d61 6e64 735f 636f 6d70  lf.commands_comp
+0001d080: 6c65 7465 5b63 6d64 5d28 7365 6c66 2c20  lete[cmd](self, 
+0001d090: 6172 6729 3a0a 2020 2020 2020 2020 2020  arg):.          
+0001d0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d0b0: 2020 7969 656c 6420 436f 6d70 6c65 7469    yield Completi
+0001d0c0: 6f6e 2870 6f73 7369 626c 655f 6172 672c  on(possible_arg,
+0001d0d0: 2073 7461 7274 5f70 6f73 6974 696f 6e3d   start_position=
+0001d0e0: 2d6c 656e 2861 7267 2929 0a20 2020 2020  -len(arg)).     
+0001d0f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001d100: 6e0a 2020 2020 2020 2020 7265 7475 726e  n.        return
+0001d110: 2043 4c49 436f 6d70 6c65 7465 7228 290a   CLICompleter().
+0001d120: 0a20 2020 2064 6566 206c 6f6f 7028 7365  .    def loop(se
+0001d130: 6c66 2c20 6465 6275 673a 2069 6e74 203d  lf, debug: int =
+0001d140: 2030 2920 2d3e 204e 6f6e 653a 0a20 2020   0) -> None:.   
+0001d150: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0001d160: 204d 6169 6e20 636f 6d6d 616e 6420 6861   Main command ha
+0001d170: 6e64 6c69 6e67 206c 6f6f 700a 2020 2020  ndling loop.    
+0001d180: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0001d190: 6672 6f6d 2070 726f 6d70 745f 746f 6f6c  from prompt_tool
+0001d1a0: 6b69 7420 696d 706f 7274 2050 726f 6d70  kit import Promp
+0001d1b0: 7453 6573 7369 6f6e 0a20 2020 2020 2020  tSession.       
+0001d1c0: 2073 6573 7369 6f6e 203d 2050 726f 6d70   session = Promp
+0001d1d0: 7453 6573 7369 6f6e 2863 6f6d 706c 6574  tSession(complet
+0001d1e0: 6572 3d73 656c 662e 5f63 6f6d 706c 6574  er=self._complet
+0001d1f0: 6572 2829 290a 0a20 2020 2020 2020 2077  er())..        w
+0001d200: 6869 6c65 2054 7275 653a 0a20 2020 2020  hile True:.     
+0001d210: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+0001d220: 2020 2020 2020 2020 2020 2020 636d 6420              cmd 
+0001d230: 3d20 7365 7373 696f 6e2e 7072 6f6d 7074  = session.prompt
+0001d240: 2873 656c 662e 7073 3128 2929 2e73 7472  (self.ps1()).str
+0001d250: 6970 2829 0a20 2020 2020 2020 2020 2020  ip().           
+0001d260: 2065 7863 6570 7420 4b65 7962 6f61 7264   except Keyboard
+0001d270: 496e 7465 7272 7570 743a 0a20 2020 2020  Interrupt:.     
+0001d280: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+0001d290: 6e75 650a 2020 2020 2020 2020 2020 2020  nue.            
+0001d2a0: 6578 6365 7074 2045 4f46 4572 726f 723a  except EOFError:
+0001d2b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d2c0: 2073 656c 662e 636c 6f73 6528 290a 2020   self.close().  
+0001d2d0: 2020 2020 2020 2020 2020 2020 2020 6272                br
+0001d2e0: 6561 6b0a 2020 2020 2020 2020 2020 2020  eak.            
+0001d2f0: 6172 6773 203d 2063 6d64 2e73 706c 6974  args = cmd.split
+0001d300: 2822 2022 295b 313a 5d0a 2020 2020 2020  (" ")[1:].      
+0001d310: 2020 2020 2020 636d 6420 3d20 636d 642e        cmd = cmd.
+0001d320: 7370 6c69 7428 2220 2229 5b30 5d2e 7374  split(" ")[0].st
+0001d330: 7269 7028 292e 6c6f 7765 7228 290a 2020  rip().lower().  
+0001d340: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+0001d350: 2063 6d64 3a0a 2020 2020 2020 2020 2020   cmd:.          
+0001d360: 2020 2020 2020 636f 6e74 696e 7565 0a20        continue. 
+0001d370: 2020 2020 2020 2020 2020 2069 6620 636d             if cm
+0001d380: 6420 696e 205b 2268 656c 7022 2c20 2268  d in ["help", "h
+0001d390: 222c 2022 3f22 5d3a 0a20 2020 2020 2020  ", "?"]:.       
+0001d3a0: 2020 2020 2020 2020 2073 656c 662e 6865           self.he
+0001d3b0: 6c70 2822 2022 2e6a 6f69 6e28 6172 6773  lp(" ".join(args
+0001d3c0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+0001d3d0: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
+0001d3e0: 2020 2020 2020 2020 6966 2063 6d64 2069          if cmd i
+0001d3f0: 6e20 2265 7869 7422 3a0a 2020 2020 2020  n "exit":.      
+0001d400: 2020 2020 2020 2020 2020 6272 6561 6b0a            break.
+0001d410: 2020 2020 2020 2020 2020 2020 6966 2063              if c
+0001d420: 6d64 206e 6f74 2069 6e20 7365 6c66 2e63  md not in self.c
+0001d430: 6f6d 6d61 6e64 733a 0a20 2020 2020 2020  ommands:.       
+0001d440: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+0001d450: 556e 6b6e 6f77 6e20 636f 6d6d 616e 642e  Unknown command.
+0001d460: 2054 7970 6520 6865 6c70 206f 7220 3f22   Type help or ?"
+0001d470: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+0001d480: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0001d490: 2020 2020 2320 6368 6563 6b20 7468 6520      # check the 
+0001d4a0: 6e75 6d62 6572 206f 6620 6172 6775 6d65  number of argume
+0001d4b0: 6e74 730a 2020 2020 2020 2020 2020 2020  nts.            
+0001d4c0: 2020 2020 6675 6e63 203d 2073 656c 662e      func = self.
+0001d4d0: 636f 6d6d 616e 6473 5b63 6d64 5d0a 2020  commands[cmd].  
+0001d4e0: 2020 2020 2020 2020 2020 2020 2020 6172                ar
+0001d4f0: 6773 2c20 6b77 6172 6773 2c20 6f75 746b  gs, kwargs, outk
+0001d500: 7761 7267 7320 3d20 7365 6c66 2e5f 7061  wargs = self._pa
+0001d510: 7273 6561 6c6c 6172 6773 2866 756e 632c  rseallargs(func,
+0001d520: 2063 6d64 2c20 6172 6773 290a 2020 2020   cmd, args).    
+0001d530: 2020 2020 2020 2020 2020 2020 6966 2066              if f
+0001d540: 756e 632e 5f73 7061 6365 733a 2020 2320  unc._spaces:  # 
+0001d550: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+0001d560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d570: 2061 7267 7320 3d20 5b22 2022 2e6a 6f69   args = [" ".joi
+0001d580: 6e28 6172 6773 295d 0a20 2020 2020 2020  n(args)].       
+0001d590: 2020 2020 2020 2020 2020 2020 2023 2069               # i
+0001d5a0: 6620 676c 6f62 7375 7070 6f72 7420 6973  f globsupport is
+0001d5b0: 2073 6574 2c20 7765 206d 6967 6874 206e   set, we might n
+0001d5c0: 6565 6420 746f 2064 6f20 7365 7665 7261  eed to do severa
+0001d5d0: 6c20 6361 6c6c 730a 2020 2020 2020 2020  l calls.        
+0001d5e0: 2020 2020 2020 2020 2020 2020 6966 2066              if f
+0001d5f0: 756e 632e 5f67 6c6f 6273 7570 706f 7274  unc._globsupport
+0001d600: 2061 6e64 2022 2a22 2069 6e20 6172 6773   and "*" in args
+0001d610: 5b30 5d3a 2020 2320 7479 7065 3a20 6967  [0]:  # type: ig
+0001d620: 6e6f 7265 0a20 2020 2020 2020 2020 2020  nore.           
+0001d630: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001d640: 6172 6773 5b30 5d2e 636f 756e 7428 222a  args[0].count("*
+0001d650: 2229 203e 2031 3a0a 2020 2020 2020 2020  ") > 1:.        
+0001d660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d670: 2020 2020 7072 696e 7428 224d 6f72 6520      print("More 
+0001d680: 7468 616e 2031 2067 6c6f 6220 7374 6172  than 1 glob star
+0001d690: 2028 2a29 2069 7320 6375 7272 656e 746c   (*) is currentl
+0001d6a0: 7920 756e 7375 7070 6f72 7465 642e 2229  y unsupported.")
+0001d6b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d6c0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+0001d6d0: 7469 6e75 650a 2020 2020 2020 2020 2020  tinue.          
+0001d6e0: 2020 2020 2020 2020 2020 2020 2020 6265                be
+0001d6f0: 666f 7265 2c20 6166 7465 7220 3d20 6172  fore, after = ar
+0001d700: 6773 5b30 5d2e 7370 6c69 7428 222a 222c  gs[0].split("*",
+0001d710: 2031 290a 2020 2020 2020 2020 2020 2020   1).            
+0001d720: 2020 2020 2020 2020 2020 2020 7265 6720              reg 
+0001d730: 3d20 7265 2e63 6f6d 7069 6c65 2872 652e  = re.compile(re.
+0001d740: 6573 6361 7065 2862 6566 6f72 6529 202b  escape(before) +
+0001d750: 2072 222e 2a22 202b 2061 6674 6572 290a   r".*" + after).
+0001d760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d770: 2020 2020 2020 2020 6361 6c6c 7320 3d20          calls = 
+0001d780: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+0001d790: 2020 2020 2020 2020 2020 2020 2020 5b78                [x
+0001d7a0: 5d20 666f 7220 7820 696e 0a20 2020 2020  ] for x in.     
+0001d7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d7c0: 2020 2020 2020 2073 656c 662e 636f 6d6d         self.comm
+0001d7d0: 616e 6473 5f63 6f6d 706c 6574 655b 636d  ands_complete[cm
+0001d7e0: 645d 2873 656c 662c 2062 6566 6f72 6529  d](self, before)
+0001d7f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d800: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001d810: 7265 672e 6d61 7463 6828 7829 0a20 2020  reg.match(x).   
+0001d820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d830: 2020 2020 205d 0a20 2020 2020 2020 2020       ].         
+0001d840: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0001d850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d860: 2020 2020 2020 2020 2063 616c 6c73 203d           calls =
+0001d870: 205b 6172 6773 5d0a 2020 2020 2020 2020   [args].        
+0001d880: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001d890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d8a0: 2020 6361 6c6c 7320 3d20 5b61 7267 735d    calls = [args]
+0001d8b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d8c0: 2023 206e 6f77 2069 7465 7261 7465 2069   # now iterate i
+0001d8d0: 6620 7265 7175 6972 6564 2c20 6361 6c6c  f required, call
+0001d8e0: 2074 6865 2066 756e 6374 696f 6e20 616e   the function an
+0001d8f0: 6420 7072 696e 7420 6974 7320 6f75 7470  d print its outp
+0001d900: 7574 0a20 2020 2020 2020 2020 2020 2020  ut.             
+0001d910: 2020 2072 6573 203d 204e 6f6e 650a 2020     res = None.  
+0001d920: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+0001d930: 7220 6172 6773 2069 6e20 6361 6c6c 733a  r args in calls:
+0001d940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d950: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
+0001d960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d970: 2020 7265 7320 3d20 6675 6e63 2873 656c    res = func(sel
+0001d980: 662c 202a 6172 6773 2c20 2a2a 6b77 6172  f, *args, **kwar
+0001d990: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
+0001d9a0: 2020 2020 2020 2020 6578 6365 7074 2054          except T
+0001d9b0: 7970 6545 7272 6f72 3a0a 2020 2020 2020  ypeError:.      
+0001d9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d9d0: 2020 7072 696e 7428 2242 6164 206e 756d    print("Bad num
+0001d9e0: 6265 7220 6f66 2061 7267 756d 656e 7473  ber of arguments
+0001d9f0: 2021 2229 0a20 2020 2020 2020 2020 2020   !").           
+0001da00: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0001da10: 662e 6865 6c70 2863 6d64 3d63 6d64 290a  f.help(cmd=cmd).
+0001da20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001da30: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+0001da40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001da50: 2020 2020 2065 7863 6570 7420 4578 6365       except Exce
+0001da60: 7074 696f 6e20 6173 2065 783a 0a20 2020  ption as ex:.   
+0001da70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001da80: 2020 2020 2070 7269 6e74 2822 436f 6d6d       print("Comm
+0001da90: 616e 6420 6661 696c 6564 2077 6974 6820  and failed with 
+0001daa0: 6572 726f 723a 2025 7322 2025 2065 7829  error: %s" % ex)
+0001dab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001dac0: 2020 2020 2020 2020 2069 6620 6465 6275           if debu
+0001dad0: 673a 0a20 2020 2020 2020 2020 2020 2020  g:.             
+0001dae0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0001daf0: 7261 6365 6261 636b 2e70 7269 6e74 5f65  raceback.print_e
+0001db00: 7863 6570 7469 6f6e 2865 7829 0a20 2020  xception(ex).   
+0001db10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001db20: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+0001db30: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0001db40: 2072 6573 2061 6e64 2063 6d64 2069 6e20   res and cmd in 
+0001db50: 7365 6c66 2e63 6f6d 6d61 6e64 735f 6f75  self.commands_ou
+0001db60: 7470 7574 3a0a 2020 2020 2020 2020 2020  tput:.          
+0001db70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001db80: 2020 7365 6c66 2e63 6f6d 6d61 6e64 735f    self.commands_
+0001db90: 6f75 7470 7574 5b63 6d64 5d28 7365 6c66  output[cmd](self
+0001dba0: 2c20 7265 732c 202a 2a6f 7574 6b77 6172  , res, **outkwar
+0001dbb0: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
+0001dbc0: 2020 2020 2020 2020 6578 6365 7074 2045          except E
+0001dbd0: 7863 6570 7469 6f6e 2061 7320 6578 3a0a  xception as ex:.
+0001dbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001dbf0: 2020 2020 2020 2020 7072 696e 7428 224f          print("O
+0001dc00: 7574 7075 7420 7072 6f63 6573 736f 7220  utput processor 
+0001dc10: 6661 696c 6564 2077 6974 6820 6572 726f  failed with erro
+0001dc20: 723a 2025 7322 2025 2065 7829 0a0a 0a64  r: %s" % ex)...d
+0001dc30: 6566 2041 7574 6f41 7267 7061 7273 6528  ef AutoArgparse(
+0001dc40: 6675 6e63 3a20 4465 636f 7261 746f 7243  func: DecoratorC
+0001dc50: 616c 6c61 626c 6529 202d 3e20 4e6f 6e65  allable) -> None
+0001dc60: 3a0a 2020 2020 2222 220a 2020 2020 4765  :.    """.    Ge
+0001dc70: 6e65 7261 7465 2061 6e20 4172 6770 6172  nerate an Argpar
+0001dc80: 7365 2063 616c 6c20 6672 6f6d 2061 2066  se call from a f
+0001dc90: 756e 6374 696f 6e2c 2074 6865 6e20 6361  unction, then ca
+0001dca0: 6c6c 2074 6869 7320 6675 6e63 7469 6f6e  ll this function
+0001dcb0: 2e0a 0a20 2020 204e 6f74 6573 3a0a 0a20  ...    Notes:.. 
+0001dcc0: 2020 202d 2066 6f72 2074 6865 2061 7267     - for the arg
+0001dcd0: 756d 656e 7473 2074 6f20 6861 7665 2061  uments to have a
+0001dce0: 2064 6573 6372 6970 7469 6f6e 2c20 7468   description, th
+0001dcf0: 6520 7370 6869 6e78 2064 6f63 7374 7269  e sphinx docstri
+0001dd00: 6e67 2066 6f72 6d61 740a 2020 2020 2020  ng format.      
+0001dd10: 6d75 7374 2062 6520 7573 6564 2e20 5365  must be used. Se
+0001dd20: 650a 2020 2020 2020 6874 7470 733a 2f2f  e.      https://
+0001dd30: 7370 6869 6e78 2d72 7464 2d74 7574 6f72  sphinx-rtd-tutor
+0001dd40: 6961 6c2e 7265 6164 7468 6564 6f63 732e  ial.readthedocs.
+0001dd50: 696f 2f65 6e2f 6c61 7465 7374 2f64 6f63  io/en/latest/doc
+0001dd60: 7374 7269 6e67 732e 6874 6d6c 0a20 2020  strings.html.   
+0001dd70: 202d 2074 6865 2061 7267 756d 656e 7473   - the arguments
+0001dd80: 206d 7573 7420 6265 2074 7970 6564 2069   must be typed i
+0001dd90: 6e20 5079 7468 6f6e 2028 7765 2069 676e  n Python (we ign
+0001dda0: 6f72 6520 5370 6869 6e78 2d73 7065 6369  ore Sphinx-speci
+0001ddb0: 6669 6320 7479 7065 7329 0a20 2020 2020  fic types).     
+0001ddc0: 2075 6e74 7970 6564 2061 7267 756d 656e   untyped argumen
+0001ddd0: 7473 2061 7265 2069 676e 6f72 6564 2e0a  ts are ignored..
+0001dde0: 2020 2020 2d20 6f6e 6c79 2074 7970 6573      - only types
+0001ddf0: 2074 6861 7420 776f 756c 6420 6265 2073   that would be s
+0001de00: 7570 706f 7274 6564 2062 7920 6172 6770  upported by argp
+0001de10: 6172 7365 2061 7265 2073 7570 706f 7274  arse are support
+0001de20: 6564 2e20 5468 6520 6f74 6865 7273 0a20  ed. The others. 
+0001de30: 2020 2020 2061 7265 206f 6d69 7474 6564       are omitted
+0001de40: 2e0a 2020 2020 2222 220a 2020 2020 6172  ..    """.    ar
+0001de50: 6773 646f 6320 3d20 7b7d 0a20 2020 2069  gsdoc = {}.    i
+0001de60: 6620 6675 6e63 2e5f 5f64 6f63 5f5f 3a0a  f func.__doc__:.
+0001de70: 2020 2020 2020 2020 2320 5370 6869 6e78          # Sphinx
+0001de80: 2064 6f63 2066 6f72 6d61 7420 7061 7273   doc format pars
+0001de90: 6572 0a20 2020 2020 2020 206d 203d 2072  er.        m = r
+0001dea0: 652e 6d61 7463 6828 0a20 2020 2020 2020  e.match(.       
+0001deb0: 2020 2020 2072 2228 283f 3a2e 7c5c 6e29       r"((?:.|\n)
+0001dec0: 2a3f 2928 5c6e 5c73 2a3a 283f 3a70 6172  *?)(\n\s*:(?:par
+0001ded0: 616d 7c74 7970 657c 7261 6973 6573 7c72  am|type|raises|r
+0001dee0: 6574 7572 6e7c 7274 7970 6529 283f 3a2e  eturn|rtype)(?:.
+0001def0: 7c5c 6e29 2a29 222c 0a20 2020 2020 2020  |\n)*)",.       
+0001df00: 2020 2020 2066 756e 632e 5f5f 646f 635f       func.__doc_
+0001df10: 5f2e 7374 7269 7028 292c 0a20 2020 2020  _.strip(),.     
+0001df20: 2020 2029 0a20 2020 2020 2020 2069 6620     ).        if 
+0001df30: 6e6f 7420 6d3a 0a20 2020 2020 2020 2020  not m:.         
+0001df40: 2020 2064 6573 6320 3d20 6675 6e63 2e5f     desc = func._
+0001df50: 5f64 6f63 5f5f 2e73 7472 6970 2829 0a20  _doc__.strip(). 
+0001df60: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0001df70: 2020 2020 2020 2020 2064 6573 6320 3d20           desc = 
+0001df80: 6d2e 6772 6f75 7028 3129 0a20 2020 2020  m.group(1).     
+0001df90: 2020 2020 2020 2073 7068 696e 7861 7267         sphinxarg
+0001dfa0: 7320 3d20 7265 2e66 696e 6461 6c6c 280a  s = re.findall(.
+0001dfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001dfc0: 7222 5c73 2a3a 2870 6172 616d 7c74 7970  r"\s*:(param|typ
+0001dfd0: 657c 7261 6973 6573 7c72 6574 7572 6e7c  e|raises|return|
+0001dfe0: 7274 7970 6529 5c73 2a28 5b5e 3a5d 2a29  rtype)\s*([^:]*)
+0001dff0: 3a28 2e2a 2922 2c0a 2020 2020 2020 2020  :(.*)",.        
+0001e000: 2020 2020 2020 2020 6d2e 6772 6f75 7028          m.group(
+0001e010: 3229 2c0a 2020 2020 2020 2020 2020 2020  2),.            
+0001e020: 290a 2020 2020 2020 2020 2020 2020 666f  ).            fo
+0001e030: 7220 6172 6774 7970 652c 2061 7267 7061  r argtype, argpa
+0001e040: 7261 6d2c 2061 7267 6465 7363 2069 6e20  ram, argdesc in 
+0001e050: 7370 6869 6e78 6172 6773 3a0a 2020 2020  sphinxargs:.    
+0001e060: 2020 2020 2020 2020 2020 2020 6172 6770              argp
+0001e070: 6172 616d 203d 2061 7267 7061 7261 6d2e  aram = argparam.
+0001e080: 7374 7269 7028 290a 2020 2020 2020 2020  strip().        
+0001e090: 2020 2020 2020 2020 6172 6764 6573 6320          argdesc 
+0001e0a0: 3d20 6172 6764 6573 632e 7374 7269 7028  = argdesc.strip(
+0001e0b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0001e0c0: 2020 6966 2061 7267 7479 7065 203d 3d20    if argtype == 
+0001e0d0: 2270 6172 616d 223a 0a20 2020 2020 2020  "param":.       
+0001e0e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001e0f0: 6e6f 7420 6172 6770 6172 616d 3a0a 2020  not argparam:.  
+0001e100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e110: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+0001e120: 6545 7272 6f72 2822 3a70 6172 616d 3a20  eError(":param: 
+0001e130: 7769 7468 6f75 7420 6120 6e61 6d65 2021  without a name !
+0001e140: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+0001e150: 2020 2020 2020 2061 7267 7364 6f63 5b61         argsdoc[a
+0001e160: 7267 7061 7261 6d5d 203d 2061 7267 6465  rgparam] = argde
+0001e170: 7363 0a20 2020 2065 6c73 653a 0a20 2020  sc.    else:.   
+0001e180: 2020 2020 2064 6573 6320 3d20 2222 0a20       desc = "". 
+0001e190: 2020 2023 204e 6f77 2062 7569 6c64 2074     # Now build t
+0001e1a0: 6865 2061 7267 7061 7273 652e 4172 6775  he argparse.Argu
+0001e1b0: 6d65 6e74 5061 7273 6572 0a20 2020 2070  mentParser.    p
+0001e1c0: 6172 7365 7220 3d20 6172 6770 6172 7365  arser = argparse
+0001e1d0: 2e41 7267 756d 656e 7450 6172 7365 7228  .ArgumentParser(
+0001e1e0: 0a20 2020 2020 2020 2070 726f 673d 6675  .        prog=fu
+0001e1f0: 6e63 2e5f 5f6e 616d 655f 5f2c 0a20 2020  nc.__name__,.   
+0001e200: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
+0001e210: 3d64 6573 632c 0a20 2020 2020 2020 2066  =desc,.        f
+0001e220: 6f72 6d61 7474 6572 5f63 6c61 7373 3d61  ormatter_class=a
+0001e230: 7267 7061 7273 652e 4172 6775 6d65 6e74  rgparse.Argument
+0001e240: 4465 6661 756c 7473 4865 6c70 466f 726d  DefaultsHelpForm
+0001e250: 6174 7465 722c 0a20 2020 2029 0a20 2020  atter,.    ).   
+0001e260: 2023 2050 726f 6365 7373 2074 6865 2070   # Process the p
+0001e270: 6172 616d 6574 6572 730a 2020 2020 706f  arameters.    po
+0001e280: 7369 7469 6f6e 616c 203d 205b 5d0a 2020  sitional = [].  
+0001e290: 2020 666f 7220 7061 7261 6d20 696e 2069    for param in i
+0001e2a0: 6e73 7065 6374 2e73 6967 6e61 7475 7265  nspect.signature
+0001e2b0: 2866 756e 6329 2e70 6172 616d 6574 6572  (func).parameter
+0001e2c0: 732e 7661 6c75 6573 2829 3a0a 2020 2020  s.values():.    
+0001e2d0: 2020 2020 6966 206e 6f74 2070 6172 616d      if not param
+0001e2e0: 2e61 6e6e 6f74 6174 696f 6e3a 0a20 2020  .annotation:.   
+0001e2f0: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+0001e300: 650a 2020 2020 2020 2020 7061 726e 616d  e.        parnam
+0001e310: 6520 3d20 7061 7261 6d2e 6e61 6d65 0a20  e = param.name. 
+0001e320: 2020 2020 2020 2070 6172 616d 6b77 6172         paramkwar
+0001e330: 6773 203d 207b 7d0a 2020 2020 2020 2020  gs = {}.        
+0001e340: 6966 2070 6172 616d 2e61 6e6e 6f74 6174  if param.annotat
+0001e350: 696f 6e20 6973 2062 6f6f 6c3a 0a20 2020  ion is bool:.   
+0001e360: 2020 2020 2020 2020 2069 6620 7061 7261           if para
+0001e370: 6d2e 6465 6661 756c 7420 6973 2054 7275  m.default is Tru
+0001e380: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001e390: 2020 2070 6172 6e61 6d65 203d 2022 6e6f     parname = "no
+0001e3a0: 2d22 202b 2070 6172 6e61 6d65 0a20 2020  -" + parname.   
+0001e3b0: 2020 2020 2020 2020 2020 2020 2070 6172               par
+0001e3c0: 616d 6b77 6172 6773 5b22 6163 7469 6f6e  amkwargs["action
+0001e3d0: 225d 203d 2022 7374 6f72 655f 6661 6c73  "] = "store_fals
+0001e3e0: 6522 0a20 2020 2020 2020 2020 2020 2065  e".            e
+0001e3f0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0001e400: 2020 2020 2070 6172 616d 6b77 6172 6773       paramkwargs
+0001e410: 5b22 6163 7469 6f6e 225d 203d 2022 7374  ["action"] = "st
+0001e420: 6f72 655f 7472 7565 220a 2020 2020 2020  ore_true".      
+0001e430: 2020 656c 6966 2070 6172 616d 2e61 6e6e    elif param.ann
+0001e440: 6f74 6174 696f 6e20 696e 205b 7374 722c  otation in [str,
+0001e450: 2069 6e74 2c20 666c 6f61 745d 3a0a 2020   int, float]:.  
+0001e460: 2020 2020 2020 2020 2020 7061 7261 6d6b            paramk
+0001e470: 7761 7267 735b 2274 7970 6522 5d20 3d20  wargs["type"] = 
+0001e480: 7061 7261 6d2e 616e 6e6f 7461 7469 6f6e  param.annotation
+0001e490: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0001e4a0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+0001e4b0: 6e75 650a 2020 2020 2020 2020 6966 2070  nue.        if p
+0001e4c0: 6172 616d 2e64 6566 6175 6c74 2021 3d20  aram.default != 
+0001e4d0: 696e 7370 6563 742e 5061 7261 6d65 7465  inspect.Paramete
+0001e4e0: 722e 656d 7074 793a 0a20 2020 2020 2020  r.empty:.       
+0001e4f0: 2020 2020 2069 6620 7061 7261 6d2e 6b69       if param.ki
+0001e500: 6e64 203d 3d20 696e 7370 6563 742e 5061  nd == inspect.Pa
+0001e510: 7261 6d65 7465 722e 504f 5349 5449 4f4e  rameter.POSITION
+0001e520: 414c 5f4f 4e4c 593a 0a20 2020 2020 2020  AL_ONLY:.       
+0001e530: 2020 2020 2020 2020 2070 6f73 6974 696f           positio
+0001e540: 6e61 6c2e 6170 7065 6e64 2870 6172 616d  nal.append(param
+0001e550: 2e6e 616d 6529 0a20 2020 2020 2020 2020  .name).         
+0001e560: 2020 2020 2020 2070 6172 616d 6b77 6172         paramkwar
+0001e570: 6773 5b22 6e61 7267 7322 5d20 3d20 273f  gs["nargs"] = '?
+0001e580: 270a 2020 2020 2020 2020 2020 2020 656c  '.            el
+0001e590: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0001e5a0: 2020 2020 7061 726e 616d 6520 3d20 222d      parname = "-
+0001e5b0: 2d22 202b 2070 6172 6e61 6d65 0a20 2020  -" + parname.   
+0001e5c0: 2020 2020 2020 2020 2070 6172 616d 6b77           paramkw
+0001e5d0: 6172 6773 5b22 6465 6661 756c 7422 5d20  args["default"] 
+0001e5e0: 3d20 7061 7261 6d2e 6465 6661 756c 740a  = param.default.
+0001e5f0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001e600: 2020 2020 2020 2020 2020 706f 7369 7469            positi
+0001e610: 6f6e 616c 2e61 7070 656e 6428 7061 7261  onal.append(para
+0001e620: 6d2e 6e61 6d65 290a 2020 2020 2020 2020  m.name).        
+0001e630: 6966 2070 6172 616d 2e6b 696e 6420 3d3d  if param.kind ==
+0001e640: 2069 6e73 7065 6374 2e50 6172 616d 6574   inspect.Paramet
+0001e650: 6572 2e56 4152 5f50 4f53 4954 494f 4e41  er.VAR_POSITIONA
+0001e660: 4c3a 0a20 2020 2020 2020 2020 2020 2070  L:.            p
+0001e670: 6172 616d 6b77 6172 6773 5b22 6163 7469  aramkwargs["acti
+0001e680: 6f6e 225d 203d 2022 6170 7065 6e64 220a  on"] = "append".
+0001e690: 2020 2020 2020 2020 6966 2070 6172 616d          if param
+0001e6a0: 2e6e 616d 6520 696e 2061 7267 7364 6f63  .name in argsdoc
+0001e6b0: 3a0a 2020 2020 2020 2020 2020 2020 7061  :.            pa
+0001e6c0: 7261 6d6b 7761 7267 735b 2268 656c 7022  ramkwargs["help"
+0001e6d0: 5d20 3d20 6172 6773 646f 635b 7061 7261  ] = argsdoc[para
+0001e6e0: 6d2e 6e61 6d65 5d0a 2020 2020 2020 2020  m.name].        
+0001e6f0: 7061 7273 6572 2e61 6464 5f61 7267 756d  parser.add_argum
+0001e700: 656e 7428 7061 726e 616d 652c 202a 2a70  ent(parname, **p
+0001e710: 6172 616d 6b77 6172 6773 2920 2023 2074  aramkwargs)  # t
+0001e720: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
+0001e730: 2320 4e6f 7720 7061 7273 6520 7468 6520  # Now parse the 
+0001e740: 7379 732e 6172 6776 2070 6172 616d 6574  sys.argv paramet
+0001e750: 6572 730a 2020 2020 7061 7261 6d73 203d  ers.    params =
+0001e760: 2076 6172 7328 7061 7273 6572 2e70 6172   vars(parser.par
+0001e770: 7365 5f61 7267 7328 2929 0a20 2020 2023  se_args()).    #
+0001e780: 2041 6374 2061 7320 696e 2069 6e74 6572   Act as in inter
+0001e790: 6163 7469 7665 206d 6f64 650a 2020 2020  active mode.    
+0001e7a0: 636f 6e66 2e6c 6f67 4c65 7665 6c20 3d20  conf.logLevel = 
+0001e7b0: 3230 0a20 2020 2066 726f 6d20 7363 6170  20.    from scap
+0001e7c0: 792e 7468 656d 6573 2069 6d70 6f72 7420  y.themes import 
+0001e7d0: 4465 6661 756c 7454 6865 6d65 0a20 2020  DefaultTheme.   
+0001e7e0: 2063 6f6e 662e 636f 6c6f 725f 7468 656d   conf.color_them
+0001e7f0: 6520 3d20 4465 6661 756c 7454 6865 6d65  e = DefaultTheme
+0001e800: 2829 0a20 2020 2023 2041 6e64 2063 616c  ().    # And cal
+0001e810: 6c20 7468 6520 6675 6e63 7469 6f6e 0a20  l the function. 
+0001e820: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+0001e830: 6675 6e63 280a 2020 2020 2020 2020 2020  func(.          
+0001e840: 2020 2a5b 7061 7261 6d73 2e70 6f70 2878    *[params.pop(x
+0001e850: 2920 666f 7220 7820 696e 2070 6f73 6974  ) for x in posit
+0001e860: 696f 6e61 6c5d 2c0a 2020 2020 2020 2020  ional],.        
+0001e870: 2020 2020 2a2a 7b0a 2020 2020 2020 2020      **{.        
+0001e880: 2020 2020 2020 2020 286b 5b33 3a5d 2069          (k[3:] i
+0001e890: 6620 6b2e 7374 6172 7473 7769 7468 2822  f k.startswith("
+0001e8a0: 6e6f 5f22 2920 656c 7365 206b 293a 2076  no_") else k): v
+0001e8b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001e8c0: 2066 6f72 206b 2c20 7620 696e 2070 6172   for k, v in par
+0001e8d0: 616d 732e 6974 656d 7328 290a 2020 2020  ams.items().    
+0001e8e0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+0001e8f0: 2020 290a 2020 2020 6578 6365 7074 2041    ).    except A
+0001e900: 7373 6572 7469 6f6e 4572 726f 7220 6173  ssertionError as
+0001e910: 2065 783a 0a20 2020 2020 2020 2070 7269   ex:.        pri
+0001e920: 6e74 2822 4552 524f 523a 2022 202b 2073  nt("ERROR: " + s
+0001e930: 7472 2865 7829 290a 2020 2020 2020 2020  tr(ex)).        
+0001e940: 7061 7273 6572 2e70 7269 6e74 5f68 656c  parser.print_hel
+0001e950: 7028 290a 0a0a 2323 2323 2323 2323 2323  p()...##########
+0001e960: 2323 2323 2323 2323 2323 2323 230a 2320  #############.# 
+0001e970: 2020 5045 5249 4f44 4943 2053 454e 4445    PERIODIC SENDE
+0001e980: 5220 2020 230a 2323 2323 2323 2323 2323  R   #.##########
+0001e990: 2323 2323 2323 2323 2323 2323 230a 0a0a  #############...
+0001e9a0: 636c 6173 7320 5065 7269 6f64 6963 5365  class PeriodicSe
+0001e9b0: 6e64 6572 5468 7265 6164 2874 6872 6561  nderThread(threa
+0001e9c0: 6469 6e67 2e54 6872 6561 6429 3a0a 2020  ding.Thread):.  
+0001e9d0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+0001e9e0: 656c 662c 2073 6f63 6b2c 2070 6b74 2c20  elf, sock, pkt, 
+0001e9f0: 696e 7465 7276 616c 3d30 2e35 2c20 6967  interval=0.5, ig
+0001ea00: 6e6f 7265 5f65 7863 6570 7469 6f6e 733d  nore_exceptions=
+0001ea10: 5472 7565 293a 0a20 2020 2020 2020 2023  True):.        #
+0001ea20: 2074 7970 653a 2028 416e 792c 205f 5061   type: (Any, _Pa
+0001ea30: 636b 6574 4974 6572 6162 6c65 2c20 666c  cketIterable, fl
+0001ea40: 6f61 742c 2062 6f6f 6c29 202d 3e20 4e6f  oat, bool) -> No
+0001ea50: 6e65 0a20 2020 2020 2020 2022 2222 2054  ne.        """ T
+0001ea60: 6872 6561 6420 746f 2073 656e 6420 7061  hread to send pa
+0001ea70: 636b 6574 7320 7065 7269 6f64 6963 616c  ckets periodical
+0001ea80: 6c79 0a0a 2020 2020 2020 2020 4172 6773  ly..        Args
+0001ea90: 3a0a 2020 2020 2020 2020 2020 2020 736f  :.            so
+0001eaa0: 636b 3a20 736f 636b 6574 2077 6865 7265  ck: socket where
+0001eab0: 2070 6163 6b65 7420 6973 2073 656e 7420   packet is sent 
+0001eac0: 7065 7269 6f64 6963 616c 6c79 0a20 2020  periodically.   
+0001ead0: 2020 2020 2020 2020 2070 6b74 3a20 7061           pkt: pa
+0001eae0: 636b 6574 206f 7220 6c69 7374 206f 6620  cket or list of 
+0001eaf0: 7061 636b 6574 7320 746f 2073 656e 640a  packets to send.
+0001eb00: 2020 2020 2020 2020 2020 2020 696e 7465              inte
+0001eb10: 7276 616c 3a20 696e 7465 7276 616c 2062  rval: interval b
+0001eb20: 6574 7765 656e 2074 776f 2070 6163 6b65  etween two packe
+0001eb30: 7473 0a20 2020 2020 2020 2022 2222 0a20  ts.        """. 
+0001eb40: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+0001eb50: 696e 7374 616e 6365 2870 6b74 2c20 6c69  instance(pkt, li
+0001eb60: 7374 293a 0a20 2020 2020 2020 2020 2020  st):.           
+0001eb70: 2073 656c 662e 5f70 6b74 7320 3d20 5b63   self._pkts = [c
+0001eb80: 6173 7428 2250 6163 6b65 7422 2c20 706b  ast("Packet", pk
+0001eb90: 7429 5d20 2023 2074 7970 653a 205f 5061  t)]  # type: _Pa
+0001eba0: 636b 6574 4974 6572 6162 6c65 0a20 2020  cketIterable.   
+0001ebb0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001ebc0: 2020 2020 2020 2073 656c 662e 5f70 6b74         self._pkt
+0001ebd0: 7320 3d20 706b 740a 2020 2020 2020 2020  s = pkt.        
+0001ebe0: 7365 6c66 2e5f 736f 636b 6574 203d 2073  self._socket = s
+0001ebf0: 6f63 6b0a 2020 2020 2020 2020 7365 6c66  ock.        self
+0001ec00: 2e5f 7374 6f70 7065 6420 3d20 7468 7265  ._stopped = thre
+0001ec10: 6164 696e 672e 4576 656e 7428 290a 2020  ading.Event().  
+0001ec20: 2020 2020 2020 7365 6c66 2e5f 656e 6162        self._enab
+0001ec30: 6c65 6420 3d20 7468 7265 6164 696e 672e  led = threading.
+0001ec40: 4576 656e 7428 290a 2020 2020 2020 2020  Event().        
+0001ec50: 7365 6c66 2e5f 656e 6162 6c65 642e 7365  self._enabled.se
+0001ec60: 7428 290a 2020 2020 2020 2020 7365 6c66  t().        self
+0001ec70: 2e5f 696e 7465 7276 616c 203d 2069 6e74  ._interval = int
+0001ec80: 6572 7661 6c0a 2020 2020 2020 2020 7365  erval.        se
+0001ec90: 6c66 2e5f 6967 6e6f 7265 5f65 7863 6570  lf._ignore_excep
+0001eca0: 7469 6f6e 7320 3d20 6967 6e6f 7265 5f65  tions = ignore_e
+0001ecb0: 7863 6570 7469 6f6e 730a 2020 2020 2020  xceptions.      
+0001ecc0: 2020 7468 7265 6164 696e 672e 5468 7265    threading.Thre
+0001ecd0: 6164 2e5f 5f69 6e69 745f 5f28 7365 6c66  ad.__init__(self
+0001ece0: 290a 0a20 2020 2064 6566 2065 6e61 626c  )..    def enabl
+0001ecf0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
+0001ed00: 2023 2074 7970 653a 2028 2920 2d3e 204e   # type: () -> N
+0001ed10: 6f6e 650a 2020 2020 2020 2020 7365 6c66  one.        self
+0001ed20: 2e5f 656e 6162 6c65 642e 7365 7428 290a  ._enabled.set().
+0001ed30: 0a20 2020 2064 6566 2064 6973 6162 6c65  .    def disable
+0001ed40: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0001ed50: 2320 7479 7065 3a20 2829 202d 3e20 4e6f  # type: () -> No
+0001ed60: 6e65 0a20 2020 2020 2020 2073 656c 662e  ne.        self.
+0001ed70: 5f65 6e61 626c 6564 2e63 6c65 6172 2829  _enabled.clear()
+0001ed80: 0a0a 2020 2020 6465 6620 7275 6e28 7365  ..    def run(se
+0001ed90: 6c66 293a 0a20 2020 2020 2020 2023 2074  lf):.        # t
+0001eda0: 7970 653a 2028 2920 2d3e 204e 6f6e 650a  ype: () -> None.
+0001edb0: 2020 2020 2020 2020 7768 696c 6520 6e6f          while no
+0001edc0: 7420 7365 6c66 2e5f 7374 6f70 7065 642e  t self._stopped.
+0001edd0: 6973 5f73 6574 2829 2061 6e64 206e 6f74  is_set() and not
+0001ede0: 2073 656c 662e 5f73 6f63 6b65 742e 636c   self._socket.cl
+0001edf0: 6f73 6564 3a0a 2020 2020 2020 2020 2020  osed:.          
+0001ee00: 2020 666f 7220 7020 696e 2073 656c 662e    for p in self.
+0001ee10: 5f70 6b74 733a 0a20 2020 2020 2020 2020  _pkts:.         
+0001ee20: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+0001ee30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ee40: 6966 2073 656c 662e 5f65 6e61 626c 6564  if self._enabled
+0001ee50: 2e69 735f 7365 7428 293a 0a20 2020 2020  .is_set():.     
+0001ee60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ee70: 2020 2073 656c 662e 5f73 6f63 6b65 742e     self._socket.
+0001ee80: 7365 6e64 2870 290a 2020 2020 2020 2020  send(p).        
+0001ee90: 2020 2020 2020 2020 6578 6365 7074 2028          except (
+0001eea0: 4f53 4572 726f 722c 2054 696d 656f 7574  OSError, Timeout
+0001eeb0: 4572 726f 7229 2061 7320 653a 0a20 2020  Error) as e:.   
+0001eec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eed0: 2069 6620 7365 6c66 2e5f 6967 6e6f 7265   if self._ignore
+0001eee0: 5f65 7863 6570 7469 6f6e 733a 0a20 2020  _exceptions:.   
+0001eef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ef00: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+0001ef10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ef20: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001ef30: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+0001ef40: 6973 6520 650a 2020 2020 2020 2020 2020  ise e.          
+0001ef50: 2020 2020 2020 7365 6c66 2e5f 7374 6f70        self._stop
+0001ef60: 7065 642e 7761 6974 2874 696d 656f 7574  ped.wait(timeout
+0001ef70: 3d73 656c 662e 5f69 6e74 6572 7661 6c29  =self._interval)
+0001ef80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ef90: 2069 6620 7365 6c66 2e5f 7374 6f70 7065   if self._stoppe
+0001efa0: 642e 6973 5f73 6574 2829 206f 7220 7365  d.is_set() or se
+0001efb0: 6c66 2e5f 736f 636b 6574 2e63 6c6f 7365  lf._socket.close
+0001efc0: 643a 0a20 2020 2020 2020 2020 2020 2020  d:.             
+0001efd0: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
+0001efe0: 2020 6465 6620 7374 6f70 2873 656c 6629    def stop(self)
+0001eff0: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
+0001f000: 3a20 2829 202d 3e20 4e6f 6e65 0a20 2020  : () -> None.   
+0001f010: 2020 2020 2073 656c 662e 5f73 746f 7070       self._stopp
+0001f020: 6564 2e73 6574 2829 0a20 2020 2020 2020  ed.set().       
+0001f030: 2073 656c 662e 6a6f 696e 2873 656c 662e   self.join(self.
+0001f040: 5f69 6e74 6572 7661 6c20 2a20 3229 0a0a  _interval * 2)..
+0001f050: 0a63 6c61 7373 2053 696e 676c 6543 6f6e  .class SingleCon
+0001f060: 7665 7273 6174 696f 6e53 6f63 6b65 7428  versationSocket(
+0001f070: 6f62 6a65 6374 293a 0a20 2020 2064 6566  object):.    def
+0001f080: 205f 5f69 6e69 745f 5f28 7365 6c66 2c20   __init__(self, 
+0001f090: 6f29 3a0a 2020 2020 2020 2020 2320 7479  o):.        # ty
+0001f0a0: 7065 3a20 2841 6e79 2920 2d3e 204e 6f6e  pe: (Any) -> Non
+0001f0b0: 650a 2020 2020 2020 2020 7365 6c66 2e5f  e.        self._
+0001f0c0: 696e 6e65 7220 3d20 6f0a 2020 2020 2020  inner = o.      
+0001f0d0: 2020 7365 6c66 2e5f 7478 5f6d 7574 6578    self._tx_mutex
+0001f0e0: 203d 2074 6872 6561 6469 6e67 2e52 4c6f   = threading.RLo
+0001f0f0: 636b 2829 0a0a 2020 2020 4070 726f 7065  ck()..    @prope
+0001f100: 7274 790a 2020 2020 6465 6620 5f5f 6469  rty.    def __di
+0001f110: 6374 5f5f 2873 656c 6629 3a20 2023 2074  ct__(self):  # t
+0001f120: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
+0001f130: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0001f140: 5f69 6e6e 6572 2e5f 5f64 6963 745f 5f0a  _inner.__dict__.
+0001f150: 0a20 2020 2064 6566 205f 5f67 6574 6174  .    def __getat
+0001f160: 7472 5f5f 2873 656c 662c 206e 616d 6529  tr__(self, name)
+0001f170: 3a0a 2020 2020 2020 2020 2320 7479 7065  :.        # type
+0001f180: 3a20 2873 7472 2920 2d3e 2041 6e79 0a20  : (str) -> Any. 
+0001f190: 2020 2020 2020 2072 6574 7572 6e20 6765         return ge
+0001f1a0: 7461 7474 7228 7365 6c66 2e5f 696e 6e65  tattr(self._inne
+0001f1b0: 722c 206e 616d 6529 0a0a 2020 2020 6465  r, name)..    de
+0001f1c0: 6620 7372 3128 7365 6c66 2c20 2a61 7267  f sr1(self, *arg
+0001f1d0: 732c 202a 2a6b 6172 6773 293a 0a20 2020  s, **kargs):.   
+0001f1e0: 2020 2020 2023 2074 7970 653a 2028 2a41       # type: (*A
+0001f1f0: 6e79 2c20 2a2a 416e 7929 202d 3e20 416e  ny, **Any) -> An
+0001f200: 790a 2020 2020 2020 2020 7769 7468 2073  y.        with s
+0001f210: 656c 662e 5f74 785f 6d75 7465 783a 0a20  elf._tx_mutex:. 
+0001f220: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001f230: 6e20 7365 6c66 2e5f 696e 6e65 722e 7372  n self._inner.sr
+0001f240: 3128 2a61 7267 732c 202a 2a6b 6172 6773  1(*args, **kargs
+0001f250: 290a 0a20 2020 2064 6566 2073 7228 7365  )..    def sr(se
+0001f260: 6c66 2c20 2a61 7267 732c 202a 2a6b 6172  lf, *args, **kar
+0001f270: 6773 293a 0a20 2020 2020 2020 2023 2074  gs):.        # t
+0001f280: 7970 653a 2028 2a41 6e79 2c20 2a2a 416e  ype: (*Any, **An
+0001f290: 7929 202d 3e20 416e 790a 2020 2020 2020  y) -> Any.      
+0001f2a0: 2020 7769 7468 2073 656c 662e 5f74 785f    with self._tx_
+0001f2b0: 6d75 7465 783a 0a20 2020 2020 2020 2020  mutex:.         
+0001f2c0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0001f2d0: 696e 6e65 722e 7372 282a 6172 6773 2c20  inner.sr(*args, 
+0001f2e0: 2a2a 6b61 7267 7329 0a0a 2020 2020 6465  **kargs)..    de
+0001f2f0: 6620 7365 6e64 2873 656c 662c 2078 293a  f send(self, x):
+0001f300: 0a20 2020 2020 2020 2023 2074 7970 653a  .        # type:
+0001f310: 2028 5061 636b 6574 2920 2d3e 2041 6e79   (Packet) -> Any
+0001f320: 0a20 2020 2020 2020 2077 6974 6820 7365  .        with se
+0001f330: 6c66 2e5f 7478 5f6d 7574 6578 3a0a 2020  lf._tx_mutex:.  
+0001f340: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
+0001f350: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0001f360: 6574 7572 6e20 7365 6c66 2e5f 696e 6e65  eturn self._inne
+0001f370: 722e 7365 6e64 2878 290a 2020 2020 2020  r.send(x).      
+0001f380: 2020 2020 2020 6578 6365 7074 2028 436f        except (Co
+0001f390: 6e6e 6563 7469 6f6e 4572 726f 722c 204f  nnectionError, O
+0001f3a0: 5345 7272 6f72 2920 6173 2065 3a0a 2020  SError) as e:.  
+0001f3b0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0001f3c0: 6c66 2e5f 696e 6e65 722e 636c 6f73 6528  lf._inner.close(
+0001f3d0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0001f3e0: 2020 7261 6973 6520 650a                   raise e.
```

### Comparing `scapy-2.5.0rc3/scapy/utils6.py` & `scapy-2.6.0rc1/scapy/utils6.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,14 @@
 # Copyright (C) Philippe Biondi <phil@secdev.org>
 # Copyright (C) 2005  Guillaume Valadon <guedou@hongo.wide.ad.jp>
 #                     Arnaud Ebalard <arnaud.ebalard@eads.net>
 
 """
 Utility functions for IPv6.
 """
-from __future__ import absolute_import
 import socket
 import struct
 import time
 
 from scapy.config import conf
 from scapy.base_classes import Net
 from scapy.data import IPV6_ADDR_GLOBAL, IPV6_ADDR_LINKLOCAL, \
@@ -21,15 +20,15 @@
 from scapy.utils import strxor
 from scapy.compat import orb, chb
 from scapy.pton_ntop import inet_pton, inet_ntop
 from scapy.volatile import RandMAC, RandBin
 from scapy.error import warning, Scapy_Exception
 from functools import reduce, cmp_to_key
 
-from scapy.compat import (
+from typing import (
     Iterator,
     List,
     Optional,
     Tuple,
     Union,
     cast,
 )
@@ -82,14 +81,16 @@
             cset = (x for x in laddr if x[1] == IPV6_ADDR_GLOBAL)
         elif in6_ismlladdr(addr):
             cset = (x for x in laddr if x[1] == IPV6_ADDR_LINKLOCAL)
         elif in6_ismsladdr(addr):
             cset = (x for x in laddr if x[1] == IPV6_ADDR_SITELOCAL)
     elif addr == '::' and plen == 0:
         cset = (x for x in laddr if x[1] == IPV6_ADDR_GLOBAL)
+    elif addr == '::1':
+        cset = (x for x in laddr if x[1] == IPV6_ADDR_LOOPBACK)
     addrs = [x[0] for x in cset]
     # TODO convert the cmd use into a key
     addrs.sort(key=cmp_to_key(cset_sort))  # Sort with global addresses first
     return addrs
 
 
 def get_source_addr_from_candidate_set(dst, candidate_set):
```

### Comparing `scapy-2.5.0rc3/scapy/volatile.py` & `scapy-2.6.0rc1/scapy/volatile.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,30 +5,28 @@
 # Copyright (C) Michael Farrell <micolous+git@gmail.com>
 # Copyright (C) Gauthier Sebaux
 
 """
 Fields that hold random numbers.
 """
 
-from __future__ import absolute_import
 import copy
 import random
 import time
 import math
 import re
 import uuid
 import struct
 import string
 
 from scapy.base_classes import Net
 from scapy.compat import bytes_encode, chb, plain_str
 from scapy.utils import corrupt_bits, corrupt_bytes
-from scapy.libs.six.moves import zip_longest
 
-from scapy.compat import (
+from typing import (
     List,
     TypeVar,
     Generic,
     Set,
     Union,
     Any,
     Dict,
@@ -106,17 +104,20 @@
         # type: () -> str
         return "<%s>" % self.__class__.__name__
 
     def _command_args(self):
         # type: () -> str
         return ''
 
-    def command(self):
-        # type: () -> str
-        return "%s(%s)" % (self.__class__.__name__, self._command_args())
+    def command(self, json=False):
+        # type: (bool) -> Union[Dict[str, str], str]
+        if json:
+            return {"type": self.__class__.__name__, "value": self._command_args()}
+        else:
+            return "%s(%s)" % (self.__class__.__name__, self._command_args())
 
     def __eq__(self, other):
         # type: (Any) -> bool
         x = self._fix()
         y = other._fix() if isinstance(other, VolatileValue) else other
         if not isinstance(x, type(y)):
             return False
@@ -506,20 +507,20 @@
         return bytes_encode(self._fix())
 
     def __mul__(self, n):
         # type: (int) -> _S
         return self._fix() * n
 
 
-class RandString(_RandString[bytes]):
+class RandString(_RandString[str]):
     _DEFAULT_CHARS = (string.ascii_uppercase + string.ascii_lowercase +
-                      string.digits).encode("utf-8")
+                      string.digits)
 
     def __init__(self, size=None, chars=_DEFAULT_CHARS):
-        # type: (Optional[Union[int, RandNum]], bytes) -> None
+        # type: (Optional[Union[int, RandNum]], str) -> None
         if size is None:
             size = RandNumExpo(0.01)
         self.size = size
         self.chars = chars
 
     def _command_args(self):
         # type: () -> str
@@ -531,41 +532,49 @@
             ret += "size=%r" % self.size
 
         if self.chars != self._DEFAULT_CHARS:
             ret += ", chars=%r" % self.chars
         return ret
 
     def _fix(self):
-        # type: () -> bytes
-        s = b""
+        # type: () -> str
+        s = ""
         for _ in range(int(self.size)):
-            rdm_chr = random.choice(self.chars)
-            s += rdm_chr if isinstance(rdm_chr, str) else chb(rdm_chr)
+            s += random.choice(self.chars)
         return s
 
 
-class RandBin(RandString):
-    def __init__(self, size=None):
-        # type: (Optional[Union[int, RandNum]]) -> None
-        super(RandBin, self).__init__(
-            size=size,
-            chars=b"".join(chb(c) for c in range(256))
-        )
+class RandBin(_RandString[bytes]):
+    _DEFAULT_CHARS = b"".join(chb(c) for c in range(256))
+
+    def __init__(self, size=None, chars=_DEFAULT_CHARS):
+        # type: (Optional[Union[int, RandNum]], bytes) -> None
+        if size is None:
+            size = RandNumExpo(0.01)
+        self.size = size
+        self.chars = chars
 
     def _command_args(self):
         # type: () -> str
         if not isinstance(self.size, VolatileValue):
             return "size=%r" % self.size
 
         if isinstance(self.size, RandNumExpo) and \
                 self.size.lambd == 0.01 and self.size.base == 0:
             # Default size for RandString, skip
             return ""
         return "size=%r" % self.size.command()
 
+    def _fix(self):
+        # type: () -> bytes
+        s = b""
+        for _ in range(int(self.size)):
+            s += struct.pack("!B", random.choice(self.chars))
+        return s
+
 
 class RandTermString(RandBin):
     def __init__(self, size, term):
         # type: (Union[int, RandNum], bytes) -> None
         self.term = bytes_encode(term)
         super(RandTermString, self).__init__(size=size)
 
@@ -1187,15 +1196,15 @@
                                  "if specified")
             tmp = RandUUID._REG.match(template)
             if tmp:
                 template = tmp.groups()
             else:
                 # Invalid template
                 raise ValueError("UUID template is invalid")
-            rnd_f = [RandInt] + [RandShort] * 2 + [RandByte] * 8  # type: ignore  # noqa: E501
+            rnd_f = [RandInt] + [RandShort] * 2 + [RandByte] * 8
             uuid_template = []  # type: List[Union[int, RandNum]]
             for i, t in enumerate(template):
                 if t == "*":
                     uuid_template.append(rnd_f[i]())
                 elif ":" in t:
                     mini, maxi = t.split(":")
                     uuid_template.append(
@@ -1408,119 +1417,7 @@
         return corrupt_bytes(self.s, self.p, self.n)
 
 
 class CorruptedBits(CorruptedBytes):
     def _fix(self):
         # type: () -> bytes
         return corrupt_bits(self.s, self.p, self.n)
-
-
-class CyclicPattern(VolatileValue[bytes]):
-    """
-    Generate a cyclic pattern
-
-    :param size: Size of generated pattern. Default is random size.
-    :param start: Start offset of the generated pattern.
-    :param charset_type: Charset types:
-                         0: basic (0-9A-Za-z)
-                         1: extended
-                         2: maximum (almost printable chars)
-
-
-    The code of this class was inspired by
-
-    PEDA - Python Exploit Development Assistance for GDB
-    Copyright (C) 2012 Long Le Dinh <longld at vnsecurity.net>
-    License: This work is licensed under a Creative Commons
-    Attribution-NonCommercial-ShareAlike 3.0 Unported License.
-    """
-
-    @staticmethod
-    def cyclic_pattern_charset(charset_type=None):
-        # type: (Optional[int]) -> str
-        """
-        :param charset_type: charset type
-                             0: basic (0-9A-Za-z)
-                             1: extended (default)
-                             2: maximum (almost printable chars)
-        :return: list of charset
-        """
-
-        charset = \
-            [string.ascii_uppercase, string.ascii_lowercase, string.digits]
-
-        if charset_type == 1:  # extended type
-            charset[1] = "%$-;" + re.sub("[sn]", "", charset[1])
-            charset[2] = "sn()" + charset[2]
-
-        if charset_type == 2:  # maximum type
-            charset += [string.punctuation]
-
-        return "".join(
-            ["".join(k) for k in zip_longest(*charset, fillvalue="")])
-
-    @staticmethod
-    def de_bruijn(charset, n, maxlen):
-        # type: (str, int, int) -> str
-        """
-        Generate the De Bruijn Sequence up to `maxlen` characters
-        for the charset `charset` and subsequences of length `n`.
-        Algorithm modified from wikipedia
-        https://en.wikipedia.org/wiki/De_Bruijn_sequence
-        """
-        k = len(charset)
-        a = [0] * k * n
-        sequence = []  # type: List[str]
-
-        def db(t, p):
-            # type: (int, int) -> None
-            if len(sequence) == maxlen:
-                return
-
-            if t > n:
-                if n % p == 0:
-                    for j in range(1, p + 1):
-                        sequence.append(charset[a[j]])
-                        if len(sequence) == maxlen:
-                            return
-            else:
-                a[t] = a[t - p]
-                db(t + 1, p)
-                for j in range(a[t - p] + 1, k):
-                    a[t] = j
-                    db(t + 1, t)
-
-        db(1, 1)
-        return ''.join(sequence)
-
-    def __init__(self, size=None, start=0, charset_type=None):
-        # type: (Optional[int], int, Optional[int]) -> None
-        self.size = size if size is not None else RandNumExpo(0.01)
-        self.start = start
-        self.charset_type = charset_type
-
-    def _command_args(self):
-        # type: () -> str
-        ret = ""
-        if isinstance(self.size, VolatileValue):
-            if self.size.lambd != 0.01 or self.size.base != 0:
-                ret += "size=%r" % self.size.command()
-        else:
-            ret += "size=%r" % self.size
-
-        if self.start != 0:
-            ret += ", start=%r" % self.start
-
-        if self.charset_type:
-            ret += ", charset_type=%r" % self.charset_type
-
-        return ret
-
-    def _fix(self):
-        # type: () -> bytes
-        if isinstance(self.size, VolatileValue):
-            size = self.size._fix()
-        else:
-            size = self.size
-        charset = self.cyclic_pattern_charset(self.charset_type or 0)
-        pattern = self.de_bruijn(charset, 3, size + self.start)
-        return pattern[self.start:size + self.start].encode('utf-8')
```

### Comparing `scapy-2.5.0rc3/scapy.egg-info/PKG-INFO` & `scapy-2.6.0rc1/scapy.egg-info/PKG-INFO`

 * *Files 22% similar despite different names*

```diff
@@ -1,124 +1,129 @@
 Metadata-Version: 2.1
 Name: scapy
-Version: 2.5.0rc3
+Version: 2.6.0rc1
 Summary: Scapy: interactive packet manipulation tool
-Home-page: https://scapy.net
 Author: Philippe BIONDI
-Author-email: guillaume@valadon.net
-Maintainer: Pierre LALET, Gabriel POTTER, Guillaume VALADON
+Maintainer: Pierre LALET, Gabriel POTTER, Guillaume VALADON, Nils WEISS
 License: GPL-2.0-only
-Download-URL: https://github.com/secdev/scapy/tarball/master
-Project-URL: Documentation, https://scapy.readthedocs.io
-Project-URL: Source Code, https://github.com/secdev/scapy/
-Description: # <img src="https://github.com/secdev/scapy/raw/master/doc/scapy/graphics/scapy_logo.png" width="64" valign="middle" alt="Scapy" />&nbsp;&nbsp; Scapy
-        
-        [![PyPI Version](https://img.shields.io/pypi/v/scapy.svg)](https://pypi.python.org/pypi/scapy/)
-        [![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](LICENSE)
-        
-        Scapy is a powerful Python-based interactive packet manipulation program and
-        library.
-        
-        It is able to forge or decode packets of a wide number of protocols, send them
-        on the wire, capture them, store or read them using pcap files, match requests
-        and replies, and much more. It is designed to allow fast packet prototyping by
-        using default values that work.
-        
-        It can easily handle most classical tasks like scanning, tracerouting, probing,
-        unit tests, attacks or network discovery (it can replace `hping`, 85% of `nmap`,
-        `arpspoof`, `arp-sk`, `arping`, `tcpdump`, `wireshark`, `p0f`, etc.). It also
-        performs very well at a lot of other specific tasks that most other tools can't
-        handle, like sending invalid frames, injecting your own 802.11 frames, combining
-        techniques (VLAN hopping+ARP cache poisoning, VoIP decoding on WEP protected
-        channel, ...), etc.
-        
-        Scapy supports Python 2.7 and Python 3 (3.4 to 3.9). It's intended to
-        be cross platform, and runs on many different platforms (Linux, OSX,
-        \*BSD, and Windows).
-        
-        ## Getting started
-        
-        Scapy is usable either as a **shell** or as a **library**.
-        For further details, please head over to [Getting started with Scapy](https://scapy.readthedocs.io/en/latest/introduction.html), which is part of the documentation.
-        
-        ### Shell demo
-        
-        ![Scapy install demo](https://secdev.github.io/files/doc/animation-scapy-install.svg)
-        
-        Scapy can easily be used as an interactive shell to interact with the network.
-        The following example shows how to send an ICMP Echo Request message to
-        `github.com`, then display the reply source IP address:
-        
-        ```python
-        sudo ./run_scapy
-        Welcome to Scapy
-        >>> p = IP(dst="github.com")/ICMP()
-        >>> r = sr1(p)
-        Begin emission:
-        .Finished to send 1 packets.
-        *
-        Received 2 packets, got 1 answers, remaining 0 packets
-        >>> r[IP].src
-        '192.30.253.113'
-        ```
-        
-        ### Resources
-        
-        The [documentation](https://scapy.readthedocs.io/en/latest/) contains more
-        advanced use cases, and examples.
-        
-        Other useful resources:
-        
-        -   [Scapy in 20 minutes](https://github.com/secdev/scapy/blob/master/doc/notebooks/Scapy%20in%2015%20minutes.ipynb)
-        -   [Interactive tutorial](https://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial) (part of the documentation)
-        -   [The quick demo: an interactive session](https://scapy.readthedocs.io/en/latest/introduction.html#quick-demo)
-        (some examples may be outdated)
-        -   [HTTP/2 notebook](https://github.com/secdev/scapy/blob/master/doc/notebooks/HTTP_2_Tuto.ipynb)
-        -   [TLS notebooks](https://github.com/secdev/scapy/blob/master/doc/notebooks/tls)
-        
-        ## [Installation](https://scapy.readthedocs.io/en/latest/installation.html)
-        
-        Scapy works without any external Python modules on Linux and BSD like operating
-        systems. On Windows, you need to install some mandatory dependencies as
-        described in [the
-        documentation](http://scapy.readthedocs.io/en/latest/installation.html#windows).
-        
-        On most systems, using Scapy is as simple as running the following commands:
-        
-        ```bash
-        git clone https://github.com/secdev/scapy
-        cd scapy
-        ./run_scapy
-        ```
-        
-        To benefit from all Scapy features, such as plotting, you might want to install
-        Python modules, such as `matplotlib` or `cryptography`. See the
-        [documentation](http://scapy.readthedocs.io/en/latest/installation.html) and
-        follow the instructions to install them.
+Project-URL: homepage, https://scapy.net
+Project-URL: documentation, https://scapy.readthedocs.io
+Project-URL: repository, https://github.com/secdev/scapy
+Project-URL: changelog, https://github.com/secdev/scapy/releases
 Keywords: network
-Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Information Technology
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: System Administrators
 Classifier: Intended Audience :: Telecommunications Industry
 Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.4
-Classifier: Programming Language :: Python :: 3.5
-Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: Security
 Classifier: Topic :: System :: Networking
 Classifier: Topic :: System :: Networking :: Monitoring
-Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, <4
+Requires-Python: <4,>=3.7
 Description-Content-Type: text/markdown
-Provides-Extra: basic
-Provides-Extra: complete
-Provides-Extra: docs
+License-File: LICENSE
+Provides-Extra: cli
+Requires-Dist: ipython; extra == "cli"
+Provides-Extra: all
+Requires-Dist: ipython; extra == "all"
+Requires-Dist: pyx; extra == "all"
+Requires-Dist: cryptography>=2.0; extra == "all"
+Requires-Dist: matplotlib; extra == "all"
+Provides-Extra: doc
+Requires-Dist: sphinx>=7.0.0; extra == "doc"
+Requires-Dist: sphinx_rtd_theme>=1.3.0; extra == "doc"
+Requires-Dist: tox>=3.0.0; extra == "doc"
+
+# <img src="https://github.com/secdev/scapy/raw/master/doc/scapy/graphics/scapy_logo.png" width="64" valign="middle" alt="Scapy" />&nbsp;&nbsp; Scapy
+
+[![PyPI Version](https://img.shields.io/pypi/v/scapy.svg)](https://pypi.python.org/pypi/scapy/)
+[![License: GPL v2](https://img.shields.io/badge/License-GPL%20v2-blue.svg)](LICENSE)
+
+Scapy is a powerful Python-based interactive packet manipulation program and
+library.
+
+It is able to forge or decode packets of a wide number of protocols, send them
+on the wire, capture them, store or read them using pcap files, match requests
+and replies, and much more. It is designed to allow fast packet prototyping by
+using default values that work.
+
+It can easily handle most classical tasks like scanning, tracerouting, probing,
+unit tests, attacks or network discovery (it can replace `hping`, 85% of `nmap`,
+`arpspoof`, `arp-sk`, `arping`, `tcpdump`, `wireshark`, `p0f`, etc.). It also
+performs very well at a lot of other specific tasks that most other tools can't
+handle, like sending invalid frames, injecting your own 802.11 frames, combining
+techniques (VLAN hopping+ARP cache poisoning, VoIP decoding on WEP protected
+channel, ...), etc.
+
+Scapy supports Python 3.7+. It's intended to
+be cross platform, and runs on many different platforms (Linux, OSX,
+\*BSD, and Windows).
+
+## Getting started
+
+Scapy is usable either as a **shell** or as a **library**.
+For further details, please head over to [Getting started with Scapy](https://scapy.readthedocs.io/en/latest/introduction.html), which is part of the documentation.
+
+### Shell demo
+
+![Scapy install demo](https://secdev.github.io/files/doc/animation-scapy-install.svg)
+
+Scapy can easily be used as an interactive shell to interact with the network.
+The following example shows how to send an ICMP Echo Request message to
+`github.com`, then display the reply source IP address:
+
+```python
+sudo ./run_scapy
+Welcome to Scapy
+>>> p = IP(dst="github.com")/ICMP()
+>>> r = sr1(p)
+Begin emission:
+.Finished to send 1 packets.
+*
+Received 2 packets, got 1 answers, remaining 0 packets
+>>> r[IP].src
+'192.30.253.113'
+```
+
+### Resources
+
+The [documentation](https://scapy.readthedocs.io/en/latest/) contains more
+advanced use cases, and examples.
+
+Other useful resources:
+
+-   [Scapy in 20 minutes](https://github.com/secdev/scapy/blob/master/doc/notebooks/Scapy%20in%2015%20minutes.ipynb)
+-   [Interactive tutorial](https://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial) (part of the documentation)
+-   [The quick demo: an interactive session](https://scapy.readthedocs.io/en/latest/introduction.html#quick-demo) (some examples may be outdated)
+-   [HTTP/2 notebook](https://github.com/secdev/scapy/blob/master/doc/notebooks/HTTP_2_Tuto.ipynb)
+-   [TLS notebooks](https://github.com/secdev/scapy/blob/master/doc/notebooks/tls)
+
+## [Installation](https://scapy.readthedocs.io/en/latest/installation.html)
+
+Scapy works without any external Python modules on Linux and BSD like operating
+systems. On Windows, you need to install some mandatory dependencies as
+described in [the
+documentation](http://scapy.readthedocs.io/en/latest/installation.html#windows).
+
+On most systems, using Scapy is as simple as running the following commands:
+
+```bash
+git clone https://github.com/secdev/scapy
+cd scapy
+./run_scapy
+```
+
+To benefit from all Scapy features, such as plotting, you might want to install
+Python modules, such as `matplotlib` or `cryptography`. See the
+[documentation](http://scapy.readthedocs.io/en/latest/installation.html) and
+follow the instructions to install them.
```

### Comparing `scapy-2.5.0rc3/scapy.egg-info/SOURCES.txt` & `scapy-2.6.0rc1/scapy.egg-info/SOURCES.txt`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,35 @@
+.appveyor.yml
+.gitattributes
+.gitignore
+.readthedocs.yml
+.travis.yml
 LICENSE
 MANIFEST.in
-README
+README.md
+pyproject.toml
 run_scapy
-setup.cfg
+run_scapy.bat
 setup.py
-doc/scapy.1
-scapy/VERSION
+.config/codespell_ignore.txt
+.config/appveyor/InstallNpcap.ps1
+.config/appveyor/InstallWindumpNpcap.ps1
+.config/ci/install.sh
+.config/ci/openssl.py
+.config/ci/test.sh
+.config/mypy/mypy.ini
+.config/mypy/mypy_check.py
+.config/mypy/mypy_deployment_stats.py
+.config/mypy/mypy_enabled.txt
+.github/FUNDING.yml
+.github/PULL_REQUEST_TEMPLATE.md
+.github/codecov.yml
+.github/ISSUE_TEMPLATE/BUGS.yml
+.github/ISSUE_TEMPLATE/config.yml
+.github/workflows/unittests.yml
 scapy/__init__.py
 scapy/__main__.py
 scapy/all.py
 scapy/ansmachine.py
 scapy/as_resolvers.py
 scapy/asn1fields.py
 scapy/asn1packet.py
@@ -45,21 +65,22 @@
 scapy.egg-info/entry_points.txt
 scapy.egg-info/not-zip-safe
 scapy.egg-info/requires.txt
 scapy.egg-info/top_level.txt
 scapy/arch/__init__.py
 scapy/arch/common.py
 scapy/arch/libpcap.py
-scapy/arch/linux.py
 scapy/arch/solaris.py
 scapy/arch/unix.py
 scapy/arch/bpf/__init__.py
 scapy/arch/bpf/consts.py
 scapy/arch/bpf/core.py
 scapy/arch/bpf/supersocket.py
+scapy/arch/linux/__init__.py
+scapy/arch/linux/rtnetlink.py
 scapy/arch/windows/__init__.py
 scapy/arch/windows/native.py
 scapy/arch/windows/structures.py
 scapy/asn1/__init__.py
 scapy/asn1/asn1.py
 scapy/asn1/ber.py
 scapy/asn1/mib.py
@@ -89,14 +110,15 @@
 scapy/contrib/ethercat.py
 scapy/contrib/etherip.py
 scapy/contrib/exposure_notification.py
 scapy/contrib/geneve.py
 scapy/contrib/gtp.py
 scapy/contrib/gtp_v2.py
 scapy/contrib/gxrp.py
+scapy/contrib/hicp.py
 scapy/contrib/homeplugav.py
 scapy/contrib/homepluggp.py
 scapy/contrib/homeplugsg.py
 scapy/contrib/http2.py
 scapy/contrib/ibeacon.py
 scapy/contrib/icmp_extensions.py
 scapy/contrib/ife.py
@@ -116,15 +138,17 @@
 scapy/contrib/modbus.py
 scapy/contrib/mount.py
 scapy/contrib/mpls.py
 scapy/contrib/mqtt.py
 scapy/contrib/mqttsn.py
 scapy/contrib/nfs.py
 scapy/contrib/nlm.py
+scapy/contrib/nrf_sniffer.py
 scapy/contrib/nsh.py
+scapy/contrib/oam.py
 scapy/contrib/oncrpc.py
 scapy/contrib/opc_da.py
 scapy/contrib/openflow.py
 scapy/contrib/openflow3.py
 scapy/contrib/ospf.py
 scapy/contrib/pfcp.py
 scapy/contrib/pim.py
@@ -138,41 +162,42 @@
 scapy/contrib/ripng.py
 scapy/contrib/roce.py
 scapy/contrib/rpl.py
 scapy/contrib/rpl_metrics.py
 scapy/contrib/rsvp.py
 scapy/contrib/rtcp.py
 scapy/contrib/rtr.py
+scapy/contrib/rtsp.py
 scapy/contrib/sdnv.py
 scapy/contrib/sebek.py
 scapy/contrib/send.py
 scapy/contrib/skinny.py
 scapy/contrib/slowprot.py
 scapy/contrib/socks.py
-scapy/contrib/spbm.py
 scapy/contrib/stamp.py
 scapy/contrib/stun.py
 scapy/contrib/tacacs.py
 scapy/contrib/tcpao.py
+scapy/contrib/tcpros.py
 scapy/contrib/tzsp.py
-scapy/contrib/ubberlogger.py
 scapy/contrib/vqp.py
 scapy/contrib/vtp.py
 scapy/contrib/wireguard.py
-scapy/contrib/wpa_eapol.py
 scapy/contrib/automotive/__init__.py
 scapy/contrib/automotive/ccp.py
 scapy/contrib/automotive/doip.py
 scapy/contrib/automotive/ecu.py
 scapy/contrib/automotive/kwp.py
 scapy/contrib/automotive/someip.py
 scapy/contrib/automotive/uds.py
 scapy/contrib/automotive/uds_ecu_states.py
 scapy/contrib/automotive/uds_logging.py
 scapy/contrib/automotive/uds_scan.py
+scapy/contrib/automotive/autosar/__init__.py
+scapy/contrib/automotive/autosar/pdu.py
 scapy/contrib/automotive/bmw/__init__.py
 scapy/contrib/automotive/bmw/definitions.py
 scapy/contrib/automotive/bmw/enumerator.py
 scapy/contrib/automotive/bmw/hsfz.py
 scapy/contrib/automotive/gm/__init__.py
 scapy/contrib/automotive/gm/gmlan.py
 scapy/contrib/automotive/gm/gmlan_ecu_states.py
@@ -255,15 +280,14 @@
 scapy/layers/l2.py
 scapy/layers/l2tp.py
 scapy/layers/ldap.py
 scapy/layers/llmnr.py
 scapy/layers/lltd.py
 scapy/layers/mgcp.py
 scapy/layers/mobileip.py
-scapy/layers/mspac.py
 scapy/layers/netbios.py
 scapy/layers/netflow.py
 scapy/layers/ntlm.py
 scapy/layers/ntp.py
 scapy/layers/pflog.py
 scapy/layers/ppi.py
 scapy/layers/ppp.py
@@ -275,21 +299,38 @@
 scapy/layers/sixlowpan.py
 scapy/layers/skinny.py
 scapy/layers/smb.py
 scapy/layers/smb2.py
 scapy/layers/smbclient.py
 scapy/layers/smbserver.py
 scapy/layers/snmp.py
+scapy/layers/spnego.py
+scapy/layers/ssh.py
 scapy/layers/tftp.py
 scapy/layers/tuntap.py
 scapy/layers/usb.py
 scapy/layers/vrrp.py
 scapy/layers/vxlan.py
 scapy/layers/x509.py
 scapy/layers/zigbee.py
+scapy/layers/msrpce/__init__.py
+scapy/layers/msrpce/all.py
+scapy/layers/msrpce/ept.py
+scapy/layers/msrpce/msdcom.py
+scapy/layers/msrpce/msnrpc.py
+scapy/layers/msrpce/mspac.py
+scapy/layers/msrpce/rpcclient.py
+scapy/layers/msrpce/rpcserver.py
+scapy/layers/msrpce/raw/__init__.py
+scapy/layers/msrpce/raw/ept.py
+scapy/layers/msrpce/raw/ms_dcom.py
+scapy/layers/msrpce/raw/ms_nrpc.py
+scapy/layers/msrpce/raw/ms_samr.py
+scapy/layers/msrpce/raw/ms_srvs.py
+scapy/layers/msrpce/raw/ms_wkst.py
 scapy/layers/tls/__init__.py
 scapy/layers/tls/all.py
 scapy/layers/tls/automaton.py
 scapy/layers/tls/automaton_cli.py
 scapy/layers/tls/automaton_srv.py
 scapy/layers/tls/basefields.py
 scapy/layers/tls/cert.py
@@ -318,35 +359,33 @@
 scapy/layers/tls/crypto/kx_algs.py
 scapy/layers/tls/crypto/md4.py
 scapy/layers/tls/crypto/pkcs1.py
 scapy/layers/tls/crypto/prf.py
 scapy/layers/tls/crypto/suites.py
 scapy/libs/__init__.py
 scapy/libs/ethertypes.py
+scapy/libs/extcap.py
+scapy/libs/manuf.py
 scapy/libs/matplot.py
 scapy/libs/rfc3961.py
-scapy/libs/six.py
 scapy/libs/structures.py
 scapy/libs/test_pyx.py
 scapy/libs/winpcapy.py
 scapy/modules/__init__.py
 scapy/modules/nmap.py
 scapy/modules/p0f.py
 scapy/modules/p0fv2.py
+scapy/modules/ticketer.py
 scapy/modules/voip.py
 scapy/modules/krack/__init__.py
 scapy/modules/krack/automaton.py
 scapy/modules/krack/crypto.py
 scapy/tools/UTscapy.py
 scapy/tools/__init__.py
 scapy/tools/check_asdis.py
 scapy/tools/generate_ethertypes.py
+scapy/tools/generate_manuf.py
 scapy/tools/scapy_pyannotate.py
 scapy/tools/automotive/__init__.py
 scapy/tools/automotive/isotpscanner.py
 scapy/tools/automotive/obdscanner.py
-scapy/tools/automotive/xcpscanner.py
-test/__init__.py
-test/testsocket.py
-test/tls/__init__.py
-test/tls/example_client.py
-test/tls/example_server.py
+scapy/tools/automotive/xcpscanner.py
```

